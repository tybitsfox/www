<HTML
><HEAD
><TITLE
>C 语言函数</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 8.1 中文文档（PostgreSQL 中国 制作）"
HREF="index.html"><LINK
REL="UP"
TITLE="扩展 SQL"
HREF="extend.html"><LINK
REL="PREVIOUS"
TITLE="内部函数"
HREF="xfunc-internal.html"><LINK
REL="NEXT"
TITLE="用户定义聚集"
HREF="xaggr.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=gb2312"><META
NAME="creation"
CONTENT="2005-12-05T14:14:52"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 8.1 中文文档（<A
HREF="http://www.pgsqldb.org"
TARGET="_top"
>PostgreSQL 中国</A
> 制作）</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="xfunc-internal.html"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="extend.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 32. 扩展 <SPAN
CLASS="ACRONYM"
>SQL</SPAN
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="extend.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="xaggr.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XFUNC-C"
>32.9. C 语言函数</A
></H1
><A
NAME="AEN31756"
></A
><P
>	用户定义的函数可以用 C 写（或者是那些可以与 C 兼容的语言，比如 C++）。
	这样的函数是编译进可动态装载的对象的（也叫做共享库）并且是由服务器根据需要装载的。
	动态装载的特性是 <SPAN
CLASS="QUOTE"
>"C 语言"</SPAN
> 函数和<SPAN
CLASS="QUOTE"
>"内部"</SPAN
>函数之间相互区别的地方 &mdash; 
	实际的编码习惯在两者之间实际上是一样的。
	（因此，标准的内部函数库为写用户定义 C 函数提供了大量最好的样例。）
   </P
><P
>        目前对 C 函数有两种调用传统。新的<SPAN
CLASS="QUOTE"
>"版本 1"</SPAN
>的调用传统是通过为该函数书写一个 <TT
CLASS="LITERAL"
>PG_FUNCTION_INFO_V1()</TT
>
        宏来标识的，象下面演示的那样。缺少这个宏标识一个老风格的（<SPAN
CLASS="QUOTE"
>"版本 0"</SPAN
>）函数。
	两种风格里在<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>里声明的都是 <TT
CLASS="LITERAL"
>C</TT
>。
        现在老风格的函数已经废弃了，主要是因为移植性原因和缺乏功能，
        不过出于兼容性原因，系统仍然支持它。
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-DYNLOAD"
>32.9.1. 动态装载</A
></H2
><A
NAME="AEN31771"
></A
><P
>        当某个特定的可装载对象文件里的用户定义的函数第一次被服务器会话调用时，
	动态装载器把函数的目标码装载入内存。
        因此，用于用户定义的 C 函数的 <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>必须为函数声明两部分信息：
        可装载对象文件名字，和所声明的在那个目标文件里调用的函数的 C 名字（联接符号）。
	如果没有明确声明C名字，那么就假设它与SQL函数名相同。
   </P
><P
>	基于在 <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> 命令中给出的名字,
	下面的算法用于定位共享对象文件：

    <P
></P
></P><OL
TYPE="1"
><LI
><P
>	如果名字是一个绝对路径名，则装载给出的文件。
      </P
></LI
><LI
><P
>	如果名字以字串 <TT
CLASS="LITERAL"
>$libdir</TT
> 开头，
	那么该部分将被<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>库目录名代替，
	该目录是在制作的时候判定的。<A
NAME="AEN31784"
></A
>
      </P
></LI
><LI
><P
>	如果名字不包含目录部分，那么在配置变量
	<A
HREF="runtime-config-client.html#GUC-DYNAMIC-LIBRARY-PATH"
>dynamic_library_path</A
> 里声明的路径里查找。
	<A
NAME="AEN31789"
></A
>
      </P
></LI
><LI
><P
>	否则（没有在路径里找到该文件，或者它包含一个非绝对目录部分），
	那么动态装载器就会试图拿这个名字来装载，这样几乎可以肯定是要失败的。（依靠当前工作目录是不可靠的。）
      </P
></LI
></OL
><P>

	如果这个顺序不管用，那么就给这个给出的名字附加上平台相关的共享库文件名扩展（通常是 <TT
CLASS="FILENAME"
>.so</TT
>），
	然后再重新按照上面的过程来一便。如果还是失败，那么装载失败。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 服务器运行时的用户 ID
	必须可以遍历路径到达你想装载的文件。一个常见的错误就是把该文件或者一个高层目录的权限设置为
	<SPAN
CLASS="SYSTEMITEM"
>postgres</SPAN
> 用户不可读和/或不能执行。
    </P
></BLOCKQUOTE
></DIV
><P
>	在任何情况下，在 <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>
	命令里给出的文件名是在系统表里按照文本记录的，因此，
	如果需要再次装载，那么会再次运行这个过程。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 不会自动编译一个函数；
	在使用 <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> 命令之前你必须编译它。
	参阅 <A
HREF="xfunc-c.html#DFUNC"
>Section 32.9.6</A
> 获取更多信息。
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>	在第一次使用之后，在内存中动态装载了一个目标文件。
	在同一次会话中的后继的函数调用将只会产生很小的符号表查询的过热。
	如果你需要强制对象文件的重载，比如你重新编译了该文件，那么可以使用
	<A
HREF="sql-load.html"
><I
>LOAD</I
></A
> 命令或者开始一次新的会话。
    </P
></BLOCKQUOTE
></DIV
><P
>	我们建议使用与 <TT
CLASS="LITERAL"
>$libdir</TT
> 相对的目录或者通过动态库路径定位共享库。这样，如果新版本安装在一个不同的
	位置，那么就可以简化版本升级。<TT
CLASS="LITERAL"
>$libdir</TT
> 
	表示的实际目录位置可以用命令 <TT
CLASS="LITERAL"
>pg_config --pkglibdir</TT
>
	找到。
   </P
><P
>	在 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 版本 7.2 之前，
	我们只能在 <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> 中声明目标文件的准确的绝对路径。
	目前这个方法已经过时了，因为这样令函数定义毫无意义的不可移植。
	最好是只声明共享库的名字，不带路径，也没有扩展名。然后让搜索机制提供那些信息。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-BASETYPE"
>32.9.2. 基本类型的 C 语言函数</A
></H2
><A
NAME="AEN31820"
></A
><P
>    要知道如何写 C 语言的函数，你需要知道 PostgreSQL 在内部是如何表现基本数据类型的，以及它们是如何传入函数以及传出函数的。
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 内部把基本类型当作<SPAN
CLASS="QUOTE"
>"一片内存"</SPAN
>看待。
        定义在某种类型上的用户定义函数实际上定义了 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 对（该数据类型）可能的操作。
	也就是说，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 只是从磁盘读取和存储该数据类型，
        而使用你定义的函数来输入，处理和输出数据。基本类型可以有下面三种内部形态（格式）之一：

     <P
></P
></P><UL
><LI
><P
>        传递数值，定长
       </P
></LI
><LI
><P
>        传递引用，定长
       </P
></LI
><LI
><P
>        传递引用，变长
       </P
></LI
></UL
><P>
    </P
><P
>        传递数值的类型的长度只能是1，2 或 4 字节。
        （还有 8 字节，如果 sizeof(Datum) 在你的机器上是 8 的话。）。
        你要仔细定义你的类型，确保它们在任何体系平台上都是相同尺寸（字节）。
        例如，<TT
CLASS="LITERAL"
>long</TT
> 型是一个危险的类型因为在一些机器上它是 4 字节而在另外一些机器上是 8 字节，
	而 <TT
CLASS="LITERAL"
>int</TT
>型在大多数 Unix 机器上都是4字节的。
     在一个 Unix 机器上的 <TT
CLASS="LITERAL"
>integer</TT
> 合理的实现可能是：
     
</P><PRE
CLASS="PROGRAMLISTING"
>/* 4-字节整数，传值 */
typedef int integer;</PRE
><P>
    </P
><P
>    另外，任何尺寸的定长类型都可以是传递引用型。例如，下面是一个
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 类型的实现：
     
</P><PRE
CLASS="PROGRAMLISTING"
>/* 16-字节结构，传递引用 */
typedef struct
{
    double  x, y;
} Point;</PRE
><P>
    </P
><P
>        只能使用指向这些类型的指针来在
      <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 函数里传入和传出数据。
        要返回这样的类型的值，用 <TT
CLASS="LITERAL"
>palloc()</TT
>
        分配正确数量的存储器，填充这些存储器，然后返回一个指向它的指针。
	（另外，如果你只是想返回和你的一个输入参数类型相同，数值相同的一个数值，
	你可以忽略额外的 <TT
CLASS="LITERAL"
>palloc</TT
>，只要返回指向输入数值的指针就行。）
    </P
><P
>        最后，所有变长类型同样也只能通过传递引用的方法来传递。
	所有变长类型必须以一个正好 4 字节长的长度域开始，
        并且所有存储在该类型的数据必须放在紧接着长度域的存储空间里。
        长度域是结构的全长，也就是说，包括长度域本身的长度。
    </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>      <I
CLASS="EMPHASIS"
>绝对</I
>不要修改一个传递引用的输入值的内容。
      如果你这么干，那么你很可能破坏磁盘上的数据，因为你给拿到指针很可能直接指向一个磁盘缓冲区。
      这条规则的唯一例外在 <A
HREF="xaggr.html"
>Section 32.10</A
> 里。
     </P
></TD
></TR
></TABLE
></DIV
><P
>       比如，我们可以用下面方法定义一个 <TT
CLASS="TYPE"
>text</TT
> 类型：

</P><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
    integer length;
    char data[1];
} text;</PRE
><P>

	显然，上面声明的数据域的长度不足以存储任何可能的字串。因为在
	<SPAN
CLASS="ACRONYM"
>C</SPAN
>中不可能声明变长度的结构，
	所以我们倚赖这样的知识：<SPAN
CLASS="ACRONYM"
>C</SPAN
> 编译器不会对数组下标进行范围检查。
	我们只需要分配足够的空间，然后把数组当做已经声明为合适长度的变量访问。
	（这是一个常用的技巧，你可以在许多 C 的教科书中读到。）
	</P
><P
>	当处理变长类型时，我们必须仔细分配正确的存储器数量并正确设置长度域。
	例如，如果我们想在一个 <TT
CLASS="STRUCTNAME"
>text</TT
> 结构里存储 40 字节，
	我们可能会使用象下面的代码片段：

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
...
char buffer[40]; /* 我们的源数据 */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
destination-&gt;length = VARHDRSZ + 40;
memcpy(destination-&gt;data, buffer, 40);
...</PRE
><P>

	<TT
CLASS="LITERAL"
>VARHDRSZ</TT
> 和 <TT
CLASS="LITERAL"
>sizeof(int4)</TT
> 一样，
	但是我们认为用宏 <TT
CLASS="LITERAL"
>VARHDRSZ</TT
> 表示附加尺寸是用于变长类型的更好的风格。
    </P
><P
>	表<A
HREF="xfunc-c.html#XFUNC-C-TYPE-TABLE"
>Table 32-1</A
>
	列出了书写一个使用了 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 内置类型的 C 
	函数里需要的知道的哪个 SQL 类型对应哪个 C 类型。
	<SPAN
CLASS="QUOTE"
>"定义在"</SPAN
> 列给出了需要包含以获取该类型定义的头文件（实际的定义可能是在包含在列出的文件所包含的文件中。
	我们建议用户只使用这里定义的接口。）
	注意，你应该总是首先包括 <TT
CLASS="FILENAME"
>postgres.h</TT
>，
	因为它声明了许多你需要的东西。

     <DIV
CLASS="TABLE"
><A
NAME="XFUNC-C-TYPE-TABLE"
></A
><P
><B
>Table 32-1. 与内建的类型等效的 C 类型 </B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
>        内建类型
	 </TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>        C 类型
	 </TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>        定义在
	 </TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>abstime</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>AbsoluteTime</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>bool</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
> （可能是编译器内置）</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>box</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>BOX*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>bytea</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>bytea*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>"char"</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>char</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>（编译器内置）</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>character</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>BpChar*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>cid</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>CommandId</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>date</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>DateADT</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>smallint</TT
> (<TT
CLASS="TYPE"
>int2</TT
>)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>int2</TT
> 或 <TT
CLASS="TYPE"
>int16</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>int2vector</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>int2vector*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>integer</TT
> (<TT
CLASS="TYPE"
>int4</TT
>)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>int4</TT
> 或 <TT
CLASS="TYPE"
>int32</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>real</TT
> (<TT
CLASS="TYPE"
>float4</TT
>)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>float4*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>double precision</TT
> (<TT
CLASS="TYPE"
>float8</TT
>)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>float8*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>interval</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>Interval*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/timestamp.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>lseg</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>LSEG*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>Name</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>Oid</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>oidvector</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>oidvector*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>path</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>PATH*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>point</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>POINT*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>reltime</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>RelativeTime</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>text*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>tid</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>ItemPointer</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>storage/itemptr.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>time</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>TimeADT</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>time with time zone</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>TimeTzADT</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>Timestamp*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/timestamp.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>tinterval</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>TimeInterval</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>varchar</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>VarChar*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>xid</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>TransactionId</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
><P
>        既然我们已经讨论了基本类型所有的可能结构，
        我们便可以用实际的函数举一些例子。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN32093"
>32.9.3. C 语言函数的版本-0 调用风格</A
></H2
><P
>        我们先提供<SPAN
CLASS="QUOTE"
>"老风格"</SPAN
>的调用风格 &mdash; 尽管这种做法现在已经不提倡了，
        但它还是比较容易迈出第一步。在版本-0方法里，
	C 函数的参数和结果只是用普通 C 风格声明，但是要小心使用上面显示的SQL数据类型的 C 表现形式。
    </P
><P
>        下面是一些例子：

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include &lt;string.h&gt;

/* 传递数值 */

int
add_one(int arg)
{
    return arg + 1;
}

/* 传递引用，定长 */

float8 *
add_one_float8(float8 *arg)
{
    float8    *result = (float8 *) palloc(sizeof(float8));

    *result = *arg + 1.0;

    return result;
}

Point *
makepoint(Point *pointx, Point *pointy)
{
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&gt;x = pointx-&gt;x;
    new_point-&gt;y = pointy-&gt;y;

    return new_point;
}

/* 传递引用，变长 */

text *
copytext(text *t)
{
    /*
     * VARSIZE 是结构以字节计的总长度
     */
    text *new_t = (text *) palloc(VARSIZE(t));
    VARATT_SIZEP(new_t) = VARSIZE(t);
    /*
     * VARDATA 是结构中一个指向数据区的指针
     */
    memcpy((void *) VARDATA(new_t), /* 目的 */
           (void *) VARDATA(t),     /* 源 */
           VARSIZE(t)-VARHDRSZ);    /* 多少字节 */
    return new_t;
}

text *
concat_text(text *arg1, text *arg2)
{
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    VARATT_SIZEP(new_text) = new_text_size;
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1)-VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1)-VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2)-VARHDRSZ);
    return new_text;
}</PRE
><P>
    </P
><P
>        假设上面的代码放在文件
        <TT
CLASS="FILENAME"
>funcs.c</TT
> 并且编译成了共享目标，
        我们可以用下面的命令为 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
        定义这些函数：
     
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'add_one'
     LANGUAGE C STRICT;

-- 注意：重载了名字为 add_one() 的 SQL 函数
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'concat_text'
     LANGUAGE C STRICT;</PRE
><P>
    </P
><P
>	这里的 <TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
> 代表共享库文件的目录
	（比如<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>教程目录，那里包含本节使用的例子的代码。）
	（更好的风格应该是在加了 <TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
> 到搜索路径之后，
	在 <TT
CLASS="LITERAL"
>AS</TT
> 子句里只使用 <TT
CLASS="LITERAL"
>'funcs'</TT
>，
	不管怎样，我们都可以省略和系统相关的共享库扩展，通常是 <TT
CLASS="LITERAL"
>.so</TT
> 或 <TT
CLASS="LITERAL"
>.sl</TT
>。）
    </P
><P
>        请注意我们把函数声明为<SPAN
CLASS="QUOTE"
>"strict"</SPAN
>（严格），意思是说如果任何输入值为 NULL，
        那么系统应该自动假设一个 NULL 的结果。这样处理可以让我们避免在函数代码里面检查 NULL 输入。
	如果不这样处理，我们就得明确检查空值，
        比如为每个传递引用的参数检查空指针。（对于传值类型的参数，我们甚至没有办法检查！）
    </P
><P
>        尽管这种老风格的调用风格用起来简单，它确不太容易移植；在一些系统上，
        我们用这种方法传递比 <TT
CLASS="TYPE"
>int</TT
> 小的数据类型就会碰到困难。
	而且，我们没有很好的返回 NULL 结果的办法，
	也没有除了把函数严格化以外的处理 NULL 参数的方法。下面要讲的版本-1的方法则解决了这些问题。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN32120"
>32.9.4. C 语言函数的版本-1调用风格</A
></H2
><P
>        版本-1 调用风格依赖宏来消除大多数传递参数和结果的复杂性。版本-1 风格函数的 C 定义总是下面这样
</P><PRE
CLASS="PROGRAMLISTING"
>Datum funcname(PG_FUNCTION_ARGS)</PRE
><P>
        另外，下面的宏
</P><PRE
CLASS="PROGRAMLISTING"
>PG_FUNCTION_INFO_V1(funcname);</PRE
><P>
        也必须出现在同一个源文件里（通常就可以写在函数自身前面）。
        对那些<TT
CLASS="LITERAL"
>内部</TT
>-语言函数而言，不需要调用这个宏，
        因为<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>目前假设内部函数都是版本-1。
        不过，对于动态链接的函数，它是<I
CLASS="EMPHASIS"
>必须</I
>的。
     </P
><P
>        在版本-1函数里，
        每个实际参数都是用一个对应该参数的数据类型的
	<TT
CLASS="FUNCTION"
>PG_GETARG_xxx()</TT
>宏抓取的，结果是用返回类型的
	<TT
CLASS="FUNCTION"
>PG_RETURN_xxx()</TT
>宏返回的。
     <TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</TT
>
     接受要抓取的函数参数的编号作为其参数，编号是从 0 开始的。
     <TT
CLASS="FUNCTION"
>PG_RETURN_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</TT
>
     接受实际要返回的数值为自身的参数。
    </P
><P
>        下面是和上面一样的函数，但是是用版本-1风格编的：

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include &lt;string.h&gt;
#include "fmgr.h"

/* 传递数值 */

PG_FUNCTION_INFO_V1(add_one);
         
Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* 传递引用，定长 */

PG_FUNCTION_INFO_V1(add_one_double precision);

Datum
add_one_float8 precision(PG_FUNCTION_ARGS)
{
    /* 用于 FLOAT8 的宏，隐藏其传递引用的本质 */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* 这里，我们没有隐藏 Point 的传递引用的本质 */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&gt;x = pointx-&gt;x;
    new_point-&gt;y = pointy-&gt;y;
       
    PG_RETURN_POINT_P(new_point);
}

/* 传递引用，变长 */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_P(0);
    /*
     * VARSIZE 是结构以字节计的总长度
     */
    text     *new_t = (text *) palloc(VARSIZE(t));
    VARATT_SIZEP(new_t) = VARSIZE(t);
    /*
     * VARDATA 是结构中指向数据区的一个指针
     */
    memcpy((void *) VARDATA(new_t), /* 目的 */
           (void *) VARDATA(t),     /* 源 */
           VARSIZE(t)-VARHDRSZ);    /* 多少字节 */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_P(0);
    text  *arg2 = PG_GETARG_TEXT_P(1);
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    VARATT_SIZEP(new_text) = new_text_size;
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1)-VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1)-VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2)-VARHDRSZ);
    PG_RETURN_TEXT_P(new_text);
}</PRE
><P>
    </P
><P
>        用到的 <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> 命令和用于老风格的等效的命令一样。
    </P
><P
>	猛地一看，版本-1的编码好象只是无目的地蒙人。但是它们的确给我们许多改进，因为宏可以隐藏许多不必要的细节。
	一个例子在<TT
CLASS="FUNCTION"
>add_one_float8</TT
>的编码里，这里我们不再需要不停叮嘱自己 <TT
CLASS="TYPE"
>float8</TT
> 是传递引用类型。
	另外一个例子是用于变长类型的宏 <TT
CLASS="LITERAL"
>GETARG</TT
> 隐藏了抓取<SPAN
CLASS="QUOTE"
>"toasted"</SPAN
>（烤炉）（压缩的或者超长的）值需要做的处理。
	</P
><P
>	版本-1的函数另一个巨大的改进是对 NULL 输入和结果的处理。
	宏 <TT
CLASS="FUNCTION"
>PG_ARGISNULL(<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>)</TT
> 允许一个函数测试每个输入是否为 NULL
	（当然，这件事只是对那些没有声明为 <SPAN
CLASS="QUOTE"
>"strict"</SPAN
> 的函数有必要）。
	因为如果有<TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</TT
>
	宏，输入参数是从零开始计算的。请注意我们不应该执行
	<TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</TT
>，
	除非有人声明了参数不是 NULL。
	要返回一个 NULL 结果，执行一个
	<TT
CLASS="FUNCTION"
>PG_RETURN_NULL()</TT
>，这样对严格的和不严格的函数都有效。
    </P
><P
>	在新风格的接口中提供的其它的选项是
	<TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</TT
>
	宏的两个变种。第一个，
	<TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_COPY()</TT
>
	保证返回一个指定参数的副本，该副本是可以安全地写入的。
	（普通的宏有时候会返回一个指向物理存储在表中的某值的指针，因此我们不能写入该指针。
	用 <TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_COPY()</TT
>
	宏保证获取一个可写的结果。）
	第二个变体由
	<TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_SLICE()</TT
>
	宏组成，它接受三个参数。第一个是参数的个数（与上同）。
	第二个和第三个是要返回的偏移量和数据段的长度。
	偏移是从零开始计算的，一个负数的长度则要求返回该值的剩余长度的数据。
	这些过程提供了访问大数据值的中部分的更有效的方法，特别是数据的存储类型是<SPAN
CLASS="QUOTE"
>"external"</SPAN
>的时候。
	（一个字段的存储类型可以用 
	<TT
CLASS="LITERAL"
>ALTER TABLE <TT
CLASS="REPLACEABLE"
><I
>tablename</I
></TT
>
	ALTER COLUMN <TT
CLASS="REPLACEABLE"
><I
>colname</I
></TT
> SET STORAGE
	<TT
CLASS="REPLACEABLE"
><I
>storagetype</I
></TT
></TT
>指定。<TT
CLASS="REPLACEABLE"
><I
>storagetype</I
></TT
> 是
	<TT
CLASS="LITERAL"
>plain</TT
>，<TT
CLASS="LITERAL"
>external</TT
>，
	<TT
CLASS="LITERAL"
>extended</TT
> 或 <TT
CLASS="LITERAL"
>main</TT
> 之一。）
    </P
><P
>	版本-1的函数调用风格也令我们可能返回一<SPAN
CLASS="QUOTE"
>"套"</SPAN
>结果
	（<A
HREF="xfunc-c.html#XFUNC-C-RETURN-SET"
>Section 32.9.10</A
>）并且实现触发器函数（<A
HREF="triggers.html"
>Chapter 33</A
>）和过程语言调用句柄（<A
HREF="plhandler.html"
>Chapter 46</A
>）。
	版本-1 的代码也比版本-0的更容易移植，因为它没有违反 C 标准对函数调用协议的限制。更多的细节请参阅
	源程序中的<TT
CLASS="FILENAME"
>src/backend/utils/fmgr/README</TT
>。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN32178"
>32.9.5. 书写代码</A
></H2
><P
>    在我们转到更深的话题之前，我们要先讨论一些<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>C 语言函数的编码规则。
    虽然可以用 C 以外的其他语言如书写用于<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 的共享函数，
    但通常很麻烦（虽然是完全可能的），因为其他像 C++，FORTRAN，或者 Pascal 这样的语言并不遵循和 C 一样的调用习惯。
    也就是说，其他语言与C的传递参数和返回值的方式不一样。
    因此我们假设你的编程语言函数是用 C 写的。
    </P
><P
>    书写和制作 C 函数的基本规则如下：

     <P
></P
></P><UL
><LI
><P
>	使用 <TT
CLASS="LITERAL"
>pg_config --includedir-server</TT
> 
	<A
NAME="AEN32188"
></A
>
	找出<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>服务器的头文件安装在你的系统（或者是你的用户所运行的系统）的何处。
	这个选项是<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>7.2 新增的。对于
	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>7.1，
	你应该使用选项 <TT
CLASS="OPTION"
>--includedir</TT
>。
	（如果碰到未知选项，<TT
CLASS="COMMAND"
>pg_config</TT
> 将带着非零状态退出。）
	对于早于 7.1 的版本，你就只能自己猜了，但是因为那是在引入目前的调用方式之前，所以你不大可能会去支持那些版本。
       </P
></LI
><LI
><P
>        当分配存储器时，用
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
        的函数<TT
CLASS="FUNCTION"
>palloc</TT
><A
NAME="AEN32200"
></A
>和
	<TT
CLASS="FUNCTION"
>pfree</TT
><A
NAME="AEN32203"
></A
> 取代相应的
        <SPAN
CLASS="ACRONYM"
>C</SPAN
> 库函数
	<TT
CLASS="FUNCTION"
>malloc</TT
>和<TT
CLASS="FUNCTION"
>free</TT
>。
	用<TT
CLASS="FUNCTION"
>palloc</TT
>分配的存储器在每个事务结束时会自动释放，避免了内存泄露。
       </P
></LI
><LI
><P
>        记得用<TT
CLASS="FUNCTION"
>memset</TT
> 对你的结构字节清零。
	如果不这么做，就很难支持 hash 索引和 hash 连接，因为我们必须从自己的数据结构中选出最具特征的位来计算 hash。
        即使你初始化了你的结构的所有域，仍然有可能有几个对齐字节（结构中的洞）含有垃圾值。
       </P
></LI
><LI
><P
>        大多数的 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
        内部类型定义在 <TT
CLASS="FILENAME"
>postgres.h</TT
>，
	而函数管理器接口（<TT
CLASS="SYMBOL"
>PG_FUNCTION_ARGS</TT
> 等等。）
	都在  <TT
CLASS="FILENAME"
>fmgr.h</TT
>，所以你至少应该包括这两个文件。
	出于移植性原因，最好<I
CLASS="EMPHASIS"
>先</I
>包括 <TT
CLASS="FILENAME"
>postgres.h</TT
>，然后再包括其它系统或者用户头文件。
        包含了
         <TT
CLASS="FILENAME"
>postgres.h</TT
> 将自动包含
        <TT
CLASS="FILENAME"
>c.h</TT
>，
	<TT
CLASS="FILENAME"
>elog.h</TT
> 和 <TT
CLASS="FILENAME"
>palloc.h</TT
>。
       </P
></LI
><LI
><P
>	在目标文件里定义的符号一定不能相互冲突，也不能和定义在
	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 服务器可执行代码中的符号名字冲突。
	如果你看到了与此相关的错误信息，那么你必须给你的函数或者变量重命名。
       </P
></LI
><LI
><P
>        把你的目标码编译和装载成可以动态装入
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
        的库文件总是需要一些特殊的标记。参阅
         <A
HREF="xfunc-c.html#DFUNC"
>Section 32.9.6</A
>
        获取如何在你的平台上做这件事的详细说明。
       </P
></LI
></UL
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DFUNC"
>32.9.6. 编译和链接动态链接的函数</A
></H2
><P
>	在你能够使用由 C 写
	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 扩展函数之前，
	你必须用一种特殊的方法编译和链接它们，这样才能生成可以被服务器动态地装载的文件。
	准确地说，我们需要创建一个<I
CLASS="FIRSTTERM"
>共享库</I
>。<A
NAME="AEN32236"
></A
>
 </P
><P
>	如果需要超出本节所包含范围的信息，那么你应该阅读你的操作系统的文档，
	特别是 C 编译器，<TT
CLASS="COMMAND"
>cc</TT
> 和链接器，
	 <TT
CLASS="COMMAND"
>ld</TT
> 的手册页。
	另外，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 源代码里包含几个可以运行的例子，
	它们在 <TT
CLASS="FILENAME"
>contrib</TT
> 目录里。
	不过，如果你依赖这些例子，那么你就要把自己的模块做得和
	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 源代码无关才行。
 </P
><P
>	创建共享库和链接可执行文件类似：首先把源代码编译成目标文件，
	然后把目标文件链接起来。目标文件需要创建成<I
CLASS="FIRSTTERM"
>位置无关码（position-independent code）</I
>
	（<SPAN
CLASS="ACRONYM"
>PIC</SPAN
>），<A
NAME="AEN32247"
></A
>概念上就是在可执行程序装载它们的时候，
	它们可以放在可执行程序的内存里的任何地方，
	（用于可执行文件的目标文件通常不是用这个方式编译的。）
	链接动态库的命令包含特殊标志，与链接可执行文件的命令是有区别的。
	（至少理论上如此 &mdash; 在一些系统里，现实更恶心。）
 </P
><P
>	在下面的例子里，我们假设你的源程序代码在
	<TT
CLASS="FILENAME"
>foo.c</TT
> 文件里并且将创建成名字叫
	<TT
CLASS="FILENAME"
>foo.so</TT
>的共享库。中介的对象文件将叫做
	<TT
CLASS="FILENAME"
>foo.o</TT
>，除非我们另外注明。一个共享库可以包含多个对象文件，不过我们在这里只用一个。
 </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><SPAN
CLASS="SYSTEMITEM"
>BSD/OS</SPAN
></DT
><DD
><P
>	创建 <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> 的编译器标志是
	<TT
CLASS="OPTION"
>-fpic</TT
>。创建共享库的链接器标志是
	<TT
CLASS="OPTION"
>-shared</TT
>。
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
ld -shared -o foo.so foo.o</PRE
><P>
	上面方法适用于版本 4.0 的
      <SPAN
CLASS="SYSTEMITEM"
>BSD/OS</SPAN
>。
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
></DT
><DD
><P
>	创建 <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> 的编译器标志是
	<TT
CLASS="OPTION"
>-fpic</TT
>。创建共享库的链接器标志是
	<TT
CLASS="OPTION"
>-shared</TT
>。
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
	上面方法适用于版本 3.0 的
      <SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
>.
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>HP-UX</SPAN
></DT
><DD
><P
>	创建 <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> 的系统编译器标志是
	<TT
CLASS="OPTION"
>+z</TT
>。如果使用
      <SPAN
CLASS="APPLICATION"
>GCC</SPAN
> 则是 <TT
CLASS="OPTION"
>-fpic</TT
>。
	创建共享库的链接器标志是 <TT
CLASS="OPTION"
>-b</TT
>。因此
</P><PRE
CLASS="PROGRAMLISTING"
>cc +z -c foo.c</PRE
><P>
      或
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c</PRE
><P>
      然后
</P><PRE
CLASS="PROGRAMLISTING"
>ld -b -o foo.sl foo.o</PRE
><P>
      <SPAN
CLASS="SYSTEMITEM"
>HP-UX</SPAN
> 使用
      <TT
CLASS="FILENAME"
>.sl</TT
> 做共享库扩展，和其它大部分系统不同。
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>IRIX</SPAN
></DT
><DD
><P
>	<SPAN
CLASS="ACRONYM"
>PIC</SPAN
> 是缺省，不需要使用特殊的编译器选项。
	生成共享库的链接器选项是
	<TT
CLASS="OPTION"
>-shared</TT
>.
</P><PRE
CLASS="PROGRAMLISTING"
>cc -c foo.c
ld -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Linux</SPAN
></DT
><DD
><P
>	创建 <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> 的编译器标志是
	<TT
CLASS="OPTION"
>-fpic</TT
>。在一些平台上的一些环境下，
	如果 <TT
CLASS="OPTION"
>-fpic</TT
> 不能用那么必须使用<TT
CLASS="OPTION"
>-fPIC</TT
>。
	参考 GCC 的手册获取更多信息。
	创建共享库的编译器标志是
	<TT
CLASS="OPTION"
>-shared</TT
>。一个完整的例子看起来象：
</P><PRE
CLASS="PROGRAMLISTING"
>cc -fpic -c foo.c
cc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>MacOS X</SPAN
></DT
><DD
><P
>	这里是一个例子。这里假设开发工具已经安装好了。
</P><PRE
CLASS="PROGRAMLISTING"
>cc -c foo.c
cc -bundle -flat_namespace -undefined suppress -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>NetBSD</SPAN
></DT
><DD
><P
>	创建 <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> 的编译器标志是
	<TT
CLASS="OPTION"
>-fpic</TT
>。对于 <SPAN
CLASS="ACRONYM"
>ELF</SPAN
> 系统，
	带 <TT
CLASS="OPTION"
>-shared</TT
> 标志的编译命令用于链接共享库。
	在老的非 ELF 系统里，使用<TT
CLASS="LITERAL"
>ld -Bshareable</TT
>。
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>OpenBSD</SPAN
></DT
><DD
><P
>	创建 <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> 的编译器标志是
	<TT
CLASS="OPTION"
>-fpic</TT
>.  <TT
CLASS="LITERAL"
>ld -Bshareable</TT
>
	用于链接共享库。
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
ld -Bshareable -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
></DT
><DD
><P
>	创建 <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> 的编译器命令是用 Sun 编译器时为
	<TT
CLASS="OPTION"
>-KPIC</TT
> 而用 <SPAN
CLASS="APPLICATION"
>GCC</SPAN
> 时为
	<TT
CLASS="OPTION"
>-fpic</TT
>。链接共享库时两个编译器都可以用
	<TT
CLASS="OPTION"
>-G</TT
> 或者用 <SPAN
CLASS="APPLICATION"
>GCC</SPAN
> 时还可以是
	<TT
CLASS="OPTION"
>-shared</TT
>。
</P><PRE
CLASS="PROGRAMLISTING"
>cc -KPIC -c foo.c
cc -G -o foo.so foo.o</PRE
><P>
      或
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -G -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Tru64 UNIX</SPAN
></DT
><DD
><P
>	<SPAN
CLASS="ACRONYM"
>PIC</SPAN
> 是缺省，因此编译命令就是平常的那个。
	带特殊选项的 <TT
CLASS="COMMAND"
>ld</TT
> 用于链接：
</P><PRE
CLASS="PROGRAMLISTING"
>cc -c foo.c
ld -shared -expect_unresolved '*' -o foo.so foo.o</PRE
><P>
	用 GCC 代替系统编译器时的过程是一样的；不需要特殊的选项。
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>UnixWare</SPAN
></DT
><DD
><P
>	SCO 编译器创建 <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> 的标志是<TT
CLASS="OPTION"
>-KPIC</TT
>
	<SPAN
CLASS="PRODUCTNAME"
>GCC</SPAN
> 是 <TT
CLASS="OPTION"
>-fpic</TT
>。
	链接共享库时 SCO 编译器用 <TT
CLASS="OPTION"
>-G</TT
> 而
	<SPAN
CLASS="PRODUCTNAME"
>GCC</SPAN
> 用<TT
CLASS="OPTION"
>-shared</TT
>。
</P><PRE
CLASS="PROGRAMLISTING"
>cc -K PIC -c foo.c
cc -G -o foo.so foo.o</PRE
><P>
      or
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
></DL
></DIV
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>技巧: </B
>	如果你觉得这些步骤实在太复杂，那么你应该考虑使用
	<A
HREF="http://www.gnu.org/software/libtool/"
TARGET="_top"
>	<SPAN
CLASS="PRODUCTNAME"
>GNU Libtool</SPAN
></A
>，它把平台的差异隐藏在了一个统一的接口里。
  </P
></BLOCKQUOTE
></DIV
><P
>	生成的共享库文件然后就可以装载到
	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>里面去了。在给
	<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> 命令声明文件名的时候，我们必须声明
	共享库文件的名字而不是中间目标文件的名字。请注意你可以在
	<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> 命令上忽略
	系统标准的共享库扩展
	(通常是<TT
CLASS="LITERAL"
>.so</TT
>或<TT
CLASS="LITERAL"
>.sl</TT
>)，
	并且出于最佳的兼容性考虑也应该忽略。
   </P
><P
>	回去看看 <A
HREF="xfunc-c.html#XFUNC-C-DYNLOAD"
>Section 32.9.1</A
> 获取有关服务器
	预期在哪里找到共享库的信息。
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-PGXS"
>32.9.7. 扩展的制作架构</A
></H2
><A
NAME="AEN32421"
></A
><P
>    如果你在考虑发布你的<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>扩展模块，那么给他们设置一个可移植的制作系统可能会相当困难。
    因此<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>安装提供了一个用于扩展的制作架构，叫做 <SPAN
CLASS="ACRONYM"
>PGXS</SPAN
>，
    这样，简单的扩展模块可以在一个已经安装了的服务器上制作了。
    请注意这个架构并不是企图用于实现一个统一的、可以用于制作所有与<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>相关的软件的架构；
    它只是用于自动化那些简单的服务器扩展模块的制作。对于更复杂的包，你还是需要书写自己的制作系统。
   </P
><P
>    要在你的扩展中使用该架构，你必须写一个简单的 makefile。
    在该makefile里，你需要设置一些变量并且最后包括全局的 <SPAN
CLASS="ACRONYM"
>PGXS</SPAN
> makefile。
    下面是一个制作一个包含一个共享库，一个 SQL 脚本，和一个文档文本文件的叫做 <TT
CLASS="LITERAL"
>isbn_issn</TT
> 的例子：
    
</P><PRE
CLASS="PROGRAMLISTING"
>MODULES = isbn_issn
DATA_built = isbn_issn.sql
DOCS = README.isbn_issn

PGXS := $(shell pg_config --pgxs)
include $(PGXS)</PRE
><P>
    最后两行应该总是一样的。在文件的前面，你赋予变量或者增加客户化的 <SPAN
CLASS="APPLICATION"
>make</SPAN
> 规则。
   </P
><P
>    可以设置下列变量：

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="VARNAME"
>MODULES</TT
></DT
><DD
><P
>	一个需要从同个根的源代码上制作的共享对象的列表（不要在这个列表里包含后缀）
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>DATA</TT
></DT
><DD
><P
>	安装到 <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>/share/contrib</TT
> 的随机文件
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>DATA_built</TT
></DT
><DD
><P
>	需要先制作的，安装到 <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>/share/contrib</TT
> 里面的随机文件。
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>DOCS</TT
></DT
><DD
><P
>	安装到 <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>/doc/contrib</TT
> 里面的随机文件
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>SCRIPTS</TT
></DT
><DD
><P
>	安装到 <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>/bin</TT
> 里面的脚本文件（非二进制）
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>SCRIPTS_built</TT
></DT
><DD
><P
>	安装到 <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>/bin</TT
> 里面的，需要先制作的脚本文件（非二进制）。
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>REGRESS</TT
></DT
><DD
><P
>	回归测试案例的列表（没有后缀）
       </P
></DD
></DL
></DIV
><P>

    或者最多声明下面两个之一：

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="VARNAME"
>PROGRAM</TT
></DT
><DD
><P
>	一个需要制作的二进制文件（在 <TT
CLASS="VARNAME"
>OBJS</TT
> 里面列出目标文件）
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>MODULE_big</TT
></DT
><DD
><P
>	一个需要制作的共享对象（在 <TT
CLASS="VARNAME"
>OBJS</TT
> 里列出目标文件）
       </P
></DD
></DL
></DIV
><P>

    还可以设置下列变量：

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="VARNAME"
>EXTRA_CLEAN</TT
></DT
><DD
><P
>	在 <TT
CLASS="LITERAL"
>make clean</TT
> 里删除的额外的文件
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>PG_CPPFLAGS</TT
></DT
><DD
><P
>	将增加到 <TT
CLASS="VARNAME"
>CPPFLAGS</TT
>
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>PG_LIBS</TT
></DT
><DD
><P
>	将增加到 <TT
CLASS="VARNAME"
>PROGRAM</TT
> 链接行里
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>SHLIB_LINK</TT
></DT
><DD
><P
>	将增加到 <TT
CLASS="VARNAME"
>MODULE_big</TT
> 连接行里
       </P
></DD
></DL
></DIV
><P>
   </P
><P
>    把这个 makefile 以 <TT
CLASS="LITERAL"
>Makefile</TT
> 的名字放在保存你的扩展的目录里。
    然后你就可以运行 <TT
CLASS="LITERAL"
>make</TT
> 来编译，然后用 <TT
CLASS="LITERAL"
>make install</TT
> 安装你的模块。
    这个扩展是为 <TT
CLASS="COMMAND"
>pg_config</TT
> 命令在你的路径里找到的第一个 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 安装编译和安装的。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN32524"
>32.9.8. 复合类型的 C 语言函数</A
></H2
><P
>        复合类型不象 C 结构那样有固定的布局。
        复合类型的实例可能包含空（null）域。
        另外，一个属于继承层次一部分的复合类
        型可能和同一继承范畴的其他成员有不同的域/字段。
        因此，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
        提供一个过程接口用于从 C 里面访问复合类型。
	</P
><P
>        假设我们为下面查询写一个函数

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT name, c_overpaid(emp, 1500) AS overpaid
	FROM emp
	WHERE name = 'Bill' OR name = 'Sam';</PRE
><P>

        在上面的查询里，用版本 0 的调用接口，我们可以这样定义<TT
CLASS="FUNCTION"
>c_overpaid</TT
>：
     
</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include "executor/executor.h"  /* 用 GetAttributeByName() */

bool
c_overpaid(HeapTupleHeader t, /* emp 的当前行*/
           int32 limit)
{
    bool isnull;
    int32 salary;

    salary = DatumGetInt32(GetAttributeByName(t, "salary", &amp;isnull));
    if (isnull)
        return (false);
    return salary &gt; limit;
}</PRE
><P>

	在版本-1编码，上面的东西会写成下面这样：

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include "executor/executor.h"  /* 用 GetAttributeByName() */

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &amp;isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
    /* 另外，我们可能更希望将 PG_RETURN_NULL() 用在空薪水上 */

    PG_RETURN_BOOL(DatumGetInt32(salary) &gt; limit);
}</PRE
><P>
    </P
><P
>        <TT
CLASS="FUNCTION"
>GetAttributeByName</TT
> 是
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 系统函数，
        用来返回当前记录的字段。它有三个参数：类型为
	<TT
CLASS="TYPE"
>HeapTupleHeader</TT
> 的传入函数的参数，你想要的字段名称，
        以及一个用以确定字段是否为空（null）的返回参数。
        <TT
CLASS="FUNCTION"
>GetAttributeByName</TT
> 函数返回一个<TT
CLASS="TYPE"
>Datum</TT
>值，
        你可以用对应的
	<TT
CLASS="FUNCTION"
>DatumGet<TT
CLASS="REPLACEABLE"
><I
>XXX</I
></TT
>()</TT
>
	 宏把它转换成合适的数据类型。
	 请注意，如果设置了空标志，那么返回值是无意义的，
	 在准备对结果做任何处理之前，总是要先检查空标志。
    </P
><P
>     还有一个 <TT
CLASS="FUNCTION"
>GetAttributeByNum</TT
>，它用字段编号而不是字段名选取目标字段。
    </P
><P
>	下面的命令在 SQL 里声明 <TT
CLASS="FUNCTION"
>c_overpaid</TT
> 函数：

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION c_overpaid(emp, integer) 
	RETURNS bool
	AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'c_overpaid'
	LANGUAGE C STRICT;</PRE
><P>

	请注意我们使用了 <TT
CLASS="LITERAL"
>STRICT</TT
>，这样我们就不需要检查输入参数是否有 NULL。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN32548"
>32.9.9. 从 C 函数里返回行（复合类型）</A
></H2
><P
>	要从一个 C 语言函数里返回一个行或者一个复合类型的数值，我们可以使用一个特殊的 API，
	它提供了许多宏和函数来消除大多数制作复合数据类型的复杂性。
	要使用该 API，源代码必须包含：
</P><PRE
CLASS="PROGRAMLISTING"
>#include "funcapi.h"</PRE
><P>
    </P
><P
>     制作一个复合类型数据值（也就是一个<SPAN
CLASS="QUOTE"
>"元组"</SPAN
>）有两种方法：
     你可以从一个 Datum 值数组里制作，也可以从一个可以传递给该元组的字段类型的输入转换函数的 C 字串数组里制作。
     不管是哪种方式，你首先都需要为元组结构获取或者制作一个 <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> 描述符。
     在使用 Datum 的时候，你给 <TT
CLASS="FUNCTION"
>BlessTupleDesc</TT
> 传递这个 <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> 然后为每行调用
     <TT
CLASS="FUNCTION"
>heap_form_tuple</TT
>。
     在使用 C 字串的时候，你给 <TT
CLASS="FUNCTION"
>TupleDescGetAttInMetadata</TT
> 传递 <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>，
     然后为每行调用 <TT
CLASS="FUNCTION"
>BuildTupleFromCStrings</TT
>。
     如果是一个函数返回一个元组集合的场合，所有设置步骤都可以在第一次调用该函数的时候一次性完成。
    </P
><P
>     有几个便利函数可以用于设置所需要的 <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>。
     在大多数返回复合类型给调用者的函数里建议的做法是这样的：
</P><PRE
CLASS="PROGRAMLISTING"
>TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)</PRE
><P>
     把传递给调用函数自己的 <TT
CLASS="LITERAL"
>fcinfo</TT
> 传递给他。（这个当然要求你使用版本 1 的调用习惯。）
     <TT
CLASS="VARNAME"
>resultTypeId</TT
> 可以声明为 <TT
CLASS="LITERAL"
>NULL</TT
> 或者事接收函数的结果类型 OID 的局部变量的地址（指针）。
     <TT
CLASS="VARNAME"
>resultTupleDesc</TT
> 应该是一个局部的 <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> 变量的地址（指针）。
     检查结果是否 <TT
CLASS="LITERAL"
>TYPEFUNC_COMPOSITE</TT
>；如是，<TT
CLASS="VARNAME"
>resultTupleDesc</TT
> 就已经填充好需要的
     <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> 了。
     （如不是，你可以报告一个类似<SPAN
CLASS="QUOTE"
>"返回记录的函数在一个不接受记录的环境中被调用"</SPAN
>的错误。）
    </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>提示: </B
>      <TT
CLASS="FUNCTION"
>get_call_result_type</TT
> 可以把一个多形的函数结果解析为实际类型；
      因此它在返回多形的标量结果的函数里也很有用，不仅仅是返回复合类型的函数里。
      <TT
CLASS="VARNAME"
>resultTypeId</TT
> 输出主要是用于那些返回多形的标量类型的函数的。
     </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>      <TT
CLASS="FUNCTION"
>get_call_result_type</TT
> 有一个同胞弟兄 <TT
CLASS="FUNCTION"
>get_expr_result_type</TT
>，
      可以用于给一个用表达式树表示的函数调用解析输出。
      它可以用于视图从函数本身外边判断结果类型的场合。还有一个 <TT
CLASS="FUNCTION"
>get_func_result_type</TT
>，
      可以用在只能拿到函数的 OID 的场合。不过，这些函数不能处理那些声明为返回 <TT
CLASS="STRUCTNAME"
>record</TT
> 的函数，
      并且 <TT
CLASS="FUNCTION"
>get_func_result_type</TT
> 不能解析多形的类型，
      因此你最好还是使用 <TT
CLASS="FUNCTION"
>get_call_result_type</TT
>。
     </P
></BLOCKQUOTE
></DIV
><P
>     旧的，现在已经废弃的获取 <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> 的函数是
  </P><PRE
CLASS="PROGRAMLISTING"
>  TupleDesc RelationNameGetTupleDesc(const char *relname)
  </PRE
><P>
     它可以从一个命名的关系里为行类型获取一个 <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>，还有是
  </P><PRE
CLASS="PROGRAMLISTING"
>  TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
  </PRE
><P>
     可以基于类型 OID 获取一个 <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>。
     它可以用于给一个基本类型或者一个复合类型获取 <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>。
     不过它不能处理返回 <TT
CLASS="STRUCTNAME"
>record</TT
> 的函数，并且不能解析多形的类型。
    </P
><P
>     一旦你有了一个 <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>，如果你想使用 Datum，那么调用
</P><PRE
CLASS="PROGRAMLISTING"
>TupleDesc BlessTupleDesc(TupleDesc tupdesc)</PRE
><P>
	如果你想用 C 字串，那么调用     
</P><PRE
CLASS="PROGRAMLISTING"
>AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)</PRE
><P>
     如果你在写一个返回集合的函数，那么你可以吧这些函数的结果保存在 <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
> 结构里 &mdash;
     分别使用 <TT
CLASS="STRUCTFIELD"
>tuple_desc</TT
> 或者 <TT
CLASS="STRUCTFIELD"
>attinmeta</TT
> 字段。
    </P
><P
>     在使用 Datum 的时候，使用
</P><PRE
CLASS="PROGRAMLISTING"
>HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, char *nulls)</PRE
><P>
     制作一个 <TT
CLASS="STRUCTNAME"
>HeapTuple</TT
>，它把数据以 Datum 的形式交给用户。
    </P
><P
>	在使用 C 字串的时候，用
</P><PRE
CLASS="PROGRAMLISTING"
>HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)</PRE
><P>
	制作一个 <TT
CLASS="STRUCTNAME"
>HeapTuple</TT
>，以 C 字串的形式给出用户数据。
	<SPAN
CLASS="QUOTE"
>"values"</SPAN
> 是一个 C 字串的数组，返回行的每个字段对应其中一个。
	每个 C 字串都应该是字段数据类型的输入函数预期的形式。为了从其中一个字段中返回一个空值，
	<TT
CLASS="PARAMETER"
>values</TT
> 数组中对应的指针应该设置为 <TT
CLASS="SYMBOL"
>NULL</TT
>。这个函数将会需要为你返回的每个元组调用一次。
    </P
><P
>	一旦你制作了一个从你的函数中返回的元组，那么该元组必须转换成一个 <TT
CLASS="TYPE"
>Datum</TT
>。使用
</P><PRE
CLASS="PROGRAMLISTING"
>HeapTupleGetDatum(HeapTuple tuple)</PRE
><P>
	把一个 <TT
CLASS="STRUCTNAME"
>HeapTuple</TT
> 转换为一个有效的 Datum。
	如果你想只返回一行，那么这个 <TT
CLASS="TYPE"
>Datum</TT
> 可以用于直接返回，
	或者是它可以用作在一个返回集合的函数里的当前返回值。
    </P
><P
>	例子在下面给出。
     </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-RETURN-SET"
>32.9.10. 从 C 语言函数里返回集合</A
></H2
><P
>     还有一个特殊的 API 用于提供从  C 语言函数中返回集合（多行）的支持。
     一个返回集合的函数必须遵循版本－1的调用方式。同样，源代码必须包含 <TT
CLASS="FILENAME"
>funcapi.h</TT
>，就像上面说的那样。
    </P
><P
>	一个返回集合的函数（<SPAN
CLASS="ACRONYM"
>SRF</SPAN
>）通常为它返回的每个项都调用一次。
	因此 <SPAN
CLASS="ACRONYM"
>SRF</SPAN
> 必须保存足够的状态用于记住它正在做的事情以及在每次调用的时候返回下一个项。
	表函数 API 提供了 <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
> 结构用于帮助控制这个过程。
	<TT
CLASS="LITERAL"
>fcinfo-&gt;flinfo-&gt;fn_extra</TT
> 用于保存一个跨越多次调用的指向 <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
> 的指针。
</P><PRE
CLASS="PROGRAMLISTING"
>typedef struct
{
    /*
     * 我们前面已经被调用的次数
     *
     * 初始的时候，call_cntr 被 SRF_FIRSTCALL_INIT() 置为里 0，并且
     * 每次你调用 SRF_RETURN_NEXT() 的时候都递增
     */
    uint32 call_cntr;

    /*
     * 可选的最大调用数量
     *
     * 这里的 max_calls 只是为了方便，设置它也是可选的
     * 如果没有设置，你必须提供可选的方法来知道函数何时结束
     * 
     */
    uint32 max_calls;

    /*
     * 指向结果槽位的可选指针
     *
     * 这个数据类型已经过时，只用于向下兼容。也就是那些使用
     * 废弃的 TupleDescGetSlot() 的用户定义 SRF
     */
    TupleTableSlot *slot;

    /*
     * 可选的指向用户提供的杂项环境信息的指针
     *
     * user_fctx 用做一个指向你自己的结构的指针，包含任意提供给你的函数的调用间的环境信息
     * 
     */
    void *user_fctx;

    /*
     * 可选的指向包含属性类型输入元信息的结构数组的指针
     * 
     *
     * attinmeta 用于在返回元组的时候（也就是说返回复合数据类型）
     * 在只返回基本（也就是标量）数据类型的时候并不需要。
     * 只有在你准备用 BuildTupleFromCStrings() 创建返回元组的时候才需要它
     * 
     */
    AttInMetadata *attinmeta;

    /*
     * 用于必须在多次调用间存活的结构的内存环境
     *
     * multi_call_memory_ctx 是由 SRF_FIRSTCALL_INIT() 为你设置的，并且由
     * SRF_RETURN_DONE() 用于清理。它是用于存放任何需要跨越多次调用 SRF 之间重复使用的内存
     * 
     * 
     */
    MemoryContext multi_call_memory_ctx;

    /*
     * 可选的指针，指向包含元组描述的结构
     *
     * tuple_desc 用于返回元组（也就是说复合数据类型）
     * 并且只是在你想使用 heap_form_tuple() 而不是  BuildTupleFromCStrings() 制作元组的
     * 时候需要。请注意这里存储的 TupleDesc 指针通常应该先用heap_form_tuple()
     * BlessTupleDesc() 处理。
     */
    TupleDesc tuple_desc;

} FuncCallContext;</PRE
><P>
	</P
><P
>	一个 <SPAN
CLASS="ACRONYM"
>SRF</SPAN
> 使用自动操作 <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
> 结构（我们可以通过 <TT
CLASS="LITERAL"
>fn_extra</TT
> 找到它）的若干个函数和宏。用
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_IS_FIRSTCALL()</PRE
><P>
	来判断你的函数是第一次调用还是后继的调用。（只有）在第一次调用的时候，用
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_FIRSTCALL_INIT()</PRE
><P>
	初始化 <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>。在每次函数调用时（包括第一次），使用
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_PERCALL_SETUP()</PRE
><P>
	为使用 <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
> 做恰当的设置以及清理任何前面的回合里面剩下的已返回的数据。
    </P
><P
>	如果你的函数有数据要返回，使用
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_RETURN_NEXT(funcctx, result)</PRE
><P>
	返回给调用者。（<TT
CLASS="LITERAL"
>result</TT
> 必须是个 <TT
CLASS="TYPE"
>Datum</TT
>，
	要么是单个值，要么是象前面介绍的那样准备的元组。）最后，如果你的函数结束了数据返回，使用
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_RETURN_DONE(funcctx)</PRE
><P>
	清理并结束<SPAN
CLASS="ACRONYM"
>SRF</SPAN
>。
    </P
><P
>	在 <SPAN
CLASS="ACRONYM"
>SRF</SPAN
> 被调用的时候的内存环境是一个临时的环境，
	在调用之间将会被清理掉。这意味着你不需要 <TT
CLASS="FUNCTION"
>pfree</TT
> 所有你
	<TT
CLASS="FUNCTION"
>palloc</TT
> 的东西；它会自动消失的。不过，如果你想分配任何跨越调用存在的数据结构，
	那你就需要把它们放在其它什么地方。被 <TT
CLASS="STRUCTFIELD"
>multi_call_memory_ctx</TT
>
	引用的环境适合用于保存那些需要直到 <SPAN
CLASS="ACRONYM"
>SRF</SPAN
> 结束前都存活的数据。
	在大多数情况下，这意味着你在做第一次调用的设置的时候应该切换到
	<TT
CLASS="STRUCTFIELD"
>multi_call_memory_ctx</TT
>。
    </P
><P
>	一个完整的伪代码例子看起来像下面这样：
</P><PRE
CLASS="PROGRAMLISTING"
>Datum
my_Set_Returning_Function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    MemoryContext     oldcontext;
    <TT
CLASS="REPLACEABLE"
><I
>还有更多的声明</I
></TT
>

    if (SRF_IS_FIRSTCALL())
    {
        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* 这里放出现一次的设置代码：*/
        <TT
CLASS="REPLACEABLE"
><I
>用户定义代码</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>if 返回复合</I
></TT
>
            <TT
CLASS="REPLACEABLE"
><I
>制作 TupleDesc，以及可能还有 AttInMetadata</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>endif 返回复合</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>用户定义代码</I
></TT
>
        MemoryContextSwitchTo(oldcontext);
    }

    /* 每次都执行的设置代码在这里出现：*/
    <TT
CLASS="REPLACEABLE"
><I
>用户定义代码</I
></TT
>
    funcctx = SRF_PERCALL_SETUP();
    <TT
CLASS="REPLACEABLE"
><I
>用户定义代码</I
></TT
>

    /* 这里只是用来测试我们是否完成的一个方法：*/
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* 这里我们想返回另外一个条目：*/
         <TT
CLASS="REPLACEABLE"
><I
>用户代码</I
></TT
>
         <TT
CLASS="REPLACEABLE"
><I
>获取结果 Datum</I
></TT
>
         SRF_RETURN_NEXT(funcctx, result);
     }
     else
     {
         /* 这里我们完成返回条目的工作了，只需要清理就OK了：*/
         <TT
CLASS="REPLACEABLE"
><I
>用户代码</I
></TT
>
         SRF_RETURN_DONE(funcctx);
     }
 }
 </PRE
><P>
     </P
><P
>	一个返回复合类型的完整 <SPAN
CLASS="ACRONYM"
>SRF</SPAN
> 例子看起来象这样：
 </P><PRE
CLASS="PROGRAMLISTING"
> PG_FUNCTION_INFO_V1(retcomposite);

 Datum
 retcomposite(PG_FUNCTION_ARGS)
 {
     FuncCallContext     *funcctx;
     int                  call_cntr;
     int                  max_calls;
     TupleDesc            tupdesc;
     AttInMetadata       *attinmeta;

      /* 只是在第一次调用函数的时候干的事情 */
      if (SRF_IS_FIRSTCALL())
      {
         MemoryContext   oldcontext;

         /* 创建一个函数环境，用于在调用间保持住 */
         funcctx = SRF_FIRSTCALL_INIT();

         /* 切换到适合多次函数调用的内存环境 */
         oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);

         /* 要返回的元组总数 */
         funcctx-&gt;max_calls = PG_GETARG_UINT32(0);

         /*
          * 为我们的结果类型制作一个元组描述
          */
         if (get_call_result_type(fcinfo, NULL, &amp;tupdesc) != TYPEFUNC_COMPOSITE)
             ereport(ERROR,
                     (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                      errmsg("function returning record called in context "
                             "that cannot accept type record")));

         /*
          * 生成稍后从裸 C 字串生成元组的属性元数据
          * 
          */
         attinmeta = TupleDescGetAttInMetadata(tupdesc);
         funcctx-&gt;attinmeta = attinmeta;

         MemoryContextSwitchTo(oldcontext);
     }

     /* 每次函数调用都要做的事情 */
     funcctx = SRF_PERCALL_SETUP();

     call_cntr = funcctx-&gt;call_cntr;
     max_calls = funcctx-&gt;max_calls;
     attinmeta = funcctx-&gt;attinmeta;

     if (call_cntr &lt; max_calls)    /* 在还有需要发送的东西时继续处理 */
     {
         char       **values;
         HeapTuple    tuple;
         Datum        result;

         /*
          * 准备一个数值数组用于版本的返回元组。
          * 它应该是一个 C 字串数组，稍后可以被合适的类型输入函数处理。
          * 
          */
         values = (char **) palloc(3 * sizeof(char *));
         values[0] = (char *) palloc(16 * sizeof(char));
         values[1] = (char *) palloc(16 * sizeof(char));
         values[2] = (char *) palloc(16 * sizeof(char));

         snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
         snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
         snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

         /* 制作一个元组 */
         tuple = BuildTupleFromCStrings(attinmeta, values);

         /* 把元组做成 datum */
	 result = HeapTupleGetDatum(tuple);

         /* 清理（这些实际上并非必要） */
         pfree(values[0]);
         pfree(values[1]);
         pfree(values[2]);
         pfree(values);

          SRF_RETURN_NEXT(funcctx, result);
     }
     else    /* 在没有数据残留的时候干的事情 */
     {
          SRF_RETURN_DONE(funcctx);
     }
 }
 </PRE
><P>

     在 SQL 里声明这个函数的一个方法是：
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</PRE
><P>
     另外一个方法是使用 OUT 参数：
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</PRE
><P>
     请注意在这个方法里，函数的输出类型实际上是匿名的 <TT
CLASS="STRUCTNAME"
>record</TT
> 类型。
     </P
><P
>	参阅源码发布包里的 <TT
CLASS="FILENAME"
>contrib/tablefunc</TT
> 获取更多有关返回集合的函数的例子。
     </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN32673"
>32.9.11. 多态参数和返回类型</A
></H2
><P
>     C 语言函数可以声明为接受和返回多态的类型 <TT
CLASS="TYPE"
>anyelement</TT
> 和 <TT
CLASS="TYPE"
>anyarray</TT
>。
     参阅 <A
HREF="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC"
>Section 32.2.5</A
> 获取有关多态函数的更详细的解释。
     如果函数参数或者返回类型定义为多态类型，那么函数的作者就无法预先知道他将收到的参数，
     以及需要返回的数据。在 <TT
CLASS="FILENAME"
>fmgr.h</TT
> 里有两个过程，可以让版本－1的 C 函数知道它的参数的确切数据类型以及它需要返回的数据类型。
     这两个过程叫 <TT
CLASS="LITERAL"
>get_fn_expr_rettype(FmgrInfo *flinfo)</TT
> 和 <TT
CLASS="LITERAL"
>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</TT
>。
     它们返回结果或者参数的类型 OID，如果这些信息不可获取，则返回 <TT
CLASS="SYMBOL"
>InvalidOid</TT
>。
     结构 <TT
CLASS="LITERAL"
>flinfo</TT
> 通常是以 <TT
CLASS="LITERAL"
>fcinfo-&gt;flinfo</TT
> 进行访问的。参数 <TT
CLASS="LITERAL"
>argnum</TT
> 是以 0 为基的。
     <TT
CLASS="FUNCTION"
>get_call_result_type</TT
> 也可以用做 <TT
CLASS="FUNCTION"
>get_fn_expr_rettype</TT
> 替换。
    </P
><P
>     比如，假设我们想写一个函数接受任意类型的一个元素，并且返回该类型的一个一维数组：

</P><PRE
CLASS="PROGRAMLISTING"
>PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* 获取提供的元素 */
    element = PG_GETARG_DATUM(0);

    /* 我们的维数是 1 */
    ndims = 1;
    /* 有一个元素 */
    dims[0] = 1;
    /* 数组下界是 1*/
    lbs[0] = 1;

    /* 获取有关元素类型需要的信息 */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);

    /* 然后制作数组 */
    result = construct_md_array(&amp;element, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}</PRE
><P>
    </P
><P
>     下面的命令用 SQL 声明函数 <TT
CLASS="FUNCTION"
>make_array</TT
>：

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'make_array'
    LANGUAGE C STRICT;</PRE
><P>

     请注意使用 <TT
CLASS="LITERAL"
>STRICT</TT
>；这一点非常重要，因为代码没有认真测试空输入。
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xfunc-internal.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xaggr.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>内部函数</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="extend.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>用户定义聚集</TD
></TR
></TABLE
></DIV
><script src="http://count1.chinaitlab.com/mystat.asp?siteid=32"></script></body></HTML
>