<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.1  (Win32)">
	<META NAME="CREATED" CONTENT="20120714;20392900">
	<META NAME="CHANGED" CONTENT="20130422;19102400">
	<STYLE TYPE="text/css">
	<!--
		@page { margin: 0.79in }
		TD P { margin-bottom: 0in }
		TD P.western { font-family: "Verdana", sans-serif; font-size: 10pt }
		H1 { margin-bottom: 0.08in; background: transparent; page-break-before: auto; page-break-after: auto }
		H1.western { font-family: "Verdana", sans-serif; font-size: 16pt }
		H1.cjk { font-family: "Lucida Sans Unicode"; font-size: 16pt }
		H1.ctl { font-family: "Tahoma"; font-size: 16pt }
		P { margin-bottom: 0.08in }
		P.western { font-family: "Verdana", sans-serif; font-size: 10pt }
		H2 { margin-bottom: 0.08in }
		H2.western { font-family: "Verdana", sans-serif; font-size: 13pt }
		H3 { margin-bottom: 0.08in }
		H3.western { font-family: "Verdana", sans-serif; font-size: 11pt }
		PRE.code { page-break-before: auto; page-break-after: auto }
		A:link { so-language: zxx }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<P CLASS="western" STYLE="margin-bottom: 0in"><A HREF="http://www.brokenthorn.com/"><IMG SRC="http://brokenthorn.com/Resources/site/5.png" NAME="graphics1" ALIGN=BOTTOM WIDTH=375 HEIGHT=71 BORDER=0></A>
<SCRIPT>
<!--

google_ad_client = "pub-9243579471203558";

google_ad_width = 468;

google_ad_height = 60;

google_ad_format = "468x60_as";

google_ad_type = "image";

google_ad_channel = "";

google_ui_features = "rc:6";

//-->

</SCRIPT>
<SCRIPT SRC="http://pagead2.googlesyndication.com/pagead/show_ads.js"></SCRIPT></P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% HEIGHT=12 BGCOLOR="#000080">
			<P CLASS="western" STYLE="page-break-after: avoid"><FONT COLOR="#ffffff"><FONT FACE="Verdana, sans-serif"><FONT SIZE=2><B>Operating
			System Development Series</B></FONT></FONT></FONT></P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western"><SCRIPT SRC="http://www.gmodules.com/ig/ifr?url=http://www.google.com/ig/modules/translatemypage.xml&amp;up_source_language=en&amp;synd=open&amp;w=160&amp;h=60&amp;title=&amp;lang=en&amp;country=ALL&amp;border=%23ffffff%7C3px%2C1px+solid+%23999999&amp;output=js"></SCRIPT>This
series is intended to demonstrate and teach operating system
development from the ground up.</P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=4 CELLSPACING=0 RULES=NONE>
	<COL WIDTH=129*>
	<COL WIDTH=127*>
	<TR VALIGN=TOP>
		<TD WIDTH=50% STYLE="background: url(images/BlueToWhiteGradient.jpg) no-repeat top left scroll">
			<P CLASS="western" STYLE="margin-top: 0.17in; font-style: normal; text-decoration: none; page-break-after: avoid">
			<FONT COLOR="#000000"><FONT FACE="Verdana"><FONT SIZE=5 STYLE="font-size: 19pt"><B>24:
			Process Management</B></FONT></FONT></FONT></P>
			<P CLASS="western">by Mike, 2012, 2013</P>
		</TD>
		<TD WIDTH=50%>
			<BLOCKQUOTE><FONT COLOR="#000000">&ldquo;</FONT><EM><FONT COLOR="#000000"><FONT FACE="Arial, sans-serif"><FONT SIZE=2><SPAN STYLE="font-weight: normal">If
			debugging is the process of removing software bugs, then
			programming must be the process of putting them in.</SPAN></FONT></FONT></FONT></EM><FONT FACE="Arial, sans-serif"><FONT SIZE=2>&ldquo;
			-</FONT></FONT><FONT COLOR="#000000"><FONT FACE="Arial, sans-serif"><FONT SIZE=2>&nbsp;</FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Arial, sans-serif"><FONT SIZE=2><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">Edsger
			Dijkstra</SPAN></SPAN></FONT></FONT></FONT><FONT FACE="Arial, sans-serif"><FONT SIZE=2>
			</FONT></FONT>
			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
<H1 CLASS="western">Introduction</H1>
<P CLASS="western">This chapter details the topics of process
management and multitasking. The previous chapters have built a basic
monolithic operating system capable of now supporting tasks. A lot of
decisions made up to this point in developing the OS was to sacrifice
complexity for simplicity; while still providing some detail in the
complex designs. I will continue this trend in this chapter; the
demonstration presented at the end by no means represents the only
way to develop an OS. This chapter will cover the following topics:</P>
<OL>
	<LI><P CLASS="western">Processes</P>
	<LI><P CLASS="western">Threads and tasks</P>
	<LI><P CLASS="western">Looking inside a process</P>
	<LI><P CLASS="western">Process management</P>
	<LI><P CLASS="western">Scheduling</P>
	<LI><P CLASS="western">Linking</P>
</OL>
<H2 CLASS="western">Process management</H2>
<P CLASS="western">Process management is the process by which
operating systems manage processes, threads, enable processes to
share information, protect process resources and allocate system
resources to processes that request them in a safe manner. This can
be a daunting task to the operating system developer and can be very
complex in design. Lets take a closer look at each one of these.</P>
<H3 CLASS="western">Processes and threads</H3>
<P CLASS="western">We will primarily be discussing processes and
threads throughout the rest of this chapter. Process creation implies
loading an executable image and creating at least one execution path
(thread) to run it.</P>
<H3 CLASS="western">Inter-Process Communication</H3>
<P CLASS="western">Inter-Process Communication (IPC) is a technique
employed by many operating systems to allow communication between
processes. This is typically done by message passing: the process
would request to send a message to another process to the operating
system which would send and queue the message to the other process if
it is able to. IPC can be implemented in a number of different ways,
the most common being files, pipes, sockets, message passing,
signals, semaphores, shared memory, and memory mapped files.
Operating systems may implement any or all of these methods of IPC.
IPC is heavily used in some hybrid and monolithic kernel designs but
is arguably most prominent in micro kernel designs.</P>
<P CLASS="western">This chapter primarily focuses on that of process
and thread creation and thus will not focus on that of IPC. We may
discuss IPC a little later but probably as an addition to this
chapter.</P>
<H3 CLASS="western">Process protection</H3>
<P CLASS="western">Loading multiple processes into the same address
space poses a fundamental problem: both processes can read or write
each other. The simple solution to this is loading the processes into
their own virtual address spaces and mapping them to separate
locations in the physical address space. The process can request to
create more threads: this is on a per-process bases so all threads
share the same address space as the process as you will soon see.</P>
<P CLASS="western">Process protection is also employed by mapping
processes with the least amount of control that they need: for
example, processes that must be in kernel land should be in kernel
space, processes that do not need to be in kernel land should be in
user space.</P>
<P CLASS="western">We will be utilizing both of these in this chapter
when creating processes. They will be mapped into user space and in
their own virtual address space. This means the process will not be
able to access kernel pages (so cannot trash kernel stack or
structures) nor can the process trash another process as they are in
separate address spaces.</P>
<H3 CLASS="western">Resource allocation</H3>
<P CLASS="western">Resource allocation means the safe manner of
handing system resources (such as files or device handles) to
processes that request them. Due to the early state of the series OS,
there really is no resources that we need to worry about at this
time. As things are needed, though, process resources that have been
allocated are typically stored within the <B>process control block</B>.
If you are wondering why we need to manage system resource
allocation, consider the case in a multi-tasking environment when two
processes try to open the same file at the same time and write to it.</P>
<P CLASS="western">With that in mind, we will be focusing on the
creation of processes and threads in the following sections. We begin
by providing a clear definition of what these are and what
constitutes a process.</P>
<H2 CLASS="western">Processes</H2>
<P CLASS="western">A <B>process</B> <SPAN STYLE="font-weight: normal">is
an instance of a program, or part of a program, in memory. Processes
are executed by the operating system or executive in order to perform
complex tasks: such as play a movie or video, play a game, or even
run the editor used to write this text in. In essence, one could say
a process is a program &ndash; but a program could contain multiple
processes. For example, a basic program to display a string might be
built in its own program file. Loading the program might yield the
operating system or executive to load other program files &ndash;
</SPAN><B>dynamic loading</B> <SPAN STYLE="font-weight: normal">of
</SPAN><B>shared libraries</B> <SPAN STYLE="font-weight: normal">containing
executable code for the process to call and use. All of these program
files are a part of the same process; its why a process can have an
instance of multiple program files or even multiple instances.</SPAN></P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">Processes may
execute in emulated or hardware environments by a </SPAN><B>central
processing unit (CPU)</B> <SPAN STYLE="font-weight: normal">or
multiple CPUs or CPU cores. CPUs that support </SPAN><B>hyper
threading</B> <SPAN STYLE="font-weight: normal">or </SPAN><B>parallel
pipeling</B> <SPAN STYLE="font-weight: normal">can also execute
multiple instructions from different processes at the same time. This
means that the process may not be executed in a sequential manner
(one instruction at a time) but may be executed in a number of
different ways depending on the environment and hardware
configuration. The IA32 CPU family defaults with these features
disabled. This means that at computer startup, the CPU will execute
all instructions one at a time (although might cache them in an
</SPAN><B>instruction cache buffer</B><SPAN STYLE="font-weight: normal">).
However if the operating system or executive were to enable these
features for a process, the process and system must be designed in a
way to be </SPAN><B>multi-processor safe</B><SPAN STYLE="font-weight: normal">.
This one is an advanced topic however and is very easy to run into
errors and thus will be discussed in an advanced chapter. </SPAN>We
can break some processes apart into <B>threads</B> <SPAN STYLE="font-weight: normal">and
</SPAN><B>tasks</B><SPAN STYLE="font-weight: normal">. We will look
at these next.</SPAN></P>
<H2 CLASS="western">Threads and tasks</H2>
<P CLASS="western"><B>Threads</B> <SPAN STYLE="font-weight: normal">can
be defined as a </SPAN><B>single execution path inside of a process.</B>
<SPAN STYLE="font-weight: normal">For example, in the most basic of
an example we can have a program that just displays a message and
returns:</SPAN></P>
<PRE CLASS="code">#include &lt;stdio.h&gt;
int main (int argc, char** argv) {
   printf (&ldquo;Hello, world!&rdquo;);
   return 0;
<FONT FACE="Lucida Console, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">}</FONT></FONT></PRE><P CLASS="western" STYLE="font-weight: normal">
In this example, the process has a single thread: it begins at main()
and the thread ends when the process terminates. (Do note however
that this might not actually be the case: The runtime library that
calls main() might contain threads.) Lets look at a multithreaded
example:</P>
<PRE CLASS="code">#include &lt;stdio.h&gt;
static int _notExit = 0;

int thread (void* data) {
   while (_notExit) {
      <FONT COLOR="#008000"><B>/* do something useful */</B></FONT>
   }
   return 0; <FONT COLOR="#008000"><B>/* thread terminates (returns to runtime which calls TerminateThread */</B></FONT>
}

int main (int argc, char** argv) {
   CreateThread (thread);
   printf (&ldquo;Hello, world!&rdquo;);
   return 0;
<FONT FACE="Lucida Console, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">}</FONT></FONT></PRE><P CLASS="western">
<SPAN STYLE="font-weight: normal">In this example, </SPAN><B>CreateThread</B>
<SPAN STYLE="font-weight: normal">calls the operating system to set
</SPAN><B>thread()</B> <SPAN STYLE="font-weight: normal">as a new
</SPAN><B>flow of execution</B><SPAN STYLE="font-weight: normal">.
After </SPAN><B>CreateThread()</B> <SPAN STYLE="font-weight: normal">if
called, </SPAN><B>thread()</B> <SPAN STYLE="font-weight: normal">will
be called by the operating system or executive and </SPAN><B>execution
will continue inside of both thread() and main() simultaneously</B>
<SPAN STYLE="font-weight: normal">until one of them terminates.
Notice that all processes are threads, but threads are not processes.
A process can contain a single thread or many threads. Threads inside
of a process can access and share the same global variables; although
some compilers support </SPAN><B>thread-local variables</B> <SPAN STYLE="font-weight: normal">as
well.</SPAN></P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">Operating
systems that support threads are said to be </SPAN><B>multi-threading
capable</B><SPAN STYLE="font-weight: normal">. Examples of such
operating systems include Windows, Linux, and Mac OS. </SPAN><B>Tasks</B>
<SPAN STYLE="font-weight: normal">are synonymous with threads. Tasks
represent a task for the operating system or executive to execute.
Thus any operating system that supports </SPAN><B>multithreading</B>
<SPAN STYLE="font-weight: normal">effectively supports </SPAN><B>multitasking</B><SPAN STYLE="font-weight: normal">.
It is important to note though that not all multitasking operating
systems supporting multi-threading.</SPAN></P>
<P CLASS="western" STYLE="font-weight: normal">What exactly is a
process? We have currently defined a process as an instance of a
program or a part of a program; lets elaborate on this definition by
taking a deeper look inside of a process.</P>
<H2 CLASS="western">Looking inside a process</H2>
<P CLASS="western"><SPAN STYLE="font-weight: normal">If we were to
break apart a process, all we will see at the most fundamental level
is code and data. Given ones' experience in programming, this makes
sense: All programs are simply instructions instructing the CPU to
perform an action or operating on data. It is understandable why
programmers tend to separate the &ldquo;data&rdquo; part of the
program from the &ldquo;code&rdquo; part in order to facilitate
program development. </SPAN><B>.data</B> <SPAN STYLE="font-weight: normal">and
</SPAN><B>.text</B> <SPAN STYLE="font-weight: normal">(for program
code) are two of what later became many different types of </SPAN><B>sections</B>
<SPAN STYLE="font-weight: normal">within a program binary. Sections
not only help program development but also facilitates standards for
how different types of things can be stored within program binaries.</SPAN></P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">We will first
discuss program sections and how they can be placed within a </SPAN><B>process
address space</B><SPAN STYLE="font-weight: normal">. We can then
discuss </SPAN><B>symbolic information</B><SPAN STYLE="font-weight: normal">,
</SPAN><B>debugging information, export and import tables,</B> <SPAN STYLE="font-weight: normal">and
how they can be used.</SPAN></P>
<H3 CLASS="western">Program sections</H3>
<P CLASS="western">We have already looked at two sections (or
<B>segments</B><SPAN STYLE="font-weight: normal">): </SPAN><B>.data</B>
<SPAN STYLE="font-weight: normal">and </SPAN><B>.text</B><SPAN STYLE="font-weight: normal">.
The program file contains these and other sections. The operating
system or executive can load each section in the address space for
the process to execute correctly. </SPAN><B>Sections can also be
relocated</B> <SPAN STYLE="font-weight: normal">during load time.
This allows the operating system or executive to find the best
location for each section if it needs to and update the process
accordingly. However, </SPAN><B>different program file formats</B><B>
support different things</B> <SPAN STYLE="font-weight: normal">so not
all program file formats support section relocating.</SPAN></P>
<P CLASS="western"><IMG SRC="images/osdev24_html_3f0ec2da.gif" NAME="graphics2" ALIGN=LEFT WIDTH=181 HEIGHT=309 BORDER=0><BR CLEAR=LEFT><SPAN STYLE="font-weight: normal">The
</SPAN><B>Portable Executable (PE)</B> <SPAN STYLE="font-weight: normal">file
format is the primary program file format used by the Windows
operating system. The PE file format supports many different sections
for code, data, resource data, symbolic information, manifest data,
and more. Each section is stored within the binary file written by
the linker or compiler. In order to see how it is stored in the file,
we need to take a look at the format of the PE file format.</SPAN></P>
<P CLASS="western" STYLE="font-weight: normal">The above is an image
of what is inside of the PE executable file. We can load an image
into memory and parse the file contents as any other type of binary
file so long as the sections do not need to be relocated. This is how
the series boot loader is able to load our kernel image: The kernel
in the series does not require section relocation so the boot loader
can just load the file, locate the entry point in the headers, and
call it directly. This is easy to do:</P>
<PRE CLASS="code"><FONT COLOR="#008000"><B>/* Get entry point from PE headers */</B></FONT>
IMAGE_DOS_HEADER dosHeader = (IMAGE_DOS_HEADER*) imageBase;
IMAGE_NT_HEADERS ntHeaders = dosHeader-&gt;<FONT COLOR="#000000"><SPAN STYLE="font-style: normal">e_lfanew;</SPAN></FONT>
IMAGE_OPTIONAL_HEADER optHeader = &amp;ntHeaders-&gt;OptionalHeader;
void (*EntryPoint) (void) = (void (*EntryPoint) (void) ) optHeader-&gt;AddressOfEntryPoint + optHeader-&gt;ImageBase;

<FONT COLOR="#008000"><B>/* Call program entry point */</B></FONT>
EntryPoint ();</PRE><P CLASS="western" STYLE="font-weight: normal">
In a similar manner, we could parse the other headers and extract any
type of information we want from the file: section information,
debugging information, symbolic information, and more. <B>Kernel
debuggers</B> and <B>user mode debuggers</B> typically use symbolic
and debugging information to facilitate debugging. In other words,
you could build your PE image with debugging information (or
without); if you build it with you can attach a debugger to it
remotely to perform source level debugging.</P>
<P CLASS="western" STYLE="font-weight: normal">Having different
sections inside of the executable files makes it easier for parsing
and writing executable files. They provide a consistent location and
way to store the data and reference them from headers. For example,
in PE files there is a <B>.rscs</B> section that stores the actual
resources (string table, bitmap images, program info, cursor, etc.)
In order to locate a resource, we just need to parse the directory
entry for it at <B>OptionalHeader-&gt;DirectoryEnteries
[</B><FONT COLOR="#000000"><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-style: normal"><B>IMAGE_DIRECTORY_ENTRY_RESOURCE</B></SPAN></FONT></FONT><B>]</B>
which gives us an RVA (relative pointer) to the resource tree
structures that point to the resource data inside of the .rscs.
section. The point is that the executable format has a specific
format defined by the <I>PE file specification</I>. It has a specific
format so there is a standard way to get information from the file.</P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">Many compilers
such as GCC and CL (Microsoft's compiler) is also capable of
</SPAN><B>programmer-defined sections</B><SPAN STYLE="font-weight: normal">.
In other words, programmers can also define their own section names
and put whatever they need into that section. Operating system
kernels and executives typically define special sections for
different purposes. For example, both Linux and Windows define a
special </SPAN><B>.INIT</B> <SPAN STYLE="font-weight: normal">section
containing one time initialization code and data. When initialization
completes, the operating system kernel can free the section and
re-use it for other things.</SPAN></P>
<H3 CLASS="western"><B>Common sections</B></H3>
<P CLASS="western" STYLE="font-weight: normal">There is a set of
section names and types that are common to different object files and
even architectures. It is important to be able to recognize these
sections and what they are used for. They are as follows:</P>
<OL>
	<LI><P CLASS="western" ALIGN=LEFT STYLE="font-weight: normal">.text</P>
	<LI><P CLASS="western" ALIGN=LEFT STYLE="font-weight: normal">.data</P>
	<LI><P CLASS="western" ALIGN=LEFT STYLE="font-weight: normal">.bss</P>
	<LI><P CLASS="western" ALIGN=LEFT STYLE="font-weight: normal">.rodata</P>
</OL>
<P CLASS="western"><SPAN STYLE="font-weight: normal">The </SPAN><B>.text</B>
<SPAN STYLE="font-weight: normal">section is the common section name
given to the section that contains program code. This is also known
as the </SPAN><B>code segment</B><SPAN STYLE="font-weight: normal">.
This section might be read only on some systems in order to prevent
writing to it; however this prevents self modifying code (which is
typically not recommended anyways.)</SPAN></P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">The </SPAN><B>.data</B>
<SPAN STYLE="font-weight: normal">section, as its name suggests,
contains </SPAN><B>static</B> <SPAN STYLE="font-weight: normal">and
</SPAN><B>global</B> <SPAN STYLE="font-weight: normal">data used by
the program. It is always writable.</SPAN></P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">The </SPAN><B>.bss</B>
<SPAN STYLE="font-weight: normal">section is a part of the .data
section and is typically used for statically allocated data that are
initialized to zero. The .bss section is always cleared by the
operating system loader so all of the data in it is set to zero. The
name &ldquo;.bss&rdquo;, according to Wikipedia, initially stood for
Block Started by Symbol in the United Aircraft Symbolic Assembly
Program. The .bss section contains all null variables and so does not
take any space in the object files.</SPAN></P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">The </SPAN><B>.rodata</B>
<SPAN STYLE="font-weight: normal">section contains read only
statically allocated data. It is typically common in Linux and Unix
environments.</SPAN></P>
<P CLASS="western" STYLE="font-weight: normal">Notice that there is
no section for temporary data. Recall that temporary variables are
stored on the stack and thus do not need to be stored in the program
file.</P>
<H3 CLASS="western"><B>Custom sections in Microsoft Visual C</B></H3>
<P CLASS="western" STYLE="font-weight: normal">Microsoft's compiler
provides several pragma directives that programmers can use to
control where to place data and code in specific sections and making
custom sections. These are:</P>
<OL>
	<LI><P CLASS="western" STYLE="font-weight: normal">alloc_text</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">code_seg</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">const_seg</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">data_seg</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">bss_seg</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">init_seg</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">section</P>
</OL>
<P CLASS="western" STYLE="font-weight: normal">The program loader
does not need to worry about any special sections that the program
has, all it needs to concern itself with is loading them into memory.
The program (and thus programmer) has the responsibility.</P>
<P CLASS="western" STYLE="font-weight: normal">Here is an example of
using alloc_text for adding a function to a special section.</P>
<PRE CLASS="code" STYLE="font-weight: normal">error_t DECL mmInitialize (SystemBoot* mb) {
   <SPAN STYLE="font-weight: normal">return SUCCESS;</SPAN>
}
#pragma alloc_text (&ldquo;.init&rdquo;, mmInitialize);</PRE><P CLASS="western">
<SPAN STYLE="font-weight: normal">In the above example, </SPAN><B>mmInitialize</B>
<SPAN STYLE="font-weight: normal">will be added to the section </SPAN><B>.init</B><SPAN STYLE="font-weight: normal">.
This is a useful tactic used by some operating system kernels and
executives. For example, the operating system kernel or executive can
add or initialization code and data to a special .init section. Once
initialization completes, the operating system can free that section
to get some of the memory back.</SPAN></P>
<H3 CLASS="western">Symbolic information</H3>
<P CLASS="western"><B>Symbolic information</B> <SPAN STYLE="font-weight: normal">is
the </SPAN><B>symbols</B> <SPAN STYLE="font-weight: normal">that
programmers give as names of addresses. For example, when we call a
function like </SPAN><B>printf()</B> <SPAN STYLE="font-weight: normal">how
can the compiler and linker know what to do? Lets take a closer look.</SPAN></P>
<P CLASS="western">&ldquo;<B>printf&rdquo;</B> <SPAN STYLE="font-weight: normal">is
a symbol for a function defined in a library. When we call
&ldquo;printf()&rdquo;, the compiler adds the symbol </SPAN><B>printf</B>
<SPAN STYLE="font-weight: normal">to a </SPAN><B>symbol table</B>
<SPAN STYLE="font-weight: normal">managed by the compiler during the
build process. Notice that the </SPAN><B>name of the function is a
symbol.</B> <SPAN STYLE="font-weight: normal">In a similar way,
</SPAN><B>static and global variables are also symbols</B><SPAN STYLE="font-weight: normal">.
We can argue that any name we give to an address (like a </SPAN><B>label</B>
<SPAN STYLE="font-weight: normal">in assembly language) is a symbol.
Thus a symbol has two things: A name and an address.</SPAN></P>
<P CLASS="western" STYLE="font-weight: normal">If we build without
linking the library containing the code for printf, the compiler is
unable to output the final executable because it will not be able to
translate the entire code to machine language. In other words, like
an assembler, it cannot do anything with code like the following
unless it knows what the function is:</P>
<PRE CLASS="code" STYLE="margin-bottom: 0.2in">call _printf</PRE><P CLASS="western">
<SPAN STYLE="font-weight: normal">An assembler cannot completely
assemble this instruction unless it knows the address of the symbol
</SPAN><B>_printf</B><SPAN STYLE="font-weight: normal">. The
assembler can not know the address if it does not know anything about
the symbol. To resolve this, we declare that the symbol is </SPAN><B>external</B>
<SPAN STYLE="font-weight: normal">and the assembler or compiler
outputs an </SPAN><B>object file</B> <SPAN STYLE="font-weight: normal">instead
of an executable file. It partially translates the instruction to
machine code but in a form like this:</SPAN></P>
<P CLASS="western" STYLE="font-style: normal; font-weight: normal"><FONT COLOR="#000000"><FONT FACE="Lucida Console, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">0xe8
_printf</FONT></FONT></FONT></P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">This allows us
to use another program&mdash;a </SPAN><I><SPAN STYLE="font-weight: normal">linker&mdash;</SPAN></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">to
resolve these symbols. The linker looks at the export symbol tables
in the different object files and libraries for the symbol &ldquo;_printf&rdquo;.
If it is found, the linker can get the address of the function code
and update the machine code with that address to properly link and
output a final executable program. If the symbol is not found, it is
</SPAN></SPAN><I><SPAN STYLE="font-weight: normal">unresolved</SPAN></I>
<SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">and
the linker gives us the famous &ldquo;unresolved external symbol&rdquo;
error.</SPAN></SPAN></P>
<P CLASS="western" STYLE="font-style: normal; font-weight: normal">Symbolic
information in the executable image can be used by debuggers to
display human-readable information (functions and variable) names but
at the cost of a bigger program file size.</P>
<P CLASS="western"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">There
are different ways to &ldquo;store&rdquo; additional information
about a symbol in the symbol name itself. This differs based on the
</SPAN></SPAN><SPAN STYLE="font-style: normal"><B>build environment</B></SPAN>
<SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">and
c</SPAN></SPAN><SPAN STYLE="font-style: normal"><B>alling convention</B></SPAN><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">.
The standard C calling convention is CDECL which just prepends an
underscore to all names. So, for example, if we call &ldquo;printf()&rdquo;;
its CDECL symbolic name is &ldquo;_printf&rdquo;. C++ symbolic names
differ between compilers and store a lot more information then just a
name (such as return data types and operand types, namespace,
classes, template names, etc.) Due to this, C++ symbolic names are
said to undergo </SPAN></SPAN><SPAN STYLE="font-style: normal"><B>name-mangling</B></SPAN><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">.
For example, the function &ldquo;</SPAN></SPAN><FONT COLOR="#000000"><FONT FACE="Lucida Console, monospace"><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-style: normal"><B>void
h(void)</B></SPAN></FONT></FONT></FONT><FONT COLOR="#000000">&rdquo;
</FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">in
CL (Microsoft's compiler) translates to the symbolic name</SPAN></SPAN></FONT></FONT></FONT><FONT COLOR="#000000">
</FONT><FONT COLOR="#000000"><FONT FACE="monospace, Courier"><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-style: normal"><B>?h@@YAXXZ</B></SPAN></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Lucida Console, monospace"><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">.
</SPAN></SPAN></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">I
will not go into the details of the name mangling format here.</SPAN></SPAN></FONT></FONT></FONT></P>
<P CLASS="western" STYLE="font-style: normal; font-weight: normal"><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>Notice
something interesting here. C symbolic names do not store anything
about return data types or operands, but C++ symbolic names due to
name mangling do. This is understandable and presents one of the many
differences between the languages: With C compilers, you can call
functions with different operand types or number of operands without
error (although perhaps a warning when it can be detected); C++
compilers do.</FONT></FONT></FONT></P>
<H3 CLASS="western">Export and import tables</H3>
<P CLASS="western"><SPAN STYLE="font-weight: normal">Symbols in a
program library or object file can be </SPAN><B>exported</B> <SPAN STYLE="font-weight: normal">for
use by other libraries or programs. </SPAN><B>Exported symbols</B>
<SPAN STYLE="font-weight: normal">just tell the compiler and linker
to add the respective symbol to the </SPAN><B>export table</B><SPAN STYLE="font-weight: normal">.
Program files and shared libraries (Windows DLL's) may export symbols
for use by other programs or debuggers. In a similar way, program
files can request to </SPAN><B>import</B> <SPAN STYLE="font-weight: normal">a
symbol for use. This is where we can complete our printf() example
above.</SPAN></P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">The Microsoft C
Runtime Library is a shared library loaded with the program file. The
operating system or executive can tell what DLL's a program file
needs to operate by looking at the program </SPAN><B>import table</B><SPAN STYLE="font-weight: normal">.
By default, CL (Microsoft's compiler) links with the Microsoft C
Runtime Library import static library that contains the import table
so the symbols are added and the respective DLL is included in the
table. The operating system or executive must load all of the shared
library files the program requires into memory if not already done so
and update the program files </SPAN><B>Import Address Table (IAT)</B>
<SPAN STYLE="font-weight: normal">with the addresses of the functions
in these other DLLs. The Microsoft C Runtime Library DLL that gets
loaded not only includes the code for _printf but also exports the
symbol _printf, so the operating system links them during runtime.
(We will discuss that in more detail later.)</SPAN></P>
<P CLASS="western" STYLE="font-weight: normal">Thus, when we call
&ldquo;printf()&rdquo; from a program file, this calls a jump table
which calls the updated IAT address which calls the function
&ldquo;_printf&rdquo; in the C runtime library DLL.</P>
<P CLASS="western" STYLE="font-weight: normal">So far we have covered
processes, threads, tasks, and took a look into what program files
are and how they work. The goal of this chapter is to be able to
load, execute, and manage multiple processes and tasks. Lets look at
that next.</P>
<H2 CLASS="western">Process Management</H2>
<P CLASS="western"><B>Process Management</B> <SPAN STYLE="font-weight: normal">is
the management of </SPAN><B>processes</B> <SPAN STYLE="font-weight: normal">in
a software system. We have defined a process earlier as a program or
a part of a program in memory. To manage processes, then, means
managing multiple instances of programs in memory in a collaborated
environment. This is typically a requirement in modern operating
systems and implemented in the kernel or executive. Operating systems
that support a form of process management is considered to be a
</SPAN><B>multitasking operating system.</B></P>
<H3 CLASS="western">Representation</H3>
<P CLASS="western" STYLE="font-weight: normal">In order to manage a
process, an operating system designer needs to determine how to best
represent a process given OS design criteria and required system
resources. A process consists of the following:</P>
<UL>
	<LI><P CLASS="western" STYLE="font-weight: normal">Image of the
	executable in memory (machine code and data);</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">Memory in use by
	the process and its virtual address space</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">Descriptors used
	to represent the processes</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">Process state
	information (registers, stack, attributes, etc.)</P>
</UL>
<P CLASS="western" STYLE="font-weight: normal">The operating system
is required to manage the processes and allocate system resources in
a fair manner to the processes that request them. Lets look at each
of these closer.</P>
<H3 CLASS="western">Image of executable in memory</H3>
<P CLASS="western">Executable programs are stored as files on disk to
facilitate program loading and managing. <B>To load a program, an
operating system loader loads the file into memory</B>. The loader
must also be able to understand the type of file (it must be an
executable the operating system can work with) and possibly support
features of these file types (like resources and debug information.)</P>
<P CLASS="western">The image of the executable in memory is the
current representation of the machine code and data of the image and
how it appears in memory at any given time. We use the term &ldquo;image&rdquo;
here to represent a &ldquo;snapshot&rdquo; of whats in memory. For
example, its like taking a camera looking at a big array of bytes and
taking a photo. The array of bytes can be machine code, data, or
neither &ndash; we don't know nor care. Only the program instructions
know.</P>
<P CLASS="western">Some data in the program image might be useful
though to other programs or even the operating system itself. This is
data the program image itself does not usually use; for example, the
program file can contain debugging information. A debugger can be
then attached to the program and use that information.</P>
<P CLASS="western">In short, the operating system needs to be able to
load the file from disk into memory somewhere in order to execute it.
This can be like just loading the file into memory &ldquo;as-is&rdquo;.
The operating system or another program can then get any useful data
from the program file that it may need.</P>
<H3 CLASS="western">Memory in use by the process and its Virtual
Address Space</H3>
<P CLASS="western">Processes typically have calls to dynamically
allocate memory and use stack space just like the operating system
does. <B>The operating system is required to allocate space for a
process stack and heap memory for the process to use</B>. For
example, the operating system typically allocates a default stack
size to all processes. <B>The executable file for the process however
can also tell the operating system to allocate a larger stack space
if the process needs it</B>.</P>
<P CLASS="western">The process heap is different. While the stack is
allocated by the operating system before executing a process, the
heap is not. Instead, each process has its own heap allocator in user
mode. This is implemented in the C Runtime Library (CRT) using the
familiar interface of malloc, free, realloc, brk, and sbrk functions.
Programs that are linked with the CRT can call these functions to
allocate memory. Programs that are not linked with the CRT however
must implement their own heap allocator or link with another library
that does.</P>
<P CLASS="western">The CRT Runtime implements a user mode heap
allocator (typically a free list). The C function malloc might call
brk, which calls the OS using the System API. The C function brk
calls the OS in order to allocate more virtual memory to expand the
heap when needed.</P>
<P CLASS="western">In short, the user mode heap works like this: The
program calls malloc, which might call brk, which calls the OS using
the System API to allocate virtual memory for the heap. The malloc
and free family of functions implement their own user mode heap
allocator. They only call the OS to allocator or free memory from the
virtual address space.</P>
<P CLASS="western">In <B>preemptive multitasking</B>, all processes
have their own virtual address space. This means every process must
have their own Page Directory and associated page tables. In order to
manage process specific information, we use a <B>process control
block (PCB)</B>. Lets look at that next.</P>
<H3 CLASS="western">Descriptors used to represent processes</H3>
<P CLASS="western"><SPAN STYLE="font-weight: normal">A </SPAN><B>Process
Control Block (PCB)</B> <SPAN STYLE="font-weight: normal">is a data
structure used to store the information about a process or task. The
PCB contains information such as interrupt descriptor pointers, Page
Directory Base Register (PDBR). Protection level, running time,
process state, process flags, VM86 flag, priority, and Process ID
(PID). PCBs may contain a lot more information &ndash; its really OS
specific.</SPAN></P>
<P CLASS="western">Operating systems may used a linked list of PCB's
to manage processes. When creating a new process, the operating
system needs to allocate a new virtual address space, load and map
the image, and attach a new PCB structure to the list. The scheduler
uses the PCB list in determining what process to execute and to store
the current state.</P>
<H3 CLASS="western">Process State Information</H3>
<P CLASS="western">Process state information includes the entire
register state of a process, in-memory state, Input/Output request
state of the process at a given time. The process state is stored in
the PCB when switching tasks. This is done by the heart of a
multitasking operating system: the scheduler. Additionally, the
current running state of the process is used to control the execution
of processes by the operating system.</P>
<P CLASS="western">In the most simple case, a state is either RUNNING
or NOT RUNNING. With this model, a process just created as stored in
a NOT RUNNING queue and only labeled as RUNNING when it is in
execution. The process that is NOT RUNNING may still exist in memory
but in a waiting state until either the RUNNING process terminates or
is interrupted by a process dispatcher inside of the scheduler.</P>
<P CLASS="western">In a three-state process management model,
processes may either be RUNNING, READY, or BLOCKED. When a RUNNING
process requests access to something that requires the process to
wait (such as an I/O request) the operating system may change the
process from RUNNING to BLOCKED. When the request can be performed,
the process may be moved to either RUNNING or READY states. Processes
in the READY state just means the process is ready for execution by
the process dispatcher. Processes that are RUNNING are already being
executed.</P>
<P CLASS="western">The final model is a five state process management
model. This model utilizes five states: SUSPEND BLOCKED, BLOCKED,
SUSPEND READY, READY, and SUSPENDED.</P>
<H3 CLASS="western">Scheduling</H3>
<P CLASS="western" STYLE="font-weight: normal">The <B>scheduler </B>is
the component of an operating system kernel or executive that is
responsible for task switching and CPU usage allocation. Operating
systems employ scheduling algorithms to determine what task to
execute next. Common scheduling algorithms used include but are not
limited to First-in First-out, Shortest remaining time, Fixed
priority preemptive, round-robin, and a multilevel queue. Possibly
the most common algorithm used by both Windows and Linux is a
<B>multilevel feedback queue</B>.</P>
<H1 CLASS="western">Basic process management support</H1>
<P CLASS="western">Now we can implement basic process management
support. The goal is simplicity so we will not be implementing an
advanced multilevel feedback system with vm86 task support, I/O
resource allocations, etc but will focus on a simpler but still
efficient scheduler.</P>
<P CLASS="western">In order to do this, lets look at the goals of
what we must do in order to add support:</P>
<OL>
	<LI><P CLASS="western">Load and parse an executable image into
	memory;</P>
	<LI><P CLASS="western">Manage a list of PCBs for processes;</P>
	<LI><P CLASS="western">Support user mode tasks;</P>
	<LI><P CLASS="western">Support multiple virtual address spaces</P>
	<LI><P CLASS="western">Allocate stack space for each process;
	default size can be 4k;</P>
	<LI><P CLASS="western">Select a scheduling algorithm and implement
	task switching</P>
</OL>
<P CLASS="western" STYLE="font-weight: normal">These are the goals in
order to support multitasking. The processes will be user mode
processes. Multitasking, however relies on both <B>process management</B>
and <B>scheduling</B>. Due to this, we will focus on building the
framework to support multitasking but will only allow one process
with one thread for this chapter. This will be extended in the next
chapter as we implement a scheduler.</P>
<H2 CLASS="western">Process Control Block</H2>
<P CLASS="western" STYLE="font-weight: normal">The PCB structure for
our system will be simple:</P>
<PRE CLASS="code">#define PROCESS_STATE_SLEEP  0
#define PROCESS_STATE_ACTIVE 1

#define MAX_THREAD 5

typedef struct _process {
   int            id;
   int            priority;
   pdirectory*    pageDirectory;
   int            state;
<FONT COLOR="#008000"><B>/* typedef struct _process* next; */</B></FONT>
<FONT COLOR="#008000"><B>/* thread* threadList; */</B></FONT>
   thread  threads[MAX_THREAD];
<FONT COLOR="#008000">   <B>/*</B></FONT>
<FONT COLOR="#008000">     <B>note: we can add more information, such as the following:</B></FONT>
<FONT COLOR="#008000">       <B>-LDT descriptor [if used]</B></FONT>
<FONT COLOR="#008000">       <B>-Processor count being used</B></FONT>
<FONT COLOR="#008000">       <B>-User and kernel times</B></FONT>
<FONT COLOR="#008000">       <B>-Execution options, etc</B></FONT>
<FONT COLOR="#008000">   <B>*/</B></FONT>
}process;</PRE><P CLASS="western" STYLE="font-weight: normal">
We can add more to this structure, but the above is really all we
need. Notice that it stores the process ID (PID), priority and
virtual address space. The two commented entries are provided for
completeness only; in a typical OS they should be linked lists of
processes and threads. This, however, requires a kernel heap
allocator which we have not written. For simplicity, we will store 5
thread objects in the process as an array.</P>
<P CLASS="western" STYLE="font-weight: normal">The final thing we
need is a way to handle threads. All processes have at most one
thread which starts execution at the entry point.</P>
<PRE CLASS="code" STYLE="font-weight: normal">typedef struct _thread {
   <SPAN STYLE="font-weight: normal">process*  parent;</SPAN>
   <SPAN STYLE="font-weight: normal">void*     initialStack;</SPAN>
   <SPAN STYLE="font-weight: normal">void*     stackLimit;</SPAN>
   <SPAN STYLE="font-weight: normal">void*     kernelStack;</SPAN>
   <SPAN STYLE="font-weight: normal">uint32_t  priority;</SPAN>
   <SPAN STYLE="font-weight: normal">int       state;</SPAN>
   <SPAN STYLE="font-weight: normal">trapFrame frame;</SPAN>
}thread;</PRE><P CLASS="western">
The thread structure stores general information about a thread in a
process. Note that the structure stores a pointer to the parent
process and information about the thread stack, priority, state (if
its running or not), and a trap frame. The trap frame stores the
current register state of a running thread.</P>
<PRE CLASS="code">typedef struct _trapFrame {
   uint32_t esp;
   uint32_t ebp;
   uint32_t eip;
   uint32_t edi;
   uint32_t esi;
   uint32_t eax;
   uint32_t ebx;
   uint32_t ecx;
   uint32_t edx;
   uint32_t flags;
<FONT COLOR="#008000">   <B>/*</B></FONT>
<FONT COLOR="#008000">      <B>note: we can add more registers to this.</B></FONT>
<FONT COLOR="#008000">      <B>For a complete trap frame, you should add:</B></FONT>
<FONT COLOR="#008000">        <B>-Debug registers</B></FONT>
<FONT COLOR="#008000">        <B>-Segment registers</B></FONT>
<FONT COLOR="#008000">        <B>-Error condition [if any]</B></FONT>
<FONT COLOR="#008000">        <B>-v86 mode segment registers [if used]</B></FONT>
<FONT COLOR="#008000">   <B>*/</B></FONT>
}trapFrame;</PRE><P CLASS="western">
We will not be using the trap frame structure much in this chapter
since we are not implementing multi-tasking yet. We will, however, be
using the trap frame structure more in the next chapter as we develop
a scheduler to store the current state of each thread.</P>
<H2 CLASS="western">Virtual Address spaces</H2>
<P CLASS="western"><SPAN STYLE="font-weight: normal">A complication
occurs when we want to support multiple virtual address spaces. </SPAN><B>Each
process address space consist of the entire 4GB address space where
the kernel code and data is located at 2GB.</B> <SPAN STYLE="font-weight: normal">When
we switch processes, we need to be able to switch address spaces&mdash;but
only the low 2GBs of the address space (&ldquo;user land&rdquo;). In
other words, lets say a user mode process is running. Somehow we need
to be able to call the scheduler in the kernel to be able to switch
tasks. Ah, but this means our kernel code needs to be in that same
address space! If its not, its an instant crash.</SPAN></P>
<P CLASS="western"><B>To resolve this problem, we have to do just
that&mdash;map our kernel code into every process address space.</B>
<SPAN STYLE="font-weight: normal">You might be wondering how this can
be done. However it might become more clear when we consider that
</SPAN><B>multiple virtual addresses can refer to the same physical
frame in memory</B><SPAN STYLE="font-weight: normal">. In other
words, we can map the kernel stack and code into both of the address
spaces. Please see the following image.</SPAN></P>
<P CLASS="western" STYLE="font-weight: normal"><IMG SRC="images/osdev24_html_27b37f61.gif" NAME="graphics3" ALIGN=LEFT WIDTH=412 HEIGHT=307 BORDER=0><BR CLEAR=LEFT>The
above image displays two virtual address spaces with the physical
address space. Notice how the location of the process stack and code
share different locations in physical memory. In other words, they
are mapped to the same basic virtual address location to different
physical address frames using our virtual memory manager. Lets
consider the kernel for a moment. The kernel starts up in an
environment with a single address space. It maps itself into its own
address space during the initialization process. We need to still be
able to map the kernel space into the other process address spaces as
well to prevent problems. The kernel is already mapped into its own
address space and is located at some place in physical memory. This
means the kernel can re-map itself to the other process address
spaces as well.</P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">In the series
kernel, the kernel maps itself from 1MB physical to 3GB virtual. The
kernel must map 3GB region of all processes to 1MB physical, then, in
order to map itself into each process address space.</SPAN> <B>The
kernel and kernel stack must be mapped to the same location in every
process address space</B><SPAN STYLE="font-weight: normal">.</SPAN></P>
<P CLASS="western" STYLE="font-weight: normal">Operating systems can
also map a portion of the kernel into the process address space
rather then the entire kernel. This is quite common in large systems.</P>
<H3 CLASS="western">Address Space Management</H3>
<P CLASS="western" STYLE="font-weight: normal">We need to be able to
work with being able to map virtual pages from different address
spaces. More specifically, we need to be able to do the following:</P>
<OL>
	<LI><P CLASS="western" STYLE="font-weight: normal">Create a page
	table from any page directory</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">Map any physical
	address to virtual address from any page directory</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">Get the physical
	address of any virtual mapping from any page directory</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">Create new
	address spaces</P>
</OL>
<P CLASS="western" STYLE="font-weight: normal">The Virtual Memory
Manager in the series currently does not support this functionality.
We can quickly implement them, though, so lets do so now.</P>
<H3 CLASS="western"><B>Creating a page table</B></H3>
<P CLASS="western"><SPAN STYLE="font-weight: normal">To create a page
table, all we need to do is to allocate a free frame (recall that a
page table consist of 1024 PTEs which is 4096 bytes, the size of a
page) and add it to the frame of a PDE in the page directory. V</SPAN><B>irt
&gt;&gt; 22</B> <SPAN STYLE="font-weight: normal">just allows us to
get the directory index from the virtual address. If the PDE at
pagedir [directory_index] is 0, then we know that this page table
does not exist and so we allocate it using the physical memory
manager. If it does exist, no need to allocate. We finish by clearing
the page table which effectively sets its pre</SPAN><FONT SIZE=2><SPAN STYLE="font-weight: normal">sent
bit to 0 (not present.)</SPAN></FONT></P>
<PRE>
<FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#0000ff"><SPAN LANG=""><SPAN STYLE="font-weight: normal">int</SPAN></SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""><SPAN STYLE="font-weight: normal"> vmmngr_createPageTable (pdirectory* dir, uint32_t virt, uint32_t flags) {</SPAN></SPAN></FONT></FONT></FONT>

        <FONT FACE="Courier New, monospace"><FONT SIZE=2>pd_entry* pagedir = dir-&gt;m_entries;</FONT></FONT>
<FONT COLOR="#000000">        </FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#0000ff"><SPAN LANG="">if</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (pagedir [virt &gt;&gt; 22] == 0) {</SPAN></FONT></FONT></FONT>
<FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">void</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">* block = pmmngr_alloc_block();</SPAN></FONT></FONT></FONT>
<FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">if</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (!block)</SPAN></FONT></FONT></FONT>
<FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#000000"><SPAN LANG="">	   </SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">return</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> 0; </SPAN></FONT><FONT COLOR="#008000"><SPAN LANG="">/* Should call debugger */</SPAN></FONT></FONT></FONT>
          <FONT FACE="Courier New, monospace"><FONT SIZE=2>pagedir [virt &gt;&gt; 22] = ((uint32_t) block) | flags;</FONT></FONT>
          <FONT FACE="Courier New, monospace"><FONT SIZE=2>memset ((uint32_t*) pagedir[virt &gt;&gt; 22], 0, 4096);</FONT></FONT>

<FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG="">/* map page table into directory */</SPAN></FONT></FONT></FONT>
<FONT FACE="Courier New, monospace"><FONT SIZE=2>	vmmngr_mapPhysicalAddress (dir, (uint32_t) block, (uint32_t) block, flags);</FONT></FONT>
        <FONT FACE="Courier New, monospace"><FONT SIZE=2>}</FONT></FONT>
<FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">return</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> 1; </SPAN></FONT><FONT COLOR="#008000"><SPAN LANG="">/* success */</SPAN></FONT></FONT></FONT>
<FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#000000"><SPAN LANG="">}</SPAN></FONT></FONT></FONT></PRE><P CLASS="western">
<SPAN STYLE="font-weight: normal">This function allows us to create
page tables for any page directory.</SPAN></P>
<H3 CLASS="western">Mapping physical addresses</H3>
<P CLASS="western" STYLE="font-weight: normal">The next missing
functionality is to be able to map physical to virtual addresses for
different page directories. This one is easy.</P>
<PRE CLASS="code"><FONT COLOR="#0000ff"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">void</FONT></FONT></FONT><FONT COLOR="#000000"> </FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">mapPhysicalAddress (pdirectory* dir, uint32_t virt, uint32_t phys, uint32_t flags) {</FONT></FONT></FONT>

        pd_entry* pagedir = dir-&gt;m_entries;
<FONT COLOR="#000000">        </FONT><FONT COLOR="#0000ff"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">if</FONT></FONT></FONT><FONT COLOR="#000000"> </FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">(pagedir [virt &gt;&gt; 22] == 0)</FONT></FONT></FONT>
                createPageTable (dir, virt, flags);
        ((uint32_t*) (pagedir[virt &gt;&gt; 22] &amp; ~0xfff))[virt &lt;&lt; 10 &gt;&gt; 10 &gt;&gt; 12] = phys | flags;
}</PRE><P CLASS="western">
This function follows the basic functionality we implemented before
in the virtual memory manager. We test for a valid page table, and
create one if it is marked not present. The last line performs the
mapping.</P>
<P CLASS="western" STYLE="font-weight: normal">This function allows
us to map physical to virtual addresses of any virtual address space.</P>
<H3 CLASS="western">Getting physical addresses</H3>
<P CLASS="western">The next missing functionality is the reverse of
what we did above: obtaining the physical address of any virtual
address from a specific address space.</P>
<PRE CLASS="code"><FONT COLOR="#0000ff"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">void</FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">* getPhysicalAddress (pdirectory* dir, uint32_t virt) {</FONT></FONT></FONT>

        pd_entry* pagedir = dir-&gt;m_entries;
<FONT COLOR="#000000">        </FONT><FONT COLOR="#0000ff"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">if</FONT></FONT></FONT><FONT COLOR="#000000"> </FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">(pagedir [virt &gt;&gt; 22] == 0)</FONT></FONT></FONT>
<FONT COLOR="#000000">                </FONT><FONT COLOR="#0000ff"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">return</FONT></FONT></FONT><FONT COLOR="#000000"> </FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">0;</FONT></FONT></FONT>
        return (void*) ((uint32_t*) (pagedir[virt &gt;&gt; 22] &amp; ~0xfff))[virt &lt;&lt; 10 &gt;&gt; 10 &gt;&gt; 12];
}</PRE><P CLASS="western">
This function tests for a valid page table at that virtual address
(by checking if its present) and returns the physical frame by
dereferencing the PDE and PTE and returns the frame.</P>
<H3 CLASS="western">Creating a new address space</H3>
<P CLASS="western">Each process runs in its own virtual address
space. In order to achieve this, we must be able to create multiple
address spaces.</P>
<PRE CLASS="code">pdirectory* createAddressSpace () {
        pdirectory* dir = 0;

        <FONT COLOR="#008000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">/* allocate page directory */</FONT></FONT></FONT>
        dir = (pdirectory*) pmmngr_alloc_block ();
<FONT COLOR="#000000">        </FONT><FONT COLOR="#0000ff"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">if</FONT></FONT></FONT><FONT COLOR="#000000"> </FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">(!dir)</FONT></FONT></FONT>
<FONT COLOR="#000000">                </FONT><FONT COLOR="#0000ff"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">return</FONT></FONT></FONT><FONT COLOR="#000000"> </FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">0;</FONT></FONT></FONT>

<FONT COLOR="#000000">        </FONT><FONT COLOR="#008000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">/* clear memory (marks all page tables as not present) */</FONT></FONT></FONT>
<FONT COLOR="#000000">        </FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">memset (dir, 0, </FONT></FONT></FONT><FONT COLOR="#0000ff"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">sizeof</FONT></FONT></FONT><FONT COLOR="#000000"> </FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">(pdirectory));</FONT></FONT></FONT>
<FONT COLOR="#000000">        </FONT><FONT COLOR="#0000ff"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">return</FONT></FONT></FONT><FONT COLOR="#000000"> </FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">dir;</FONT></FONT></FONT>
}</PRE><P CLASS="western">
Notice the simplicity of this function: all it does is allocate a
block and clears it. This makes sense as a page directory represents
an address space and a page directory is 4096 bytes. By clearing, we
are effectively setting the present bit to 0 in all the PDE's.</P>
<P CLASS="western">When it is time to execute a process we must be
able to switch to this new address space that we just created. In
other words, we need to be able to load this new page directory into
the PDBR. We already implemented this functionality in the PMM. If we
just load an empty page directory into the PDBR, however, we will
surely triple fault right after. The cause of this is simple: none of
our kernel code or stack is mapped into this new address space.</P>
<P CLASS="western">To resolve this, we just need to map kernel space.
Interestingly, we can just copy the current page directory (stored in
the PDBR) into this new address space like the following.</P>
<PRE CLASS="code" STYLE="margin-bottom: 0.2in"><FONT COLOR="#000000">        </FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">memcpy (dst-&gt;m_entries, cur-&gt;m_entries, </FONT></FONT></FONT><FONT COLOR="#0000ff"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">sizeof</FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2 STYLE="font-size: 9pt">(uint32_t)*1024);</FONT></FONT></FONT></PRE><P CLASS="western">
This is all that we need to do. We do not need to worry about copying
any of the page tables as they were already mapped into the original
page directory. The above effectively makes a copy of the address
space &ndash; the kernel page tables mapped into both address spaces
which is what we want.</P>
<H2 CLASS="western"><B>Creating a thread</B></H2>
<P CLASS="western" STYLE="font-weight: normal">In order to create a
thread, we need to first decide what our createThread function needs
and what thread creation actually implies. Recall that we defined a
thread as a single path of execution. Knowing this, all we need is an
entry point function. When the function is completed, it calls the
operating system to terminate the thread. This is typically done by
the system API (such as the Win32 API) to simplify creating and
terminating threads.</P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">To create a
thread, all that we need to do is allocate a thread structure and add
it to the process. We were originally going to implement this
functionality for this demo however decided to leave it for chapter
25 where we look at multi-threading.</SPAN></P>
<H2 CLASS="western">Process creation</H2>
<P CLASS="western">In order to create a process, we must already have
a dedicated loader component for the operating system. The loader
component is responsible for loading and parsing executable files,
clearing the BSS section, section alignment, and any other thing you
might want, such as dynamic loading of dynamic linked libraries.
Creating a loader can be a complex task, specifically for a file
format as complex as PE. Due to this, I opted to go for a simpler
solution for the series so we can focus on the goal of this chapter:
process management.</P>
<P CLASS="western">In order to crate a process, we must have a clear
understanding of what a process is and how it differs from that of a
thread. To be specific:</P>
<OL>
	<LI><P CLASS="western">Threads each have their own dedicated stack;
	the process itself does not have one.</P>
	<LI><P CLASS="western">Each process must have at least one thread.
	This starts at the entry point of the process.</P>
	<LI><P CLASS="western">Each process must have their own virtual
	address space. Threads in a process share the same address space as
	the process.</P>
	<LI><P CLASS="western">Each process must be loaded from disk as an
	executable image. This is typically done using a separate loader
	component.</P>
</OL>
<P CLASS="western">Due to the series not having a dedicated image
loader component, for simplicity we will perform all of these steps
in a single function called <B>createProcess</B><SPAN STYLE="font-weight: normal">.
The function follows the following steps.</SPAN></P>
<OL>
	<LI><P CLASS="western" STYLE="font-weight: normal">Load the
	executable file.</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">Create the
	address space for the process.</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">Create a Process
	Control Block (PCB).</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">Create the main
	thread.</P>
	<LI><P CLASS="western" STYLE="font-weight: normal">Map the image
	into the process virtual address space.</P>
</OL>
<P CLASS="western" STYLE="font-weight: normal">This is quite a lot
for a single function. Remember, however, that it is better to
separate the loader from process creation; later we can move the
loading of the executable file to a dedicated loader. For simplicity,
the routine assumes the same criteria of the boot loader. That is,
the image to be loaded must have sector aligned sections (using the
/align:512 flag) and can not be linked with any Microsoft Windows
runtime libraries. While I might decide to add this functionality to
the demo in the future, this complicates the loading code and&mdash;as
noted earlier&mdash;is typically handled by the loader component
anyways.</P>
<H3 CLASS="western">Process Address Space structure</H3>
<P CLASS="western" STYLE="font-weight: normal">At the moment, the
kernel for the series OS has a lot of kernel structures loaded below
the 1MB mark in identity mapped memory. This includes the kernel
stack, initial page directory table and the page tables. The Direct
Memory Access Controller (DMAC) memory region may also be located in
this region. We must also take into consideration that the kernel
also utilizes other memory regions (such as display memory) that are
also in this identity mapped region.</P>
<P CLASS="western" STYLE="font-weight: normal">This was all done for
simplicity only. Typical kernels would initialize the kernel stack
and initial page tables in kernel memory initially using Position
Independent Code (PIC). PIC is also what allows higher half kernels
to start when loaded at some other physical base address. This is
tricky to do right which is why I decided against it for the series.
The result however created a mess: we now have a few kernel
structures below 1MB.</P>
<P CLASS="western" STYLE="font-weight: normal">Rather then moving
things around, I decided that reserving 0-4MB for kernel mode only
would be the best option. This allows the kernel to continue
functioning with no modifications at all and no problems with
remapping memory for display output and other basic things. In other
words, the address space will look like this:</P>
<PRE>0x00000000-0x00400000 &ndash; Kernel reserved
0x00400000-0x80000000 &ndash; User land
0x80000000-0xffffffff &ndash; Kernel reserved</PRE><P CLASS="western" STYLE="font-weight: normal">
This means that all processes must have an image base within the
region of 4 MB and 2 GB. I will be using 4MB as the base address of
all user mode processes. The first 4 MB will remain identity mapped
as kernel mode pages (this is already done); and the kernel itself
will remain mapped at 3 GB. In short, a<B>ll pages for the process
will be mapped as user mode pages between 4 MB and 2 GB.</B></P>
<H3 CLASS="western">Creating a process</H3>
<P CLASS="western">With all of that in mind, lets take a look at the
function. This is a fairly long routine as it includes some software
that is typically done in loaders. For this demo, the software loads
and maps the image into the current address space rather then
creating a new one; although both are implemented. This was done due
to the software only designed to run one process at a time. We will
change this in chapter 25 when we cover multitasking.</P>
<P CLASS="western">Notice two new functions - <FONT SIZE=2><B>
vmmngr_createAddressSpace</B></FONT><FONT SIZE=2><SPAN STYLE="font-weight: normal">
and </SPAN></FONT><FONT SIZE=2><B>mapKernelSpace</B></FONT><FONT SIZE=2><SPAN STYLE="font-weight: normal">;
these are not currently used in the demo. The first function
allocates a new address space (we looked at this earlier in the
chapter), the second maps kernel space into a virtual address space.
That is, it maps the kernel memory, stack, page directory, and
display memory into a new address space. Although these functions are
not used, they will be used in the next chapter.</SPAN></FONT></P>
<P CLASS="western"><FONT SIZE=2><SPAN STYLE="font-weight: normal">The
</SPAN></FONT><FONT SIZE=2><B>validateImage</B></FONT><FONT SIZE=2><SPAN STYLE="font-weight: normal">
function just parses the image headers and verifies that it is
supported. Finally, although it creates an initial thread structure;
it does not support multiple threads. It assumes one thread per
process; where only one thread of one process can execute.</SPAN></FONT></P>
<PRE CLASS="code"><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">int</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> createProcess (</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">char</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">* appname) {</SPAN></FONT></FONT>

        <FONT SIZE=3>IMAGE_DOS_HEADER* dosHeader;</FONT>
        <FONT SIZE=3>IMAGE_NT_HEADERS* ntHeaders;</FONT>
        <FONT SIZE=3>FILE              file;</FONT>
        <FONT SIZE=3>pdirectory*       addressSpace;</FONT>
        <FONT SIZE=3>process*          proc;</FONT>
        <FONT SIZE=3>thread*           mainThread;</FONT>
<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">unsigned</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> </SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">char</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">*    memory;</SPAN></FONT></FONT>
        <FONT SIZE=3>uint32_t          i;</FONT>
<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">unsigned</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> </SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">char</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">     buf[512];</SPAN></FONT></FONT>
<FONT COLOR="#000000"> </FONT>
<FONT COLOR="#000000">       </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* open file */</B></SPAN></FONT></FONT>
        <FONT SIZE=3>file = volOpenFile (appname);</FONT>
<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">if</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (file.flags == FS_INVALID)</SPAN></FONT></FONT>
<FONT COLOR="#000000">                </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">return</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> 0;</SPAN></FONT></FONT>
<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">if</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (( file.flags &amp; FS_DIRECTORY ) == FS_DIRECTORY)</SPAN></FONT></FONT>
<FONT COLOR="#000000">                </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">return</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> 0;</SPAN></FONT></FONT>

<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* read 512 bytes into buffer */</B></SPAN></FONT></FONT>
        <FONT SIZE=3>volReadFile ( &amp;file, buf, 512);</FONT>
<FONT COLOR="#0000ff">        <FONT SIZE=3><SPAN LANG="">if</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (! validateImage (buf)) {</SPAN></FONT></FONT>
            <FONT SIZE=3>volCloseFile ( &amp;file );</FONT>
<FONT COLOR="#000000">            </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">return</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> 0;</SPAN></FONT></FONT>
        <FONT SIZE=3>}</FONT>
        <FONT SIZE=3>dosHeader = (IMAGE_DOS_HEADER*)buf;</FONT>
        <FONT SIZE=3>ntHeaders = (IMAGE_NT_HEADERS*)(dosHeader-&gt;e_lfanew + (uint32_t)buf);</FONT>

<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* get process virtual address space */</B></SPAN></FONT></FONT>
        <FONT SIZE=3><SPAN STYLE="font-weight: normal">//addressSpace = vmmngr_createAddressSpace ();</SPAN></FONT>
        <FONT SIZE=3>addressSpace = vmmngr_get_directory ();</FONT>
<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">if</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (!addressSpace) {</SPAN></FONT></FONT>
            <FONT SIZE=3>volCloseFile (&amp;file);</FONT>
<FONT COLOR="#000000">            </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">return</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> 0;</SPAN></FONT></FONT>
        <FONT SIZE=3>}</FONT>
<FONT COLOR="#008000">        <FONT SIZE=3><B><SPAN LANG="">/*</SPAN></B></FONT></FONT>
<FONT COLOR="#008000">           <FONT SIZE=3><B>map kernel space into process address space.</B></FONT></FONT>
<FONT COLOR="#008000">           <FONT SIZE=3><B>Only needed if creating new address space</B></FONT></FONT>
<FONT COLOR="#008000">        <FONT SIZE=3><B>*/</B></FONT></FONT>
<FONT COLOR="#008000">        <FONT SIZE=3><SPAN LANG="">//mapKernelSpace (addressSpace);</SPAN></FONT></FONT>

<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* create PCB */</B></SPAN></FONT></FONT>
        <FONT SIZE=3>proc = getCurrentProcess();</FONT>
        <FONT SIZE=3>proc-&gt;id            = 1;</FONT>
        <FONT SIZE=3>proc-&gt;pageDirectory = addressSpace;</FONT>
        <FONT SIZE=3>proc-&gt;priority      = 1;</FONT>
        <FONT SIZE=3>proc-&gt;state         = PROCESS_STATE_ACTIVE;</FONT>
        <FONT SIZE=3>proc-&gt;threadCount   = 1;</FONT>

<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* create thread descriptor */</B></SPAN></FONT></FONT>
        <FONT SIZE=3>mainThread               = &amp;proc-&gt;threads[0];</FONT>
        <FONT SIZE=3>mainThread-&gt;kernelStack  = 0;</FONT>
        <FONT SIZE=3>mainThread-&gt;parent       = proc;</FONT>
        <FONT SIZE=3>mainThread-&gt;priority     = 1;</FONT>
        <FONT SIZE=3>mainThread-&gt;state        = PROCESS_STATE_ACTIVE;</FONT>
        <FONT SIZE=3>mainThread-&gt;initialStack = 0;</FONT>
<FONT COLOR="#000000">        <FONT SIZE=3><SPAN LANG="">mainThread-&gt;stackLimit   = (</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">void</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">*) ((uint32_t) mainThread-&gt;initialStack + 4096);</SPAN></FONT></FONT>
        <FONT SIZE=3>mainThread-&gt;imageBase    = ntHeaders-&gt;OptionalHeader.ImageBase;</FONT>
        <FONT SIZE=3>mainThread-&gt;imageSize    = ntHeaders-&gt;OptionalHeader.SizeOfImage;</FONT>
<FONT COLOR="#000000">        <FONT SIZE=3><SPAN LANG="">memset (&amp;mainThread-&gt;frame, 0, </SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">sizeof</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (trapFrame));</SPAN></FONT></FONT>
        <FONT SIZE=3>mainThread-&gt;frame.eip    = ntHeaders-&gt;OptionalHeader.AddressOfEntryPoint</FONT>
                <FONT SIZE=3>+ ntHeaders-&gt;OptionalHeader.ImageBase;</FONT>
        <FONT SIZE=3>mainThread-&gt;frame.flags  = 0x200;</FONT>

<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* copy our 512 block read above and rest of 4k block */</B></SPAN></FONT></FONT>
<FONT COLOR="#000000">        <FONT SIZE=3><SPAN LANG="">memory = (</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">unsigned</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> </SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">char</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">*)pmmngr_alloc_block();</SPAN></FONT></FONT>
        <FONT SIZE=3>memset (memory, 0, 4096);</FONT>
        <FONT SIZE=3>memcpy (memory, buf, 512);</FONT>

<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* load image into memory */</B></SPAN></FONT></FONT>
<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">for</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (i=1; i &lt;= mainThread-&gt;imageSize/512; i++) {</SPAN></FONT></FONT>
<FONT COLOR="#000000">           </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">if</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (file.eof == 1)</SPAN></FONT></FONT>
<FONT COLOR="#000000">              </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">break</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">;</SPAN></FONT></FONT>
           <FONT SIZE=3>volReadFile ( &amp;file, memory+512*i, 512);</FONT>
        <FONT SIZE=3>}</FONT>

<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* map page into address space */</B></SPAN></FONT></FONT>
        <FONT SIZE=3>vmmngr_mapPhysicalAddress (proc-&gt;pageDirectory,</FONT>
                <FONT SIZE=3>ntHeaders-&gt;OptionalHeader.ImageBase,</FONT>
                <FONT SIZE=3>(uint32_t) memory,</FONT>
                <FONT SIZE=3>I86_PTE_PRESENT|I86_PTE_WRITABLE|I86_PTE_USER);</FONT>

<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* load and map rest of image */</B></SPAN></FONT></FONT>
        <FONT SIZE=3>i = 1;</FONT>
<FONT COLOR="#000000">        </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">while</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (file.eof != 1) {</SPAN></FONT></FONT>
<FONT COLOR="#000000">                </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG="">/</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>* allocate new frame */</B></SPAN></FONT></FONT>
<FONT COLOR="#000000">                </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">unsigned</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> </SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">char</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">* cur = (</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">unsigned</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> </SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">char</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">*)pmmngr_alloc_block();</SPAN></FONT></FONT>
<FONT COLOR="#000000">                </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* read block */</B></SPAN></FONT></FONT>
<FONT COLOR="#000000">                </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">int</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> curBlock = 0;</SPAN></FONT></FONT>
<FONT COLOR="#000000">                </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">for</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (curBlock = 0; curBlock &lt; 8; curBlock++) {</SPAN></FONT></FONT>
<FONT COLOR="#000000">                        </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">if</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (file.eof == 1)</SPAN></FONT></FONT>
<FONT COLOR="#000000">                                </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">break</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">;</SPAN></FONT></FONT>
                        <FONT SIZE=3>volReadFile ( &amp;file, cur+512*curBlock, 512);</FONT>
                <FONT SIZE=3>}</FONT>
<FONT COLOR="#000000">                </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* map page into process address space */</B></SPAN></FONT></FONT>
                <FONT SIZE=3>vmmngr_mapPhysicalAddress (proc-&gt;pageDirectory,</FONT>
                        <FONT SIZE=3>ntHeaders-&gt;OptionalHeader.ImageBase + i*4096,</FONT>
                        <FONT SIZE=3>(uint32_t) cur,</FONT>
                        <FONT SIZE=3>I86_PTE_PRESENT|I86_PTE_WRITABLE|I86_PTE_USER);</FONT>
                <FONT SIZE=3>i++;</FONT>
        <FONT SIZE=3>}</FONT>

<FONT COLOR="#000000">         </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* Create userspace stack (process esp=0x100000) */</B></SPAN></FONT></FONT>
<FONT COLOR="#000000">         </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">void</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">* stack =</SPAN></FONT></FONT>
<FONT COLOR="#000000">            <FONT SIZE=3><SPAN LANG="">(</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">void</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">*) (ntHeaders-&gt;OptionalHeader.ImageBase</SPAN></FONT></FONT>
             <FONT SIZE=3>+ ntHeaders-&gt;OptionalHeader.SizeOfImage + PAGE_SIZE);</FONT>
<FONT COLOR="#000000">         </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">void</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">* stackPhys = (</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">void</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">*) pmmngr_alloc_block ();</SPAN></FONT></FONT>

<FONT COLOR="#000000">         </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* map user process stack space */</B></SPAN></FONT></FONT>
         <FONT SIZE=3>vmmngr_mapPhysicalAddress (addressSpace, (uint32_t) stack, (uint32_t) stackPhys,</FONT>
<FONT SIZE=3>		I86_PTE_PRESENT|I86_PTE_WRITABLE|I86_PTE_USER);</FONT>

<FONT COLOR="#000000">         </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* final initialization */</B></SPAN></FONT></FONT>
         <FONT SIZE=3>mainThread-&gt;initialStack = stack;</FONT>
         <FONT SIZE=3>mainThread-&gt;frame.esp    = (uint32_t)mainThread-&gt;initialStack;</FONT>
         <FONT SIZE=3>mainThread-&gt;frame.ebp    = mainThread-&gt;frame.esp;</FONT>

<FONT COLOR="#000000">         </FONT><FONT SIZE=3><FONT COLOR="#008000"><SPAN LANG=""><B>/* close file and return process ID */</B></SPAN></FONT></FONT>
         <FONT SIZE=3>volCloseFile(&amp;file);</FONT>
<FONT COLOR="#000000">         </FONT><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">return</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> proc-&gt;id;</SPAN></FONT></FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">}</SPAN></FONT></FONT></PRE><H2 CLASS="western">
Process execution</H2>
<P CLASS="western">To execute a process, all we have to do is get EIP
and ESP from the main thread in the process, drop to user mode, and
execute it. We run into a problem though: how do we know what process
to execute? Due to us having no scheduler yet, we can only execute
one process at a time. This is done using a global process object
that stores what process we are currently working with.
<B>GetCurrentProcess()</B> <SPAN STYLE="font-weight: normal">returns
a pointer to this object. We get ESP and EIP from its main thread,
switch to the process address space, and drop to user mode to execute
it.</SPAN></P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">Notice that we
do </SPAN><B>not</B> <SPAN STYLE="font-weight: normal">call
</SPAN><B>enter_usermode</B><SPAN STYLE="font-weight: normal">. This
is due to user mode software not being able to access kernel-only
pages. If we called it, we will page fault. Instead, we just drop to
user mode and execute the program directly using IRETD.</SPAN></P>
<PRE CLASS="code"><FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#0000ff"><SPAN LANG="">void</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> executeProcess () {</SPAN></FONT></FONT></FONT>
        <FONT FACE="Courier New, monospace"><FONT SIZE=2>process* proc = 0;</FONT></FONT>
<FONT COLOR="#000000">        </FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#0000ff"><SPAN LANG="">int</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> entryPoint = 0;</SPAN></FONT></FONT></FONT>
<FONT COLOR="#000000">        </FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#0000ff"><SPAN LANG="">unsigned</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> </SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">int</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> procStack = 0;</SPAN></FONT></FONT></FONT>

<FONT COLOR="#000000">        </FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#008000"><SPAN LANG=""><B>/* get running process */</B></SPAN></FONT></FONT></FONT>
        <FONT FACE="Courier New, monospace"><FONT SIZE=2>proc = getCurrentProcess();</FONT></FONT>
<FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#000000"><SPAN LANG="">		</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">if</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (proc-&gt;id==PROC_INVALID_ID)</SPAN></FONT></FONT></FONT>
<FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#000000"><SPAN LANG="">			</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">return</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">;</SPAN></FONT></FONT></FONT>
<FONT COLOR="#000000">        </FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#0000ff"><SPAN LANG="">if</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (!proc-&gt;pageDirectory)</SPAN></FONT></FONT></FONT>
<FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#000000"><SPAN LANG="">			</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">return</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">;</SPAN></FONT></FONT></FONT>

<FONT COLOR="#000000">        </FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#008000"><SPAN LANG=""><B>/* get esp and eip of main thread */</B></SPAN></FONT></FONT></FONT>
        <FONT FACE="Courier New, monospace"><FONT SIZE=2>entryPoint = proc-&gt;threads[0].frame.eip;</FONT></FONT>
        <FONT FACE="Courier New, monospace"><FONT SIZE=2>procStack  = proc-&gt;threads[0].frame.esp;</FONT></FONT>

<FONT COLOR="#000000">        </FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#008000"><SPAN LANG=""><B>/* switch to process address space */</B></SPAN></FONT></FONT></FONT>
<FONT COLOR="#000000">        </FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#0000ff"><SPAN LANG="">__asm</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> cli</SPAN></FONT></FONT></FONT>
        <FONT FACE="Courier New, monospace"><FONT SIZE=2>pmmngr_load_PDBR ((physical_addr)proc-&gt;pageDirectory);</FONT></FONT>

<FONT COLOR="#000000">        </FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#008000"><SPAN LANG=""><B>/* execute process in user mode */</B></SPAN></FONT></FONT></FONT>
<FONT COLOR="#000000">        </FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#0000ff"><SPAN LANG="">__asm</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> {</SPAN></FONT></FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>mov     ax, 0x23		; user mode data selector is 0x20 (GDT entry 3). Also sets RPL to 3</FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>mov     ds, ax</FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>mov     es, ax</FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>mov     fs, ax</FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>mov     gs, ax</FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>;</FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>; create stack frame</FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>;</FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>push   0x23			; SS, notice it uses same selector as above</FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>push   [procStack]		; stack</FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>push    0x200			; EFLAGS</FONT></FONT>
<FONT COLOR="#000000">                <FONT FACE="Courier New, monospace"><FONT SIZE=2><SPAN LANG="">push    0x1b			; CS, user mode code selector is 0x18. With RPL 3 </SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">this</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> is 0x1b</SPAN></FONT></FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>push    [entryPoint]	; EIP</FONT></FONT>
                <FONT FACE="Courier New, monospace"><FONT SIZE=2>iretd</FONT></FONT>
        <FONT FACE="Courier New, monospace"><FONT SIZE=2>}</FONT></FONT>
<FONT FACE="Courier New, monospace"><FONT SIZE=2><FONT COLOR="#000000"><SPAN LANG="">}</SPAN></FONT></FONT></FONT></PRE><H1 CLASS="western">
Demo</H1>
<P CLASS="western"><IMG SRC="images/osdev24.png" NAME="graphics6" ALIGN=BOTTOM WIDTH=495 HEIGHT=309 BORDER=0>
</P>
<P CLASS="western"><I>Running a usermode process that uses the system
API </I>
</P>
<P CLASS="western"><a href="Demos/demo24.zip">Demo Download</a></P>
<P CLASS="western"><SPAN STYLE="font-weight: normal">This is an
important milestone for any operating system in development; this
milestone marks the beginning of interactivity and self hosting
system designs. The demo uses the topics we looked at in this
chapter, memory management chapter, and the PE loading chapter to
implement a </SPAN><B>proc (process)</B> <SPAN STYLE="font-weight: normal">command
that loads an executable image (</SPAN><B>Portable Executable</B>
<SPAN STYLE="font-weight: normal">format), maps it into its own
address space in user land, and interacts with the kernel using the
</SPAN><B>system API</B> <SPAN STYLE="font-weight: normal">through
two system calls: </SPAN><B>DebugPrintf</B> <SPAN STYLE="font-weight: normal">which
can be used by the user land process to display strings using the
kernel text terminal, and </SPAN><B>TerminateProcess</B> <SPAN STYLE="font-weight: normal">which
is used to terminate the process itself. The system calls are
implemented using </SPAN><B>software interrupts</B> <SPAN STYLE="font-weight: normal">that
we looked at in earlier chapters.</SPAN></P>
<H2 CLASS="western">Project &ldquo;proc&rdquo;</H2>
<P CLASS="western">The usermode process we used is called <B>proc</B><SPAN STYLE="font-weight: normal">.
It is built as a 32 bit PE executable image, image base at 4 MB, with
512 byte section alignment. Here is the source for the project for
reference.</SPAN></P>
<PRE CLASS="code"><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG=""><SPAN STYLE="font-weight: normal">void</SPAN></SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""><SPAN STYLE="font-weight: normal"> processEntry () {</SPAN></SPAN></FONT></FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">char</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">* str=</SPAN></FONT><FONT COLOR="#800000"><SPAN LANG="">&quot;\n\rHello world!&quot;</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">;</SPAN></FONT></FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">__asm</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> {</SPAN></FONT></FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">		</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>/* display message through kernel terminal */</B></SPAN></FONT></FONT>
<FONT SIZE=3>		mov ebx, str</FONT>
<FONT SIZE=3>		mov eax, 0</FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">		</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">int</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> 0x80</SPAN></FONT></FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">		</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>/* terminate */</B></SPAN></FONT></FONT>
<FONT SIZE=3>		mov eax, 1</FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">		</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">int</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> 0x80</SPAN></FONT></FONT>
<FONT SIZE=3>	}</FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">for</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (;;);</SPAN></FONT></FONT>
<FONT SIZE=3>}</FONT></PRE><P CLASS="western">
<SPAN STYLE="font-weight: normal">Notice the process uses system
calls to display the message and to terminate. These system calls are
added to our system API implemented in earlier chapters. </SPAN><B>Int
0x80 function 0 calls DebugPrintf</B><SPAN STYLE="font-weight: normal">
and </SPAN><B>Int 0x80 function 1</B><SPAN STYLE="font-weight: normal">
is a new function, </SPAN><B>TerminateProcess</B><SPAN STYLE="font-weight: normal">.
We can add more system services to improve the functionality of the
demo; such as for file reading or input in a similar way.</SPAN></P>
<P CLASS="western"><B>TerminateProcess</B><SPAN STYLE="font-weight: normal">
is responsible for cleaning up process resources and returning
execution to the kernel command shell. Recall that when </SPAN><B>int
0x80</B><SPAN STYLE="font-weight: normal"> is executed, the CPU traps
into kernel mode and restores CS, SS, and ESP to their respective
values from the TSS. Thus whenever any of the system calls execute,
the CPU is in kernel land running in the same address space.</SPAN><SPAN STYLE="font-weight: normal"><SPAN STYLE="font-weight: normal">
This allows us to call kernel functions directly from
</SPAN></SPAN><SPAN STYLE="font-weight: normal"><B>TerminateProcess</B></SPAN><SPAN STYLE="font-weight: normal"><SPAN STYLE="font-weight: normal">
and to call the kernel command shell.</SPAN></SPAN></P>
<PRE CLASS="code"><FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">extern</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> </SPAN></FONT><FONT COLOR="#800000"><SPAN LANG="">&quot;C&quot;</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> {</SPAN></FONT></FONT>
<FONT SIZE=3><FONT COLOR="#0000ff"><SPAN LANG="">void</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> TerminateProcess () {</SPAN></FONT></FONT>
<FONT SIZE=3>	process* cur = &amp;_proc;</FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">if</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (cur-&gt;id==PROC_INVALID_ID)</SPAN></FONT></FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">		</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">return</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">;</SPAN></FONT></FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>/* release threads */</B></SPAN></FONT></FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">int</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> i=0;</SPAN></FONT></FONT>
<FONT SIZE=3>	thread* pThread = &amp;cur-&gt;threads[i];</FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>/* get physical address of stack */</B></SPAN></FONT></FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">void</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">* stackFrame = vmmngr_getPhysicalAddress (cur-&gt;pageDirectory,</SPAN></FONT></FONT>
<FONT SIZE=3>		(uint32_t) pThread-&gt;initialStack); </FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>/* unmap and release stack memory */</B></SPAN></FONT></FONT>
<FONT SIZE=3>	vmmngr_unmapPhysicalAddress (cur-&gt;pageDirectory, (uint32_t) pThread-&gt;initialStack);</FONT>
<FONT SIZE=3>	pmmngr_free_block (stackFrame);</FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>/* unmap and release image memory */</B></SPAN></FONT></FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">for</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (uint32_t page = 0; page &lt; pThread-&gt;imageSize/PAGE_SIZE; page++) {</SPAN></FONT></FONT>
<FONT SIZE=3>		uint32_t phys = 0;</FONT>
<FONT SIZE=3>		uint32_t virt = 0;</FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">		</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>/* get virtual address of page */</B></SPAN></FONT></FONT>
<FONT SIZE=3>		virt = pThread-&gt;imageBase + (page * PAGE_SIZE);</FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">		</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>/* get physical address of page */</B></SPAN></FONT></FONT>
<FONT SIZE=3>		phys = (uint32_t) vmmngr_getPhysicalAddress (cur-&gt;pageDirectory, virt);</FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">		</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>/* unmap and release page */</B></SPAN></FONT></FONT>
<FONT SIZE=3>		vmmngr_unmapPhysicalAddress (cur-&gt;pageDirectory, virt);</FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">		pmmngr_free_block ((</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">void</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">*)phys);</SPAN></FONT></FONT>
<FONT SIZE=3>	}</FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>/* restore kernel selectors */</B></SPAN></FONT></FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">__asm</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> {</SPAN></FONT></FONT>
<FONT SIZE=3>		cli</FONT>
<FONT SIZE=3>		mov eax, 0x10</FONT>
<FONT SIZE=3>		mov ds, ax</FONT>
<FONT SIZE=3>		mov es, ax</FONT>
<FONT SIZE=3>		mov fs, ax</FONT>
<FONT SIZE=3>		mov gs, ax</FONT>
<FONT SIZE=3>		sti</FONT>
<FONT SIZE=3>	}</FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#008000"><SPAN LANG=""><B>/* return to kernel command shell */</B></SPAN></FONT></FONT>
<FONT SIZE=3>	run ();</FONT>

<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	DebugPrintf (</SPAN></FONT><FONT COLOR="#800000"><SPAN LANG="">&quot;\nExit command recieved; demo halted&quot;</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG="">);</SPAN></FONT></FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">	</SPAN></FONT><FONT COLOR="#0000ff"><SPAN LANG="">for</SPAN></FONT><FONT COLOR="#000000"><SPAN LANG=""> (;;);</SPAN></FONT></FONT>
<FONT SIZE=3>}</FONT>
<FONT SIZE=3><FONT COLOR="#000000"><SPAN LANG="">} </SPAN></FONT><FONT COLOR="#008000"><SPAN LANG="">// extern &quot;C&quot;</SPAN></FONT></FONT></PRE><H2 CLASS="western">
Bug report</H2>
<P CLASS="western">There is a reoccurring bug that has been fixed in
a few previous demo's but may still be present in others. We plan to
upload the fix for all the demo's that it may be present in the
future. The bug is in <B>vmmngr_initialize</B><SPAN STYLE="font-weight: normal">,
where some demo's call this function prior to initializing the
physical memory manager and those demo's also improperly map kernel
space thus may result in page fault or triple fault. It has been
resolved (again) in this chapter's demo so please check </SPAN><B>main.cpp</B><SPAN STYLE="font-weight: normal">
and </SPAN><B>mmngr_virt.cpp</B><SPAN STYLE="font-weight: normal">
for the updated code.</SPAN></P>
<H2 CLASS="western"><B>Updated file list</B></H2>
<UL>
	<LI><P CLASS="western"><B>sysapi.h</B><SPAN STYLE="font-weight: normal">
	- </SPAN><B>_syscalls</B><SPAN STYLE="font-weight: normal"> has been
	updated to include </SPAN><B>DebugPrintf</B><SPAN STYLE="font-weight: normal">
	and </SPAN><B>TerminateProcess.</B></P>
	<LI><P CLASS="western"><B>task.h</B><SPAN STYLE="font-weight: normal">
	&ndash; New.</SPAN></P>
	<LI><P CLASS="western"><B>task.cpp</B><SPAN STYLE="font-weight: normal">
	&ndash; New.</SPAN></P>
	<LI><P CLASS="western"><B>main.cpp</B><SPAN STYLE="font-weight: normal">
	&ndash; Added </SPAN><B>proc</B><SPAN STYLE="font-weight: normal">
	command. Also VMM bug fix.</SPAN></P>
	<LI><P CLASS="western"><B>mmngr_virt.h</B><SPAN STYLE="font-weight: normal">
	&ndash; New address space functions.</SPAN></P>
	<LI><P CLASS="western"><B>mmngr_virt.cpp</B><SPAN STYLE="font-weight: normal">
	&ndash; New address space functions. Also VMM bug fix.</SPAN></P>
	<LI><P CLASS="western"><B>image.h</B><SPAN STYLE="font-weight: normal">
	&ndash; PE image structures and definitions.</SPAN></P>
	<LI><P CLASS="western"><B>proc/main.cpp</B><SPAN STYLE="font-weight: normal">
	&ndash; New.</SPAN></P>
</UL>
<H1 CLASS="western">Conclusion</H1>
<P CLASS="western">In this chapter we have looked at processes,
threads, process management, and built basic process management
support. We have covered everything needed for executing user mode
programs from disk which marks a big milestone for the operating
system.</P>
<P CLASS="western">In the next chapter we will build on the process
management functionality implemented in this chapter to build a
scheduler and complete preemptive multitasking support.</P>
<P CLASS="western">Until next time,</P>
<P CLASS="western">~Mike ();</P>
<P CLASS="western">OS Development Series Editor</P>
<H2 CLASS="western">Resources</H2>
<P CLASS="western">The following links were referenced to provide
more through and accurate information. Please reference them for
additional information.</P>
<P CLASS="western"><SPAN STYLE="font-weight: normal"><A HREF="http://en.wikipedia.org/wiki/Process_(computing)">http://en.wikipedia.org/wiki/Process_(computing)</A>
</SPAN>
</P>
<P CLASS="western"><SPAN STYLE="font-weight: normal"><A HREF="http://en.wikipedia.org/wiki/Scheduling_(computing)#Scheduling_disciplines">http://en.wikipedia.org/wiki/Scheduling_(computing)#Scheduling_disciplines</A>
</SPAN>
</P>
<P CLASS="western"><SPAN STYLE="font-weight: normal"><A HREF="http://en.wikipedia.org/wiki/Process_management_(computing)">http://en.wikipedia.org/wiki/Process_management_(computing)</A>
</SPAN>
</P>
<H2 CLASS="western"><B>Additional links</B></H2>
<P CLASS="western" STYLE="font-weight: normal">The following links
are additional tutorials or resources related to this topic. They
might be helpful as a supplement to the material or even help with
providing different designs. If you know of any additional links that
might be helpful to add, please let me know. Links may also include
some multi-tasking concepts that will not be looked at in depth until
the next chapter.</P>
<P CLASS="western"><SPAN STYLE="font-weight: normal"><A HREF="http://www.jamesmolloy.co.uk/tutorial_html/9.-Multitasking.html">http://www.jamesmolloy.co.uk/tutorial_html/9.-Multitasking.html</A>
</SPAN>
</P>
<P CLASS="western"><BR><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P CLASS="western" ALIGN=LEFT><A HREF="OSDev23.html"><IMG SRC="images/left.jpg" NAME="osdev23" ALIGN=BOTTOM BORDER=0></A>
			&nbsp;&nbsp; <A HREF="OSDev23.html"><FONT SIZE=4>Chapter 23</FONT>
			</A>
			</P>
		</TD>
		<TD>
			<P CLASS="western" ALIGN=CENTER><A HREF="OSDevIndex.html"><FONT SIZE=4>Home</FONT></A>
						</P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western"><BR><BR>
</P>
</BODY>
</HTML>