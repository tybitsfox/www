<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"> 
<!-- saved from url=(0056)http://www.gamedev.net/reference/articles/article290.asp --> 
<HTML><HEAD><TITLE>Operating Systems Development Series</TITLE> 
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="Files/reference.css" 
type=text/css rel=stylesheet> 
<META content="MSHTML 6.00.6000.16441" name=GENERATOR></HEAD> 
<BODY text=#000000 vLink=#666699 aLink=#000000 link=#666699 bgColor=#ffffff 
leftMargin=0 
background=Files/watermark.gif 
topMargin=0 marginheight="0" marginwidth="0"> 


<table border=0 cellpadding=0 cellspacing=0 width="100%"> 
<tr> 
     <td width="60%"> 
	<a href="http://www.brokenthorn.com"><img src="site/5.png" border=0></a> 
     </td> 
     <td width="40%"> 
 
        <div id="ad_main"> 
 
        </div> 
 
     </td> 
  </tr> 
</table> 

<TABLE cellSpacing=0 cellPadding=3 width="100%" border=0> 
  <TBODY> 
  <TR> 
    <TD class=tblhdr>Operating Systems Development Series</TD> 
</TR> 
  <TR> 
    <TD align=middle colSpan=2></TD></TR></TBODY></TABLE> 
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=0> 
  <TBODY> 
  <TR> 
    <TD> 
 
 
<!-- Title --> 
 
      <CENTER><SPAN class=title>Operating Systems Development - Basic Theory</SPAN> 
 
<BR><SPAN class=author>by Mike, 2009</SPAN></CENTER> 
 
      <P>This series is intended to demonstrate and teach operating system development from
	the ground up.</p> 
 
 
 
      <H1>Introduction</H1> 
	Welcome to the wonderful and crazy world of operating systems!
	<p> 
	In the previous tutorial, we have defined what an operating system is. An operating
	system provides the basic interface between the user and the computer system. It
	provides the basic look and feel for the system.
	<p> 
	We have also taken a look at alot of tools that will help us. Assemblers, Compliers, Linkers,
	PartCopy, MagicISO, and Bochs.
	<p> 
	For anyone who has no programming experence who is reading this (I know there is some)
	shame on you :) Please go back and reread the "Prerequisites" section from the first tutorial.
	Why are you still reading me? Go go go!
	<p> 
	In this article, we are going to look at operating systems in a different way. We will
	first go Back in Time(tm) to look at the history of operating systems. You will find there
	are many similarities between these operating systems. These similarities will then be
	classified into the basic things operating systems have in common--and the building blocks
	for your own.
 
	<h1>Blast from the Past</h1> 
	<p> 
	Most of todays operating systems are graphical. These graphical user interfaces (GUI),
	however, provide a large abstraction layer to what is really going on in an OS.
	<p> 
	Alot of the concepts about operating systems date back sinse programs were on tape.
	Alot of these concepts still remain active today.
 
	<h2>Prehistory - The Need for Operating Systems</h2> 
 
	<p> 
	Prior to the 1950s, all programs were on punch cards. These punch cards
	represented a form of instructions, which would control every faucet of the
	computer hardware. Each peice of software would have full control of the system.
	Most of the time, the software would be completely different with each other.
	Even the versions of a program.
	<p> 
	The problem was that each program was completely different. They had to be
	simply because they had to be always rewritten from scratch. There was no
	common support for the software, so the software had to communicate directly
	with the hardware. This also made portability and compatibility impossible.
	<p> 
	During the realm of Mainframe computers, creating code libraries became more
	feasable. While it did fix some problems, such as two versions of software
	being completely different, each software still had full control of hardware.
	<p> 
	If new hardware came out, the software will not work. If the software crashed,
	it would need to be debugged using light switches from a control panel.
	<p> 
	The idea of an interface between hardware and programs came during the Mainframe
	era. By having an abstraction layer to the hardware, programs will no longer need
	to have full control, but instead they all would use a single common interface
	to the hardware.
	<p> 
	What is this ultra cool interface? Why, its that sweet cuddley (sometimes nasty)
	thing we call an Operating System! :)
 
	<h1>1950s - Yes there were OSs then</h1> 
 
	The first real operating system recorded, according to Wikipedia, is the GM-NAA I/O.
	The SHARE Operating System was a successor of the GM-NAA I/O. SHARE provided sharing
	programs, managed buffers, and was the first OS to allow the execution of programs
	written in Assembly Language. SHARE became the standard OS for IBM computers in the late 1950s.
	<p><center><img src="images/SHARE.jpg" /></center><p>The SHARE Operating System (SOS) was the first OS to manage
	buffers, provide program sharing, and allow execution of assembly language programs.
	<p> 
	"Managing Buffers" relate to a form of "Managing Memory".
	"Program Sharing" relates to using libraries from different programs.
	<p> 
	<b>The two important things to note here are that,since the beginning of time</b> (Not really :) ),
	<b>Operating Systems are responsible for Memory Management and Program Execution/Management</b> 
	<p> 
	Because this isnt the history of the world (nor computers) that I am describing, lets jump now ahead
	to good old DOS.
 
	<h2>1964 - DOS/360 and OS/360</h2> 
	<p> 
	DOS/360 (or just "DOS") was a Disk Operating System was originally announced by IBM to be released
	on the last day of 1964. Do to some problems, IBM was forced to ship DOS/360 with 3 versions,
	each released June 1966.
	<p> 
	The versions were:
	<ul> 
		<li>BOS/360 - 8KB Configuation.</li> 
		<li>DOS/360 - 16KB Configuation with disk.</li> 
		<li>TOS/360 - 16KB Configuation with tape.</li> 
	</ul> 
	A couple of important things to note is that DOS/360 offered no <b>Multitasking</b>,
	and no <b>Memory Protection</b>.
 
	The OS/360 was being developed about the same time by IBM. The OS/360 used "OS/MFT"
	(Multiple Fixed Transactions) to support multiple programs, with a <b>Fixed Base Address</b>.
	With OS/MVT (Multiple Varable Transaction), it can support varies program sizes.
	<p> 
	Now we have a few more interesting words--<b>Multitasking, Memory Protection,</b> and <b>Fixed Base Address</b>.
	Adding to before, we also have <b>Program execution</b> and <b>Memory Management</b>.
 
	<h2>1969 - Its Unix!</h2> 
	<p> 
	The Unix Operating System was originally written in C. Both C and Unix were originally
	created by AT&T. Unix and C were freely distributed to government and acedimic institutions,
	causing it to be ported to a wider varity of machine families then any other OS.
	<p> 
	Unix is a <b>multiuser</b>, <b>Multitasking</b> Operating System.
	<p> 
	Unix includes a <b>Kernel</b>, <b>File System</b> and a <b>Command Shell</b>.
	There are alot of <b>Graphical User Interfaces (GUI)</b> that uses the <b>Command Shell</b> 
	to interact with the OS, and provide a much friendler and nicer look.
 
	<h2>1982 - Commodore DOS</h2> 
	<p><center><img src="images/DOS[1].gif" /></center> 
	<p> 
	Commodore DOS (CBM DOS) was used with Commodore's 8 bit computers. Unlike the other
	computers before or since-which booted from disk into the systems memory at startup,
	CBM DOS executed internally within the drive-internal ROM chips, and was executed by
	an MOS 6502 CPU.
 
	<h2>1985 - Microsoft Windows 1.0</h2> 
	<p><center><img src="images/Windows1.gif" /></center> 
	<p> 
	The first Windows was a DOS application. Its "MSDOS Executive" program allows the running of a program.
	None of the "Windows" could overlap, however, so each "window" was displayed side to side.
	It was not very popular.
 
	<h2>1987 - Microsoft Windows 2.0</h2> 
	<p><center><img src="images/Windows2.gif" /></center> 
	<p> 
	The second version of Windows was still a DOS <b>Graphical Shell</b>, but supported overlapping
	windows, and more colors. However, do to the limitation of DOS, it was not widley used.
 
 
	<p> 
	<b>Note: DOS is a 16 bit operating system. During this timeframe, DOS had to refrence memory
	through Linear Addressing, and disks through LBA (Linear Block Addressing). Because the x86 platform
	is backward compatible, When the PC boots it is in 16 bit mode (Real Mode), and still has LBA.
	More on this later.
	<p> 
	Do to 16 bit mode limitations, DOS could not access more then 1 MB of memory. This is solved,
	today, by enabling the 20th address line through the Keyboard Controller. We will go over this
	later.</b> 
 
	<p> 
	Because of this 1 MB limitation, Windows was far to slow, which was one primary reason of
	it being unpopular.
 
 
	<h2>1987 - Microsoft Windows 3.0</h2> 
	<p><center><img src="images/Windows3.gif" /></center> 
	<p> 
	Windows 2.0 was completely redesigned. Windows 3.0 was still a DOS Graphical Shell, however it included
	A "DOS Extender" to allow access to 16 MB of memory, over the 1 MB limit of DOS. It is supports <b>multitasking</b> 
	with DOS programs.
	<p> 
	This is the Windows that made Microsoft big. It supportes resizable windows, and movable windows.
 
 
	<h2>Windows in relation to OS Developers</h2> 
	<p> 
	I have seen quite a few beginning OS developers want to develope the next Windows. While it is possible,
	it is extremily difficault, and is impossible with a one person team. Take a look at the above picture again.
	Remember that it is a <b>graphical shell</b> over a <b>command shell</b>, being executed by a <b>Kernel</b>.
	Also, remember that even Windows had to start here. The Command Shell was DOS. the Graphical Shell
	was "Windows".
 
 
	<h1>Basic Concepts</h1> 
	<p> 
	Looking back though our small trip to memory lane brings some important new terms with it.
	So far, we only gave "operating system" a small definition. The previous section should
	help us in defining a better, more descriptive definition of what an operating system is.
	<p> 
	To help define a better definition, lets put the above bolded terms into a list:
	<p> 
	<ul> 
		<li>Memory Management</li> 
		<li>Program Management</li> 
		<li>Multitasking</li> 
		<li>Memory Protection</li> 
		<li>Fixed Base Address</li> 
		<li>Multiuser</li> 
		<li>Kernel</li> 
		<li>File System</li> 
		<li>Command Shell</li> 
		<li>Graphical User Interface (GUI)</li> 
		<li>Graphical Shell</li> 
		<li>Linear Block Addressing (LBA)</li> 
		<li>Bootloader (From the previous tutorial)</li> 
	</ul> 
	<p> 
	Thats alot to think about, huh? And yet--The above list is techincally still
	an abstraction layer itself.
	<p> 
	Lets take a look closer, shall we?
 
	<h2>Memory Management</h2> 
	<p> 
	Memory Management refers to:
	<ul> 
		<li>Dynamically giving and using memory to and from programs that request it.</li> 
		<li>Implimenting a form of <b>Paging</b>, or even <b>Virtual Memory</b>.</li> 
		<li>Insuring the OS Kernel does not read or write to unkown or invalid memory.</li> 
		<li>Watching and handling <b>Memory Fragmentation</b>.</li> 
	</ul> 
 
	<h2>Program Management</h2> 
	<p> 
	This relates cosely with Memory Management. Program Management is responsible for:
	<ul> 
		<li>Insuring the program doesnt write over another program.</li> 
		<li>Insuring the program does not currupt system data.</li> 
		<li>Handle requests from the program to complete a task (such as allocate or deallocate memory).</li> 
	</ul> 
 
	<h2>Multitasking</h2> 
	<p> 
	Multitasking refers to:
	<ul> 
		<li>Switching and giving multiple programs a certain timeframe to execute.</li> 
		<li>Providing a <b>Task Manager</b> to allow switching (Such as Windows Task Manager).</li> 
		<li><b>TSS (Task State Segment) switching. Another new term!</b></li> 
		<li>Executing multiple programs simulataniously.</li> 
	</ul> 
 
	<h2>Memory Protection</h2> 
	<p> 
	This referrs to:
	<ul> 
		<li>Accessing an invalid descriptor in protected mode (Or an invalid segment address)</li> 
		<li>Overwriting the program itself.</li> 
		<li>Overwriting a part or parts of another file in memory.</li> 
	</ul> 
 
	<h2>Fixed Base Address</h2> 
	<p> 
	A "Base Address" is the location where a program is loaded in memory. In normal applications
	programming, you wouldnt normally need this. In OS Development, however, you do.
	<p> 
	A "Fixed" Base Address simply means that the program will always have the same base address
	each time it is loaded in memory. Two example programs are the BIOS and the Bootloader.
 
	<h2>Multiuser</h2> 
	<p> 
	This refers to:
	<ul> 
		<li>Login and Security Protection.</li> 
		<li>Ability of multiple users to work on the computer.</li> 
		<li>Switching between users without loss or curruption of data.</li> 
	</ul> 
 
	<h2>Kernel</h2> 
	<p> 
	The Kernel is the heart of the Operating System. It provides the
	basic foundation, memory management, file systems, program execution,
	etc. We will take a closer look at the kernel very soon, dont worry :)
 
	<h2>File System</h2> 
	<p> 
	In OS Development, there is no such thing as a "file". Everything could be pure
	binary code (from the bootsector); from the start.
	<p> 
	A File System is simply a specification that describes information reguarding files.
	In most cases, this referrs to Clusters, Segments, segment address, root directories,
	etc. the OS has to find the exact starting address of the file in order to load it.
	<p> 
	File Systems also describe file names. There are <b>external</b> and <b>internal</b> 
	file names. For example, the FAT12 specification states a filename can only be 11 characters.
	No more, no less. Seriously. This means the filename "KRNL.sys", for example, will have
	the internal file name <PRE>"KRNL    SYS"</pre> We will be using FAT12 and be discussing
	it in detail later.
 
	<h2>Command Shell</h2> 
	<p> 
	A Command Shell sits ontop the Kernel as a seperate program. The Command Shell provides
	basic input and output through the use of typing commands. The Command Shell uses the Kernel
	to help with this, and complete low level tasks.
 
	<h2>Graphical User Interface (GUI)</h2> 
	<p> 
	The Graphical User Interface (GUI) simply refers to the graphical interface and interactions
	between the Graphical Shell and the user.
 
	<h2>Graphical Shell</h2> 
	<p> 
	The Graphical Shell provides video routines and low level graphical abilities. It normally
	will be executed by the Command Shell. (As in Windows 1.0,2.0, and 3.0). Useually this is automatic
	these days, however.
 
	<h2>Linear Block Addressing (LBA)</h2> 
	<p> 
	Operating Systems have control over <b>every single little byte in memory</b>. Linear Addressing
	refers to directly accessing linear memory. For example:
        <BLOCKQUOTE><PRE><DIV class=code>mov	ax, [09000h]		; There is no such thing as Access Violations in OS Development</DIV></PRE></BLOCKQUOTE> 
 
	This is a good thing, but is also a very bad thing. For example:
        <BLOCKQUOTE><PRE><DIV class=code>		mov	bx, [07bffh]		; or some other address less then 7c00h
		mov	cx, 10
	.loop1:
		mov	[bx], 0h		; clear bx
		inc	bx			; go to next address
		loop	.loop1			; loop until cx=0</DIV></PRE></BLOCKQUOTE> 
	The above code seems harmless. However, if the above code was found in a bootloader,
	the above code will overwrite itself by 10 bytes. Ouch. The reason is that bootloaders
	are loaded with a Fixed address of 0x7c00:0, and the above code starts writing from
	07bffh: One byte before 07c00h.
 
	<h2>Bootloader</h2> 
	<p> 
	The bootloader. We seen this term from the previous tutorial. From the previous tutorial,
	we know the bootloader is loaded by the BIOS, and is the very first program to execute
	for your operaing system.
	<p> 
	The bootloader is loaded by the BIOS at absolute address 0x7c00:0. After loading,
	CS:IP is set to your bootloader, and the bootloader takes full control.
	<p> 
	A Floppy Sector is only 512 bytes in size. Remember that the bootloader has to fit
	in a single bootsector. What does this mean? The bootloader is very limited in size,
	and cannot exceed 512 bytes.
	<p> 
	Most of the time, the bootloader will either just load and execute the kernel, or
	a <b>Second Stage Bootloader</b>.
	<p> 
	We will take a closer look at the booting process very soon. That is when we will look at
	bootloaders.
 
 
	<h1>Conclusion</h1> 
	<p> 
	We have taken a look into the past, and learned a few more terms to our list. After the history
	lesson, we took the terms and built a more broader perspective on how everything works. We even
	got to see some code. A small amount, though.
	<p> 
	After all of this, one should be able to develope a more concise definition of what we are doing.
	<p><b><center><i> 
	"An interactive envirement that provides an interface for the user and supplied programs, providing
	a stable and safe envirement, an interface layer to System services and computer hardware."
	</i></center></b> 
	<p> 
	Yep. Thats my new definition of "Operating System", what is yours?
	<p> 
	In the next tutorial, we are going to take a look on the booting process in descrete detail.
	Afterwords, we will take a look at building and assembling of a real bootloader.
 
 
	<p> 
	Until next time,
	<p>
	~Mike<br>
	<i>BrokenThorn Entertainment. Currently developing DoE and the <a href="http://www.brokenthorn.com/mos/site2/">Neptune Operating System</a></i>

	<br><br>
	<i>Questions or comments? Feel free to <a href="mailto:neon6000@aol.com">Contact me</a>.</i>

	<br><br>
	Would you like to contribute and help improve the articles? If so, please <a href="mailto:neon6000@aol.com">let me know!</a>

<br><br> 
<table width=100% border=0> 
<tr> 
<td><p align=left> 
<a class="anchor" href="OSDev1.html"> 
<img src="images/left.jpg" border=0></a> 
&nbsp;&nbsp;
<a class="anchor" href="OSDev1.html"> 
<font size=4>Chapter 1</font> 
</a> 
 
</p></td> 
<td> 
<p align=center> 
<font size=4><a class="anchor" href="OSDevIndex.html">Home</a></font> 
</p> 
</td> 
<td><p align=right> 
<a class="anchor" href="OSDev3.html"><font size=4>Chapter 3</font></a> 
&nbsp;&nbsp;
<a class="anchor" href="OSDev3.html"><img src="images/right.jpg" border=0></a> 
</p></td> 
</tr> 
</table> 
 
 
</BODY></HTML> 
