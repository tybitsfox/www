<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0056)http://www.gamedev.net/reference/articles/article290.asp -->
<HTML><HEAD><TITLE>Operating Systems Development Series</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="Files/reference.css" 
type=text/css rel=stylesheet>
<META content="MSHTML 6.00.6000.16441" name=GENERATOR></HEAD>
<BODY text=#000000 vLink=#666699 aLink=#000000 link=#666699 bgColor=#ffffff 
leftMargin=0 
background=Files/watermark.gif 
topMargin=0 marginheight="0" marginwidth="0">


<table border=0 cellpadding=0 cellspacing=0 width="100%"> 
<tr> 
     <td width="60%"> 
	<a href="http://www.brokenthorn.com"><img src="site/5.png" border=0></a> 
     </td> 
     <td width="40%"> 
 
        <div id="ad_main"> 
 
        </div> 
 
     </td> 
  </tr> 
</table> 

<TABLE cellSpacing=0 cellPadding=3 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=tblhdr>Operating Systems Development Series</TD>
</TR>
  <TR>

    <TD align=middle colSpan=2></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
  <TBODY>
  <TR>
    <TD>


<!-- Title -->

      <CENTER><SPAN class=title>Operating Systems Development - Introduction</SPAN> 

<BR><SPAN class=author>by Mike, 2008, Updated 2010</SPAN></center>

      <P>This series is intended to demonstrate and teach operating system development from
	the ground up.</p>

<script src="http://www.gmodules.com/ig/ifr?url=http://www.google.com/ig/modules/translatemypage.xml&amp;up_source_language=en&amp;synd=open&amp;w=160&amp;h=60&amp;title=&amp;lang=en&amp;country=ALL&amp;border=%23ffffff%7C3px%2C1px+solid+%23999999&amp;output=js"></script>


<H1>What is this about?</H1> 	
<p> 	
Operating systems can be a very complex topic. Learning how operating systems work can be a great 
learning experience. 	<p> 	The purpose of this series is to teach the black art of Operating 
System (OS) Development, from the ground up. Whether 	you want to make your own OS, or simply 
to learn how they work, this series is for you.    

<H1>What is an Operating System?</H1> 	

<p> 	
An Operating System provides the basic functionality, look, and feel, for a computer. 	
The primary purpose is to create a workable Operating Environment for the user. 	<p> 
	An example of an Operating System is Windows, Linux, and Macintosh.        


<H1>If you have never programmed before</H1> 
<p>
 Computer programming is designing and writing software, or programs, for the computer to 
load and execute. However, the Operating System needs to be designed with this functionality. 	
<p>
An Operating System is not a single program, but a collection of software that work and 	
communicate with each other. This is what I mean by "Operating Environment". 
<p> 
Because Operating Systems are a collection of software, in order to develop an Operating 
System, one must know how to develop software. That is, one must know computer programming. 
<p> 	
If you have never programmed before, take a look at the Requirements section below, and look 	
no further. This section will have links to good tutorials and articles that could help you 	
to learn computer programming with C++ and 80x86 Assembly Language.       

 <H1>Requirements</H1> 

	<h2>Knowledge of the C Programming Language</h2> 	

	<p> 	
	Using a high level language, such as C, can make OS development much easier. The most common 
	languages that are used in OS 	development are C, C++, and Perl. Do not think these are the
	only languages that may be used; It is possible in other languages. I have even seen one
	with FreeBASIC! Getting higher level languages to work properly can also make it harder
	to work within the long run, however.

	<p/>C and C++ are the most common,
	 with C being the most used. C, as being a middle level language, provides high level 
	constructs while still providing low level details that are closer to assembly language, and 
	hence, the system. Because of this, using C is fairly easy in OS development. This is one of the
	primary reasons why it is the most commonly used: Because the C programming language was
	originally <i>designed</i> for system level and embedded software development.	
	<p> 
	Because of this, we are going to be using C for most of the OS. 	
	<p> 	
	C is a complex programming language, that can take a book to cover. If you do not know C, the
	following may help: 

	<ul> 	
		<li><a href="http://fresh2refresh.com/">Learn C – A complete resource for a beginner</a></li>

		<li><a href="http://www.cprogramming.com/">cprogramming.com</a></li>

		<li><a href="http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html">Thinking in C++</a></li>

 	</ul> 
	I personally learned from the original "The C++ Programming language", which is now obsolete, though.

 	<h2>Knowledge of x86 Assembly Language</h2> 	
	<p> 	
	80x86 Assembly Language is a low level programming language. Assembly Language provides a direct 
	one to one relation 	with the processor machine instructions, which make assembly 
	language suitable for hardware programming. 	
	<p> 	
	Assembly Language, as being low level, tend to be more complex and harder to develop in,
	then high level languages like C. 	
	Because of this, and to aid in simplicity, We are only going to use assembly language when required,
	and no more. 	
	<p>
	Assembly Language is another complex language that can take a book to fill. If you do not know x86
	Assembly Language, the 	following may help: 

	<ul> 	

	<li><a href="http://www.duntemann.com/assembly.htm">Assembly Language: Step by Step</a></li> 	
	<li><a href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/toc.html">Art of Assembly</a></li> 
	</ul> 	

	I personally learned from Assembly Language Step by Step (Excellent beginning book) and the Art of
	Assembly Language. Both are very great 	books.  

	<h2>Getting ready</h2> 
	That is all you need to know--Everything else I'll teach along the way. Be forewarned:
	From here on out, I will not be explaining 
	C or x86 Assembly Language concepts. I will still explain new instructions that you may not
	be familiar with, such as <b>lgdt</b>, 	and the use of <b>sti, cli, bt, cpuid</b> and some others,
	however.     


    <H1>Tools of the trade</H1>  
	<p> 	
	In developing low level code, we will need specialized low level software to help us out. 
	Some of these tools are not needed, however, they are highly recommended as they can significantly 
	aid in development. 


	<h2>NASM - The Assembler</h2> 		
	<p> 	
	The Netwide Assembler (NASM) can generate flat binary 16bit programs, while most other assemblers 
	(Turbo Assembler (TASM), Microsoft's Macro Assembler (MASM)) cannot. 
	<p> 
	During the development of the OS, some programs must be pure binary executables. Because of this, 
	NASM is a great choice to use. 	
	<p> 
	You can download NASM from <a href="http://nasm.sourceforge.net/">here</a>.  




<h2>Microsoft Visual C++ 2005 or 2008</h2>

Because portability is a concern, most of the code for our operating system will be developed in C.
<p/>
During
OS Development, there are some things that we must have control over that not all compilers may support,
however. For example, say good bye to all runtime compiler support (templates, exceptions) and the
good old standard library! Depending on the design of your system, you may also need to support or change
more detailed properties: Such as loading at a specific address, adding your own internal sections
in your programs' binary, etc..) The basic idea is that not all compilers out there are capable of developing
operating system code.
<p/>
I will be using Microsoft Visual C++ for developing the system. However, it is also possible to develop
in other compilers such as DJGPP, GCC or even Cygwin. Cygwin is a command shell program
that is designed to emulate Linux command shell. There is a GCC port for Cygwin. 
<p/>
You can get Visual C++ 2008 from <a href="http://www.microsoft.com/express/download/">here</a>
<p/>
You can also still get Visual C++ 2005 from
<a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=32BC1BEE-A3F9-4C13-9C99-220B62A191EE&displaylang=en">here</a>.

<h3>Support for other compilers</h3>  	

<p> 	
As previously stated, it is possible to develop an operating system using other compilers. 	
While my primary compiler of use will be Visual C++, I will explain on how to setup the working 	
environments so that you will be able to use your favorite compiler.  	
<p> 	
Currently, I plan on describing on setting up the environments for: 	

<ul> 		
<li>DJGPP</li> 		
<li>Microsoft Visual Studio 2005</li> 
<li>GCC</li>
<p> 	
I will also try to support the following compilers, if possible:
<p> 		
<li>Mingw</li> 		
<li>Pelles C</li> 	

</ul> 	

If you would like to add more to this list, please <a href="mailto:neon6000@aol.com">contact me</a>.    

<h2>Copying the Boot Loader</h2>

The bootloader is a pure binary program that is stored in a single 512 byte sector. It is a very 
important program as it is impossible to create an OS without it. It is the very first program of your OS 
that is loaded directly by the BIOS, and executed directly by the processor. 	
<p> 	
We can use NASM to assemble the program, but how do we get it on a floppy disk? We cannot just 	
copy the file. Instead, we have to overwrite the boot record that Windows places (after formatting 	
the disk) with our bootloader. Why do we need to do this? Remember that the BIOS only looks at the bootsector
when finding a bootable disk. The bootsector, and the "boot record" are both in the same sector! 	
Hence, we have to overwrite it. 
<p/>
There are alot of ways we can do this. Here, I will present two. If you are unable to get one method working on
your system, our readers may try the other method.
<p/>

<b>Warning: Do Not attempt to play with the following software until I explain how to use it. Using this 
	oftware incorrectly can corrupt the data on your disk or make your PC unable to boot.</b>  

<h3>PartCopy - Low Level Disk Copier</h3>  	


<p> 	
PartCopy allows the copying of sectors from one drive to another. PartCopy stands for "Partial copy". 	
Its function is to copy a certain number of sectors from one location to another, to and from a specific address. 
<p/>

<p> 	
You can download it from <a href="Programs/pcopy02.zip">here</a>.   	
<p> 

<h3>Windows DEBUG Command</h3>

Windows provides a small command line debugger that may be used through the command line. There are quite a bit of different
things that we can do with this software, but all we need it to do is copy our boot loader to the first 512 bytes on disk.
<p/>
Go to the command prompt, and type <b>debug</b>. You will be greeted by a little prompt (-):
     <BLOCKQUOTE><PRE>C:\Documents and Settings\Michael>debug
-</PRE></BLOCKQUOTE>

Here is where you enter your commands. <b>h</b> is the help command, <b>q</b> is the quit command. The <b>w</b> (write)
command is the most important for us.
<p/>
You can have debug load a file into memory such as, say, our boot loader:

     <BLOCKQUOTE><PRE>C:\Documents and Settings\Michael>debug boot_loader.bin
-</PRE></BLOCKQUOTE>

This allows us to perform operations on it. (We can also use debugs <b>L (Load)</b> command to load the file is we
wanted to). In the above example, <b>boot_loader.bin</b> will be loaded at address 0x100.

<p/>
To write the file to the first sector of our disk, we need to use the <b>W (Write)</b> command which
takes the following form:

     <BLOCKQUOTE><PRE>W [address] [drive] [firstsector] [number]</PRE></BLOCKQUOTE>
Okay... so let's see: The file is at address 0x100. We want the floppy drive (Drive 0). The first sector is
the first sector on the disk (sector 0) and the number of sectors is ehm... 1.
<p/>
Putting this together, this is our command to write <b>boot_loader.bin</b> to the boot sector of a floppy:
    <BLOCKQUOTE><PRE>C:\Documents and Settings\Michael>debug boot_loader.bin
-w 100 0 0 1
-q</PRE></BLOCKQUOTE>
<p/>
If you would like to learn more about this command, take a look at <a href="http://mirror.href.com/thestarman/asm/debug/debug.htm">this tutorial</a>.



<h2>VFD - Virtual Floppy Drive</h2>  	
<p> 	
Weather you have a floppy drive or not, this program is very useful. It can simulate a real floppy drive
from a stored floppy image, or even in RAM. This program creates a virtual floppy image, allows formatting,
and copying files (Such as, your kernel perhaps?) directly using Windows Explorer. 
<p> 	
You can download it from

<a href="http://sourceforge.net/projects/vfd/">here</a>.

<!--old site is down
<a href="http://chitchat.at.infoseek.co.jp/vmware/vfd.html">here</a>
-->


<h2>Bochs Emulator - PC Emulator and Debugger</h2>  
<p> 
You pop in a floppy disk into a computer, in hopes that it works. You boot your computer and look in aw
at your greatest creation! ...Until your floppy motor dies out because you forgot to send the command to 
the controller in your bootloader.  
<p> 
When working with low level code, it is possible to destroy hardware if you are not careful. Also, to 
test your OS, you will need to reboot your computers hundreds of times during development.  
<p> 
Also, what do you do if the computer just reboots? What do you do if your Kernel crashes? Because there
is no debugger for your OS, it is virtually impossible to debug.  
<p> 

The solution? A PC Emulator. There are plenty available, two of them being VMWare and Bochs Emulator. 
I will be using Bochs and Microsoft Virtual PC for testing.
<p/>
You can download Bochs from <a href="http://bochs.sourceforge.net/">here</a>.  

<h2>Thats all, fokes</h2>  
<p> 
You do not need to know how to use the software I listed.
I will explain how to use them as we start using them.
<p/>
If you would like to run your system on a real computer that does not have a floppy drive, it is still
possible to boot from CD even though it is a floppy image. This is done through <b>Floppy Emulation</b>
that which most of BIOSs support.
<p/>
Simply get a CD burning software (I personally use MagicISO) that can create a bootable ISO from a floppy image.
Then, simply burn the ISO image to a CD and it should work.


<H1>The Build Process</H1>  

<p> 
There are a lot of tools listed above. To better understand how they can be useful, we should take a look at 
the entire build process of the OS.  
<p> 

<ul> 	
<li><b>Setting everything up</b></li> 	
<ol> 		
<li>Use VFD to create and format a virtual floppy image to use.</li> 		
<li>Set up Bochs Emulator to boot from the floppy image.</li> 	
</ol> 	
<li><b>The bootloader</b></li> 	
<ol> 		
<li>Assemble the bootloader with NASM to create a flat binary program.</li> 	

<li>Use PartCopy or the DEBUG command to copy the bootloader to the bootsector of the virtual floppy image.</li> 
</ol> 
<li><b>The Kernel (And basically all other programs)</b></li> 	
<ol> 	
<li>Assembly and/or compile all sources into an object format (Such as ELF or PE) that can be loaded and executed by the boot loader.
<li>Copy kernel into floppy disk using Windows Explorer.</li> 	
</ol> 	
<li><b>Test it!</b></li> 
<ol> 	
<li>Using Bochs emulator and debugger, using a real floppy disk, or by using MagicISO to create a bootable
CD.</li> 
</ol>

</ul> 

 
<p> 

<h1>Until next time</h1>  
<p> 
Some of the terms and concepts listed here may be new to you. Do not worry--everything will be explained in the next 	few articles.  	<p> 


The purpose of this tutorial is to create a stepping stone for the rest of the series. It provides
a basic introduction, 	and a listing of the tools we will be using. I will explain how to use these
programs as we need to, so you do not 	need a tutorial on anything listed here besides what has been
listed in the Requirements section.  	<p> 	We also have taken a look at the building process for
developing an operating system. For the most part, its fairly 	simple, however it provides a way to see
<b>when</b> the programs  listed will be used.  	

<p>In the next tutorial we are going to go back in time from the first Disk Operating System (DOS) and
take a little 	tour through history. We will also look at some basic OS concepts. 

<p> 
We will not be using any of the tools listed above just yet, so you do not need to download them
just yet.


	<p>

	Until next time,
	<p>
	~Mike<br>
	<i>BrokenThorn Entertainment. Currently developing DoE and the <a href="http://www.brokenthorn.com/mos/site2/">Neptune Operating System</a></i>

	<br><br>
	<i>Questions or comments? Feel free to <a href="mailto:neon6000@aol.com">Contact me</a>.</i>

	<br><br>
	Would you like to contribute and help improve the articles? If so, please <a href="mailto:neon6000@aol.com">let me know!</a>

<br><br>
<table width=100% border=0>
<tr>
<td><p align=left>
<a class="anchor" href="OSDev0.html">
<img src="images/left.jpg" border=0></a>
&nbsp;&nbsp;
<a class="anchor" href="OSDev0.html">
<font size=4>Chapter 0</font>
</a>

</p></td>
<td>
<p align=center>
<font size=4><a class="anchor" href="OSDevIndex.html">Home</a></font>
</p>
</td>
<td><p align=right>
<a class="anchor" href="OSDev2.html"><font size=4>Chapter 2</font></a>
&nbsp;&nbsp;
<a href="anchor" href="OSDev2.html"><img src="images/right.jpg" border=0></a>
</p></td>
</tr>
</table>

</BODY></HTML>


