<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"> 
<!-- saved from url=(0056)http://www.gamedev.net/reference/articles/article290.asp --> 
<HTML><HEAD><TITLE>Operating Systems Development Series</TITLE> 
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="Files/reference.css" 
type=text/css rel=stylesheet> 
<META content="MSHTML 6.00.6000.16441" name=GENERATOR></HEAD> 
<BODY text=#000000 vLink=#666699 aLink=#000000 link=#666699 bgColor=#ffffff 
leftMargin=0 
background=Files/watermark.gif 
topMargin=0 marginheight="0" marginwidth="0"> 


<table border=0 cellpadding=0 cellspacing=0 width="100%"> 
<tr> 
     <td width="60%"> 
	<a href="http://www.brokenthorn.com"><img src="site/5.png" border=0></a> 
     </td> 
     <td width="40%"> 
 
        <div id="ad_main"> 
 
        </div> 
 
     </td> 
  </tr> 
</table> 

<TABLE cellSpacing=0 cellPadding=3 width="100%" border=0> 
  <TBODY> 
  <TR> 
    <TD class=tblhdr>Operating Systems Development Series</TD> 
</TR> 
  <TR> 
    <TD align=middle colSpan=2></TD></TR></TBODY></TABLE> 
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=0> 
  <TBODY> 
  <TR> 
    <TD> 
 
 
<!-- Title --> 
 
      <CENTER><SPAN class=title>Operating Systems Development - Kernel: Basic Concepts Part 1</SPAN> 
 
<BR><SPAN class=author>by Mike, 2009</SPAN></CENTER> 
 
 
      <P>This series is intended to demonstrate and teach operating system development from
	the ground up.</p> 
 
	<h1>Introduction</h1> 
	Welcome! :)<p> 
	Well...We have finally made it to the most important part of any operating system: The <b>Kernel</b>.
	<p> 
	We have heard this term alot so far throughout the series, already. The reason is because of how important
	it really is.
	<p> 
	The Kernel is the Core of all operating systems. Understanding what it is and how it effects the operating
	system is important.
	<p> 
	In this tutorial, We will look at what goes behind Kernels, what they are, and what they are responsible for.
	Understading these concepts is essental in coming up with a good design.
	<p> 
	<i>Ready?</i> 
 
	<h1>Kernel: Basic Definition</h1> 
	In order to understand what an OS <b>Kernel</b> is, we need to first understand what a <b>"kernel"</b> is at it's basic
	definitions. Dictionaries define "kernel" as "core", "essental part", or even "The body of something". When applying
	this definition to an Operating System envirement, we can easily state that:
	<p> 
	<b>The Kernel is the core component of an operating system.</b> 
	<p> 
	Okay, but what does this mean for us? What exactally is an OS Kernel, and why should we care for it?
	<p> 
	There is no rule that states a kernel is mandatory. We can easily just load and execute programs at specific
	addresses without any "kernel". In fact, all of the early computer systems started this way. Some modern systems
	also use this. A notable example of this are the early counsole video game systems, which required <b>rebooting</b> 
	the system in order to execute <b>one</b> of the games designed for that console.
	<p> 
	So, what is the point of a Kernel? In a computing envirement, it is impractical to restart every time
	to execute a program. This will means that each program itself would need its own bootloaders and direct
	hardware controlling. After all, if the programs need to be executed at bootup, there would be no such thing
	as an operating system.
	<p> 
	What we need is an abstraction layer to provide the capability of executing multiple programs, and manage their
	memory allocations. It also can provide an abstraction to the hardware, which will not be possible if each program
	had to start on bootup without an OS. After all, the software will be running on raw hardware.
	<p> 
	The keyword here is <b>Abstraction</b>.
	Lets look closer...
 
	<h1>The need for Kernels</h1> 
 
	The Kernel provides the primary abstraction layer to the hardware itself. The Kernel is useually at Ring 0
	because of this very reason: <b>It has direct control over every little thing</b>. Because we are still at Ring 0,
	we already experenced this.
	<p> 
	This is good--but what about other software? Remember that we are deveoping an <b>operating envirement</b>? Our primary
	goal is providing a safe, and effective envirement for applications and other software to execute. If we let all
	software to run at Ring 0, alongside the Kernel, there would be no need for a kernel, would there be? If there
	was, <b>The ring 0 software may conflict with the ring 0 Kernel</b>, causing unpredictable results. After all,
	they all have complete control over every byte in the system. Any software can overwrite the kernel, or any other
	software without any problems. Ouch.
	<p> 
	Yet, that is only the beginning of the problems. It is impossible to have multitasking, or multiprocessing as there
	is no common ground to switch between programs and processes. Only one program can execute at a time.
	<p> 
	The basic idea is that a Kernel is a neccessity. Not only do we want to <b>prevent</b> other software direct
	control over everything, but we want to create an <b>abstraction layer</b> for it.
 
	<p>Understanding where and how the Kernel fits in with the rest of the system is very important.
	
	<h1>Abstraction Layers of Software</h1> 
	Software has alot of abstractions. All of these abstractions is ment to provide a core and basic interfaces
	to not only hide implimentation detail, but to <b>shield</b> you from it. Having direct control over everything
	might seem cool--but imagine how much problems would be caused by doing this.
	<p> 
	You might be curious as of what problems I am referring to. Remember that, it its core, electronics does
	only what we tell it. We can control the software down to the <b>hardware</b> level, and in some cases,
	<b>electronics</b> level. Making a mistake at these levels can physically cause damage to those devices.
	<p> 
	Lets take a look at each abstraction layer to understand what I mean, and to see where our Kernel fits in.
 
	<h2>Relationship with PMode Protection Ring Levels</h2> 
 
	In <b>Bootloaders 3 Tutorial</b>, we have took a detailed look at the Rings of Assembly Language. We
	also looked at how this related to <b>protected mode</b>.
	<p> 
	Remember that <b>Ring 0 software has the lowest protection level.</b> This means that we have direct control
	over everything, and are <b>expected</b> to never crash. If <b>any</b> Ring 0 program was to crash, it will
	take the system down with it (Triple Fault).
	<p> 
	Because of this, not only do we want to <b>shield</b> everything else from direct control, but we want to only
	give software the protection level needed to run it. Because of this, normally:
<ul> 
	<li>Kernels work in Ring 0 ("Supervisor Mode")</li> 
	<li>Device Drivers work in Rings 1 and 2, as they require direct access to hardware devices</li> 
	<li>Normal application software work in Ring 3 ("User Mode")</li> 
</ul> 
 
	Okay... <b>how</b> does this all fit together? Lets take a closer look...
 
	<h2>Level 1: Hardware Level</h2> 
 
	This is the actual physical component. The actual microcontroller chips on the motherboard.
	They send low level commands to other microcontrollers on other devices that pysically control
	this device. How? We will look at that in Level 2.
	<p> 
	Examples of hardware are the microcontroller chipset (The "Motherboard Chipset'), disk drives,
	 SATA, IDE, hard drives, memory, the processor (Which is also a controller--Please see
	Level 2 more more information).
	<p> 
	This is the lowest level, and the most detailed as it is pure electronics.
 
	<h2>Level 2: Firmware Level</h2> 
 
	The Firmware sets ontop of the electronics level. It contains the software needed
	by each hardware device and microcontroller. One example of firmware is the BIOS POST.
	<p> 
 
	Remember the processor itself is nothing more then a controller--and just like other controllers,
	rely on its firmware. The <b>Instruction Decoder</b> within the processor dissects a single machine
	instruction into either <b>Macrocode</b>, or directly to <b>Microcode</b>.
	<p> 
	Please see the <b>Tutorial 7: System Architecture Tutorial</b> for more information.
 
	<h3>Microcode</h3> 
	Firmware is useually developed using microcode, and either assembled (With a microassembler) and
	uploaded into a storage area (Such as the BIOS POST), or hardwired into the logic circuits of
	the device through various of means.
	<p> 
	Microcode is useually stored within a ROM chip, such as EEPROM.
	<p> 
	Microcode is very hardware specific. Whenever there is a new change or revision, a new Microcode
	instruction set and Microassembler needs to be developed. On some systems, Microcode has been used to control
	individual electronic gates and switches within the circuit. Yes, It is that low level.
 
	<h3>Macrocode</h3> 
	Microcode is <b>very</b> low level, and can be <b>very</b> hard to develop with, espically in complex systems,
	such as a microprocessor or CPU. It also must be reimplimented whenever a change happens--Not only the code, but the
	Microprograms as well.
	<p> 
	Because of this, some systems have implimented a more higher level language called <b>Macrocode</b> ontop of Microcode.
	Because of this abstraction layer, Macrocode changes less frequently then that of Microcode, and is more portable.
	Also, do to its abstraction layer, is more easier to work with.
	<p> 
	It is still, however, very low level. It is used as the internal logic instruction set to convert higher level machine
	language into Microcode--which is translated by the Instruction Decoder.
 
 
	<h2>Level 3: Ring 0 - Kernel Level</h2> 
 
	This is where we are at. The Stage 2 Bootloaders only focus was to set everything up
	so that our Kernel has an envirement to run in.
	<p> 
	Our Kernel provides the abstraction between Device Drivers and Applications software, and
	the firmware that the hardware uses.
 
	<h2>Level 4: Rings 1 and 2 - Device Drivers</h2> 
 
	Device Drivers go through the Kernel to access the hardware. Device Drivers need alot of freedom
	and control because they require direct control over specific microcontrollers. Having <b>to much</b> control,
	however, can crash the system. For example, what would happen if a driver modified the GDT, or set up its own?
	Doing so will immediately crash the kernel. Because of this, we will want to insure these drivers cannot use <b>LGDT</b> 
	to load its own GDT. <b>This is why we want these drivers to operate at either Ring 1 or Ring 2--Not ring 0</b>.
	<p> 
	For an example, a <b>Keyboard Device Driver</b> will need to provide the interface between <b>Applications software</b> 
	and the <b>Keyboard Microcontroller</b>. The driver may be loaded by the Kernel as a library providing the routines
	to indirectly access the controller.
	<p> 
	As long as there is a standard interface used, we can provide a very portable Kernel as long as we hide all hardware
	dependencies.
 
	<h2>Level 5: Ring 3 - Applications Level</h2> 
	This is where the software are at. They use the interfaces provided by the System API and Device Driver interfaces.
	Normally they do not access the Kernel directly.
 
	<h2>Conclusion</h2> 
 
	This Series will be developing the drivers during the development of the Kernel. This will allow us to keep things
	object orianted, and provide abstraction layer for the Kernel.
	<p> 
	With that in mind, notice where we are at--<b>Level 0</b>. All other programs rely on the Kernel. Why?
	Lets look at the Kernel...
 
	<h1>The Kernel</h1> 
	Because the Kernel is the Core component, it needs to provide the management for everything that relys on it.
	<b>The primary purpose of the Kernel is to manage system resources, and provide an interface so other programs
	can access these resources.</b> In alot of cases, the Kernel itself is unable to use the interface it provides
	to other resources. <b>It has been stated that the Kernel is the most complex and difficault tasks in programming.</b> 
	<p> 
	This implies that designing and implimenting a good Kernel is very difficault.
	<p> 
	In <b>Tutorial 2</b> we took a brief look at different past operating systems. We have bolded alot of new
	terms inside that tutorial--and have compilied a list of those terms at the end of the tutorial. This
	is where that list starts getting implimented.
	<p> 
	Lets first look at that list again, and look at how it related to the Kernel. Everything <b>Bolded</b> is handled by the Kernel:
	<p> 
	<ul> 
		<li><b>Memory Management</b></li> 
		<li><b>Program Management</b></li> 
		<li><b>Multitasking</b></li> 
		<li><b>Memory Protection</b></li> 
 
		<li>Fixed Base Address - This was covered in Tutorial 2</li> 
		<li>Multiuser - This is useually implimented by a shell</li> 
		<li><b>Kernel</b> - Of course</li> 
		<li><b>File System</b></li> 
		<li>Command Shell</li> 
		<li>Graphical User Interface (GUI)</li> 
 
		<li>Graphical Shell</li> 
		<li>Linear Block Addressing (LBA) - This was covered in Tutorial 2</li> 
		<li>Bootloader -Completed</li> 
	</ul> 
	<p> 
	Some of the above can be implimented as seperate drivers, used by the Kernel. For example, Windows uses <b>ntfs.sys</b> 
	as an NTFS Filesystem Driver.
	<p> 
	This list should look familiar from <b>Tutorial 2</b>. We have also covered some of these terms. Lets look
	at the <b>bolded</b> terms, and see how they relate to the Kernel. We will also look at some new concepts.
 
	<h2>Memory Management</h2> 
 
	This is quite possibly the most important part of any Kernel. And rightfully so--all programs and data require it.
	As you know, in the Kernel, because we are still in <b>Supervisor Mode</b> (Ring 0), <b>We have direct access to
	every byte in memory</b>. This is very powerful, but also produces problems, espically in a multitasking evirement,
	where multiple programs and data require memory.
	<p> 
	One of the primary problems we have to solve is: What do we do when we run out of memory?
	<p> 
	Another problem is <b>fragmentation</b>. <b>It is not always possible to load a file or program into a sequencal
	area of memory</b>. For an example, lets say we have 2 programs loaded. One at 0x0, the other at 0x900. Both of these
	programs requested to load files, so we load the data files:
	<p> 
	<center><img src="images/MemFrag.gif"></center> 
	<p> 
	Notice what is happening here. There is alot of unused memory between all of these programs and files. Okay...What
	happens if we add a bigger file that is unable to fit in the above? This is when big problems arise with the current
	scheme. We cannot directly manipulate memory in any specific way, as it will currupt the currently executing programs
	and loaded files.
	<p> 
	Then there is the problems of where each program is loaded at. Each program will be required to be <b>Position Indipendent</b> 
	or provide <b>relocation Tables</b>. Without this, we will not know what
	base address the program is supposed to be loaded at.
	<p> 
	Lets look at these deeper. Remember the <b>ORG</b> directive? This directive sets the location
	where your program is expected to load from. By loading the program at a different location, the
	program will refrence incorrect addresses, and will crash. We can easily test this theory. Right now,
	Stage2 expects to be loaded at 0x500. However, if we load it at 0x400 within Stage1 (While keeping
	the <b>ORG 0x500</b> within Stage2), a triple fault will accure.
	<p> 
	This adds on two new problems. How do we know where to load a program at? Coinsidering all we have is a binary
	image, we <b>cannot</b> know. However, if we make it standard that all programs begin at the same address--lets say, 0x0,
	then we can know. This would work--but is impossible to impliment if we plan to support multitasking. <b>However,
	if we give each program there own memory space, that virtually begins at 0x0, this will work.</b> After all, from each
	programs' perspective, they are all loaded at the same base address--even if they are different in the real (physical) memory.
	<p> 
	What we need is some way to abstract the physical memory. Lets look closer.
 
	<h3>Virtual Address Space (VAS)</h3> 
 
	A <b>Virtual Address Space</b> is a <b>Program's Address Space</b>. One needs to take note that this does <b>not</b> have to do
	with <b>System Memory</b>. The idea is <b>so that each program has their own independent address space.</b> <b>This insures one
	program cannot access another program, because they are using a different address space.</b> 
	<p> 
	Because <b>VAS</b> is <b>Virtual</b> and not directly used with the physical memory, it allows the use of other sources,
	such as disk drives, as if it was memory. That is, <b>It allows us to use more memory then what is physically installed in the system.</b> 
	<p> 
	This fixes the "Not enough memory" problem.
	<p> 
	Also, as each program uses its own <b>VAS</b>, we can have each program always begin at base 0x0000:0000. This solves
	the relocation problems discussed ealier, as well as memory fragmentation--as we no longer need to worry about
	allocating continous physical blocks of memory for each program.
 
	<p> 
	<b>Virtual Addresses are mapped by the Kernel trough the MMU. More on this a little later.</b> 
 
	<h3>Virtual Memory: Abstract</h3> 
 
	<b>Virtual Memory</b> is a special <b>Memory Addressing Scheme</b> implimented by both the hardware and software.
	It allows non contigous memory to act as if it was contigius memory.
	<p> 
	Virtual Memory is based off the <b>Virtual Address Space</b> concepts. It provides every program its own
	Virtual Address Space, allowing memory protection, and decreasing memory fragmentation.
	<p> 
	Virtual Memory also provides a way to indirectly use more memory then we actually have within the system.
	One common way of approching this is by using <b>Page files</b>, stored on a <b>hard drive</b>.
	<p> 
	Virtual Memory needs to be mapped through a hardware device controller in order to work, as it is handled
	at the hardware level. This is normally done through the <b>MMU</b>, which we will look at later.
	<p> 
	For an example of seeing virtual memory in use, lets look at it in action:
	<p> 
	<center><img src="images/virtual-memory[1].png"></center><p> 
	Notice what is going on here. Each memory block within the <b>Virtual Addresses</b> are linear. Each Memory Block
	is <b>mapped</b> to either it's location within the real physical RAM, or another device, such as a hard disk.
	The blocks are swapped between these devices as an as needed bases. This might seem slow, but it is very fast
	thanks to the MMU.
	<p> 
	<b>Remember: Each program will have its own Virtual Address Space--shown above.</b> Because each address space is linear,
	and begins from 0x0000:00000, this immiedately fixes alot of the problems relating to memory fragmentation and program
	relocation issues.
	<p> 
	Also, because <b>Virtual Memory</b> uses different devices in using memory blocks, it can easily manage more then
	the amount of memory within the system. i.e., If there is no more system memory, we can allocate blocks on the hard
	drive instead. If we run out of memory, we can either increase this page file on an as needed bases, or display a warning/error
	message,
	<p> 
	Each memory "Block" is known as a <b>Page</b>, which is useually <b>4096 bytes</b> in size.
	<p> 
	Once again, we will cover everything in much detail later.
 
	<h3>Memory Management Unit (MMU): Abstract</h3> 
	My, oh my, where have we heard this term before? o.0 :)
	<p> 
	The MMU, Also known as <b>Paged Memory Management Unit (PMMU)</b> is a component inside the microprocessor
	responsible for the management of the memory requested by the CPU. It has a number of responsibilities,
	including <b>Translating Virtual Addresses to Physical Addresses, Memory Protection, Cache Control, and more.</b> 
 
	<h3>Segmentation: Abstract</h3> 
	Segmentation is a method of <b>Memory Protection</b>. In Segmentation, we only allocate a certain address space
	from the currently running program. This is done through the <b>hardware registers</b>.
	<p> 
	Segmentation is one of the most widly used memory protection scheme. On the x86, it is useually handled by
	the <b>segment registers</b>: CS, SS, DS, and ES.
	<p> 
	We have seen the use of this through Real Mode.
 
	<h3>Paging: Abstract</h3> 
	THIS will be important to us. Paging is the process of managing program access to the virtual memory pages that are not
	in RAM. We will cover this alot more later.
 
	<h2>Program Management</h2> 
 
	THIS is where the ring levels start getting important.
	<p> 
	As you know, Our Kernel is at Ring 0, while the applications are at Ring 3. This is good, as it prevents the
	applications direct access to certain system resources. This is also bad, as alot of these resources are needed by
	the applications.
	<p> 
	You might be curious on how the processor knows what ring level it is in, and how we can switch ring levels.
	The processor simply uses an internal flag to store the current ring level. Okay, but how does the processor
	know what ring to execute the code in?
	<p> 
	This is where the <b>GDT and LDT</b> become important.
	<p> 
	As you know, in Real Mode, there is no protection levels. Because of this, everything is "Ring 0".
	Remember that <b>we have to set up a GDT prior to going into protected mode?</b> Also, remember
	that we needed to execute a <b>far jump</b> to enter the 32 bit mode. Lets go over this in more detail here, as
	they will play very important roles here.
 
	<h3>Supervisor Mode</h3> 
 
	Ring 0 is known as <b>supervisor mode</b>. It has access to every instruction, register, table, and other,
	more privedged resources that no other applications with higher ring levels can access.
	<p> 
	Ring 0 is also known as <b>Kernel level</b>, and is <b>expected</b> never to fail. If a ring 0 program
	crashes, it will take the system down with it. Remember that: <b><i>"With great power comes great responsibility"</i></b>.
	This is the primary reason for protected mode. ;)
	<p> 
	Supervisor Mode utilizes a hardware flag that can be changed by system level software. System level sftware
	(Ring 0) will have this flag set, while application level software (Ring 3) will not.
	<p> 
	There are alot of things that only Ring 0 code can do, that Ring 3 code cannot. Remember the flags register
	from <b>Tutorial 7</b>? The <B>IOPL Flag</b> of the RFLAGS register determins what level is required to execute
	certain instructions, such as <b>IN and OUT</b> instructions. Because the IOPL is useually 0, this means
	that <b>Only Ring 0 programs have direct access to hardware via software ports.</b> Because of this, we will need
	to switch back to Ring 0 often.
 
	<h3>Kernel Space</h3> 
	<b>Kernel Space</b> referrs to a special region of memory that is reserved for the Kernel, and Rng 0 device drivers.
	In most cases, <b>Kernel Space should never be swapped out to disk, like virtual memory</b>.
	<p> 
	If an operating software runs in <b>User Space</b>, it is often known as <b>"Userland"</b>.
 
	<h3>User Space</h3> 
	This is normally the <b>Ring 3 application programs</b>. Each application useually executes in its own <b>Virtual Address
	Space (VAS)</b> and can be swapped from different disk devices. <b>Because each application is within their
	own virtual memory, they are unable to access another programs memory directly.</b> Because of this, they
	will be required to go through a Ring 0 program to do this. This is neccessary for <b>Debuggers</b>.
	<p> 
	Applications are normally the least priveldged. Because of this, they useually need to request support from
	a ring 0 Kernel level software to access system resources.
 
 
	<h3>Switching Protection Levels</h3> 
	<p> 
	What we need is a way so that these applications can query the system for these resources. However, to do this,
	we need to be in Ring 0, Not Ring 3. Because of this, we need a way to switch the processor state from
	Ring 3 to Ring 0, and allow applications to quey our system.
	<p> 
	Remember back in <b>Tutorial 5</b> we covered the rings of assembly language. Remember that the processor will change
	the current ring level under these conditions:
<ul> 
	<li>A directed instruction, such as a <b>far jump, far call, fat ret</b> etc.</li> 
	<li>A <b>trap</b> instructon, such as <b>INT, SYSCALL, SYSEXIT, SYSENTER, SYSRETURN</b> etc.</li> 
	<li><b>Exceptions</b></li> 
</ul> 
	So...In order for an application to execute a system routine (while switching to Ring 0), the application must either
	<b>far jump</b>, execute an <b>Interrupt</b>, or use a special instruction, such as <b>SYSENTER</b>.
	<p> 
	This is great--but how does the processor know what ring level to switch into? This is where the GDT comes into play.
	<p> 
	Remember that, in each descriptor of the GDT, we had to set up the <b>Ring Level</b> for each descriptor? In our current GDT,
	We have 2 descriptors: Each for Kernel Mode Ring 0. <b>This is our Kernel Space</b>.
	<p> 
	All we need to do is to add 2 mode descriptors to our current GDT, <b>but set for Ring 3 access</b>. <b>This is
	our User Space</b>.
	<p> 
	Lets take a closer look.
	<p> 
	<b>Remember from tutorial 8 that the important byte here is the access byte!</b>. Because of this, here is the byte pattern again:
<ul> 
<li>Bit 0 (Bit 40 in GDT): Access bit (Used with Virtual Memory). Because we don't use virtual memory (Yet, anyway), we will ignore it. Hence, it is 0</li> 
<li>Bit 1 (Bit 41 in GDT): is the readable/writable bit. Its set (for code selector), so we can read and execute data in the segment (From 0x0 through 0xFFFF) as code</li> 
<li>Bit 2 (Bit 42 in GDT): is the "expansion direction" bit. We will look more at this later. For now, ignore it.</li> 
<li>Bit 3 (Bit 43 in GDT): tells the processor this is a code or data descriptor. (It is set, so we have a code descriptor)</li> 
<li>Bit 4 (Bit 44 in GDT): Represents this as a "system" or "code/data" descriptor. This is a code selector, so the bit is set to 1.</li> 
<li>Bits 5-6 (Bits 45-46 in GDT): is the privilege level (i.e., Ring 0 or Ring 3). We are in ring 0, so both bits are 0.</li> 
<li>Bit 7 (Bit 47 in GDT): Used to indicate the segment is in memory (Used with virtual memory). Set to zero for now, since we are not using virtual memory yet</li> 
</ul> 
 
 
      <BLOCKQUOTE><PRE><DIV class=code>;*******************************************
; Global Descriptor Table (GDT)
;*******************************************
 
gdt_data: 
 
; Null descriptor (Offset: 0x0)--Remember each descriptor is 8 bytes!
	dd 0 				; null descriptor
	dd 0 
 
; Kernel Space code (Offset: 0x8 bytes)
	dw 0FFFFh 			; limit low
	dw 0 				; base low
	db 0 				; base middle
	db 10011010b 			; access - Notice that bits 5 and 6 (privilege level) are 0 for Ring 0
	db 11001111b 			; granularity
	db 0 				; base high
 
; Kernel Space data (Offset: 16 (0x10) bytes
	dw 0FFFFh 			; limit low (Same as code)10:56 AM 7/8/2007
	dw 0 				; base low
	db 0 				; base middle
	db 10010010b 			; access - Notice that bits 5 and 6 (privilege level) are 0 for Ring 0
	db 11001111b 			; granularity
	db 0				; base high
 
; User Space code (Offset: 24 (0x18) bytes)
	dw 0FFFFh 			; limit low
	dw 0 				; base low
	db 0 				; base middle
	db 11111010b 			; access - Notice that bits 5 and 6 (privilege level) are 11b for Ring 3
	db 11001111b 			; granularity
	db 0 				; base high
 
; User Space data (Offset: 32 (0x20) bytes
	dw 0FFFFh 			; limit low (Same as code)10:56 AM 7/8/2007
	dw 0 				; base low
	db 0 				; base middle
	db 11110010b 			; access - Notice that bits 5 and 6 (privilege level) are 11b for Ring 3
	db 11001111b 			; granularity
	db 0				; base high</DIV></PRE></BLOCKQUOTE> 
	Notice what is happening here. All code and data have the same range values--the only difference is that
	of the <b>Ring</b> levels.
	<p> 
	As you know, <b>protected mode</b> uses CS to store the <b>Current Privilege Level (CPL)</b>. When entering protected mode
	for the first time, <b>We needed to switch to Ring 0</b>. Because the value of CS was invalid (From real mode), we
	need to choose the correct descriptor from the GDT into CS. <b>Please see Tutorial 8 for more information</b>.
	<p> 
	This required a far jump, as we needed to upload a new value into CS. By <b>far jumping</b> to a Ring 3
	descriptor, we can effectivly enter a Ring 3 state.
	<p> 
	As, as you know, we can use a <b>INT, SYSCALL/SYSEXIT/SYSENTER/SYSRET, far call, or an exception</b> to have the processor switch back to Ring 0.
	<p> 
	Lets take a look closer at these methods...
 
	<h3>System API: Abstract</h3> 
	The program relies on the System API to access system resources. Most applications refrence the System API directly,
	or through their language API--Such as the <b>C runtime library</b>.
	<p> 
	The System API provides the <b>Interface</b> between applications and system resources through <b>System Calls</b>.
 
	<h3>Interrupts</h3> 
	A <b>Software Interrupt</b> is a special type of interrupt implimented in software. Interrupts are used quite often,
	and rely on the use of a special table--the <b>Interrupt Descriptor Table (IDT)</b>. We will look at Interrupts alot
	more closer later, as it is the first thing we will impliment in our Kernel.
	<p> 
	Linux uses INT 0x80 for all system calls.
	<p> 
	<b>Interrupts are the most portable way to impliment system calls.</b> Because of this, we will be using interrupts
	as the first way of invoking a system routine.
 
	<h3>Call Gates</h3> 
	Call Gates provide a way for Ring 3 applications to execute more prividged (Ring 0,1,2) code. The <b>Call gate</b> 
	interfaces between the Ring 0 routines and the Ring 3 applications, and is normally set up by the Kernel.
	<p> 
	Call Gates provide a single gate (Entry point) to FAR CALL. This entry point is defined within the GDT or LDT.
	<p> 
	It is much easier to understand a call gate with an example.
 
      <BLOCKQUOTE><PRE><DIV class=code>;*******************************************
; Global Descriptor Table (GDT)
;*******************************************
 
gdt_data: 
 
; Null descriptor (Offset: 0x0)--Remember each descriptor is 8 bytes!
	dd 0 				; null descriptor
	dd 0 
 
; Kernel Space code (Offset: 0x8 bytes)
	dw 0FFFFh 			; limit low
	dw 0 				; base low
	db 0 				; base middle
	db 10011010b 			; access - Notice that bits 5 and 6 (privilege level) are 0 for Ring 0
	db 11001111b 			; granularity
	db 0 				; base high
 
; Kernel Space data (Offset: 16 (0x10) bytes
	dw 0FFFFh 			; limit low (Same as code)10:56 AM 7/8/2007
	dw 0 				; base low
	db 0 				; base middle
	db 10010010b 			; access - Notice that bits 5 and 6 (privilege level) are 0 for Ring 0
	db 11001111b 			; granularity
	db 0				; base high
 
; Call gate (Offset: 24 (0x18) bytes
 
 CallGate1:
	dw (Gate1 & 0xFFFF)		; limit low address of gate routine
	dw 0x8				; code segment selector
	db 0				; base middle
	db 11101100b			; access - Notice that bits 5 and 6 (privilege level) are 11 for Ring 3
	db 0				; granularity
	db (Gate1 >> 16)		; base high of gate routine
 
; End of the GDT. Define the routine wherever
 
; The call gate routine
 
Gate1:
	; do something special here at Ring 3
 
	retf			; far return back to calling routine</DIV></PRE></BLOCKQUOTE> 
	The above is an example of a call gate.
	<p> 
	To execute the call gate, we offset from the <b>descriptor code</b> within the GDT. Notice how simular this is from
	our <b>jmp 0x8:Stage2</b> instruction:
      <BLOCKQUOTE><PRE><DIV class=code>; execute the call gate
	call far	0x18:0			; far call--calls our Gate1 routine</DIV></PRE></BLOCKQUOTE> 
 
	Call Gates are not used too often in modern operating systems. One of the reasons is that most architectures
	do not support Call Gates. They are also quite slow as they require a <b>FAR CALL</b> and <b>FAR RET</b> instructions.
	<p> 
	On systems where the GDT is not in protected memory, it is also possible for other programs to create their own
	Call Gates to raise its protection level (and get Ring 0 access.) They have also been known to have security issues.
	One notable worm, for example, is <b>Gurong</b>, which installs its own call gate in the Windows Operating System.
 
	<h3>SYSENTER / SYSEXIT Instructions</h3> 
	These instructions were introduced from the Pentium II and later CPUs. Some recent AMD processors also support
	these instructions.
	<p> 
	<b>SYSENTER</b> can be executed by any application. <b>SYSRET</b> can only be executed by Ring 0 programs.
	<p> 
	These instructions are used as a fast way to transfer control from a User Mode (Ring 3) to a Privildge Mode (Ring 0),
	and back quickly. This allows a fast and safe way to execute system routines from user mode.
	<p> 
	<b>These instructions directly rely on the Model Specific Registers (MSR's). Please see Tutorial 7 for an explination
	of MSRs, and the RDMSR and WRMSR instructions.</b> 
	<p> 
	<b>SYSENTER</b><p> 
	The <b>SYSENTER</b> instruction automatically sets the following registers to their locations defined within the MSR:
<ul>	
	<li>CS  = 	IA32_SYSENTER_CS MSR + the value 8</li> 
	<li>ESP = 	IA32_SYSENTER_ESP MSR</li> 
	<li>EIP  = 	IA32_SYSENTER_IP MSR</li> 
	<li>SS  = 	IA32_SYSENTER_SS MSR</li> 
</ul> 
<p> 
	This instruction is only used to transfer control from a Ring 3 code to Ring 0. At startup, we will need to set these
	MSR's to point to a <b>Starting location</b> which will be our <b>Syscall Entry Point</b> for all system calls.
	<p> 
	Lets take a look at SYSEXIT.
 
	<p> 
	<b>SYSEXIT</b><p> 
	The <b>SYSEXIT</b> instruction automatically sets the following registers to their locations defined within the MSR:
<ul>	
	<li>CS  = 	IA32_SYSENTER_CS MSR + the value 16</li> 
	<li>ESP = 	ECX Register</li> 
	<li>EIP = 	EDX Register</li> 
	<li>SS  = 	IA32_SYSENTER_CS MSR MSR + 24</li> 
</ul> 
	<p> 
	<b>Using SYSENTER/SYSEXIT</b> 
	<p> 
	Okay, using these instructions might seem complicated, but they are not too hard ;)
	<p> 
	Because SYSENTER and SYSEXIT require that the MSR's are set up <b>prior</b> to calling them, we
	first need to initialize those MSRs.
	<p> 
	<b>Remember that IA32_SYSENTER_CS is index 0x174, IA32_SYSENTER_ESP is 0x175, and IA32_SYSENTER_IP is 0x176 within
	the MSR. Remember from tutorial 7?</b> 
	<p> 
	Knowing this, lets set them up for SYSENTER:
      <BLOCKQUOTE><PRE><DIV class=code>	%define IA32_SYSENTER_CS 0x174
	%define IA32_SYSENTER_ESP 0x175
	%define IA32_SYSENTER_EIP 0x176
 
	mov	eax, 0x8				; kernel code descriptor
	mov	edx, 0
	mov	ecx, IA32_SYSENTER_CS
	wrmsr
	
	mov	eax, esp
	mov	edx, 0
	mov	ecx, IA32_SYSENTER_ESP
	wrmsr
	
	mov	eax, Sysenter_Entry
	mov	edx, 0
	mov	ecx, IA32_SYSENTER_EIP
	wrmsr
 
	; Now, we can use sysenter to execute Sysenter_Entry at ring 0 from either a Ring 0 program or Ring 3:
	sysenter
 
Sysenter_Entry:
 
	; sysenter jumps here, is is executing this code at prividege level 0. Simular to Call Gates, normally we will
	; provide a single entry point for all system calls.</DIV></PRE></BLOCKQUOTE> 
If the code that executes <b>sysenter</b> is at Ring 3, and <b>Sysenter_Entry</b> is at protection level 0, the processor
will switch modes within the <b>SYSENTER</b> instruction.
<p> 
in the above code, both are at Protection Level 0, so the processor will just call the routine without changing modes.
<p> 
As you can see, there is a bit of work that must be done prior to calling SYSENTER.\ and SYSEXIT.
<p> 
<b>SYSENTER and SYSEEXIT are not portable.</b> Because of this, it is wise to impliment another, more portable, method
alongside SYSENTER/SYSEXIT.
<p> 
 
<h3>SYSCALL / SYSRET Instructions</h3> 
 
<i>[I plan on adding a section for SYSCALL and SYSRET here soon]</i> 
 
	<h3>Error Handling</h3> 
	What do we do if a program causes a problem? How will we know what that problem is and how to handle it?
	<p> 
	Normally this is done by means of <b>Exception Handling</b>. Whenever the procesor enters an invalid state caused by
	an invalid instruction, divide by 0, etc; the processor triggers an <b>Interrupt Service Routine (ISR)</b>. If
	you have mapped our own ISR's, it will call our routines.
	<p> 
	The <b>ISR</b> called depends on what the problem was. This is great, as we know what the problem is, and can try finding
	the program that originally caused the problem.
	<p> 
	One way of doing this is simply getting the last program that you have given processor time to. That is guaranteed
	to be the one that has generated the ISR.
	<p> 
	Once you have the programs information, then one can either output an error or attempt to shutdown the program.
	<p> 
	<b>IRQs are mapped by the internal Programmable Interrupt Controller (PIC) inside the processor. They are mapped to
	interrupt entrys within the Interrupt Descriptor Table (IDT). This is the first thing we will work on inside the Kernel,
	so we will cover everything later.</b> 
 
 
	<h1>Conclusion</h1> 
	<p> 
	We looked at alot of different concepts in this tutorial, ranging from Kernel theory, memory management concepts,
	Virtual Memory Addressing (VMA), and program management, including seperating Ring 0 from Ring 3, and providing
	the interface between applications and system software. Whew! Thats alot, don't you think?
	<p> 
	Alot of the concepts in this tutorial may be new to you--don't worry. This is more of a "Get your feet wet"
	tutorial, where we cover all of the basic concepts related to Kernels.
	<p> 
	This tutorial has bairly scratched the surface of what a Kernel must do. That is a start, though. ;)
	<p> 
	In the next tutorial, we are going to look at Kernels from another perspective. We will cover some new concepts
	yet again, and talk about Kernel designs and implimentations. Afterwords, we will start building our compiliers
	and toolchains to work with C and C++. Sound fun?
	<p> 
	I am currently using MSVC++ 2005 for my Kernel.
	<p> 
	We will also finish off other concepts that we have not looked at here, including <b>multitasking, TSS, Filesystems</b>,
	and more. <i>Its going to be fun ;)</i> 
	<p> 
	Until next time,
	<p>
	~Mike<br>
	<i>BrokenThorn Entertainment. Currently developing DoE and the <a href="http://www.brokenthorn.com/mos/site2/">Neptune Operating System</a></i>

	<br><br>
	<i>Questions or comments? Feel free to <a href="mailto:neon6000@aol.com">Contact me</a>.</i>

	<br><br>
	Would you like to contribute and help improve the articles? If so, please <a href="mailto:neon6000@aol.com">let me know!</a>

<br><br> 
<table width=100% border=0> 
<tr> 
<td><p align=left> 
<a class="anchor" href="OSDev11.html"> 
<img src="images/left.jpg" border=0></a> 
&nbsp;&nbsp;
<a class="anchor" href="OSDev11.html"> 
<font size=4>Chapter 11</font> 
</a> 
 
</p></td> 
<td> 
<p align=center> 
<font size=4><a class="anchor" href="OSDevIndex.html">Home</a></font> 
</p> 
</td> 
<td><p align=right> 
<a class="anchor" href="OSDev13.html"><font size=4>Chapter 13</font></a> 
&nbsp;&nbsp;
<a class="anchor" href="OSDev13.html"><img src="images/right.jpg" border=0></a> 
</p></td> 
</tr> 
</table> 
 
 
</BODY></HTML> 
