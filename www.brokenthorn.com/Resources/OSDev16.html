<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"> 
<!-- saved from url=(0056)http://www.gamedev.net/reference/articles/article290.asp --> 
<HTML><HEAD><TITLE>Operating Systems Development Series</TITLE> 
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="Files/reference.css" 
type=text/css rel=stylesheet> 
<META content="MSHTML 6.00.6000.16441" name=GENERATOR></HEAD> 
<BODY text=#000000 vLink=#666699 aLink=#000000 link=#666699 bgColor=#ffffff 
leftMargin=0 
background=Files/watermark.gif 
topMargin=0 marginheight="0" marginwidth="0"> 


<table border=0 cellpadding=0 cellspacing=0 width="100%"> 
<tr> 
     <td width="60%"> 
	<a href="http://www.brokenthorn.com"><img src="site/5.png" border=0></a> 
     </td> 
     <td width="40%"> 
 
        <div id="ad_main"> 
 
        </div> 
 
     </td> 
  </tr> 
</table> 

<TABLE cellSpacing=0 cellPadding=3 width="100%" border=0> 
  <TBODY> 
  <TR> 
    <TD class=tblhdr>Operating Systems Development Series</TD> 
</TR> 
  <TR> 
 
    <TD align=middle colSpan=2></TD></TR></TBODY></TABLE> 
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=0> 
  <TBODY> 
  <TR> 
    <TD> 
 
<!-- Title --> 
 
      <CENTER><SPAN class=title>Operating Systems Development - PIC, PIT, and exceptions</SPAN> 
 
<BR><SPAN class=author>by Mike, 2008</SPAN></CENTER> 
 
 
      <P>This series is intended to demonstrate and teach operating system development from
	the ground up.</p> 
 
	<i>Please note: This tutorial covers hardware interrupt handling, not software interrupt handling.
	If you are looking for software interrupts, please see <a href="OSDev15.html">Tutorial 15</a>.
	This tutorial requires knowledge of software interrupt handling.</i> 
 
 
	<h1>Introduction</h1> 
 
	Welcome to...what? Tutorial 16 already?
	<p/> 
	In the last tutorial, we have dived deep into the world of interrupt handling. We have covered,
	and even implimented, interfaces for the GDT and IDT inside of our <b>hardware abstraction layer</b>.
	We have covered almost everything we needed for software interrupt handling to work. ...But WAIT!
	What about hardware interrupts? o_0
	<p/> 
	Because alot of critical system devices use interrupts, it is necessary for us to be able to handle
	and catch interrupts triggered by hardware devices. The good news? This is already done for us! By what?
	The <b>8259 Programmable Interrupt Controller (PIC)</b>. We will look closer in the next section.
	<p/> 
	Even if we get hardware interrupts working by itself, we will still be running into problems do to the
	system timer. As long as the system timer does not use a valid interrupt handler that we have set up for it,
	it will triple fault a few milliseconds after you enable hardware interrupts. After all, it will call
	an invalid interrupt handler, remember? Thus, we will also fix this small problem by reprogramming the
	system timer, otherwise known as the <b>Programmable Interval Timer (PIT)</b>.
	<p/> 
	Alot of stuff in this tutorial. We will look at:
 
	<ul> 
		<li>Hardware Interrupts</li> 
		<li>Interrupt Chaining</li> 
		<li>Hal: Programmable Interrupt Controller</li> 
		<li>Hal: Programmable Interval Timer</li> 
		<li>Hardware Abstraction</li> 
		<li>Interrupts Implimentation and Design for our HAL</li> 
	</ul> 
 
	Please note that this does not cover interrupt handling. Please see <a href="OSDev15.html">Tutorial 15</a> 
	for interrupt handlng.
	<p/> 
	With all of that in mind, lets take a look...
 
 
	<h1>Hardware Interrupts</h1> 
 
There are two types of interrupts, those generated by software (Useually by an instruction, such as INT, INT 3,
BOUND, INTO), and an interrupt generated by hardware.
<p/> 
Hardware interrupts are very important for PC's. It allows other hardware devices to signal the CPU that
something is about to happen. For example, a keystroke on the keyboard, or a single clock tick on the internal
timer, for example.
<p/> 
We will need to map what Interrupt Request (IRQ) to generate when these interrupts happen. This way, we
have a way to track these hardware changes.
<p/> 
Lets take a look at these hardware interrupts. 
	<center> 
	<table border=1 bgcolor="CCCCCC"> 
	<th colspan=5 bgcolor="FFFFFF">x86 Hardware Interrupts</th> 
	<tr bgcolor="AAAAAA"> 
	<td>8259A Input pin</td><td>Interrupt Number</td><td>Description</td> 
 
	</tr> 
 
	<tr><td bgcolor="ffffff">IRQ0</td><td>0x08</td><td colspan=4>Timer</td></tr> 
	<tr><td bgcolor="ffffff">IRQ1</td><td>0x09</td><td colspan=4>Keyboard</td></tr> 
	<tr><td bgcolor="ffffff">IRQ2</td><td>0x0A</td><td colspan=4>Cascade for 8259A Slave controller</td></tr> 
 
	<tr><td bgcolor="ffffff">IRQ3</td><td>0x0B</td><td colspan=4>Serial port 2</td></tr> 
	<tr><td bgcolor="ffffff">IRQ4</td><td>0x0C</td><td colspan=4>Serial port 1</td></tr> 
	<tr><td bgcolor="ffffff">IRQ5</td><td>0x0D</td><td colspan=4>AT systems: Parallel Port 2. PS/2 systems: reserved</td></tr> 
 
	<tr><td bgcolor="ffffff">IRQ6</td><td>0x0E</td><td colspan=4>Diskette drive</td></tr> 
 
	<tr><td bgcolor="ffffff">IRQ7</td><td>0x0F</td><td colspan=4>Parallel Port 1</td></tr> 
	<tr><td bgcolor="ffffff">IRQ8/IRQ0</td><td>0x70</td><td colspan=4>CMOS Real time clock</td></tr> 
	<tr><td bgcolor="ffffff">IRQ9/IRQ1</td><td>0x71</td><td colspan=4>CGA vertical retrace</td></tr> 
	<tr><td bgcolor="ffffff">IRQ10/IRQ2</td><td>0x72</td><td colspan=4>Reserved</td></tr> 
 
	<tr><td bgcolor="ffffff">IRQ11/IRQ3</td><td>0x73</td><td colspan=4>Reserved</td></tr> 
 
 
	<tr><td bgcolor="ffffff">IRQ12/IRQ4</td><td>0x74</td><td colspan=4>AT systems: reserved. PS/2: auxiliary device</td></tr> 
	<tr><td bgcolor="ffffff">IRQ13/IRQ5</td><td>0x75</td><td colspan=4>FPU</td></tr> 
 
	<tr><td bgcolor="ffffff">IRQ14/IRQ6</td><td>0x76</td><td colspan=4>Hard disk controller</td></tr> 
	<tr><td bgcolor="ffffff">IRQ15/IRQ7</td><td>0x77</td><td colspan=4>Reserved</td></tr> 
	</table> 
	</center> 
	<p> 
	You do not need to worry to much about each device just yet.
	The 8259A Pins are described in detail in the <a href="OSDevPic.html">8259 PIC tutorial</a>.
 
	The Interrupt Numbers listed in this table are the default DOS <b>interrupt requests (IRQ)</b> 
 
	to execute when these events trigger.
	<p> 
	In most cases, we will need to recreate a new interrupt table. As such, most operating systems need to remap the interrupts
	the PIC's use to insure they call the proper IRQ within their IVT. This is done for us by the BIOS for the real mode IVT.
	We will cover how to do this later in this tutorial as well.
	<p/> 
	Wait...What is this PIC thing? All of these hardware devices that can signal hardware devices are connected
	indirectly to the <b>8259A Programmable Interrupt Controller (PIC)</b>. This is a special, and very important
	microcontroller that is used to signal the microprocessor when it needs to fire a hardware interrupt.
	<p/> 
	We will be programming this microcontroller a little later in this tutorial. Because this microcontroller is
	fairly complex, we have dedicated another tutorial for it. Please read it <a href="OSDevPic.html">here</a>.
 
	<h1>Interrupt Chaining</h1> 
 
	We will be able to install our own interrupt handlers within the <b>Interrupt Descriptor Table (IDT)</b> 
	very easily. We create interrupt handlers to handle not only software interrupts, but interrupts triggered
	by hardware devices. <b>Remember: The hardware devices signal the Programmable Interrupt Controller to signal
	the processor to request a hardware interrupt to be triggered.</b> The PIC lets the processor know what
	<b>Interrupt Request (IRQ)</b> to call within out <b>Interrupt Descriptor Table (IDT)</b>.
	<p/> 
	But wait... How does the PIC know what IRQs to call within our IDT? <i>We tell it</i>.
	<p/> 
	This is why we must reprogram the PIC in order to let it know what interrupts to use.
	<p/> 
	Okay, lets say we now have interrupt handlers to handle software and hardware interrupts. What now? How does this
	work from our perspecitive? Sure, we can easily install handlers for different devices, but what if multiple
	devices require the same interrupt? What about multiple functions for a software interrupt? This is where
	<b>Interrupt Chaining</b> comes in.
	<p/> 
	Interrupt chaning is a technique used to restore and call all of the interrupt handlers that share that same
	interrupt number. This is done by saving the previus <b>Interrupt Routine (IR)</b> in a function pointer.
	Then, installing the new handler, and calling the previus interrupt handler whenever the new IR is called.
	<p/> 
	Here is an example:
 
<BLOCKQUOTE><PRE><DIV class=code>void deviceInitialize () {
 
	//store previus interrupt handler
	prevhandler = getvect (0);
 
	//install new interrupt handler
	setvect (0, handler);
}
 
void deviceShutdown () {
 
	//install previus interrupt handler
	setvect (0, prevhandler);
}
 
void handler () {
 
	// do stuff...
 
	// call previus interrupt handler
	(*prevhandler) ();
}</DIV></PRE></BLOCKQUOTE> 
 
As you can see, interrupt chaining is rather easy. Notice how the previus interrupt handlers will always be called
whenever this interrupt fires? <b>setvect()</b> installs a new interrupt vector. <b>getvect()</b> returns an interrupt
vector. These interrupt vectors can be stored in either the <b>Interrupt Vector Table (IVT)</b> or <b>Interrupt Descriptor
Table (IDT)</b>. Wait, what? Thats right--ours :)
 
<h1>Get Ready - Implimenting Interrupt Handling</h1> 
 
We have covered alot of ground with interrupts and interrupt handling. Text alone can only go so far. We have even
looked a little bit about how hardware interrupt handling works, but not enough to get very far.
<p/> 
We cannot impliment hardware interrupt handling until we learn how to program the <b>Programmable Interrupt Controller</b>.
Also, we cannot enable hardware interrupts until we fix the timing problem (Remember that the <b>Programmable Interval Timer</b> 
is still connected to IRQ8 thanks to the BIOS? That means, as soon as we re-enable hadware interrupts, the next timer tick
will result in a double fault.) Because of this, we also have to learn how to reprogram the <b>Programmable Interval Timer</b>.
<p/> 
This, dear readers, is where things get complex. <b>Welcome back to the world of hardware programming</b> :)
<p/> 
There is good news, however... None of these microcontrollers are very complex. However, to keep the main series from
getting too complex, I have decided to write <b>2 tutorials dedicated to these microcontrollers.</b> This is required
reading for understanding of the demo and code that lies ahead.
<p/> 
Because of this, I recommend for all of our readers to read the following tutorials before continuing:
 
<ul> 
	<li><a href="OSDevPic.html">8259 Programmable Interrupt Controller</a></li> 
	<li><a href="OSDevPit.html">8253 Programmable Interval Timer</a></li> 
</ul> 
Do not worry if you do not understand everything in these tutorials yet. You will see us implimenting everything
within the above tutorials in the sections to come. :) I will also still be describing everything here, so I
will not lead you in the dark.
<p/> 
It may also be helpful to use the above tutorials as a refrence, as we will be refrencing the above tutorials alot
throughout the upcoming sections.
<p/> 
So..? What are you waiting for? Jump into those tutorials! And come back here when you are done. Don't worry,
I am just text... I will still be here when you get back.. ...unless I am deleted of course :)
 
<h1>Demo</h1> 
 
<center><img src="images/Demo16.jpg"><p/><i>The new demo in action</i></center> 
<p/> 
<center><a href="Demos/Demo8.zip">Demo Download</a> (MSVC++)</center> 
<p/> 
I am going to admit, this demo is a little complex. It is not too hard, though, as most of the code should look
familiar.
<p/> 
This demo uses our <b>hardware abstraction layer (HAL)</b> to install its own exception handlers.
This allows us to catch processor exception errors (Like divide by 0.) It also initializes the HAL,
which in turns initializes processor tables, the PIC, and the PIT. This allows us to enable hardware
exceptions (Finally!) and start a timer. <b>The demo displays the current tick count (Updated by the
PIT's interrupt handler) on screen.</b> Any other interrupt generated will be handled by the IDT's
default interrupt handler. We have set this up in our IDT tutorial remember?
<p/> 
Because the keyboard generates IRQ 9, and we have not defined an interrupt for it yet, anytime a key is
pressed the default handler for the IDT will execute.
<p/> 
Okay... I have tried to make this demo look a little cooler then the other ones. At the same time, I did
not want to add even more complexity to it. Because we have looked at creating interfaces for the PIC
and PIT microcontrollers, lets look a little bit at the demo code itself, shall we..?
 
<h1>Hardware Abstraction</h1> 
 
The first interface that we will look at is the one provided by the hardware abstraction layer. This can be
seen by looking at <b>include/hal.h</b> and <b>hal/hal.cpp</b>. I will not be describing the routines in depth
as most of it is very simple and simply use the other interfaces (GDT, IDT, CPU, PIC, PIT, etc) that we have
developed (And are about to develop). Instead, I want to look at the interface itself. This will be the interface
used by the kernel and device drivers, so why not?
 
<h2>The new hal.h</h2> 
 
This is where we start seeing how useful hardware abstraction can be. I wanted to provide a "DOS"-like
interface that is just as easy to use as programming 16bit DOS is. In doing so, I came up with a very
easy list of routines that can be used for alot of different purposes. Looking at these routines,
you will see there is absolutley no refrence to the hardware devices or tables that are used by them.
This is what hardware abstraction is all about. It does not abstract the architecture; but rather the
hardware that it uses.
<p/> 
Alot of the code that we use later use the routines within the HAL to perform its task. Because of this,
I wanted you to take a look at the hardware abstraction layer now, and the routines it provides.
 
      <BLOCKQUOTE><PRE><DIV class=code>extern	int			_cdecl	hal_initialize ();
extern	int			_cdecl	hal_shutdown ();
extern	void			_cdecl	enable ();
extern	void			_cdecl	disable ();
extern	void			_cdecl	geninterrupt (int n);
extern	unsigned char		_cdecl	inportb (unsigned short id);
extern	void			_cdecl	outportb (unsigned short id, unsigned char value);
extern	void			_cdecl	setvect (int intno, void (_cdecl far &vect) ( ) );
extern	void (_cdecl	far *   _cdecl	getvect (int intno)) ( );
extern	bool			_cdecl	interruptmask (uint8_t intno, bool enable);
extern	inline void		_cdecl	interruptdone (unsigned int intno);
extern	void			_cdecl	sound (unsigned frequency);
extern  const char*		_cdecl	get_cpu_vender ();
extern	int			_cdecl	get_tick_count ();</DIV></PRE></BLOCKQUOTE> 
<p/> 
If you have ever programmed 16bit DOS, you should feel at home right about now! :)
 
	<h1>Programmable Interrupt Controller</h1> 
 
	<h2>8259: Microcontroller</h2> 
 
	The 8259 Microcontroller familiy is a set of <b>Programmable Interrupt Controller (PIC) Integrated Circuits (ICs)</b>.
	Hardware controllers are indirectly connected to the PIC when a hardware interrupt is requested. Because of this,
	in order to handle hardware interrupts, we must have an understanding of how to program this microcontroller.
	<p/> 
	I will still go over everything here, however the 8259 is a complex microcontroller. Because of this, we have
	dedicated a full tutorial to cover just this controller. Because of this, <b>in order to get the most out
	of this section, Please see (and refrence) the following tutorial to learn about the PIC:</b> 
	<p/> 
	<b><a href="OSDevPic.html">8259A Programmable Interrupt Controller Tutorial</a></b> 
	<p/> 
	Please note: <b>We will not cover everything about the PIC nor hardware interrupt handling here. Please
	see the above tutorial for this.</b> 
 
	<h2>8259: Abstract</h2> 
 
	The <b>Programmable Interrupt Controller (PIC)</b> is a microcontroller used to provide the connection
	between devices and the processor through <b>interrupt lines</b>. This allows devices to signal
	the processor whenever it requires attention from the system software or executive. This is the
	<b>Interrupt Request (IRQ)</b>.
	<p/> 
	The PIC controls all of the hardware interrupt requests. It allows us to recieve signals from different
	hardware devices whenever they require attention. When a device, such as the <b>Floppy Disk Controller (FDC)</b> 
	requires attention, it tells the PIC to fire the IRQ it is assigned to. From here, the PIC will signal the
	processor, and give the interrupt number to call. The processor then offsets into the IDT, and executes the
	interrupt handler at ring 0. We define all of the interrupt handlers, so we now take control.
	<p/> 
	The best thing about this is that it is all <b>automatic</b> thanks to the PIC. Whenever a device signals the PIC,
	our interrupt handler will be executed automatically. The processor also performs a <b>task switch</b> to ring 0,
	so we will always end up in kernal land to handle the request. Cool, huh?
	<p/> 
	The PIC itself is a complex microcontroller. I will try to cover everything in detail here, but please
	keep in mind that--in order to get the most out of this tutorial, we encourage our readers to read the
	above PIC tutorial.
	<p/> 
	With all of that in mind--lets dive into the interface. All of this code can be found in the demo at the end
	of this tutorial.
 
	<h2>Operation Commands</h2> 
 
	An <b>Operation Command</b> is a special command that is composed of a bit pattern. This bit pattern must
	be set up to describe the command for a microcontroller. There are basically two types of operation commands:
	<b>Initialization Command Words (ICWs)</b> and <b>Operation Command Words (OCWs)</b>.
	<p/> 
	ICWs are operation commands that must only be used during the initialization of the device. OCWs are used to
	control the device after the device has been initialized.
 
 
	<h2>pic.h: Interface</h2> 
 
	This file provides the overall minidriver interface for the rest of the system. This is the interface
	to controlling and managing the PIC. I define a "minidriver" as a driver embedded in a peice of software,
	and not as stand alone software.
 
	<h3>pic.h: Device Connections</h3> 
 
	In the PIC tutorial, we have looked at hardware interrupts in alot of depth. We have looked at how hardware
	devices signal the PIC whenever it requires attention of the system software or executive. For this to work,
	each device is indirectly connected to an <b>Interrupt Request (IR)</b> line on the PIC. This line not only
	represents the <b>Interrupt Request (IRQ)</b> the device uses but also its pririty level (The lower the IRQ
	number, the higher pririty.)
	<p/> 
	To help when working with individual devices and their IRQs, we will want to abstract the IRQ they use.
	This helps increase portability but also readability as they are behind nice constants. Remember: Magic numbers
	are bad!
 
      <BLOCKQUOTE><PRE><DIV class=code>//! The following devices use PIC 1 to generate interrupts
#define		I86_PIC_IRQ_TIMER		0
#define		I86_PIC_IRQ_KEYBOARD		1
#define		I86_PIC_IRQ_SERIAL2		3
#define		I86_PIC_IRQ_SERIAL1		4
#define		I86_PIC_IRQ_PARALLEL2		5
#define		I86_PIC_IRQ_DISKETTE		6
#define		I86_PIC_IRQ_PARALLEL1		7
 
//! The following devices use PIC 2 to generate interrupts
#define		I86_PIC_IRQ_CMOSTIMER		0
#define		I86_PIC_IRQ_CGARETRACE		1
#define		I86_PIC_IRQ_AUXILIARY		4
#define		I86_PIC_IRQ_FPU			5
#define		I86_PIC_IRQ_HDC			6</DIV></PRE></BLOCKQUOTE> 
 
The above constants list all of the devices (along with their IRQ line/number) that they use. <b>There are only 8 IR lines
per PIC</b>, hence only 8 possible IRQs per PIC. <b>Remember that PIC's can be cascaded with secondary PICs</b> (Up to 8 PICs can be
cascaded with each other.) Typical x86 architectures only have 2--One primary and one secondary.
<p/> 
The two most important devices for us right now are the timer (I86_PIC_IRQ_TIMER) and keyboard (I86_PIC_IRQ_KEYBOARD). We
will be using I86_PIC_IRQ_TIMER in this tutorial, so you will see how everything works together, cool?
 
	<h3>pic: 8259 Commands</h3> 
 
Setting up the PIC is farily complex. It is done through a series of <b>Command Words</b>, which are a bit pattern that containes various of states used for initialization and operation. This might seem a little complex, but it is not to hard.
 
We will first look at the <b>Operation Command Word (OCW)</b> that are used to control the PIC. We will look at the initialization
commands a little later.
 
	<h3>pic: Operation Command Word 1</h3> 
 
	This represents the value in the <b>Interrupt Mask Register (IMR)</b>. It does not have a special format,
	so it is handled directly in the implimentation file to enable and disable hardware interrupts.
	It is a single byte in size. We enable and disable ("mask and unmask") an interrupt request line
	by setting the correct bit. Remember that there are only 8 IRQ's per PIC? So, bit 0 in the IMR is IRQ 0,
	bit 1 is IRQ 1, bit 2 is IRQ 2, and so on.
	<p/> 
	We will take a look at the <b>Interrupt Mask register</b> a little later on, cool?
 
	<h3>pic: Operation Command Word 2</h3> 
 
	This is the primary control word used to control the PIC. Lets take a look...
 
	<p> 
 
	<center> 
	<table border=1 bgcolor="CCCCCC"> 
	<th colspan=5 bgcolor="FFFFFF">Operation Command Word (OCW) 2</th> 
	<tr bgcolor="AAAAAA"> 
	<td>Bit Number</td><td>Value</td><td>Description</td> 
	</tr> 
	<tr><td bgcolor="ffffff">0-2</td><td>L0/L1/L2</td><td>Interrupt level upon which the controller must react</td></tr> 
 
	<tr><td bgcolor="ffffff">3-4</td><td>0</td><td>Reserved, must be 0</td></tr> 
	<tr><td bgcolor="ffffff">5</td><td>EOI</td><td>End of Interrupt (EOI) request</td></tr> 
	<tr><td bgcolor="ffffff">6</td><td>SL</td><td>Selection</td></tr> 
	<tr><td bgcolor="ffffff">7</td><td>R</td><td>Rotation option</td></tr> 
 
	</table></center><p/> 
	Okay then!
	<p/> 
	The format of OCW 2 is very easy. The first three bits are the current interrupt level. Bits 3-4 are reserved (Must
	be 0). Bit 5 represents <b>End of Interrupt (EOI)</b>. Bit 6 is the <b>Selection</b> bit. Bit 7 provides a <b>Rotation</b> 
	command.
	<p/> 
	Because each command is selected in individual bits, we can <b>bitwise OR</b> these commands together to produce OCW 2.
 
      <BLOCKQUOTE><PRE><DIV class=code>//! Command Word 2 bit masks. Use when sending commands
#define		I86_PIC_OCW2_MASK_L1		1		//00000001	//Level 1 interrupt level
#define		I86_PIC_OCW2_MASK_L2		2		//00000010	//Level 2 interrupt level
#define		I86_PIC_OCW2_MASK_L3		4		//00000100	//Level 3 interrupt level
#define		I86_PIC_OCW2_MASK_EOI		0x20		//00100000	//End of Interrupt command
#define		I86_PIC_OCW2_MASK_SL		0x40		//01000000	//Select command
#define		I86_PIC_OCW2_MASK_ROTATE	0x80		//10000000	//Rotation command</DIV></PRE></BLOCKQUOTE> 
 
	There you have it! This is an important command word for us. We will be required to send this
	command word from all interrupt handlers.
	<p/> 
	Remember that the PIC masks off the interrupt when it gets executed? This means that no more interrupt
	requests on that IR line can execute until the processor acknowledges the PIC. This is done by sending
	an <b>End of Interrupt</b> command word to the correct PIC. We can do this by <b>masking off</b> the EOI
	bit in the command word. This is what <b>I86_PIC_OCW2_MASK_EOI</b> is used for.
	<p/> 
	A little later on, you will see that the interface has a <b>i86_pic_send_command</b> routine that is used
	to...erm...send commands to the PIC. Lets look at an example of sending the EOI command using this routine
	so that you can see how it works:
 
      <BLOCKQUOTE><PRE><DIV class=code>i86_pic_send_command (I86_PIC_OCW2_MASK_EOI, picNumber);</DIV></PRE></BLOCKQUOTE> 
 
	The above code will send an EOI command to the pic in <b>picNumber</b>, cool?
	<p/> 
	I suppose thats it for OCW 2. On to the next one!
 
	<h3>pic: Operation Command Word 3</h3> 
 
	<i>*I plan on adding to this section.*</i> 
 
<BLOCKQUOTE><PRE><DIV class=code>//! Command Word 3 bit masks. Use when sending commands
#define		I86_PIC_OCW3_MASK_RIS		1		//00000001
#define		I86_PIC_OCW3_MASK_RIR		2		//00000010
#define		I86_PIC_OCW3_MASK_MODE		4		//00000100
#define		I86_PIC_OCW3_MASK_SMM		0x20		//00100000
#define		I86_PIC_OCW3_MASK_ESMM		0x40		//01000000
#define		I86_PIC_OCW3_MASK_D7		0x80		//10000000</DIV></PRE></BLOCKQUOTE> 
 
 
 
	<h2>pic.cpp: Implimentation</h2> 
 
	Okay...Everything was easy so far, right? You are probably asking "Where is the challenge!??" Well, okay
	then.
	<p/> 
	pic.cpp provides the implimentation for our PIC interface. First thing we must look at are the registers.
 
	<h3>pic.cpp: Register constants</h3> 
 
	This is where we define the constants to abstract the port locations for the PICs. Notice that
	I have defined constants for all register names, even though they share the same port address.
	The reason is for completness: Even though they share the same port location, they still are different
	registers.
 
<BLOCKQUOTE><PRE><DIV class=code>//! PIC 1 register port addresses
#define I86_PIC1_REG_COMMAND			0x20			// command register
#define I86_PIC1_REG_STATUS			0x20			// status register
#define I86_PIC1_REG_DATA			0x21			// data register
#define I86_PIC1_REG_IMR			0x21			// interrupt mask register (imr)
 
//! PIC 2 register port addresses
#define I86_PIC2_REG_COMMAND			0xA0			// ^ see above register names
#define I86_PIC2_REG_STATUS			0xA0
#define I86_PIC2_REG_DATA			0xA1
#define I86_PIC2_REG_IMR			0xA1</DIV></PRE></BLOCKQUOTE> 
 
	Not to hard. We send commands to the <b>command register</b>, and read data from the <b>data register</b>.
	If we are writing from a data register, we are accessing the <b>Interrupt Mask Register (IMR)</b> which
	can be used to manually mask off or unmask interrupt requests. This is how we enable or disable interrupt
	requests.
	<p/> 
	The register we are accessing depends on wether it is a write or read operation. If we <b>write</b> to port
	0x20, we are accessing the command register. If we are <b>reading</b> from it, we are accessing the status
	register.
	<p/> 
	Lastly, because this is an implimentation detail, it is part of the implimentation (pic.cpp), not interface.
	<p/> 
	Lets take a look at the constants used during initialization next.
 
	<h3>pic.cpp: Initialization Control Word 1</h3> 
 
	This is the primary control word used when initializing the PICs.
 
	This is a 7 bit value that must be put in the primary PIC
	command register. This is the format:<p> 
	<center> 
	<table border=1 bgcolor="CCCCCC"> 
 
	<th colspan=5 bgcolor="FFFFFF">Initialization Control Word (ICW) 1</th> 
	<tr bgcolor="AAAAAA"> 
	<td>Bit Number</td><td>Value</td><td>Description</td> 
	</tr> 
 
	<tr><td bgcolor="ffffff">0</td><td>IC4</td><td>If set(1), the PIC expects to recieve IC4 during initialization.</td></tr> 
 
	<tr><td bgcolor="ffffff">1</td><td>SNGL</td><td>If set(1), only one PIC in system. If cleared, PIC is cascaded with slave PICs, and ICW3 must be sent to controller.</td></tr> 
	<tr><td bgcolor="ffffff">2</td><td>ADI</td><td>If set (1), CALL address interval is 4, else 8. This is useually ignored by x86, and is default to 0</td></tr> 
	<tr><td bgcolor="ffffff">3</td><td>LTIM</td><td>If set (1), Operate in Level Triggered Mode. If Not set (0), Operate in Edge Triggered Mode</td></tr> 
	<tr><td bgcolor="ffffff">4</td><td>1</td><td>Initialization bit. Set 1 if PIC is to be initialized</td></tr> 
 
	<tr><td bgcolor="ffffff">5</td><td>0</td><td>MCS-80/85: Interrupt Vector Address. x86 Architecture: Must be 0</td></tr> 
	<tr><td bgcolor="ffffff">6</td><td>0</td><td>MCS-80/85: Interrupt Vector Address. x86 Architecture: Must be 0</td></tr> 
	<tr><td bgcolor="ffffff">7</td><td>0</td><td>MCS-80/85: Interrupt Vector Address. x86 Architecture: Must be 0</td></tr> 
	</table></center><p> 
 
	As you can see, there is alot going on here. We have seen some of these before. This is not as hard as it seems,
	as most of these bits are not used on the x86 platform.
 
 
	<p/> 
	There are two types of constants for each command word. The first type are <b>bit masks</b> 
	that are used to mask off the bits that the data represents. The second type of constants
	used are <b>command control bits</b> which are used in conjunction with the masks to set
	them to their correct values.
	<p/> 
	Lets look closer. Here are the ICW 1 bit masks. Notice how they follow the format shown in the above table.
	We do not define anything for the last three bits as they are always zero for x86 architectures.
 
<BLOCKQUOTE><PRE><DIV class=code>//! Initialization Control Word 1 bit masks
#define I86_PIC_ICW1_MASK_IC4			0x1	//00000001	// Expect ICW 4 bit
#define I86_PIC_ICW1_MASK_SNGL			0x2	//00000010	// Single or Cascaded
#define I86_PIC_ICW1_MASK_ADI			0x4	//00000100	// Call Address Interval
#define I86_PIC_ICW1_MASK_LTIM			0x8	//00001000	// Operation Mode
#define I86_PIC_ICW1_MASK_INIT			0x10	//00010000	// Initialization Command</DIV></PRE></BLOCKQUOTE> 
 
	<p/> 
	Okay...We can easily use the above bit masks to set the bits in the ICW 1. But, how do we know what they mean?
	That is, when we mask off the bits that we are wanting to set, how do we know what the value we are setting them
	to mean? This is where <b>command control bits</b> come in.
	<p/> 
	They contain the constant values that may be used to set the above masked off bits to. This helps increase
	readability and extendability alot.
	<p/> 
	Here are the command control bits for ICW 1. Lets take a look...
 
<BLOCKQUOTE><PRE><DIV class=code>#define I86_PIC_ICW1_IC4_EXPECT			1	//1		//Use when setting I86_PIC_ICW1_MASK_IC4
#define I86_PIC_ICW1_IC4_NO			0	//0
#define I86_PIC_ICW1_SNGL_YES			2	//10		//Use when setting I86_PIC_ICW1_MASK_SNGL
#define I86_PIC_ICW1_SNGL_NO			0	//00
#define I86_PIC_ICW1_ADI_CALLINTERVAL4		4	//100		//Use when setting I86_PIC_ICW1_MASK_ADI
#define I86_PIC_ICW1_ADI_CALLINTERVAL8		0	//000
#define I86_PIC_ICW1_LTIM_LEVELTRIGGERED	8	//1000		//Use when setting I86_PIC_ICW1_MASK_LTIM
#define I86_PIC_ICW1_LTIM_EDGETRIGGERED		0	//0000
#define I86_PIC_ICW1_INIT_YES			0x10	//10000		//Use when setting I86_PIC_ICW1_MASK_INIT
#define I86_PIC_ICW1_INIT_NO			0	//00000</DIV></PRE></BLOCKQUOTE> 
 
	Not to hard. The naming convention used allows us to easily know what to use, and where. For example,
	<b>I86_PIC_ICW1_SNGL_YES</b> is used with <b>I86_PIC_ICW1_MASK_SNGL</b>, <b>I86_PIC_ICW1_LTIM_EDGETRIGGERED</b> 
	is used with <b>I86_PIC_ICW1_MASK_LTIM</b>.
	<p/> 
	Here is an example of how they work together. When we are initializing the PIC, we will need to enable initialization,
	and to send ICW 4. To do this, we simply set up ICW 1 like this:
<BLOCKQUOTE><PRE><DIV class=code>	uint8_t	icw=0;
	icw = (icw & ~I86_PIC_ICW1_MASK_INIT) | I86_PIC_ICW1_INIT_YES;
	icw = (icw & ~I86_PIC_ICW1_MASK_IC4) | I86_PIC_ICW1_IC4_EXPECT;</DIV></PRE></BLOCKQUOTE> 
 
	Thats it!? Yep. Notice how everything works and fits together. This is used throughout the implimentations
	to set specific bits (or a series of bits) to known values. The best thing here as that--just by looking
	at the above code--you know what it is doing. (Begin initialization, and to expect ICW 4). Pretty cool, huh?
	We will be using this method throughout this series when needed when setting and masking off bits.
 
 
	<h3>Initialization Control Word 2</h3> 
	This control word is used to map the base address of the IVT of which the PIC are to use.</b><p> 
 
	<center> 
	<table border=1 bgcolor="CCCCCC"> 
	<th colspan=5 bgcolor="FFFFFF">Initialization Control Word (ICW) 2</th> 
	<tr bgcolor="AAAAAA"> 
	<td>Bit Number</td><td>Value</td><td>Description</td> 
	</tr> 
 
	<tr><td bgcolor="ffffff">0-2</td><td>A8/A9/A10</td><td>Address bits A8-A10 for IVT when in MCS-80/85 mode.</td></tr> 
	<tr><td bgcolor="ffffff">3-7</td><td>A11(T3)/A12(T4)/A13(T5)/A14(T6)/A15(T7)</td><td>Address bits A11-A15 for IVT when in MCS-80/85 mode. <b>In 80x86 mode, specifies the interrupt vector address.</b> May be set to 0 in x86 mode.</td></tr> 
	</table></center><p> 
	<p> 
 
	During initialization, we need to send ICW 2 to the PICs to tell them where the base address of the IRQ's to use. If an ICW1
	was sent to the PICs (With the initialization bit set), you must send ICW2 next. <b>Not doing so can result in undefined results.</b> Most
	likley the incorrect interrupt handler will be executed.
	<p/> 
	Because this command does not have a complex format, it is handled directly inside of <b>pic.cpp</b> and does
	not have any constants.
 
 
	<h3>Initialization Control Word 3</h3> 
 
	This command word is used to let the PIC controllers know how they are cascaded. To cascade multiple PICs,
	we must connect one of the PIC's IR lines to each other. We use this command word to let them know what line
	it is.
	<p/> 
	<center> 
	<table border=1 bgcolor="CCCCCC"> 
	<th colspan=5 bgcolor="FFFFFF">Initialization Control Word (ICW) 3</th> 
	<tr bgcolor="AAAAAA"> 
	<td>Bit Number</td><td>Value</td><td>Description</td> 
	</tr> 
	<tr><td bgcolor="ffffff">0-7</td><td>S0-S7</td><td>Specifies what Interrupt Request (IRQ) is connected to slave PIC</td></tr> 
	</table></center><p> 
	<p> 
	Because this command does not have a complex format, it is handled directly inside of <b>pic.cpp</b> and does
	not have any constants.
 
	<h3>Initialization Control Word 4</h3> 
 
	Yey! This is the final initialization control word. This controls how everything is to operate.
	<p> 
	<center> 
	<table border=1 bgcolor="CCCCCC"> 
	<th colspan=5 bgcolor="FFFFFF">Initialization Control Word (ICW) 4</th> 
	<tr bgcolor="AAAAAA"> 
	<td>Bit Number</td><td>Value</td><td>Description</td> 
 
	</tr> 
	<tr><td bgcolor="ffffff">0</td><td>uPM</td><td>If set (1), it is in 80x86 mode. Cleared if MCS-80/86 mode</td></tr> 
	<tr><td bgcolor="ffffff">1</td><td>AEOI</td><td>If set, on the last interrupt acknowledge pulse, controller automatically performs End of Interrupt (EOI) operation</td></tr> 
	<tr><td bgcolor="ffffff">2</td><td>M/S</td><td>Only use if BUF is set. If set (1), selects buffer master. Cleared if buffer slave.</td></tr> 
 
	<tr><td bgcolor="ffffff">3</td><td>BUF</td><td>If set, controller operates in buffered mode</td></tr> 
	<tr><td bgcolor="ffffff">4</td><td>SFNM</td><td>Special Fully Nested Mode. Used in systems with a large amount of cascaded controllers.</td></tr> 
	<tr><td bgcolor="ffffff">5-7</td><td>0</td><td>Reserved, must be 0</td></tr> 
	</table></center><p> 
 
	This is a pretty complex command word, but not to bad. Lets take a look at our defined bit masks.
	Notice how they follow the format shown above.
 
<BLOCKQUOTE><PRE><DIV class=code>//! Initialization Control Word 4 bit masks
#define I86_PIC_ICW4_MASK_UPM		0x1	//00000001	// Mode
#define I86_PIC_ICW4_MASK_AEOI		0x2	//00000010	// Automatic EOI
#define I86_PIC_ICW4_MASK_MS		0x4	//00000100	// Selects buffer type
#define I86_PIC_ICW4_MASK_BUF		0x8	//00001000	// Buffered mode
#define I86_PIC_ICW4_MASK_SFNM		0x10	//00010000	// Special fully-nested mode</DIV></PRE></BLOCKQUOTE> 
 
Simular to <b>ICW 1</b>, we have a set of control bits that are used in conjunction with the bit
masks to set properties. Here they are...
 
<BLOCKQUOTE><PRE><DIV class=code>#define I86_PIC_ICW4_UPM_86MODE		1	//1		//Use when setting I86_PIC_ICW4_MASK_UPM
#define I86_PIC_ICW4_UPM_MCSMODE	0	//0
#define I86_PIC_ICW4_AEOI_AUTOEOI	2	//10		//Use when setting I86_PIC_ICW4_MASK_AEOI
#define I86_PIC_ICW4_AEOI_NOAUTOEOI	0	//00
#define I86_PIC_ICW4_MS_BUFFERMASTER	4	//100		//Use when setting I86_PIC_ICW4_MASK_MS
#define I86_PIC_ICW4_MS_BUFFERSLAVE	0	//000
#define I86_PIC_ICW4_BUF_MODEYES	8	//1000		//Use when setting I86_PIC_ICW4_MASK_BUF
#define I86_PIC_ICW4_BUF_MODENO		0	//0000
#define I86_PIC_ICW4_SFNM_NESTEDMODE	0x10	//10000		//Use when setting I86_PIC_ICW4_MASK_SFNM
#define I86_PIC_ICW4_SFNM_NOTNESTED	0	//00000</DIV></PRE></BLOCKQUOTE> 
 
	This is simple snough, huh? ^_^ We can use the above control bits in conjunction with the bit masks to build
	up the control word. The naming convention used allows us to easily identify what bit masks they are used with.
	<p/> 
	I suppose thats it for the constants used in the implimentation. Lets get on with the functions...
 
	<h3>i86_pic_send_command (): Sends a command to a PIC</h3> 
 
	This routine sends a command byte to the PIC's command register. <b>picNum</b> is a zero-based index
	representing the PIC we are accessing. On x86, this should either be a 0 or 1. Notice that we test
	what PIC we are working with in order to get the correct command register.
	<p/> 
	While this is part of the interface, it should not be used that much outside of the interface. It provides
	a method so we can manually send and control the PICs, if needed. <b>This will be required by the interrupt
	handlers to send the EOI command.</b> 
 
<BLOCKQUOTE><PRE><DIV class=code>inline void i86_pic_send_command (uint8_t cmd, uint8_t picNum) {
 
	if (picNum > 1)
		return;
 
	uint8_t	reg = (picNum==1) ? I86_PIC2_REG_COMMAND : I86_PIC1_REG_COMMAND;
	outportb (reg, cmd);
}</DIV></PRE></BLOCKQUOTE> 
 
	<h3>i86_pic_send_data () and i86_pic_read_data (): Send and return a data byte to or from a PIC</h3> 
 
	These routine are very simular to the above routine, however it writes or reads to the PIC's data register depending
	on the PIC in <b>picNum</b>. Notice how both of these routines are <b>inline</b>. Because these routines are
	small, we want to take out the function call.
 
<BLOCKQUOTE><PRE><DIV class=code>inline void i86_pic_send_data (uint8_t data, uint8_t picNum) {
 
	if (picNum > 1)
		return;
 
	uint8_t	reg = (picNum==1) ? I86_PIC2_REG_DATA : I86_PIC1_REG_DATA;
	outportb (reg, data);
}
 
inline uint8_t i86_pic_read_data (uint8_t picNum) {
 
	if (picNum > 1)
		return 0;
 
	uint8_t	reg = (picNum==1) ? I86_PIC2_REG_DATA : I86_PIC1_REG_DATA;
	return inportb (reg);
}</DIV></PRE></BLOCKQUOTE> 
 
 
 
	<h3>i86_pic_initialize (): Initializes the PICs</h3> 
 
	This is the final routine for the PIC interface. This initializes both PICs for operation using
	all of the routines above, and our constants defined for the initialization control words.
	<p/> 
	This routine is not too complex. Or, rather, not as complex as it looks ;) All it does is send the initialization command to the PIC. It does this
	by setting the <b>I86_PIC_ICW1_INIT_YES</b> bit in the command word. We also set the <b>I86_PIC_ICW1_IC4_EXPECT</b> bit.
	This insures that the controller expects us to send ICW 4. Notice how the constants help improve readability?
	<p/> 
	The ICW is stored in..well... <b>icw</b>. We send the command to both PICs using our <b>i86_pic_send_command()</b> 
	routine.
	<p/> 
	After ICW 1 is sent, we begin initialization by sending ICW 2. Remember that ICW 2 containes the base interrupt numbers?
	This is passed into the <b>base0</b> and <b>base1</b> parameters.
	<p/> 
	Afterwords, we simply send ICW 3. Remember that ICW 3 provides the connection between the master and secondary PIC
	controllers.
	<p/> 
	Lastly is ICW 4. We set up x86 mode by setting the <b>I86_PIC_ICW4_UPM_86MODE</b> bit. Compare this routine with the
	example found in the <a href="OSDevPic.html">PIC tutorial</a> and be amazed...very amazed on their simularities!
 
<BLOCKQUOTE><PRE><DIV class=code>//! Initialize pic
void i86_pic_initialize (uint8_t base0, uint8_t base1) {
 
	uint8_t		icw	= 0;
 
	//! Begin initialization of PIC
 
	icw = (icw & ~I86_PIC_ICW1_MASK_INIT) | I86_PIC_ICW1_INIT_YES;
	icw = (icw & ~I86_PIC_ICW1_MASK_IC4) | I86_PIC_ICW1_IC4_EXPECT;
 
	i86_pic_send_command (icw, 0);
	i86_pic_send_command (icw, 1);
 
	//! Send initialization control word 2. This is the base addresses of the irq's
 
	i86_pic_send_data (base0, 0);
	i86_pic_send_data (base1, 1);
 
	//! Send initialization control word 3. This is the connection between master and slave.
	//! ICW3 for master PIC is the IR that connects to secondary pic in binary format
	//! ICW3 for secondary PIC is the IR that connects to master pic in decimal format
 
	i86_pic_send_data (0x04, 0);
	i86_pic_send_data (0x02, 1);
 
	//! Send Initialization control word 4. Enables i86 mode
 
	icw = (icw & ~I86_PIC_ICW4_MASK_UPM) | I86_PIC_ICW4_UPM_86MODE;
 
	i86_pic_send_data (icw, 0);
	i86_pic_send_data (icw, 1);
}</DIV></PRE></BLOCKQUOTE> 
 
	*Whew*, I guess thats all of the big stuff for the PIC. All that is left is reprogramming the PIT.
	Don't worry--its not as complex as the PIC is.
	Lets take a look...
 
	<h1>Programmable Interval Timer</h1> 
 
	Okay... So the PIC is ready to go, so we can now enable hardware interrupts, right? Yep--Kind of. While
	everything is okay so far, we still do not have an interrupt handler installed for the PIT yet. So, what
	will happen on the next timer tick? ...I think you know where I am getting at :)
	<p/> 
 
	A <b>Programmable Interval Timer (PIT)</b> is a counter which triggers an interrupts when they reach their
	programmed count. The 8253 and 8254 microcontrollers are PITs avialble for the i86 architectures used
	as timer for i86-compatable systems.
	<p/> 
	On x86 architectures, <b>The PIT acts as the system timer</b>, and is <b>connected to the PIC's IR0 line.</b> 
	This allows the PIT to fire <b>IRQ 0</b> each timer tick. Because of this, we will need to reprogram this
	microcontroller before we can use it.
	<p/> 
	The PIT is a complex microcontroller to program. Because of this, we have created a separate tutorial for it.
	While I will still try to cover everything in detail, <b>I will not cover everything about the PIT here.</b> 
	<p/> 
	Please see (and refrence) the following tutorial to learn about the PIT:
 
	<p/> 
	<a href="OSDevPit.html">8253 Programmable Interval Timer Tutorial</a><p/> 
 
 
	<h2>pit.h: Interface</h2> 
 
	The good thing about the PIT is that it is not that complex to program. It does not contain that much
	commands, and yet does not need that much commands. It is a small, but powerful chip used for hardware timing
	and requests.
 
	<h3>Operation Command Word</h3> 
 
	The PIT only containes one <b>Operation Command Word (OCW)</b> which is used to initialize a counter.
	It sets up the counters counting mode, operation mode, and allows us to set up an initil count value.
	<p/> 
	The command word is a little complex. Here is the complete command word:
 
	<ul> 
		<li><b>Bit 0: (BCP)</b> Binary Counter</li> 
		<ul> 
			<li><b>0:</b> Binary</li> 
			<li><b>1:</b> Binary Coded Decimal (BCD)</li> 
 
		</ul> 
		<li><b>Bit 1-3: (M0, M1, M2)</b> Operating Mode. See above sections for a description of each.</li> 
		<ul> 
			<li><b>000:</b> Mode 0: Interrupt or Terminal Count</li> 
			<li><b>001:</b> Mode 1: Programmable one-shot</li> 
 
			<li><b>010:</b> Mode 2: Rate Generator</li> 
			<li><b>011:</b> Mode 3: Square Wave Generator</li> 
			<li><b>100:</b> Mode 4: Software Triggered Strobe</li> 
			<li><b>101:</b> Mode 5: Hardware Triggered Strobe</li> 
 
			<li><b>110:</b> Undefined; Don't use</li> 
			<li><b>111:</b> Undefined; Don't use</li> 
		</ul> 
		<li><b>Bits 4-5: (RL0, RL1)</b> Read/Load Mode. We are going to read or send data to a counter register</li> 
 
		<ul> 
			<li><b>00:</b> Counter value is latched into an internal control register at the time of the I/O write
			operation.</li> 
			<li><b>01:</b> Read or Load Least Significant Byte (LSB) only</li> 
			<li><b>10:</b> Read or Load Most Significant Byte (MSB) only</li> 
 
			<li><b>11:</b> Read or Load LSB first then MSB</li> 
		</ul> 
		<li><b>Bits 6-7: (SC0-SC1)</b> Select Counter. See above sections for a description of each.</li> 
		<ul> 
			<li><b>00:</b> Counter 0</li> 
 
			<li><b>01:</b> Counter 1</li> 
			<li><b>10:</b> Counter 2</li> 
			<li><b>11:</b> Illegal value</li> 
		</ul> 
 
	</ul> 
	<p/> 
	Simular to the PIC's interface, we set up several bit masks that are used to describe the format
	of the command. Here it is...
 
<BLOCKQUOTE><PRE><DIV class=code>#define		I86_PIT_OCW_MASK_BINCOUNT			1	//00000001
#define		I86_PIT_OCW_MASK_MODE				0xE	//00001110
#define		I86_PIT_OCW_MASK_RL				0x30	//00110000
#define		I86_PIT_OCW_MASK_COUNTER			0xC0	//11000000</DIV></PRE></BLOCKQUOTE> 
 
	Okay...While this is smaller then the ICWs and OCWs we set up in the PIC, this is actually
	more complex. The commands used in the PIC are simple in that they are 1 bit in size.
	The commands used in this operation command word are not.
	<p/> 
	This is where <b>Command Control Bits</b> shine. These help define the different settings and bit combinations
	for the different bit masks above. Here they are.
 
<BLOCKQUOTE><PRE><DIV class=code>#define		I86_PIT_OCW_BINCOUNT_BINARY	0	//0		//! Use when setting I86_PIT_OCW_MASK_BINCOUNT
#define		I86_PIT_OCW_BINCOUNT_BCD	1	//1
#define		I86_PIT_OCW_MODE_TERMINALCOUNT	0	//0000		//! Use when setting I86_PIT_OCW_MASK_MODE
#define		I86_PIT_OCW_MODE_ONESHOT	0x2	//0010
#define		I86_PIT_OCW_MODE_RATEGEN	0x4	//0100
#define		I86_PIT_OCW_MODE_SQUAREWAVEGEN	0x6	//0110
#define		I86_PIT_OCW_MODE_SOFTWARETRIG	0x8	//1000
#define		I86_PIT_OCW_MODE_HARDWARETRIG	0xA	//1010
#define		I86_PIT_OCW_RL_LATCH		0	//000000	//! Use when setting I86_PIT_OCW_MASK_RL
#define		I86_PIT_OCW_RL_LSBONLY		0x10	//010000
#define		I86_PIT_OCW_RL_MSBONLY		0x20	//100000
#define		I86_PIT_OCW_RL_DATA		0x30	//110000
#define		I86_PIT_OCW_COUNTER_0		0	//00000000	//! Use when setting I86_PIT_OCW_MASK_COUNTER
#define		I86_PIT_OCW_COUNTER_1		0x40	//01000000
#define		I86_PIT_OCW_COUNTER_2		0x80	//10000000</DIV></PRE></BLOCKQUOTE> 
 
	Lets look at an example. Lets say we want to initialize counter 0 as a square wave generator in binary
	count mode. This is how we can do it:
 
<BLOCKQUOTE><PRE><DIV class=code>	uint8_t ocw=0;
	ocw = (ocw & ~I86_PIT_OCW_MASK_MODE) | I86_PIT_OCW_MODE_SQUAREWAVEGEN;
	ocw = (ocw & ~I86_PIT_OCW_MASK_BINCOUNT) | I86_PIT_OCW_BINCOUNT_BINARY;
	ocw = (ocw & ~I86_PIT_OCW_MASK_COUNTER) | I86_PIT_OCW_COUNTER_0;</DIV></PRE></BLOCKQUOTE> 
 
	I think I am making this too easy, what do you think? :p This is all you need to do, and <b>ocw</b> will contain the operation
	command word that can be sent to the PIC. Notice how using these constants help both improve readabilty, but
	also to decrease the possibility for errors.
	<p/> 
	I guess thats all there is to pit.h. Lets dive into pit.cpp next, shall we? Wee...!!
 
	<h2>pit.cpp: Implimentation</h2> 
 
	This containes the bulk of the PIT minidriver. It containes the implimentations of each routine
	used by both the interface and implimentation.
 
	<h3>pit.cpp: Registers</h3> 
 
	This is where we define the constants to abstract the port locations for the PIT.
 
<BLOCKQUOTE><PRE><DIV class=code>#define		I86_PIT_REG_COUNTER0		0x40
#define		I86_PIT_REG_COUNTER1		0x41
#define		I86_PIT_REG_COUNTER2		0x42
#define		I86_PIT_REG_COMMAND		0x43
 
//! Global Tick count
uint32_t		_pit_ticks=0;</DIV></PRE></BLOCKQUOTE> 
 
Not to bad. <b>I86_PIT_REG_COUNTER0, I86_PIT_REG_COUNTER1,</b> and <b>I86_PIT_REG_COUNTER2</b> are the data registers
for each counter. Remember that the PIT has three internal counters? <b>I86_PIT_REG_COMMAND</b> is our command register.
We will need to write commands to the command register to control and operate the PIT.
<p/> 
Also, notice <b>_pit_ticks</b>. This is a very special and important global.
<p/> 
<b>Remember that the PIT counter 0 connects to the IR0 line on the PIC?</b> This means, when counter 0 fires, it
will generate <b>Interrupt Request (IRQ) 0</b>. We will need to create and install an interrupt handler to handle
this request.
<p/> 
All the interrupt handler needs to do is update the <b>Global Tick Count</b> for the system. That is what <b>_pit_ticks</b> 
is for.
 
<h3>i86_pit_irq(): PIT Counter 0 Interrupt Handler</h3> 
 
This is the interrupt handler that handles the IRQ 0 request. Whenever Counter 0 fires, it will call this interrupt handler.
<p/> 
All it does is increment the global tick count whenever it fires. Note the general format for an interrupt handler.
<p/> 
<b>intstart()</b> is a macro used to disable hardware interrupts and save the stack frame so that we can return to
the task without missing up its stack. <b>intret()</b> is a macro that disables hardware interrupts, restors the stack
frame and returns from the handler using the <b>IRETD</b> instruction. The purpose of this is simply so that we can
protect the current stack from being changed, and return back to the task with its stack intact. These macros are
defined in <b>asm/system.h</b> so they can be used by the kernel and device drivers interrupt handlers.
 
<p/><b>interrupt</b> is a special constant that is only used on certain compiliers. For MSVC++, it is defined as
<b>__declspec (naked)</b>. This is so we don't need to worry about the compiliers added code. Some compiliers
support this keyword directly (Most notably 16 bit compiliers). Others (Like MSVC++) do not, so we must define it.
<p/> 
<b>interruptdone()</b> is a special routine defined in the <b>Hardware Abstraction Layer</b>. It is resposible
for sending the <b>End of Interrupt</b> commands to the PIC.
<p/> 
<b>This is the generic format that all of our interrupt handlers will use.</b> 
<BLOCKQUOTE><PRE><DIV class=code>void interrupt _cdecl i86_pit_irq () {
 
	//! macro to hide interrupt start code
	intstart ();
 
	//! increment tick count
	_pit_ticks++;
 
	//! tell hal we are done
	interruptdone(0);
 
	//! macro used with intstart to return from interrupt handler
	intret ();
}</DIV></PRE></BLOCKQUOTE> 
 
<h3>i86_pit_send_command (): Send Command to PIT</h3> 
 
This is a very important routine that allows us to send command to the PIT. This hides the command port
we are sending it to, which is nice if we need to change the port name. The command is in the form of an
<b>Operation Command Word (OCW)</b>.<p/> 
 
<BLOCKQUOTE><PRE><DIV class=code>//! send command to pic
void i86_pit_send_command (uint8_t cmd) {
 
	outportb (I86_PIT_REG_COMMAND, cmd);
}</DIV></PRE></BLOCKQUOTE> 
 
For an example, we can build up an OCW using our bit masks and command control bits above. Then, we can use
<b>i86_pit_send_command()</b> to send the OCW to the PIT.
 
<h3>i86_pit_send_data() and i86_pit_read_data(): Sends and reads data from counter</h3> 
 
	These routines help abstract the port name used when reading or writing to a counter.
	These are used to set and get the current count value. All they do is test the counter
	passed in <b>counter</b> to insure we get the correct port. Then, its just a simple
	read or write operation through that port.
 
<BLOCKQUOTE><PRE><DIV class=code>//! send data to a counter
void i86_pit_send_data (uint16_t data, uint8_t counter) {
 
	uint8_t	port= (counter==I86_PIT_OCW_COUNTER_0) ? I86_PIT_REG_COUNTER0 :
		((counter==I86_PIT_OCW_COUNTER_1) ? I86_PIT_REG_COUNTER1 : I86_PIT_REG_COUNTER2);
 
	outportb (port, data);
}
 
//! read data from counter
uint8_t i86_pit_read_data (uint16_t counter) {
 
	uint8_t	port= (counter==I86_PIT_OCW_COUNTER_0) ? I86_PIT_REG_COUNTER0 :
		((counter==I86_PIT_OCW_COUNTER_1) ? I86_PIT_REG_COUNTER1 : I86_PIT_REG_COUNTER2);
 
	return inportb (port);
}</DIV></PRE></BLOCKQUOTE> 
 
<h3>i86_pit_initialize (): Initialize the PIT</h3> 
 
Okay, lets talk about initializing the PIT. Yeah! Well... er.. There really is not much to talk about,
as it really does not require initialization. What we will need to do, however, is provide a way to install
our interrupt handler. <b>irq</b> is the interrupt number to use and <b>irCodeSeg</b> is the <b>code seletor</b> 
offset into the <b>Global Descriptor Table (GDT)</b>.
<p/> 
We use our <b>i86_install_ir()</b> routine to install our interrupt handler (<b>i86_pit_irq</b>) into the <b>Interrupt
Descriptor Table</b>. From here on out, IRQ 0 is mapped to our interrupt handler at <b>irq</b>. <b>irq</b> should be
the same base IRQ number that the primary PIC was mapped to use to insure it is mapped to IRQ 0.
 
<BLOCKQUOTE><PRE><DIV class=code>//! initialize minidriver
void i86_pit_initialize (uint8_t irq, uint8_t irCodeSeg) {
 
	//! Install our interrupt handler
	i86_install_ir (irq, I86_IDT_DESC_PRESENT | I86_IDT_DESC_BIT32,
		irCodeSeg, i86_pit_irq);
}</DIV></PRE></BLOCKQUOTE> 
 
<h3>i86_pit_start_counter (): Starts an internal counter</h3> 
 
This is the final routine in the PIT interface. This starts up a counter. We pass the counter into <b>counter</b> 
that we want to start (Such as <b>I86_PIT_REG_COUNTER0</b>). <b>mode</b> containes the operation mode that we want the
counter to use (Such as <b>I86_PIT_OCW_MODE_SQUAREWAVEGEN</b>). <b>freq</b> containes the frequency rate that we
want the counter to operate at.
<p/> 
This routine builds up the <b>operational command word</b> based on the paramaters passed into the routine.
 
<BLOCKQUOTE><PRE><DIV class=code>void i86_pit_start_counter (uint32_t freq, uint8_t counter, uint8_t mode) {
 
	if (freq==0)
		return;
 
	uint16_t divisor = 1193180 / freq;
 
	//! send operational command
	uint8_t ocw=0;
	ocw = (ocw & ~I86_PIT_OCW_MASK_MODE) | mode;
	ocw = (ocw & ~I86_PIT_OCW_MASK_RL) | I86_PIT_OCW_RL_DATA;
	ocw = (ocw & ~I86_PIT_OCW_MASK_COUNTER) | counter;
	i86_pit_send_command (ocw);
 
	//! set frequency rate
	i86_pit_send_data (divisor & 0xff, 0);
	i86_pit_send_data ((divisor >> 8) & 0xff, 0);
 
	//! reset tick count
	_pit_ticks=0;
}</DIV></PRE></BLOCKQUOTE> 
 
<h1>Conclusion</h1> 
<p/> 
From here on out, all of the basics are completed. We have covered alot in this series, from processor modes and
architecture, to processor tables, interrupts, interrupt management, and more. This is the beginning of the kernel,
and where the kernel builds off from.
<p/> 
In this tutorial, we have added support for the PIC, PIT, exceptions, and hardware interrupt management. This is a
important steps, as alot of important devices use hardware interrupts. Also, this gives us a chanch to re-enable
hardware interrupts (Remember that we needed to disable hardware interrupts before the switch to protected mode?)
<p/> 
In the next tutorial, we will go back to the kernel itself. Its time to talk about one of the most fundemental aspects
of any computer system: <b>Paging</b> and <b>Low Level Memory Management</b>. This will also be the foundation of our own <b>System API</b>.
<p/> 
I'll see you there... ;)
 
 
	<p> 
	Until next time,
	<p>
	~Mike<br>
	<i>BrokenThorn Entertainment. Currently developing DoE and the <a href="http://www.brokenthorn.com/mos/site2/">Neptune Operating System</a></i>

	<br><br>
	<i>Questions or comments? Feel free to <a href="mailto:neon6000@aol.com">Contact me</a>.</i>

	<br><br>
	Would you like to contribute and help improve the articles? If so, please <a href="mailto:neon6000@aol.com">let me know!</a>

<br><br> 
<table width=100% border=0> 
<tr> 
<td><p align=left> 
<a class="anchor" href="OSDev15.html"> 
<img src="images/left.jpg" border=0></a> 
&nbsp;&nbsp;
<a class="anchor" href="OSDev15.html"> 
<font size=4>Chapter 15</font> 
</a> 
 
</p></td> 
<td> 
<p align=center> 
<font size=4><a class="anchor" href="OSDevIndex.html">Home</a></font> 
</p> 
</td> 
<td><p align=right> 
<a class="anchor" href="OSDev17.html"><font size=4>Chapter 17</font></a> 
&nbsp;&nbsp;
<a class="anchor" href="OSDev17.html"><img src="images/right.jpg" border=0></a> 
</p></td> 
</tr> 
</table> 
 
 
</BODY></HTML> 
