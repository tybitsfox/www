<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<title>Operating Systems Development Series</title>
		<meta http-equiv="Content-Type" content="text/html; charset=windows-1252" />
		<link href="Files/reference.css" type="text/css" rel="stylesheet" />
		<meta content="MSHTML 6.00.6000.16441" name="GENERATOR" />
		<style type="text/css">
			body
			{
				background-image: url(OSDevVga_files/watermark.htm);
				background-color: #FFFFFF;
				A:link: color: #666699  /* link="#666699" 	*/
				A:visited color: 000000 /* alink="#000000"	*/
				A:active color: 666699 	/* vlink="#666699"  */
				margin-right: 0px;
				margin-left: 0px;
				margin-top: 0px;
				margin-bottom: 0px;
				text: #000000			/* text="#000000"	*/
			}
			.special
			{
				font-weight: 4;
			}
			.center
			{
				text-align: center;
			}
		</style>
	</head>
	<body>


<table border=0 cellpadding=0 cellspacing=0 width="100%"> 
<tr> 
     <td width="60%"> 
	<a href="http://www.brokenthorn.com"><img src="site/5.png" border=0></a> 
     </td> 
     <td width="40%"> 
 
        <div id="ad_main"> 
 
        </div> 
 
     </td> 
  </tr> 
</table> 

		<table border="0" cellpadding="3" cellspacing="0" width="100%">
			<tbody>
				<tr>
					<td class="tblhdr">Operating Systems Development Series</td>
				</tr>
				<tr>
					<td colspan="2" align="center"></td>
				</tr>
			</tbody>
		</table>
		<table border="0" cellpadding="5" cellspacing="0" width="100%">
			<tbody>
				<tr>
					<td>
						<p class="center"><span class="title">Operating Systems Development - Graphics 1</span>
						<br />
						<span class="author">by Mike, 2010</span></p>

						<p>This series is intended to demonstrate and teach operating system development from
						the ground up.</p>
						
<script type="text/javascript" src="http://www.gmodules.com/ig/ifr?url=http://www.google.com/ig/modules/translatemypage.xml&amp;up_source_language=en&amp;synd=open&amp;w=160&amp;h=60&amp;title=&amp;lang=en&amp;country=ALL&amp;border=%23ffffff%7C3px%2C1px+solid+%23999999&amp;output=js"></script>

						<h1>Introduction</h1>

						<p>Welcome!</p>
						<p>
							Wait, what? Graphics already? Thats right, we will start developing an ultra-cool GUI
							for the OS! :) Okay, not really, but its a start in that direction.
						</p>
						<p>
							This chapter is the first of a miniseries of chapters covering graphics programming. I plan
							to cover Vesa VBE, Video BIOS, and direct hardware programming for the VGA and, possibly,
							some SVGA concepts. I also plan on covering graphics concepts and rendering, including 2d
							vector rendering and images. Who knows; mabye a little 3d a little later.
						</p>
						<p>
							Excited? A lot of cool material coming up in this mini series spinoff of the OS Development Series!
							However, before we can dive into the wonderful world of computer graphics, we have to set up
							a ground rule. There are a lot of ways that we can work with computer graphics, and a lot of
							directions that we can take. Computer graphics are a complicated topic: It cannot be covered
							in one chapter. Well, it can. It would just be one .. very, very long chapter.
						</p>
						<p>
							Because of this, I decided to do this in stages. The first chapter covers working with graphics
							in real or v86 modes. We use the system BIOS interrupts and cover basic graphics concepts.
							The second chapter we will dive into Video BIOS Extensions (VBE) and Super VGA. The third chapter,
							will be the first chapter of a smaller miniseries covering direct hardware programming of
							the graphics pipeline: VGA and mabye some Super VGA topics.
						</p>
						<p>
							So for this chapter, lets get started with working with real mode graphics using the real mode
							Video BIOS...
						</p>

						<h1>Basic Concepts</h1>

							<h2>Abstract</h2>
							<p>
								<b>Computer Graphics (CG)</b> does not need an introduction. It has revolutionized the computer,
								animation, and video game industries. The field of computer graphics encompasses the development,
								creation, and continuation of the ability of producing graphical effects on computer displays.
								From 1D graphics, 2D, 3D, and even 4D graphics simulation software.
							</p>

							<h2>History</h2>

							<p>
								The computer graphics industry started to emerge from early projects like the <b>Whirlwind</b> in the 1960's.
								The Whirlwind was the first computer that used video display output and helped introduce the
								<b>Cathode Ray Tube (CRT)</b> technology. Whirlwind eventually led to the development of the SAGE
								(Air Force Semi Automatic Ground Environment) computer system. The ealiest known version of the CRT was created by Ferdinand Braun in 1897 known as the <i>Braun tube</i>.
							</p>
							<p>
								The <b>Special Interest Group on GRAPHics and Interactive Techniques (SIGGRAPH)</b>, is governed by
								the <b>Association for Computing Machinery (ACM) SIGGRAPH</b> group. Originally started in 1969
								by Andy van Dam, the group hosts the SIGGRAPH conferences around the world. These conferences
								are attended by thousands of professionals from companies from the engineering, graphics, motion
								picture, and video game industries.
							</p>
							<p>
								As graphics hardware advanced the ability of creating more powerful graphics designs emerged.
								As other display technologies emerges, such as <b>Liquid Crystal Display (LCD)</b>, The use of
								the CRT technology started to decline.
							</p>
							<p>
 								<b>Video Display Terminals (VDT)</b>, also known as a <b>Video Display unit (VDU)</b> are early
								display terminals.
							</p>

							<h2>Cathode ray tube (CRT)</h2>

            <p class="center">

              <img src="images/crt.png" alt=""></img>
            </p>

								<h3>Abstract</h3>
								<p>
									A CRT is a vacuum tube which consists of electron guns and a phosphor target. The entire
									front area of the tube is scanned repetitibely in a pattern called a <b>raster</b>.
									The image is produced by changing the intensity of the three electron beams: one for
									red, green, and blue color components at a given point on display. These electron beams
									first travel through a <b>Shadow Mask</b> layer before hitting the phosphor coated screen.
								</p>

								<h3>Problems</h3>
								<p>
									CRT monitors can emit a small amount of X-Ray radiation. Also, do to the constant rescanning
									of the display, at low <b>refresh rates</b> (below 60Hz) flicker may be seen. CRTs may also
									contain some toxic phosphore. Because of this the United States Environmental Protection Agency  (EPA) created a rule that CRTs must be
									bought to a proper recycling facility. Finally, do to
									the CRT containing a vaccum of glass, if the outer glass is damaged, the CRT may implode.
									This may cause the glass to shatter outward at dangerous speeds. Modern CRTs have certain
									measures in place to prevent the shattering of the CRT.
								</p>
								<p>
									<b>It is possible to control the frequency of the CRT using software.</b> At higher frequency rates,
									it is possible to make the CRT operate faster then its intended use increasing the possibility
									of imploding the CRT. Because of this, it is very important to be careful when working
									with the <b>CRT Controller (CRTC)</b>. Modern CRTs have protections in place to prevent
									this, however.
								</p>

						<h1>VGA</h1>

							<h2>Abstract</h2>
								<p>
									<b>The Video Graphics Array (VGA)</b> is an anolog computer display standard marketed in 1987 by IBM. It is called an "Array" because it was originally developed as a single chip, replacing dozens of logic chips in a Industry Standard Architecture (ISA) board that the MDA, CGA, and EGA used. Because this was all on a single ISA board, it was very easy to connect it to the motherboard.
								</p>
								<p>
									The VGA consists of the video buffer, video DAC, CRT Controller, Sequencer unit, Graphics Controller, and an Attribute Controller.
									We will cover all of these components in more detail in later chapters.
								</p>

								<h3>Video Buffer</h3>
									<p>
										The <b>Video Buffer</b> is a segment of memory mapped as Video Memory. We can change what region of memory is mapped to video memory. At startup, the BIOS maps it to 0xA0000., which means that video memory is mapped to 0xA0000. (Remember the Real Mode Address Map from Tutorial 7?) We will cover memory
										mapping a little later in this chapter in more detail.
									</p>

								<h3>Video DAC</h3>
									<p>
										The <b>Video Digital to Analog Converter (DAC)</b> contains the color palette that is used to convert the video data into an analog video signal that is sent to the display. This signal indicates the red, green, and blue intensities in analog form. We will go into more detail later, so don't worry if you do not understand this yet.
									</p>

								<h3>CRT Controller</h3>
									<p>
										This controller generates horizontal and vertical synchronization signal
										timings, addressing for the video buffer, cursor and underline timings.
										We will go into more detail later when we cover the VGA hardware.
									</p>

								<h3>Sequencer</h3>
									<p>
										The Sequencer generates basic memory timings for video memory and the character
										clock for controlling regenerative buffer fetches.
										It allows the system to access memory during active display intervals.
										Once more, we will not cover this in detail yet.
									</p>

								<h3>Graphics Controller</h3>
									<p>
                     This is the interface between video memory and the <b>attribute controller</b>, and between video memory and the CPU. During active display times, memory data is sent from the video buffer (Video Memory) and sent to the Attribute Controller. In Graphics Modes, this data is converted from parallel to a serial bit plane data before being sent. In text modes, Just the parallel data is sent.
	                </p>
                  <p>
                      Don't worry if you do not understand these yet. I do not plan on going into much detail here. We will cover everything in detail later when we talk about developing a video driver. For now, just remember that: The Graphics Controller refreshes the display from the parallel data from video memory. This is automatic based on the active display times. This simply means, that By writing to video memory (Default mapped to 0xA0000) we effectivly write to video display, depending on the current mode. This is important when printing characters.
	                </p>
                  <p>
                      Remember that it is possible to change the address range used by the Graphics Cotroller. When initializing, the BIOS does just this to map video memory to 0xA0000. 
	                </p>

	            <h2>Video Modes</h2>
	                <p>
                      A "Video Mode" is a specification of display. That is, it describes how Video Memory is refrenced, and how this data is displayed by the video adapter.
	                </p>
                  <p>
                    The VGA supports two types of modes: APA Graphics, and Text.
                  </p>
	              <h3>APA Graphics</h3>
	                 <p>
                     All Points Addressable (APA) is a display mode, that, on a video monitor, dot matrix, or any device that consists of a pixel array, where every cell can be refrenced individually. In the case of video display, where every cell represents a "pixel", where every pixel can be manipulated directly. Because of this, almost all graphic modes use this method. By modifying this pixel buffer, we effectivly modify individual pixels on screen.
	                 </p>
	                   <p><b>Pixel</b>
                    </p>
	                  <p>
                      A "Pixel" is the smallest unit that can be represented on a display. On a display, it represents the smallest unit of color. That is, basically, a single dot. The size of each pixel depends heavily on the current resolution and video mode.
      	            </p>
	              <h3>Text Modes</h3>
	                 <p>
                     A Text Mode is a display mode where the content on the screen is internally represented in terms of characters rather then pixels, as with APA.
	                </p>
	                <p>
                    A Video Controller implimenting text mode uses two buffers: A character map representing the pixels for each individual character to be displayed, and a buffer that represents what characters are in each cell. By changing the character map buffer, we effectivly change the characters themselves, allowing us to create a new character set. By changing the Screen Buffer, which represents what characters are in each cell, we effectivly change what characters are displayed on screen. Some text modes also allow attributes, which may provide a character color, or even blinking, underlined, inversed, brightened, etc. 
	                </p>

	            <h2>MDA, CGA, EGA</h2>
                  <p>
                    Remember that VGA is based off of MDA, CGA, and EGA. VGA also supports alot of the modes these adapters do. Understanding these modes will help in better understanding VGA.
                   </p>
            
	               <h3>MDA</h3>
	               <p>
                   Back before I was born (Seriously :) ) in 1981, IBM developed a standard video display card for the PC. They were the Monochrome Display Adapter (MDA), and Monochrome Display and Printer Adapter (MDPA).
	               </p>
                <p>
                  The MDA did not have any graphics mode of any kind. It only had a single text mode, (Mode 7) which could display 80 columns by 25 lines of high resolution text characters.
	              </p>
                <p>
                  This display adapter was a common standard used in older PC's.
                </p>
	            <h3>CGA</h3>
	              <p>
                  In 1981, IBM also developed the Color Graphics Adapter (CGA), coinsidered the first color display standard for PC's.
	              </p>
                <p>
                  The CGA only supported a Color Palette of 16 colors, because it was limited to 4 bytes per pixel.
                </p>
                 <p>
                   CGA supported two text modes and two graphics modes, including:
                 </p>
	               <ul>
	                  <li>40x25 characters (16 color) text mode</li>
	                  <li>18x25 characters (16 color) text mode</li>
	                  <li>320x200 pixels (4 colors) graphics modes</li>
	                  <li>640x200 pixels (Monochrome) graphics mode</li>
	               </ul>

	                <p>
                    It is possible to treak the display adapter in creating and discovering new, "undocumented" video modes. More on this later.
	               </p>
            
            <h3>EGA</h3>
	            <p>Introduced in 1984 by IBM, The Enhanced Graphics Adapter (EGA) produced a display of 16 colors at a resolution up to 640x350 pixels.

	            </p><p>Remember that the VGA adapters are backward compatible, simular to the 80x86 microprocessor family. Because of this, and to insure backward compatibility, the BIOS starts up in Mode 7 (Originally from the MDA), which supports 80 columns, by 25 lines. This is important to us, because this is the mode we are in! 
	            </p>

	            <h2>Video Memory</h2>

	            <h3>Memory Mapped I/O (MMIO)</h3>
	            <p>
	            If you know what Memory Mapped I/O is, you can skip this part.
	            </p>
	            <p>
	                <b>The processor can work with reading from RAM and ROM devices.</b> In applications programming,
	                this is something you never see. This is made possible with MMIO devices.
	                <b>Memory Mapped I/O allows a hardware device to map its own RAM or ROM into
	                your processors physical address space.</b> This allows the processor to be able to access hardware RAM or ROM in different
	                ways by just using a pointer to that location in the address space. This is made possible because
	                MMIO devices uses the same physical address and data bus that the processor and system memory uses.
	            </p>
	            <p>
	                It is important to remember, however, that Memory Mapped I/O is a mapping to the physical address space
	                of the processor, not actual computer memory. In some architectures, it is possible to <i>bank switch</i>,
	                or provide a method to switch between either using the MMIO device mapping or the system memory "hidden"
	                behind it, while on others it is not. What this means for us is that we cannot access the actual system
	                memory addresses that are "hidden" by the MMIO device. For example, CMOS RAM memory is mapped into
	                the physical address space at address 0x400. This is different then main system memory; accessing 0x400
	                with a pointer will access the CMOS RAM memory always do to MMIO. It is not possible to access this
	                location in system memory in the i86 architecture.
	            </p>
	            <p>
	                MMIO devices allows us to have more control over the hardware - it allows high resolution video
	                displays with limited system memory, it allows us to obtain information from a device that is
	                kept current by a battery (CMOS RAM) that would have altherwise been lost if in system memory.
	                Another example of an MMIO device is the system BIOS ROM itself. MMIO is what allows the processor
	                to execute the BIOS from ROM as it is mapped to the systems physical address space. Cool, huh?
	            </p>
	            <p>
	                You might be wondering what this has to do with graphics. Video memory is RAM that is
	                mapped into the physical address space. Video memory is managed by the video display device
	                which uses MMIO to do this. <b>How MMIO memory is managed and worked with is up to the device</b>;
	                it is not always nice and linear. Different graphics modes require different ways that you
	                have to work with this memory, so understanding that it is an MMIO device is important.
	            </p>
	            <p>
	                <b>An interesting fact about MMIO address space regions is that, with paging they can
	                be mapped to any virtual address and accessed from that address.</b> This means you
	                can map, for example, video memory, to any virtual address you want and access video
	                memory using that virtual address. This, of course, has to do with the way pages are mapped
	                to frames in the physical address space.
	            </p>
	            <p>
	                <b>Also remember that MMIO memory is not in system memory</b>. Computer system memory does
	                not need to be greater then the size of the MMIO address that you are trying to access.
	                For example, if your system only has 2GB of system memory, you can still access the MMIO
	                device if it has RAM mapped to the physical address space at 0xFC000000 without error.
	            </p>


	            <p>
	            See this text right here? Thats right, me; I am in your computer... residing in <b>Video RAM (VRAM).</b> VRAM
	            is Video Memory, also known as the <b>video framebuffer</b>. It containes all of the pixels that you see before
	            you, and more.
	            </p>

	            <h3>Standard VGA</h3>

	            <p>
	                Video memory is stored inside of the video device; usually a video card or onboard video adapter. Standard VGA
	                cards have 256 KB of VRAM. It is not uncommon however to see SVGA+ cards to have much more video memory however.
	                After all, they have to be able to store all of the pixels in the high resolution video modes somehow, right?
	            </p>
	            <p>
	                Remember the memory map from <a href="OSDev7.html">chapter 7</a>? We can see the Standard VGA memory resides in
	                <b>0x000A0000 - 0x000BFFFF</b>. 0xBFFFF - 0xA0000 = 0xA0000, which is 655360 bytes,
	                or 640 KB.
	            </p>
	                <p>
	                    It is important to remember that video memory is mapped in the PCs address space at this location. What this
	                    means is by writing here, you are writing to video memory that is located in the video adapter. This is a form
	                    of <b>Memory Mapped I/O</b>.
	            </p>
	            <p>
	                When accessing video memory, you typically access it using a "window" into the real video RAM. This is typically:
	                </p>
	            <ul>
		            <li>0xA0000 - EGA/VGA graphics modes (64 KB)</li>
		            <li>0xB0000 - Monochrome text mode (32 KB)</li>
		            <li>0xB8000 - Color text mode and CGA (32 KB)</li>
	            </ul>
	            <p>
		                Because different modes uses different address mappings, it is possible to combine
		                a monochome display adapter and color adapter on the same machine. This allows a
		                computer with a dual monitor setup to be able to run without issues. Of course,
		                this is just standard VGA.
	            </p>
	            <h3>Super VGA</h3>
	            <p>
		            Super VGA and other display adapters typically do things differently. It is not uncommon
		            to see a Super VGA or higher resolution display adapter to have VRAM mapped to a high
		            address range. While they will usually support the Standard VGA memory mapped range,
		            they can use other memory ranges as well to help with high resolution video modes or
		            to provide additional functionality. For example, my NVideo GeForce 7600 GT has 4 memory
		            ranges that it can use: 0xA0000 - 0x000BFFFFF (Look familier?), 0xFC000000 - 0xFCFFFFFF,
		            0xD0000000 - 0xDFFFFFFF, and 0xFD000000 - 0xFDFFFFFF. This can be different on your system.
	            </p>

	            <h3>Linear Frame Buffer (LFB)</h3>
	            <p>
	                If it is possible to map the entire video memory of the current display into the physical address space,
	                it is possible to set it up to act like a linear frame buffer. A linear frame buffer is just a packed-pixel
	                frame buffer that allows you to be able to read or write to it in linear fashion. For example, buffer[0]
	                is the first element of the buffer, buffer[1] is the second - there is nothing special. Well, actually
	                there is. Standard VGA does not support LFB modes. Remember Mode 0x13 above? That is the only Standard VGA
	                video mode that creates the effect of a linear frame buffer.
	             </p>
	             <p>
	                This might be a little confusing. After all, how "else" can you read or write to video memory if its not
	                in linear fashion? This has to do with Standard VGA being a <b>planer</b> device. We will talk about that after
	                the next section,
	             </p>

	            <h3>Bank Switching</h3>
	            <p>
		            Super VGA and higher resolution video modes can also provide a way of using a "window" into
		            the full video memory that is on the adapter. For example, notice above that, for graphics modes,
		            we are limited to a 64KB region between <b>0xA0000 - 0xB0000</b>. If this was a "window", and we
		            can "move" this 64K window around, we can access a much larger video memory area. For example:
	            </p>
	            <p class="center">
                <img src="images/bankSwitch.png" alt=""></img>
              </p>
	            <p>
	                  This is known as <b>Bank Switching</b>. A "Bank" is a window into the larger video memory. The size of
	                  the window is typically 64K do to standard VGA only having a graphics region of 64K.
	            </p>

	            <h3>Planer Memory</h3>
	            <p>
	                Okay, it gets a little tricky here. Standard VGA modes operate in planer memory mode. This is the VGAs
	                native memory model.
	            </p>
	            <p class="center">
                <img src="images/planer.png" alt=""></img>
              </p>
	            <p>
	                The above is an example of Mode 12h's planer memory format. Mode 12h has 4 bits per pixel. To draw a pixel,
	                you have to set or unset the bit in the plane. To better understand this, imagine you have a 64k block
	                of video memory. Imagine it as a flat sheet of paper and put three more behind it. Each sheet of paper
	                is a 64k "plane" that shares this same 64k area of memory. Each plane holds a little bit of information
	                about the pixel that it is used for.
	            </p>
	            <p>
	                Dont worry to much about understanding planer memory and how it works, we wont be needing it in
	                this chapter. It will be important when we cover VGA and Mode 12h in more detail however. Because
	                we are using Mode 0x13, which hides the details of working with planer memory, we wont need it now.
	            </p>

	            <h3>Odd / Even Memory Addressing</h3>
	            <p>
	                Odd / Even Memory Addressing uses the Planer Memory model and <b>is used in all text modes</b>. All even
	                addresses work with planes 0 or 2 and odd addresses work with planes 1 or 3. For example:
	            </p>

            <div class="code"><blockquote><pre>Memory Address | Plane   | Offset in plane
----------------------------------------
 0              | Plane 0 | Offset 0
 1              | Plane 1 | Offset 0
 2              | Plane 0 | Offset 2
 3              | Plane 1 | Offset 2</pre></blockquote></div>
	            <p>
	            Remember what it is like writing to video memory in text modes?</p>

            <div class="code"><blockquote><pre>unsigned char* vmem = 0xb8000;
	            vmem [0] = 'a'; // plane 0 [character plane] offset 0
	            vmem [1] = 0x7; // plane 1 [attribute plane] offset 0
	            vmem [2] = 'b'; // plane 0 [character plane] offset 2
	            vmem [3] = 0x7; // plane 1 [attribute plane] offset 2</pre></blockquote></div>

            <p>


	            </p>
	            <p>
	                <b>In text modes, plane 0 is used to store character codes and plane 1 stores the attribute bytes. Plane 2
	                stores the font data.</b> If you overwrite plane 2 when writing to video memory, you will overwrite the font
	                installed at boot time by the BIOS. This means that, <b>if you write over plane 2 in graphics mode, and go back
	                to text mode, the BIOS text output routines will not work as expected as the font data is corrupt.</b>
	            </p>
	            <p>
	                If you would like to go back to text mode, you will either need to store your own font or backup the default font
	                and write it back to plane 2 before using any text output routines again.
	            </p>
	            <p>
	                Because we are not using the planer memory model in this chapter, we wont be using the Odd/Even addressing model
	                in this chapter.
	            </p>
	            <h2>Color Palette</h2>
	            <p>
	                A <b>Palette</b> is like a look-up table. A <b>Color Palette</b> is a look-up table for colors. For example,
	                we can store a list of the actual color information in a table. We can then use another table of <b>indices</b>
	                into that table:
	            </p>
            <div class="code">
              <blockquote>
                <pre>
                  Index Table | Color Palette
            ---------------------------------------
                 0      | red(0), green(0), blue(0)
                 1      | red(0), green(0), blue(1)
                 2      | red(0), green(1), blue(0)
            ...
          </pre>
              </blockquote>
            </div>

	            <p>
	                In the above example, we can reference whatever color we want by just using the index. That saves storage
	                space greatly because after the look up table (The color palette) is created, any time that we want to
	                refer to a color we just use the index.
	            </p>
	            <p>
	                For example, in a video mode that uses a color palette, video memory acts as the index buffer. So, to
	                draw a pixel using the palette that we created above, just write the <b>index</b> of the color that you
	                would like to use:
	            </p>

            <div class="code"><blockquote><pre>unsigned char* p = 0xa0000;
            p[0] = 0; // black pixel
            p[1] = 1; // blue pixel
            p[2] = 2; // green pixel</pre></blockquote></div>
	            <p>
	                In the VGA, the Color Palette is handled by the hardware. We can control and change the colors in
	                the palette however way we want. However, because working with the palette requires VGA hardware programming,
	                we will not cover it too much here. Dont worry, we will cover it when we get into VGA hardware.
	            </p>
	            <h3>Palette Animation</h3>
	            <p>
	                Okay, lets take a step back for a moment. Look at the above example again. Notice that the video display
	                will determin what the color is of a pixel by an index. What if, lets say, that the index 1 in the color
	                palette (Like in the above example) changes to a different color? Looking at the above example,
	                index 1 in the color palette is a bright blue color. So, if we are in a palette video mode, any time
	                we write a "1" to someplace in video memory, it will be that bright blue color. This means a simple
	                <b>memset (vidmem, 1, VIDMEM_SIZE)</b> will effectively clear video display to this color. Cool, huh?
	            </p>
	            <p>
	                Knowing that the video display determins what color to display for an index is inside of the Color Palette
	                table, we can change what the color is for any palette entry. This allows us to change the colors on screen
	                by just updating the colors in the palette in some way. This is known as <b>Palette Animation</b>.
	            </p>
	            <p>
	                Palette Animation can create alot of really nice looking and cool effects, such as fire animation, icy effects,
	                etc.
	            </p>

	            <h1>Mode 0x13</h1>

	            <h2>Abstract</h2>
	            <p>
	                Video Mode 0x13 is a standard IBM VGA BIOS mode number for a 256 color 320x200 resolution. It uses a 256 <b>color palette</b>,
	                did not have square <b>pixels</b>, and allowed access to the <b>Video Memory</b> as a <b>Packed-Pixel Framebuffer</b>. What this
	                means is that it allowed access to video memory as if it was a linear buffer: Just get a pointer to video memory. pointer[0] = pixel 1,
	                pointer[1] = pixel 2, and so on, assuming <i>pointer</i> is an <i>unsigned char*</i>. This is made possible by specific hardware register
	                settings (The video mode "configuation") - Standard VGA does not, by itself, provide access to video memory like this.
	            </p>
	            <p>
	                The important thing here is that video modes define the resolution, how video memory is accessed, and hardware configuation setup
	                for the operation of that mode. Do not worry if you do not understand everything here; we will go into detail when we cover the
	                VGA hardware in a later chapter.
	            </p>
	            <p>
	                Because video Mode 0x13 is easy to work with (and fast) I decided to use it for the duration of this chapter.
	                Some other modes require experience with the VGA hardware which I am wanting to avoid in this chapter do
	                to its complexity. Dont worry though, I plan on covering some (Like Mode 12h, 640x480x4 color) later on.
	            </p>

	            <p>
	                Video Mode 0x13 was used alot in the DOS era for video games do to its simplicity to program and speed.
	                It is a video configuation for a 320 width, 200 height pixel resolution with a 256 color palette. It
	                is a planer video memory mode but acts as a <b>Linear Frame Buffer (LFB)</b> which makes it easy to
	                program.
	            </p>

	            <h2>Color Palette</h2>
	            <p>
	                Mode 0x13 has a color palette of 256 colors. Video memory in Mode 0x13 only stores the palette
	                index; the video device will determin what color to render from the installed palette color
	                table. By default, the color table is this:
	            </p>
	                <p class="center">
                    <img src="images/mode13h.png" alt=""></img><br /><i>Mode 13h Color Palette</i>
                  </p>
	            <p>
	                Here is an example, lookint at the above we can see the first color (0) is black, color 1 is blue,
	                color 2 is green, etc. We can write these colors to video display by using these indices in the
	                above lookup table:
	            </p>

            <div class="code"><blockquote><pre>unsigned char* p = 0xa0000;

            *p = 0; //black pixel
            *(p++) = 1; // blue pixel
            *(p++) = 4; // red pixel
            *(p++) = 255; //white pixel</pre></blockquote></div>
	            Compare the above code to the table above and notice how the indices match with the colors
	            in the palette.

	            <h3>Changing the palette</h3>

	                It is possible to change the palette to whatever colors that you would like. However there is
	                not any easy BIOS interrupt for it (Not without using VBE anyways.) Most of the interrupt calls
	                are used to set or get individual or all palette registers which are inside of the VGA <b>Digital to Analog Converter (DAC)</b>.
	                This requires some knowledge of the VGA hardware which I am wanting to avoid this chapter for simplicity (Dont worry,
	                I am planning on covering that soon!) Because of this, I decided to wait on covering palette changing
	                (And mabye palette animations) in a future chapter.

	            <h1>The Video BIOS Interface</h1>

	                The VGA Video BIOS Interface is a set of video interrupts (Software interrupt 0x10).
	                Because these are BIOS interrupts, they can only be used in real or v86 modes.

	            <h2>Setting the video mode</h2>

	            <h3>INT 0x10 Function 0</h3>

	            <p>You can set the video mode by calling BIOS interrupt 0x10 function 0:</p>

	            <ul>
                <li>
                  Input
                  <ul>
                    <li>AH = 0</li>
                    <li>AL = video mode</li>
                  </ul>
                </li>
                <li>
                  Output
                  <ul>
                    <li>AL = video mode flag (Phoenix, AMI BIOS)</li>
                    <li>AL = CRT Controller (CRTC) mode byte (Phoenix 386 BIOS v1.10)</li>
                  </ul>
                </li>
	            </ul>

	            <p>
	                You will see the CRTC alot more in the future as it is one of the controllers that you
	                will need to program if you plan to directly program the video hardware.
             </p>

               <p>
                This interrupt can set any text or video mode. For example, the following switches to
                320x200x8 bit [mode 0x13]: (<b>
                  Please remember that all code samples can be
                  found in the demo.
              </b>
	            </p><div class="code"><blockquote><pre>
            mode13h:
	            mov ah, 0
	            mov al, 0x13
	            int 0x10
	            ret</pre></blockquote></div><p>Easy, huh?</p>
            <p>
                  The above is all that is needed to get you in a graphics mode. Sure, it will only work in real
                or v86 mode, but it is as easy as you can get. Dont worry if you do not understand video modes yet;
                we will cover them a little later.
             </p>

	            <h2>Getting the video mode</h2>

	            <h3>INT 0x10 Function 0xF</h3>

	            <p>
                You can get the video mode by calling BIOS interrupt 0x10 function 0xF:
              </p>

	            <ul>
                <li>
                  Input
                  <ul>
                    <li>AH = 0xF</li>
                  </ul>
                </li>
                <li>
                  Output
                  <ul>
                    <li>AH = number of character columns</li>
                    <li>AL = display mode number</li>
                    <li>BH = active page</li>
                  </ul>
                </li>
	            </ul>

            <p>
                  This interrupt is an easy one and can be used to obtain the current video or text mode. Dont worry
	                about the "active page" part yet. Dont worry if you do not understand video modes yet;
                   we will cover them a little later.
            </p>
            <div class="code"><blockquote><pre>
            getMode:
	            mov ah, 0xf
	            int 0x10
	            ret</pre></blockquote></div>

	            <h2>Other Video BIOS Interrupts</h2>

	            <h3>INT 0x10 Function 0xB/BH=1</h3>

	            <p>You can set the palette by calling Video BIOS INT 0x10 function 0xB:</p>

	            <ul>
                <li>
                  Input
                  <ul>
                    <li>AH = 0xB</li>
                    <li>BH = 1</li>
                    <li>
                      BL = Palette ID
                      <ul>
                        <li>00h background, green, red, and brown/yellow</li>
                        <li>01h background, cyan, magenta, and white</li>
                      </ul>
                    </li>
                  </ul>
                </li>
	            </ul>

	            This interrupt may not be supported on all systems.

	            <h3>INT 0x10 Function 0xC</h3>

	            <p>
                You can write a pixel to the display using this interrupt.
              </p>

	            <ul>
                <li>
                  Input
                  <ul>
                    <li>AH = 0xC</li>
                    <li>BH = Page number</li>
                    <li>
                      AL = Pixel color
                      <ul>
                        <li>
                          if bit 7 set, value is XOR'ed onto screen except in 256-color modes
                        </li>
                      </ul>
                    </li>
                    <li>CX = column</li>
                    <li>DX = row</li>
                  </ul>
                </li>
                <li>
                  Output
                  <ul>
                    <li>AL = pixel color</li>
                  </ul>
                </li>
	            </ul>

	            This interrupt can only be used in graphics modes.

	            <h3>INT 0x10 Function 0xD</h3>

	            <p>You can read the pixel by calling Video BIOS INT 0x10 function 0xB:</p>

	            <ul>
                <li>
                  Input
                  <ul>
                    <li>AH = 0xC</li>
                    <li>BH = Page number</li>
                    <li>CX = column</li>
                    <li>DX = row</li>
                  </ul>
                </li>
	            </ul>

	            This interrupt will only work on graphics modes.

	            <h1>Primitives</h1>

	            <h2>Plotting your first pixel</h2>

               <i>"The secret to making any video game is the ability to change the color of a pixel."</i> - Teej

	            <p>
	                We have covered alot in this chapter and have yet to draw a pixel on screen. Whats up with that?
	                I decided to close this chapter with the basics of most basic graphics primitives - rendering a pixel
	                to the screen.
	            </p>
	            <p>
	                Because we are working in Mode 0x13, remember that it acts like a linear frame buffer. So vidmem[0] is the
	                first byte of video memory, vidmem[1] is the second byte. Also, remember that Mode 0x13 uses a byte for
	                each pixel as an index into the Color Palette. This means that, we can write a pixel easy like this:
	             </p>
            <div class="code"><blockquote><pre>unsigned char* p = 0xa0000;
            p[0] = 1; // blue pixel</pre></blockquote></div>
	            <p>
	                Cool, huh? Thats all that is needed and you have a pixel!
	            </p>
	            <p>
	                It is easier to think in terms of the <b>cartesian coordinate system</b>. In this system, we use
	                coordinates, such as X and Y to represent its location on a 2d graph like this:
	            </p>
	                <p class="center">
                    <img src="images/vmem.png" alt=""></img>
                  </p>
	            <p>
	                The top-left corner of video memory is at <b>v = [0,0]</b> where <b>v</b> is a 2d vector. This is the first
	                pixel in video display. The last byte is at <b>v = [width, height]</b>. Assuming each coordinate is a pixel,
	                we can come up with a formula that allows us to be able to draw a pixel at any location on screen.
	            </p>
	            <p>
	                Lets say we start at <b>v = [0,0]</b> in the graph above. If we add <b>width</b> to our position, we
	                always end up right below where we were. For example, in the above graph, <b>width = 16</b>. Assuming
	                we started at the top-left corner, counting 16 to the right, you will find yourself right below (on
	                the next line) from where you started. Because of this, we can calculate <b>y</b> by doing <b>y * width</b>.
	                Afterwords we can just add <b>x</b> (The offset in that line) and we have our formula:
	            </p>
    	            <p class="center">
                    <img src="images/pixel.png" alt=""></img>
                  </p>
	            <p>
	                To render a pixel at any <b>[x,y]</b> location, we use the formula <b>x + y * width</b>. With this,
	                we can create a simple routine like this:
	            </p>

            <div class="code"><blockquote><pre>
            ;-----------------------;
            ;	renders pixel
            ;	cl = color ax = y bx = x
            ;	es:bp = buffer
            ;-----------------------;
            pixel:
            ; [x + y * width] = col

	            pusha
	            mov di, VGA_MODE13_WIDTH
	            mul di ; ax = y * width
	            add ax, bx ; add x
	            mov di, ax
	            mov byte [es:bp + di], cl ; plot pixel
	            popa
	            ret</pre></blockquote></div>

	            <p>
	                es:bp points to the video display, or another buffer that we want to render to. cl is the color
	                index that you want to use, ax is the Y location and bx is the X location.
	            </p>

            <h2>Clearing the screen</h2>

	            <p>
	                There are several ways of clearing the screen. This is important as alot of times when switching
	                video modes, you may see alot of garbage on screen.
	            </p>
	            <p>
	                One method that we can do is just call our pixel routine above <b>width * height</b> times. A better method
	                would be to write multiple pixels at once. Knowing, for example, that the size of a pixel in Mode 13h is
	                a byte, we can easily store 2 bytes (2 pixels) in a word size register and use that instead:
	            </p>

            <div class="code"><blockquote><pre>
            ;---------------------------;
            ;	clear screen
            ;	cl = color
            ;---------------------------;
            clrscr:

	            pusha
		            mov dl, cl	; dx = 2 pixels
		            mov dh, cl

		            mov cx, 0
		            xor di, di

	            .l:
		            mov word [es:bp + di], dx ; plot 2 pixels
		            inc di ; go forward 2 bytes
		            inc di
		            inc cx
		            cmp cx, (VGA_MODE13_WIDTH * VGA_MODE13_HEIGHT) / 2 ;end of display?
		            jl .l

	            popa
	            ret</pre></blockquote></div>
            <p>
	            es:bp refers to either video memory or another buffer and cl is the color that you would like to use.
            </p>


	            <h1>Demo</h1>

	            <p class="center">
                <img src="images/mode13hDem.png" alt=""></img><br /><i>Mode 13h Demo running in real mode</i><br /><a href="Demos/DemoGfx1.zip">Demo Download</a></p>

	            <p>
	                This demo spices what we talked about a little by adding an additional routines: <b>line</b>, which renders
	                a horizontal line, and is used to render the rectangles in the demo.
	            </p>


						<h1>Conclusion</h1>

						<p>That's all for this chapter!</p>
	
						<p>
							The next chapter will cover VESA VBE and how we can use it to work with high resolution
							graphics modes. We will also cover the Super VGA, Bank Switching, and a few more 
							graphics concepts including <b>Double and Triple Buffering, </b> and 
							<b>Page Flipping</b>. Thats right, we are going high resolution with VBE :)
						</p>
						<p>
							We will also be going back to C in the next chapter and cover some more graphics
							primitives. I still plan on covering VGA hardware however that will be after VBE. VGA
							hardware is quite overcomplicated; I want to hold off on the more complex topics in
							graphics and VGA until a little later.
						</p>
	<p>
	Until next time,
	<p>
	~Mike<br>
	<i>BrokenThorn Entertainment. Currently developing DoE and the <a href="http://www.brokenthorn.com/mos/site2/">Neptune Operating System</a></i>

	<br><br>
	<i>Questions or comments? Feel free to <a href="mailto:neon6000@aol.com">Contact me</a>.</i>

	<br><br>
	Would you like to contribute and help improve the articles? If so, please <a href="mailto:neon6000@aol.com">let me know!</a>

						<br />
						<br />
						<table border="0" width="100%">
							<tbody>	
								<tr>
									<td>
										<p class="center">
											<span class="special">
												<a class="anchor" 
													href="http://www.brokenthorn.com/Resources/OSDevIndex.html">
													Home
												</a>
											</span>
										</p>
									</td>
								</tr>
							</tbody>
						</table>
					</td>
				</tr>
			</tbody>
		</table>

		<p>
			<a href="http://validator.w3.org/check?uri=referer">
				<img
					src="http://www.w3.org/Icons/valid-xhtml10-blue"
					alt="Valid XHTML 1.0 Strict" height="31" width="88" 
				/>
			</a>
		</p>

	</body>
</html>
