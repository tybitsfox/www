<HTML
><HEAD
>

<TITLE
>日期/时间类型 PostgreSQL 手册</TITLE
><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.64 "><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 8.1 中文文档（PostgreSQL 中国 制作）" HREF="index.html"><LINK REL="UP" TITLE="数据类型" HREF="datatype.html"><LINK REL="PREVIOUS" TITLE="二进制数据类型" HREF="datatype-binary.html"><LINK REL="NEXT" TITLE="布尔类型" HREF="datatype-boolean.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312"><META NAME="creation" CONTENT="2006-01-03T05:00:21"></HEAD
><BODY CLASS="SECT1" ><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR ><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 8.1 中文文档</TH
></TR
><TR ><TD WIDTH="10%" ALIGN="left" VALIGN="top" ><A HREF="datatype-binary.html" >Prev</A
></TD
><TD WIDTH="10%" ALIGN="left" VALIGN="top" ><A HREF="datatype.html" >Fast Backward</A
></TD
><TD WIDTH="60%" ALIGN="center" VALIGN="bottom" >Chapter 8. 数据类型</TD
><TD WIDTH="10%" ALIGN="right" VALIGN="top" ><A HREF="datatype.html" >Fast Forward</A
></TD
><TD WIDTH="10%" ALIGN="right" VALIGN="top" ><A HREF="datatype-boolean.html" >Next</A
></TD
></TR
></TABLE
><HR size="1" 
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A NAME="DATATYPE-DATETIME" >8.5. 日期/时间类型</A
></H1
><A NAME="AEN4416" ></A
><A NAME="AEN4418" ></A
><A NAME="AEN4420" ></A
><A NAME="AEN4422" ></A
><A NAME="AEN4424" ></A
><A NAME="AEN4426" ></A
><A NAME="AEN4428" ></A
><A NAME="AEN4430" ></A
><A NAME="AEN4432" ></A
><P
>    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 支持 <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> 中所有的日期和时间类型。
	在 <A HREF="datatype-datetime.html#DATATYPE-DATETIME-TABLE" >Table 8-9</A
> 中显示。
	这些数据类型上可以进行的操作在 <A HREF="functions-datetime.html" >Section 9.9</A
> 描述。
   </P
><P
>    <DIV
CLASS="TABLE"
><A NAME="DATATYPE-DATETIME-TABLE" ></A
><P
><B
>Table 8-9. 日期/时间类型</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>名字</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>存储空间</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>最低值</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>最高值</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>分辨率</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>timestamp [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] [without time zone]</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >8 字节</TD
><TD ALIGN="LEFT" VALIGN="TOP" >包括日期和时间</TD
><TD ALIGN="LEFT" VALIGN="TOP" >4713 BC</TD
><TD ALIGN="LEFT" VALIGN="TOP" >5874897 AD</TD
><TD ALIGN="LEFT" VALIGN="TOP" >1 毫秒 / 14 位</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>timestamp [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] with time zone</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >8 字节</TD
><TD ALIGN="LEFT" VALIGN="TOP" >日期和时间，带时区</TD
><TD ALIGN="LEFT" VALIGN="TOP" >4713 BC</TD
><TD ALIGN="LEFT" VALIGN="TOP" >5874897 AD</TD
><TD ALIGN="LEFT" VALIGN="TOP" >1 毫秒 / 14 位</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>interval [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ]</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >12 字节</TD
><TD ALIGN="LEFT" VALIGN="TOP" >时间间隔</TD
><TD ALIGN="LEFT" VALIGN="TOP" >-178000000 年</TD
><TD ALIGN="LEFT" VALIGN="TOP" >178000000 年</TD
><TD ALIGN="LEFT" VALIGN="TOP" >1 毫秒 / 14 位</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>date</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >4 字节</TD
><TD ALIGN="LEFT" VALIGN="TOP" >只用于日期</TD
><TD ALIGN="LEFT" VALIGN="TOP" >4713 BC</TD
><TD ALIGN="LEFT" VALIGN="TOP" >32767 AD</TD
><TD ALIGN="LEFT" VALIGN="TOP" >1 天</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>time [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] [ without time zone ]</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >8 字节</TD
><TD ALIGN="LEFT" VALIGN="TOP" >只用于一日内时间</TD
><TD ALIGN="LEFT" VALIGN="TOP" >00:00:00</TD
><TD ALIGN="LEFT" VALIGN="TOP" >24:00:00</TD
><TD ALIGN="LEFT" VALIGN="TOP" >1 毫秒 / 14 位</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>time [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] with time zone</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >只用于一日内时间，带时区</TD
><TD ALIGN="LEFT" VALIGN="TOP" >12 字节</TD
><TD ALIGN="LEFT" VALIGN="TOP" >00:00:00+1359</TD
><TD ALIGN="LEFT" VALIGN="TOP" >24:00:00-1359</TD
><TD ALIGN="LEFT" VALIGN="TOP" >1 毫秒 / 14 位</TD
></TR
></TBODY
></TABLE
></DIV
>
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>	在 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.3 以前，只写
	<TT
CLASS="TYPE"
>timestamp</TT
> 等效于 <TT
CLASS="TYPE"
>timestamp with time zone</TT
>。
	这样是为了和 SQL 兼容。
    </P
></BLOCKQUOTE
></DIV
><P
>	<TT
CLASS="TYPE"
>time</TT
> ，<TT
CLASS="TYPE"
>timestamp</TT
> 和<TT
CLASS="TYPE"
>interval</TT
>
	接受一个可选的精度值 <TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>，这个精度值声明在秒域后面小数点之后保留的位数。
	缺省的时候在精度上是没有明确的绑定的，
	<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
> 有用的范围对 <TT
CLASS="TYPE"
>timestamp</TT
>和 <TT
CLASS="TYPE"
>interval</TT
> 是从 0 到大约 6。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>	如果 <TT
CLASS="TYPE"
>timestamp</TT
> 数值是以双精度浮点数（目前的缺省）的方式存储的，
	那么精度的有效限制会小于 6。 timestamp 值是以 2000-01-01 午夜之前或之后以来的秒数存储的，而微秒的精度是为那些在 2000-01-01 前后几年的日期实现的，
	对于那些远一些的日子，精度会下降。如果 timestamp 以八字节整数存储（一个编译时的选项），那么微秒的精度就可以在数值的全部范围内都可以获得。
	不过，八位整数的时间戳的日期范围缩小到 4713 BC 到  294276 AD。
	同一个编译时选项也决定 <TT
CLASS="TYPE"
>time</TT
> 和 <TT
CLASS="TYPE"
>interval</TT
> 值是保存成浮点数还是八字节整数。
	在以浮点数存储的时候，随着时间间隔的大小增加，大的 <TT
CLASS="TYPE"
>interval</TT
> 数值的精度会降低。
   </P
></BLOCKQUOTE
></DIV
><P
>	对于 <TT
CLASS="TYPE"
>time</TT
> 类型，如果使用了八字节的整数存储，那么
	<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
> 允许的范围是从 0 到 6，如果使用的是浮点数存储，那么这个范围是 0 到 10。
   </P
><P
>	类型<TT
CLASS="TYPE"
>time with time zone</TT
>是 SQL 标准定义的，
	但是整个定义有些方面会导致有问题的用法。在大多数情况下，
	<TT
CLASS="TYPE"
>date</TT
>，<TT
CLASS="TYPE"
>time</TT
>，<TT
CLASS="TYPE"
>timestamp without time zone</TT
>
	和 <TT
CLASS="TYPE"
>timestamp with time zone</TT
> 的组合就应该能提供提供任何应用需要的日期/时间的完整功能。
   </P
><P
>	类型 <TT
CLASS="TYPE"
>abstime</TT
>
	和 <TT
CLASS="TYPE"
>reltime</TT
> 是低分辨率类型，它们被用于系统内部。
	我们不鼓励你在新的应用里面使用这些类型，同时我们支持合适的时候把旧应用中对应的类型转换成目前上面指明的。
	因为这些旧类型的部分或全部可能会在未来的版本里消失。
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A NAME="DATATYPE-DATETIME-INPUT" >8.5.1. 日期/时间输入</A
></H2
><P
>	日期和时间的输入几乎可以是任何合理的格式，包括
	<SPAN
CLASS="ACRONYM"
>ISO 8601</SPAN
>，<SPAN
CLASS="ACRONYM"
>SQL</SPAN
>-兼容的，
	传统 <SPAN
CLASS="PRODUCTNAME"
>POSTGRES</SPAN
> 的和其他的形式。
	对于一些格式，日期输入里的月份和日子输入可能会让人模糊，
	因此系统支持声明自己预期的这些字段的顺序。
	把 <A HREF="runtime-config-client.html#GUC-DATESTYLE" >DateStyle</A
> 参数设置为 <TT
CLASS="LITERAL"
>MDY</TT
>，
	就是“月－日－年”的解析，设置为 <TT
CLASS="LITERAL"
>DMY</TT
> 就是
	“日－月－年”，而 <TT
CLASS="LITERAL"
>YMD</TT
> 是 “年－月－日”。
    </P
><P
>	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 在处理日期/时间输入上比
	<SPAN
CLASS="ACRONYM"
>SQL</SPAN
> 标准要求的更灵活。
	参阅 <A HREF="datetime-appendix.html" >Appendix B</A
>
	获取关于日期/时间输入的准确的分析规则和可识别文本字段，包括月份，星期几，和时区。
    </P
><P
>	请记住任何日期或者时间的文本输入需要由单引号包围，
	就象一个文本字符串一样。
	参考 <A HREF="sql-syntax.html#SQL-SYNTAX-CONSTANTS-GENERIC" >Section 4.1.2.5</A
>
	获取更多信息。<SPAN
CLASS="ACRONYM"
>SQL</SPAN
> 要求下面的语法
</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] '<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>'</PRE
><P>
	在这里可选的精度声明中的 <TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
> 是一个整数，
	对应在秒域中小数部分的位数，
	我们可以对 <TT
CLASS="TYPE"
>time</TT
>，
	<TT
CLASS="TYPE"
>timestamp</TT
>，和 <TT
CLASS="TYPE"
>interval</TT
> 类型声明精度。
	允许的精度在上面已经说明。如果在常量声明中没有声明精度，缺省是文本值的精度。
    </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A NAME="AEN4563" >8.5.1.1. 日期</A
></H3
><A NAME="AEN4565" ></A
><P
>     <A HREF="datatype-datetime.html#DATATYPE-DATETIME-DATE-TABLE" >Table 8-10</A
> 显示了 <TT
CLASS="TYPE"
>date</TT
> 类型可能的输入方式。
    </P
><DIV
CLASS="TABLE"
><A NAME="DATATYPE-DATETIME-DATE-TABLE" ></A
><P
><B
>Table 8-10. 日期输入</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>例子</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >January 8, 1999</TD
><TD ALIGN="LEFT" VALIGN="TOP" >在任何<TT
CLASS="VARNAME"
>datestyle</TT
>输入模式下都无歧义</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >1999-01-08</TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO-8601 格式，任何方式下都是1999年1月8号，（建议格式）</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >1/8/1999</TD
><TD ALIGN="LEFT" VALIGN="TOP" >歧义，在<TT
CLASS="LITERAL"
>MDY</TT
>下是一月八号；在 <TT
CLASS="LITERAL"
>DMY</TT
> 模式下读做八月一日</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >1/18/1999</TD
><TD ALIGN="LEFT" VALIGN="TOP" >在<TT
CLASS="LITERAL"
>MDY</TT
>模式下读做一月十八日，其它模式下被拒绝</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >01/02/03</TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>MDY</TT
> 模式下的2003年一月2日；
	 <TT
CLASS="LITERAL"
>DMY</TT
> 模式下的 2003 年 2月 1日；
	 <TT
CLASS="LITERAL"
>YMD</TT
> 模式下的2001年二月三日；
         </TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >1999-Jan-08</TD
><TD ALIGN="LEFT" VALIGN="TOP" >任何模式下都是一月8日</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >Jan-08-1999</TD
><TD ALIGN="LEFT" VALIGN="TOP" >任何模式下都是一月8日</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >08-Jan-1999</TD
><TD ALIGN="LEFT" VALIGN="TOP" >任何模式下都是一月8日</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >99-Jan-08</TD
><TD ALIGN="LEFT" VALIGN="TOP" >在 <TT
CLASS="LITERAL"
>YMD</TT
> 模式下是一月8日，否则错误</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >08-Jan-99</TD
><TD ALIGN="LEFT" VALIGN="TOP" >一月八日，除了在 <TT
CLASS="LITERAL"
>YMD</TT
> 模式下是错误的之外</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >Jan-08-99</TD
><TD ALIGN="LEFT" VALIGN="TOP" >一月八日，除了在 <TT
CLASS="LITERAL"
>YMD</TT
> 模式下是错误的之外</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >19990108</TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO-8601; 任何模式下都是1999年1月8日</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >990108</TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO-8601; 任何模式下都是1999年1月8日</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >1999.008</TD
><TD ALIGN="LEFT" VALIGN="TOP" >年和年里的第几天</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >J2451187</TD
><TD ALIGN="LEFT" VALIGN="TOP" >儒略日</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >January 8, 99 BC</TD
><TD ALIGN="LEFT" VALIGN="TOP" >公元前99年</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A NAME="AEN4637" >8.5.1.2. 时间</A
></H3
><A NAME="AEN4639" ></A
><A NAME="AEN4642" ></A
><A NAME="AEN4645" ></A
><P
>	当日时间类型是 <TT
CLASS="TYPE"
>time [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] without time zone</TT
>
	和 <TT
CLASS="TYPE"
>time [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] with time zone</TT
>。
	只写 <TT
CLASS="TYPE"
>time</TT
> 等效于 <TT
CLASS="TYPE"
>time without time zone</TT
>。
     </P
><P
>	这些类型的有效输入由当日时间后面跟着可选的时区组成。
	（参阅 <A HREF="datatype-datetime.html#DATATYPE-DATETIME-TIME-TABLE" >Table 8-11</A
>。）
	如果在 <TT
CLASS="TYPE"
>time without time zone</TT
> 类型的输入
	中声明了时区，那么它会被无声地忽略。
     </P
><DIV
CLASS="TABLE"
><A NAME="DATATYPE-DATETIME-TIME-TABLE" ></A
><P
><B
>Table 8-11. 时间输入</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>例子</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>04:05:06.789</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO 8601</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>04:05:06</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO 8601</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>04:05</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO 8601</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>040506</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO 8601</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>04:05 AM</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >与 04:05 一样；AM 不影响数值</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>04:05 PM</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >与 16:05一样；输入小时数必须 &lt;= 12</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >04:05:06.789-8</TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO 8601</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >04:05:06-08:00</TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO 8601</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >04:05-08:00</TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO 8601</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >040506-08</TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO 8601</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>04:05:06 PST</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >用名字声明的时区</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A NAME="DATATYPE-TIMEZONE-TABLE" ></A
><P
><B
>Table 8-12. 时区输入</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>例子</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>PST</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >太平洋标准时间（Pacific Standard Time）</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>-8:00</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO-8601 与 PST 的偏移</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>-800</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO-8601 与 PST 的偏移</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>-8</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO-8601 与 PST 的偏移</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>zulu</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >军方对 UTC 的缩写（译注：可能是美军）</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>z</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>zulu</TT
> 的缩写</TD
></TR
></TBODY
></TABLE
></DIV
><P
>     参考<A HREF="datetime-appendix.html" >Appendix B</A
> 获取可以识别的时区输入。
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A NAME="AEN4741" >8.5.1.3. 时间戳</A
></H3
><A NAME="AEN4743" ></A
><A NAME="AEN4746" ></A
><A NAME="AEN4749" ></A
><P
>	时间戳类型的有效输入由一个日期和时间的联接组成，后面跟着一个可选的时区，一个可选的 <TT
CLASS="LITERAL"
>AD</TT
>
	或者 <TT
CLASS="LITERAL"
>BC</TT
>。（另外，<TT
CLASS="LITERAL"
>AD</TT
>/<TT
CLASS="LITERAL"
>BC</TT
> 可以出现在时区前面，但这个顺序并非最佳的。）
	因此

</P><PRE
CLASS="PROGRAMLISTING"
>1999-01-08 04:05:06</PRE
><P>

	和

</P><PRE
CLASS="PROGRAMLISTING"
>1999-01-08 04:05:06 -8:00</PRE
><P>

	都是有效的数值，
	它是兼容 <SPAN
CLASS="ACRONYM"
>ISO</SPAN
> 8601 的。另外，下面这种使用广泛的格式

</P><PRE
CLASS="PROGRAMLISTING"
>January 8 04:05:06 1999 PST</PRE
><P>
	也受支持。
     </P
><P
>      <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> 标准通过 <SPAN
CLASS="QUOTE"
>"+"</SPAN
> 或者 <SPAN
CLASS="QUOTE"
>"-"</SPAN
> 是否存在来区分
      <TT
CLASS="TYPE"
>timestamp without time zone</TT
> 和 <TT
CLASS="TYPE"
>timestamp with time zone</TT
> 文本。
      因此，根据标准，</P><PRE
CLASS="PROGRAMLISTING"
>TIMESTAMP '2004-10-19 10:23:54'</PRE
><P>
      是一个 <TT
CLASS="TYPE"
>timestamp without time zone</TT
>，
      而 </P><PRE
CLASS="PROGRAMLISTING"
>TIMESTAMP '2004-10-19 10:23:54+02'</PRE
><P> 是一个 <TT
CLASS="TYPE"
>timestamp with time zone</TT
>。
      <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 从来不会在确定文本的类型之前检查文本内容，因此会把上面两个都看做是
      <TT
CLASS="TYPE"
>timestamp without time zone</TT
>。因此要保证把上面的当作 <TT
CLASS="TYPE"
>timestamp without time zone</TT
> 看待，
      就要给它明确的类型：
      </P><PRE
CLASS="PROGRAMLISTING"
>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</PRE
><P>。
      如果一个文本已被确定是 <TT
CLASS="TYPE"
>timestamp without time zone</TT
> ，
      <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 将不声不响忽略任何文本中指出的时区。
      因此，生成的日期/时间值是从输入值的日期/时间字段衍生出来的，并且没有就时区进行调整。
     </P
><P
>	对于 <TT
CLASS="TYPE"
>timestamp [without time zone]</TT
>，任何在输入中声明的时区都被悄悄吞掉。
	也就是说，生成的日期/时间数值是从输入中明确的日期/时间字段中得出的，并且没有根据时区调整。
     </P
><P
>	对于 <TT
CLASS="TYPE"
>timestamp with time zone</TT
>，内部存储的数值总是
	UTC （全球统一时间，以前也叫格林威治时间<SPAN
CLASS="ACRONYM"
>GMT</SPAN
>）。如果一个输入值有明确的时区声明，
	那么它将用该时区合适的偏移量转换成 UTC。如果在输入字串里没有时区声明，
	那么它就假设是在系统的 <A HREF="runtime-config-client.html#GUC-TIMEZONE" >timezone</A
> 参数里的那个时区，然后使用这个
	<TT
CLASS="VARNAME"
>timezone</TT
> 时区转换成 UTC。
     </P
><P
>	如果输出一个 <TT
CLASS="TYPE"
>timestamp with time zone</TT
>，那么它总是从 UTC
	转换成当前的 <TT
CLASS="VARNAME"
>timezone</TT
> 时区，并且显示为该时区的本地时间。
	要看其它时区的该时间，要么修改 <TT
CLASS="VARNAME"
>timezone</TT
>，要么使用 <TT
CLASS="LITERAL"
>AT TIME ZONE</TT
>
	构造（参阅 <A HREF="functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT" >Section 9.9.3</A
>）。
     </P
><P
>	在 <TT
CLASS="TYPE"
>timestamp without time zone</TT
> 和 <TT
CLASS="TYPE"
>timestamp with time zone</TT
>
	之间的转换通常假设 <TT
CLASS="TYPE"
>timestamp without time zone</TT
>
	数值应该以 <TT
CLASS="VARNAME"
>timezone</TT
> 本地时间的形式接受或者写出。
	其它的时区引用可以用 <TT
CLASS="LITERAL"
>AT TIME ZONE</TT
> 的方式为转换声明。
     </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A NAME="AEN4796" >8.5.1.4. 间隔</A
></H3
><A NAME="AEN4798" ></A
><P
>	<TT
CLASS="TYPE"
>interval</TT
>数值可以用下面语法声明：

</P><PRE
CLASS="PROGRAMLISTING"
>[<SPAN
CLASS="OPTIONAL"
>@</SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
> [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
>...</SPAN
>] [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>direction</I
></TT
></SPAN
>]</PRE
><P>

	这里：<TT
CLASS="LITERAL"
>quantity</TT
> 是一个数字（可能有符号）；
	<TT
CLASS="LITERAL"
>unit</TT
> 是 <TT
CLASS="LITERAL"
>second</TT
>,
	<TT
CLASS="LITERAL"
>minute</TT
>, <TT
CLASS="LITERAL"
>hour</TT
>, <TT
CLASS="LITERAL"
>day</TT
>,
	<TT
CLASS="LITERAL"
>week</TT
>, <TT
CLASS="LITERAL"
>month</TT
>, <TT
CLASS="LITERAL"
>year</TT
>,
	<TT
CLASS="LITERAL"
>decade</TT
>, <TT
CLASS="LITERAL"
>century</TT
>, <TT
CLASS="LITERAL"
>millennium</TT
>,
	或者这些单位的缩写或复数；
	<TT
CLASS="LITERAL"
>direction</TT
> 可以是 <TT
CLASS="LITERAL"
>ago</TT
>
	或者为空。符号 <TT
CLASS="LITERAL"
>@</TT
> 是一个可选的东西。不同的单位以及相应正确的符号都是隐含地增加的。
     </P
><P
>	日期，小时，分钟，以及秒钟的数量可以在无明确单位标记的情况下声明。
	比如，<TT
CLASS="LITERAL"
>'1 12:59:10'</TT
> 和 
	<TT
CLASS="LITERAL"
>'1 day 12 hours 59 min 10 sec'</TT
> 读数一样。
     </P
><P
>	可选的精度 <TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
> 应该介于 0 和 6 之间，
	并且缺省是输入文本的精度。
     </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A NAME="AEN4831" >8.5.1.5. 特殊值</A
></H3
><A NAME="AEN4833" ></A
><A NAME="AEN4836" ></A
><P
>	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 为方便起见支持几个特殊输入值，
	如在 <A HREF="datatype-datetime.html#DATATYPE-DATETIME-SPECIAL-TABLE" >Table 8-13</A
> 里面显示的那样。
	值<TT
CLASS="LITERAL"
>infinity</TT
> 和 <TT
CLASS="LITERAL"
>-infinity</TT
>
	是特别在系统内部表示的，并且将按照同样的方式显示；
	但是其它的都只是符号缩写，在读取的时候将被转换成普通的日期/时间值。
	（特别是，<TT
CLASS="LITERAL"
>now</TT
> 和相关的字串在读取的时候就被转换成对应的数值。）
	所有这些值在 SQL 命令里当作普通常量对待时，都需要写在单引号里面。
	</P
><DIV
CLASS="TABLE"
><A NAME="DATATYPE-DATETIME-SPECIAL-TABLE" ></A
><P
><B
>Table 8-13. 特殊日期/时间输入</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>输入字串</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>有效类型</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>epoch</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >1970-01-01 00:00:00+00 (Unix 系统零时)</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>infinity</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >比任何其它时间戳都晚</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>-infinity</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >比任何其它时间戳都早</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>now</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>time</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >当前事务时间</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>today</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >今日午夜</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>tomorrow</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >明日午夜</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>yesterday</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >昨日午夜</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>allballs</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>time</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >00:00:00.00 UTC</TD
></TR
></TBODY
></TABLE
></DIV
><P
>      下列 <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> 兼容函数也可以用于获取对应数据类型的当前时间值：
      <TT
CLASS="LITERAL"
>CURRENT_DATE</TT
>，<TT
CLASS="LITERAL"
>CURRENT_TIME</TT
>，
      <TT
CLASS="LITERAL"
>CURRENT_TIMESTAMP</TT
>，<TT
CLASS="LITERAL"
>LOCALTIME</TT
>，
      <TT
CLASS="LITERAL"
>LOCALTIMESTAMP</TT
>。最后四个接受一个可选的精度声明。
      （见 <A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT" >Section 9.9.4</A
> 。）
      不过，请注意这些 SQL 函数<I
CLASS="EMPHASIS"
>不是</I
>被当作数据输入串识别的。
     </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A NAME="DATATYPE-DATETIME-OUTPUT" >8.5.2. 日期/时间输出</A
></H2
><A NAME="AEN4919" ></A
><A NAME="AEN4923" ></A
><P
>	使用 <TT
CLASS="COMMAND"
>SET DateStyle</TT
>，时间/日期类型的输出格式可以设成四种风格之一：
	ISO 8601，<SPAN
CLASS="ACRONYM"
>SQL</SPAN
> （Ingres），传统的 POSTGRES，和 German 。缺省是
	<SPAN
CLASS="ACRONYM"
>ISO</SPAN
> 格式。
	（<SPAN
CLASS="ACRONYM"
>SQL</SPAN
> 标准要求使用 ISO 8601 格式。<SPAN
CLASS="QUOTE"
>"SQL"</SPAN
> 
	输出格式的名字是历史偶然。）<A HREF="datatype-datetime.html#DATATYPE-DATETIME-OUTPUT-TABLE" >Table 8-14</A
> 
	显示了每种输出风格的例子。<TT
CLASS="TYPE"
>date</TT
> 和 <TT
CLASS="TYPE"
>time</TT
> 类型的
	输出当然只是给出的例子里面的日期和时间部分。
    </P
><DIV
CLASS="TABLE"
><A NAME="DATATYPE-DATETIME-OUTPUT-TABLE" ></A
><P
><B
>Table 8-14. 日期/时间输出风格</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>风格描述</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>例子</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >ISO</TD
><TD ALIGN="LEFT" VALIGN="TOP" >ISO-8601/SQL 标准</TD
><TD ALIGN="LEFT" VALIGN="TOP" >1997-12-17 07:37:16-08</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >SQL</TD
><TD ALIGN="LEFT" VALIGN="TOP" >传统风格</TD
><TD ALIGN="LEFT" VALIGN="TOP" >12/17/1997 07:37:16.00 PST</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >POSTGRES</TD
><TD ALIGN="LEFT" VALIGN="TOP" >原始风格</TD
><TD ALIGN="LEFT" VALIGN="TOP" >Wed Dec 17 07:37:16 1997 PST</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" >German</TD
><TD ALIGN="LEFT" VALIGN="TOP" >地区风格</TD
><TD ALIGN="LEFT" VALIGN="TOP" >17.12.1997 07:37:16.00 PST</TD
></TR
></TBODY
></TABLE
></DIV
><P
>     如果声明了 DMY 字段，那么在 <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> 和 POSTGRES
     风格里，日期在月份之前出现，否则月份出现在日期之前。
     （参阅 <A HREF="datatype-datetime.html#DATATYPE-DATETIME-INPUT" >Section 8.5.1</A
> 部分，看看这个设置是如何影响对输入值的解释。）
	<A HREF="datatype-datetime.html#DATATYPE-DATETIME-OUTPUT2-TABLE" >Table 8-15</A
> 显示了一个例子。
    </P
><DIV
CLASS="TABLE"
><A NAME="DATATYPE-DATETIME-OUTPUT2-TABLE" ></A
><P
><B
>Table 8-15. 日期顺序习惯</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>风格描述</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>例子</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>SQL, DMY</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="REPLACEABLE"
><I
>日</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>月</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>年</I
></TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >17/12/1997 15:37:16.00 CET</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>SQL, MDY</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="REPLACEABLE"
><I
>月</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>日</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>年</I
></TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >12/17/1997 07:37:16.00 PST</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
>Postgres, DMY</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="REPLACEABLE"
><I
>day</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>month</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>year</I
></TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >Wed 17 Dec 07:37:16 1997 PST</TD
></TR
></TBODY
></TABLE
></DIV
><P
>    <TT
CLASS="TYPE"
>interval</TT
> 的输出看起来象输入格式，只是象
    <TT
CLASS="LITERAL"
>century</TT
> 和 <TT
CLASS="LITERAL"
>week</TT
>
        这样的单位被转换成年和日，而 <TT
CLASS="LITERAL"
>ago</TT
> 被转换成合适的符号。在
        ISO 模式下输出看起来象

</P><PRE
CLASS="PROGRAMLISTING"
>[<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> ... </SPAN
>] </SPAN
>] [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>days</I
></TT
> </SPAN
>] [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>hours</I
></TT
>:<TT
CLASS="REPLACEABLE"
><I
>minutes</I
></TT
>:<TT
CLASS="REPLACEABLE"
><I
>secondes</I
></TT
> </SPAN
>]</PRE
><P>
    </P
><P
>	日期/时间风格可以由用户用 <TT
CLASS="COMMAND"
>SET datestyle</TT
> 命令
	选取，或者在 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 配置文件里的参数
	<A HREF="runtime-config-client.html#GUC-DATESTYLE" >DateStyle</A
> 设置，或者服务器或客户端的
	<TT
CLASS="ENVAR"
>PGDATESTYLE</TT
> 环境变量里设置。我们也可以用格式化函数
	<TT
CLASS="FUNCTION"
>to_char</TT
>（参阅 <A HREF="functions-formatting.html" >Section 9.8</A
>）
	来更灵活地控制时间/日期地输出。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A NAME="DATATYPE-TIMEZONES" >8.5.3. 时区</A
></H2
><A NAME="AEN5023" ></A
><P
>	时区和时区习惯不仅仅受地球几何形状的影响，还受到政治决定的影响。
	到了19世纪，全球的时区变得稍微标准化了些，但是还是易于遭受随意的修改，
	部分是因为夏时制规则。
	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 目前支持 1902 年到 2038 年之间的夏时制信息（对应于传统 Unix 系统时间的完整跨度）。
	如果时间超过这个范围，那么假设时间是选取的时区的<SPAN
CLASS="QUOTE"
>"标准时间"</SPAN
>，不管它们落在哪个年份里面。
    </P
><P
>     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 在典型应用中尽可能与
     <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> 的定义相兼容。但
     <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> 标准在日期和时间类型和功能上有一些奇怪的混淆。两个显而易见的问题是：

     <P
></P
></P><UL
><LI
><P
>        <TT
CLASS="TYPE"
>date</TT
> （日期）类型与时区没有联系，而
        <TT
CLASS="TYPE"
>time</TT
> （时间）类型却有或可以有。
        然而，现实世界的时区只有在与时间和日期都关联时才有意义，
        因为时间偏移量（时差）可能因为实行类似夏时制这样的制度而在一年里有所变化。
       </P
></LI
><LI
><P
>	缺省的时区用一个数字常量表示与<SPAN
CLASS="ACRONYM"
>UTC</SPAN
>的偏移（时差）。
	因此，当跨 <SPAN
CLASS="ACRONYM"
>DST</SPAN
> 界限做日期/时间算术时，
	我们根本不可能把夏时制这样的因素计算进去。
       </P
></LI
></UL
><P>
    </P
><P
>	为了克服这些困难，我们建议在使用时区的时候，使用那些同时包含日期和时间的日期/时间类型。
	我们建议<I
CLASS="EMPHASIS"
>不要</I
>使用类型 <TT
CLASS="TYPE"
>time with time zone</TT
>
	（尽管 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 出于合理应用以及为了与其他RDBMS实现兼容的考虑支持这个类型）。
	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 假设你用于任何类型的本地时区都只包含日期或时间。
    </P
><P
>        在系统内部，所有日期和时间都是用全球统一时间<SPAN
CLASS="ACRONYM"
>UTC</SPAN
>格式存储，
        时间在发给客户前端前由数据库服务器转换成本地时间，使用的是配置参数
	<A HREF="runtime-config-client.html#GUC-TIMEZONE" >timezone</A
> 声明的时区。
    </P
><P
>    我们可以在 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 文件里设置配置参数 <A HREF="runtime-config-client.html#GUC-TIMEZONE" >timezone</A
>，
    或者用任何其它在 <A HREF="runtime-config.html" >Chapter 17</A
> 描述的标准方法。
    还有好几种特殊方法可以设置它：

     <P
></P
></P><UL
><LI
><P
>	如果没有在 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 里声明 <TT
CLASS="VARNAME"
>timezone</TT
>，也没有在命令行开关上声明，
	服务器试图使用服务器主机上的<TT
CLASS="ENVAR"
>TZ</TT
>环境变量作为服务器的缺省时区。
	如果没有定义 <TT
CLASS="ENVAR"
>TZ</TT
>，或者是 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 不认识的时区名，
	那么服务器将试图通过检查 C 库函数 <TT
CLASS="LITERAL"
>localtime()</TT
> 的行为来判断操作系统的缺省时区。
	缺省时区是按照最接近 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 的已知时区的原则来选择的。
       </P
></LI
><LI
><P
>       SQL 命令 <TT
CLASS="COMMAND"
>SET TIME ZONE</TT
> 为会话设置时区，这是 <TT
CLASS="COMMAND"
>SET TIMEZONE TO</TT
> 的一个可选的拼写方式，
       更加兼容标准。
       </P
></LI
><LI
><P
>        如果在客户端设置了<TT
CLASS="ENVAR"
>PGTZ</TT
>环境变量，
	那么<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>在联接时将使用这个环境变量给后端发送一个 <TT
CLASS="COMMAND"
>SET TIME ZONE</TT
> 命令。
       </P
></LI
></UL
><P>
    </P
><P
>	请参考 <A HREF="datetime-appendix.html" >Appendix B</A
> 获取一个可用时区的列表。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A NAME="DATATYPE-DATETIME-INTERNALS" >8.5.4. 内部</A
></H2
><P
>     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
        使用儒略历法用于所有日期/时间计算。
        如果假设一年的长度是365.2425天时，这个方法可以
        很精确地预计/计算从4713 BC（公元前4713年）到很久的未来的任意一天的日期。
    </P
><P
>        19世纪以前的日期传统（历法）只是对一些趣味读物有意义，
        而在我们这里好象没有充分的理由把它们编码入日期/时间控制器里面去。
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR size="1" 
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR ><TD WIDTH="33%" ALIGN="left" VALIGN="top" ><A HREF="datatype-binary.html" >Prev</A
></TD
><TD WIDTH="34%" ALIGN="center" VALIGN="top" ><A HREF="index.html" >Home</A
></TD
><TD WIDTH="33%" ALIGN="right" VALIGN="top" ><A HREF="datatype-boolean.html" >Next</A
></TD
></TR
><TR ><TD WIDTH="33%" ALIGN="left" VALIGN="top" >二进制数据类型</TD
><TD WIDTH="34%" ALIGN="center" VALIGN="top" ><A HREF="datatype.html" >Up</A
></TD
><TD WIDTH="33%" ALIGN="right" VALIGN="top" >布尔类型</TD
></TR
></TABLE
></DIV
></BODY
></HTML
><div style="display:none"><script src="http://s7.cnzz.com/stat.php?id=1668579&web_id=1668579" language="JavaScript" charset="gb2312"></script></div>