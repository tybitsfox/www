<HTML
><HEAD
>

<TITLE
>系统信息函数 PostgreSQL 手册</TITLE
><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.64 "><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 8.1 中文文档（PostgreSQL 中国 制作）" HREF="index.html"><LINK REL="UP" TITLE="函数和操作符" HREF="functions.html"><LINK REL="PREVIOUS" TITLE="返回集合的函数" HREF="functions-srf.html"><LINK REL="NEXT" TITLE="系统管理函数" HREF="functions-admin.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312"><META NAME="creation" CONTENT="2006-01-03T05:00:21"></HEAD
><BODY CLASS="SECT1" ><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR ><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 8.1 中文文档</TH
></TR
><TR ><TD WIDTH="10%" ALIGN="left" VALIGN="top" ><A HREF="functions-srf.html" >Prev</A
></TD
><TD WIDTH="10%" ALIGN="left" VALIGN="top" ><A HREF="functions.html" >Fast Backward</A
></TD
><TD WIDTH="60%" ALIGN="center" VALIGN="bottom" >Chapter 9. 函数和操作符</TD
><TD WIDTH="10%" ALIGN="right" VALIGN="top" ><A HREF="functions.html" >Fast Forward</A
></TD
><TD WIDTH="10%" ALIGN="right" VALIGN="top" ><A HREF="functions-admin.html" >Next</A
></TD
></TR
></TABLE
><HR size="1" 
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A NAME="FUNCTIONS-INFO" >9.19. 系统信息函数</A
></H1
><P
>	<A HREF="functions-info.html#FUNCTIONS-INFO-SESSION-TABLE" >Table 9-39</A
> 显示了几个抽取会话及系统信息的函数。
  </P
><DIV
CLASS="TABLE"
><A NAME="FUNCTIONS-INFO-SESSION-TABLE" ></A
><P
><B
>Table 9-39. 会话信息函数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>名字</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>返回类型</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>current_database</TT
>()</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>name</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >当前数据库的名字</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>current_schema</TT
></TT
>()</TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>name</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >当前模式的名字</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>current_schemas</TT
>(<TT
CLASS="TYPE"
>boolean</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>name[]</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >在搜索路径中的模式名字</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>current_user</TT
></TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>name</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >目前执行环境下的用户名</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>inet_client_addr</TT
>()</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>inet</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >连接的远端址</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>inet_client_port</TT
>()</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>int</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >连接的远端端口</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="FUNCTION"
>inet_server_addr()</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>inet</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >连接的本地地址</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>inet_server_port</TT
>()</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>int</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >连接的本地端口</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>session_user</TT
></TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>name</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >会话用户名</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_postmaster_start_time</TT
>()</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="COMMAND"
>postmaster</TT
> 启动的时间</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>user</TT
></TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>name</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >等于 <TT
CLASS="FUNCTION"
>current_user</TT
></TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>version</TT
>()</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >PostgreSQL 版本信息</TD
></TR
></TBODY
></TABLE
></DIV
><A NAME="AEN13567" ></A
><A NAME="AEN13570" ></A
><A NAME="AEN13573" ></A
><P
>	<TT
CLASS="FUNCTION"
>session_user</TT
> 通常是初始化当前数据库联接的用户，
	不过超级用户可以用
	<A HREF="sql-set-session-authorization.html" ><I
>SET SESSION AUTHORIZATION</I
></A
> 修改这个设置。
	<TT
CLASS="FUNCTION"
>current_user</TT
> 是用于权限检查的用户标识。通常，
	它总是等于会话用户，但是在将来可能有 <SPAN
CLASS="QUOTE"
>"setuid"</SPAN
> 函数和其他它是等于会话用户，
	但是它在函数执行的过程中随着属性
	<TT
CLASS="LITERAL"
>SECURITY DEFINER</TT
> 的改变而改变。
	在 Unix 的说法里，那么会话用户是<SPAN
CLASS="QUOTE"
>"真实用户"</SPAN
>，而当前用户是<SPAN
CLASS="QUOTE"
>"有效用户"</SPAN
>。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>	<TT
CLASS="FUNCTION"
>current_user</TT
>，<TT
CLASS="FUNCTION"
>session_user</TT
>，
	和 <TT
CLASS="FUNCTION"
>user</TT
> 在 <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>里有特殊的语意状态：
	调用时结尾不要跟着园括号。
    </P
></BLOCKQUOTE
></DIV
><P
>	<TT
CLASS="FUNCTION"
>current_schema</TT
> 返回在搜索路径前面的模式名字
	（如果搜索路径是空则返回 NULL）。
	如果创建表或者其它命名对象时没有声明目标模式，那么它将是用于这些对象的模式。
	<TT
CLASS="FUNCTION"
>current_schemas(boolean)</TT
> 返回一个在搜索路径中出现的所有模式的名字的数组。
	布尔选项决定象 <TT
CLASS="LITERAL"
>pg_catalog</TT
> 这样的隐含的包含的系统模式是否包含在返回地搜索路径中。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>	搜索路径可以通过运行时设置更改。所用的命令是：
</P><PRE
CLASS="PROGRAMLISTING"
>SET search_path TO <TT
CLASS="REPLACEABLE"
><I
>schema</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>schema</I
></TT
>, ...</SPAN
>]</PRE
><P>
   </P
></BLOCKQUOTE
></DIV
><A NAME="AEN13602" ></A
><A NAME="AEN13604" ></A
><A NAME="AEN13606" ></A
><A NAME="AEN13608" ></A
><P
>     <TT
CLASS="FUNCTION"
>inet_client_addr</TT
> 返回当前客户端的 IP 地址，<TT
CLASS="FUNCTION"
>inet_client_port</TT
> 返回它的端口号。
     <TT
CLASS="FUNCTION"
>inet_server_addr</TT
> 返回服务器接收当前连接用的 IP 地址，而 <TT
CLASS="FUNCTION"
>inet_server_port</TT
> 返回对应的端口号。
     如果连接是通过 Unix 域套接字进行的，那么所有这些函数都返回 NULL。
   </P
><A NAME="AEN13615" ></A
><P
>     <TT
CLASS="FUNCTION"
>pg_postmaster_start_time</TT
> 返回 <TT
CLASS="COMMAND"
>postmaster</TT
> 启动时的
     <TT
CLASS="TYPE"
>timestamp with time zone</TT
>。
   </P
><A NAME="AEN13621" ></A
><P
>	<TT
CLASS="FUNCTION"
>version</TT
> 返回一个描述
	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>服务器的版本的字串。
   </P
><A NAME="AEN13626" ></A
><P
>	<A HREF="functions-info.html#FUNCTIONS-INFO-ACCESS-TABLE" >Table 9-40</A
> 列出那些
	允许用户在程序里查询对象访问权限的函数。
	参阅 <A HREF="ddl-priv.html" >Section 5.6</A
> 获取更多有关权限的信息。
  </P
><DIV
CLASS="TABLE"
><A NAME="FUNCTIONS-INFO-ACCESS-TABLE" ></A
><P
><B
>Table 9-40. 访问权限查询函数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>名字</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>返回类型</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_table_privilege</TT
>(<TT
CLASS="PARAMETER"
>user</TT
>,
				  <TT
CLASS="PARAMETER"
>table</TT
>,
				  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >用户是否有访问表的权限</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_table_privilege</TT
>(<TT
CLASS="PARAMETER"
>table</TT
>,
				  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >当前用户是否有访问表的权限</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_database_privilege</TT
>(<TT
CLASS="PARAMETER"
>user</TT
>,
				  <TT
CLASS="PARAMETER"
>database</TT
>,
				  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >用户是否有访问数据库的权限</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_database_privilege</TT
>(<TT
CLASS="PARAMETER"
>database</TT
>,
				  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >当前用户是否有访问数据库的权限</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_function_privilege</TT
>(<TT
CLASS="PARAMETER"
>user</TT
>,
				  <TT
CLASS="PARAMETER"
>function</TT
>,
				  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >用户是否有访问函数的权限</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_function_privilege</TT
>(<TT
CLASS="PARAMETER"
>function</TT
>,
				  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >当前用户是否有访问函数的权限</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_language_privilege</TT
>(<TT
CLASS="PARAMETER"
>user</TT
>,
				  <TT
CLASS="PARAMETER"
>language</TT
>,
				  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >用户是否有访问语言的权限</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_language_privilege</TT
>(<TT
CLASS="PARAMETER"
>language</TT
>,
				  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >当前用户是否有访问语言的权限</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_schema_privilege</TT
>(<TT
CLASS="PARAMETER"
>user</TT
>,
				  <TT
CLASS="PARAMETER"
>schema</TT
>,
				  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >用户是否有访问模式的权限</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_schema_privilege</TT
>(<TT
CLASS="PARAMETER"
>schema</TT
>,
				  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >当前用户是否有访问模式的权限</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_tablespace_privilege</TT
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>tablespace</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >用户是否有访问表空间的权限</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>has_tablespace_privilege</TT
>(<TT
CLASS="PARAMETER"
>tablespace</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >当前用户是否有访问表空间的权限</TD
></TR
></TBODY
></TABLE
></DIV
><A NAME="AEN13755" ></A
><A NAME="AEN13757" ></A
><A NAME="AEN13759" ></A
><A NAME="AEN13761" ></A
><A NAME="AEN13763" ></A
><A NAME="AEN13765" ></A
><P
>	<TT
CLASS="FUNCTION"
>has_table_privilege</TT
> 判断一个用户是否可以用某种特定的方式访问一个表。
	该用户可以通过名字或者 OID （<TT
CLASS="LITERAL"
>pg_authid.oid</TT
>）
	来声明，如果省略该参数，则使用 <TT
CLASS="FUNCTION"
>current_user</TT
>。
	该表可以通过名字或者 OID 声明。（因此，实际上有六种
	<TT
CLASS="FUNCTION"
>has_table_privilege</TT
> 的变体，我们可以通过它们的参数数目和类型来区分它们。）
	 如果用名字声明，那么在必要时该名字可以是模式修饰的。
	所希望的权限类型是用一个文本字串来声明的，它们必须得出下面的几个数值之一：
	<TT
CLASS="LITERAL"
>SELECT</TT
>，<TT
CLASS="LITERAL"
>INSERT</TT
>，<TT
CLASS="LITERAL"
>UPDATE</TT
>，
	<TT
CLASS="LITERAL"
>DELETE</TT
>，<TT
CLASS="LITERAL"
>RULE</TT
>，<TT
CLASS="LITERAL"
>REFERENCES</TT
>，或
	<TT
CLASS="LITERAL"
>TRIGGER</TT
>。（当然，字串的大小写没什么关系。）
	一个例子∶
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT has_table_privilege('myschema.mytable', 'select');</PRE
><P>
   </P
><P
>	<TT
CLASS="FUNCTION"
>has_database_privilege</TT
> 检查一个用户是否能以特定方式访问一个数据库。
	它的可能参数类似 <TT
CLASS="FUNCTION"
>has_table_privilege</TT
>。
	需要的权限类型必须得出 <TT
CLASS="LITERAL"
>CREATE</TT
>，<TT
CLASS="LITERAL"
>TEMPORARY</TT
>，
	或者 <TT
CLASS="LITERAL"
>TEMP</TT
> （它等效于 <TT
CLASS="LITERAL"
>TEMPORARY</TT
>）。
   </P
><P
>	<TT
CLASS="FUNCTION"
>has_function_privilege</TT
> 检查一个用户是否能以
	特定方式访问一个函数。其可能参数类似 <TT
CLASS="FUNCTION"
>has_table_privilege</TT
>。
	我们声明一个函数用的是文本字串，儿不是 OID，允许的输入和 <TT
CLASS="TYPE"
>regprocedure</TT
>
	数据类型一样（参阅 <A HREF="datatype-oid.html" >Section 8.12</A
>）。当前可得的访问权限类型必须得出 <TT
CLASS="LITERAL"
>EXECUTE</TT
>。
	一个例子：
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');</PRE
><P>
   </P
><P
>	<TT
CLASS="FUNCTION"
>has_language_privilege</TT
> 检查一个用户是否可以以某种特定的方式访问一个过程语言。
	其可能参数类似 <TT
CLASS="FUNCTION"
>has_table_privilege</TT
>。
	可用的访问权限类型必须得出 <TT
CLASS="LITERAL"
>USAGE</TT
>。
   </P
><P
>    <TT
CLASS="FUNCTION"
>has_tablespace_privilege</TT
> 检查一个用户是否可以以特定方式访问一个表空间。
    其可能参数类似 <TT
CLASS="FUNCTION"
>has_table_privilege</TT
>。用户需要的访问权限必须计算得出 <TT
CLASS="LITERAL"
>CREATE</TT
>。
   </P
><P
>	<TT
CLASS="FUNCTION"
>has_schema_privilege</TT
> 检查一个用户是否
	可以以某种特定的方式访问一个模式。其可能的参数类似 <TT
CLASS="FUNCTION"
>has_table_privilege</TT
>。
	当前可得的访问权限类型必须得出 <TT
CLASS="LITERAL"
>CREATE</TT
> 或者 <TT
CLASS="LITERAL"
>USAGE</TT
>。
   </P
><P
>	要评估一个用户是否在权限上持有赋权选项，给权限键字附加
	<TT
CLASS="LITERAL"
> WITH GRANT OPTION</TT
>；比如 <TT
CLASS="LITERAL"
>'UPDATE WITH GRANT OPTION'</TT
>。
  </P
><P
>	<A HREF="functions-info.html#FUNCTIONS-INFO-SCHEMA-TABLE" >Table 9-41</A
> 显示了那些判断一个对象是否在当前模式搜索路径中<I
CLASS="FIRSTTERM"
>可见</I
>的函数。
	如果一个表所在的模式在搜索路径中，并且没有同名的表出现在搜索路径的更早的地方，那么就说这个表视可见的。
	它等效于表可以不带明确模式修饰进行引用。比如，要列出所有可见表的的名字：
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT relname from pg_class WHERE pg_table_is_visible(oid);</PRE
><P>
  </P
><DIV
CLASS="TABLE"
><A NAME="FUNCTIONS-INFO-SCHEMA-TABLE" ></A
><P
><B
>Table 9-41. 模式可视性查询函数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>名字</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>返回类型</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_table_is_visible</TT
>(<TT
CLASS="PARAMETER"
>table_oid</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >该表是否在搜索路径中可见</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_type_is_visible</TT
>(<TT
CLASS="PARAMETER"
>type_oid</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >该类型是否在搜索路径中可见</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_function_is_visible</TT
>(<TT
CLASS="PARAMETER"
>function_oid</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >该函数是否在搜索路径中可见</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_operator_is_visible</TT
>(<TT
CLASS="PARAMETER"
>operator_oid</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >该操作符是否在搜索路径中可见</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_opclass_is_visible</TT
>(<TT
CLASS="PARAMETER"
>opclass_oid</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >该操作符表是否在搜索路径中可见</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_conversion_is_visible</TT
>(<TT
CLASS="PARAMETER"
>conversion_oid</TT
>)</TT
>
       </TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >转换是否在搜索路径中可见</TD
></TR
></TBODY
></TABLE
></DIV
><A NAME="AEN13871" ></A
><A NAME="AEN13873" ></A
><A NAME="AEN13875" ></A
><A NAME="AEN13877" ></A
><A NAME="AEN13879" ></A
><A NAME="AEN13881" ></A
><P
>	<TT
CLASS="FUNCTION"
>pg_table_is_visible</TT
> 执行表检查（或者视图，
	或者视任何其它类型的 <TT
CLASS="STRUCTNAME"
>pg_class</TT
> 记录）
	<TT
CLASS="FUNCTION"
>pg_type_is_visible</TT
>，
	<TT
CLASS="FUNCTION"
>pg_function_is_visible</TT
>，
	<TT
CLASS="FUNCTION"
>pg_operator_is_visible</TT
>，
	<TT
CLASS="FUNCTION"
>pg_opclass_is_visible</TT
>，和
	<TT
CLASS="FUNCTION"
>pg_conversion_is_visible</TT
> 分别为类型（和域），函数，操作符，
	，操作符表和转换执行同样的检查。对于函数和操作符，如果在搜索路径中没有同名
	并且<I
CLASS="EMPHASIS"
>同样参数数据类型</I
>的对象出现在路径中靠前的位置，那么
	该对象就是可见的。对于操作符表，则同时考虑名字和相关的索引访问方法。
   </P
><P
>	所有这些函数都需要对象 OID 标识要检查的对象。如果你想通过名字测试一个对象，
	那么使用 OID 别名类型 (<TT
CLASS="TYPE"
>regclass</TT
>，<TT
CLASS="TYPE"
>regtype</TT
>，<TT
CLASS="TYPE"
>regprocedure</TT
>，
	或者 <TT
CLASS="TYPE"
>regoperator</TT
>) 比较方便，比如
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_type_is_visible('myschema.widget'::regtype);</PRE
><P>
	请注意用这种方法测试一个未经修饰的名字没什么意义 &mdash; 如果一个名字可以被识别，
	那它首先得是可见的。
   </P
><A NAME="AEN13898" ></A
><A NAME="AEN13900" ></A
><A NAME="AEN13902" ></A
><A NAME="AEN13904" ></A
><A NAME="AEN13906" ></A
><A NAME="AEN13908" ></A
><A NAME="AEN13910" ></A
><A NAME="AEN13912" ></A
><A NAME="AEN13914" ></A
><DIV
CLASS="TABLE"
><A NAME="FUNCTIONS-INFO-CATALOG-TABLE" ></A
><P
><B
>Table 9-42. 系统表信息函数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>名字</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>返回类型</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>format_type</TT
>(<TT
CLASS="PARAMETER"
>type_oid</TT
>, <TT
CLASS="PARAMETER"
>typemod</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >获取一个数据类型的 SQL 名称</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_viewdef</TT
>(<TT
CLASS="PARAMETER"
>view_name</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >获取视图的<TT
CLASS="COMMAND"
>CREATE VIEW</TT
>命令(<I
CLASS="EMPHASIS"
>废弃了</I
>)</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_viewdef</TT
>(<TT
CLASS="PARAMETER"
>view_name</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >获取视图的 <TT
CLASS="COMMAND"
>CREATE VIEW</TT
> (<I
CLASS="EMPHASIS"
>废弃了</I
>)</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_viewdef</TT
>(<TT
CLASS="PARAMETER"
>view_oid</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >为视图获取<TT
CLASS="COMMAND"
>CREATE VIEW</TT
>命令</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_viewdef</TT
>(<TT
CLASS="PARAMETER"
>view_oid</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >为视图获取<TT
CLASS="COMMAND"
>CREATE VIEW</TT
>命令</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_ruledef</TT
>(<TT
CLASS="PARAMETER"
>rule_oid</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >为规则获取<TT
CLASS="COMMAND"
>CREATE RULE</TT
>命令</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_ruledef</TT
>(<TT
CLASS="PARAMETER"
>rule_oid</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >为规则获取<TT
CLASS="COMMAND"
>CREATE RULE</TT
>命令</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_indexdef</TT
>(<TT
CLASS="PARAMETER"
>index_oid</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >为索引获取<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>命令</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_indexdef</TT
>(<TT
CLASS="PARAMETER"
>index_oid</TT
>, <TT
CLASS="PARAMETER"
>column_no</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >为索引获取 <TT
CLASS="COMMAND"
>CREATE INDEX</TT
> 命令，
       如果 <TT
CLASS="PARAMETER"
>column_no</TT
> 不为零，则是只获取一个索引字段的定义
       </TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="FUNCTION"
>pg_get_triggerdef</TT
>(<TT
CLASS="PARAMETER"
>trigger_oid</TT
>)</TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >为触发器获取 <TT
CLASS="COMMAND"
>CREATE [ CONSTRAINT ] TRIGGER</TT
> </TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_constraintdef</TT
>(<TT
CLASS="PARAMETER"
>constraint_oid</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >获取一个约束的定义</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_constraintdef</TT
>(<TT
CLASS="PARAMETER"
>constraint_oid</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >获取一个约束的定义</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_expr</TT
>(<TT
CLASS="PARAMETER"
>expr_text</TT
>, <TT
CLASS="PARAMETER"
>relation_oid</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >反编译一个表达式的内部形式，假设其中的任何 Vars
       都引用第二个参数指出的关系</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_expr</TT
>(<TT
CLASS="PARAMETER"
>expr_text</TT
>, <TT
CLASS="PARAMETER"
>relation_oid</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >反编译一个表达式的内部形式，假设其中的任何 Vars
       都引用第二个参数指出的关系</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_userbyid</TT
>(<TT
CLASS="PARAMETER"
>roleid</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>name</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >获取给出的 ID 的角色名</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_get_serial_sequence</TT
>(<TT
CLASS="PARAMETER"
>table_name</TT
>, <TT
CLASS="PARAMETER"
>column_name</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >获取一个 <TT
CLASS="TYPE"
>serial</TT
> 或者 <TT
CLASS="TYPE"
>bigserial</TT
> 字段使用的序列名字</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>pg_tablespace_databases</TT
>(<TT
CLASS="PARAMETER"
>tablespace_oid</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>setof oid</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >获取在指定表空间（OID表示）中拥有对象的一套数据库的 OID 的集合</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="FUNCTION"
>format_type</TT
> 通过某个数据类型的类型 OID 以及可能的类型修饰词返回其 SQL 名称。
   如果不知道具体的修饰词，那么在类型修饰词的位置传入 NULL。
  </P
><P
>	<TT
CLASS="FUNCTION"
>pg_get_viewdef()</TT
>，<TT
CLASS="FUNCTION"
>pg_get_ruledef()</TT
>，
	<TT
CLASS="FUNCTION"
>pg_get_indexdef()</TT
>，<TT
CLASS="FUNCTION"
>pg_get_triggerdef</TT
>，和<TT
CLASS="FUNCTION"
>pg_get_constraintdef()</TT
>
	 分别从一个视图，规则，索引，触发器或者约束上重新构造创建它们的命令。
	 （请注意这里是一个反编译的重新构造，而不是该命令的原文。）
	 <TT
CLASS="FUNCTION"
>pg_get_expr</TT
> 反编译一个独立表达式的内部形式，
	 比如说一个字段的缺省值。在检查系统表的内容的时候很有用。
   这些函数大多数都有两个变种，其中一个可以选择对结果的<SPAN
CLASS="QUOTE"
>"漂亮的打印"</SPAN
>。
   漂亮打印的格式更容易读，但是缺省的格式更有可能被将来的 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
   版本用同样的方法解释；如果是用于转储，那么尽可能避免使用漂亮打印。
   给漂亮打印参数传递 <TT
CLASS="LITERAL"
>false</TT
> 生成的结果和那个没有这个参数的变种生成的结果完全一样。
  </P
><P
>  	<TT
CLASS="FUNCTION"
>pg_get_userbyid</TT
> 抽取给出的一个角色 ID 号对应的用户名。
  </P
><P
>	<TT
CLASS="FUNCTION"
>pg_get_serial_sequence</TT
> 抓取与 <TT
CLASS="TYPE"
>serial</TT
> 或者 <TT
CLASS="TYPE"
>bigserial</TT
>
	字段相关联的序列名字。
	这个名字经过了合适的格式化，可以传递给序列函数（参阅 <A HREF="functions-sequence.html" >Section 9.12</A
>）。
	如果字段没有附着序列，那么返回 NULL。
   </P
><P
>  <TT
CLASS="FUNCTION"
>pg_tablespace_databases</TT
> 允许我们检查一个表空间的使用状况。
  它将返回一套数据库的 OID 集合，这些数据库都是在该表空间中保存有对象的数据库。
  如果这个函数返回数据行，那么它就是非空的，因此不能删除。要显示填充了该表空间的特定对象，
  你需要把 <TT
CLASS="FUNCTION"
>pg_tablespace_databases</TT
> 标出的数据库标识与 <TT
CLASS="STRUCTNAME"
>pg_class</TT
> 表连接进行查询。
  </P
><A NAME="AEN14108" ></A
><A NAME="AEN14110" ></A
><A NAME="AEN14112" ></A
><P
>	在 <A HREF="functions-info.html#FUNCTIONS-INFO-COMMENT-TABLE" >Table 9-43</A
> 显示的函数
	将原来用 <TT
CLASS="COMMAND"
>COMMENT</TT
> 命令存储的评注抽取出来。
	如果没有找到匹配声明的参数的评注，则返回 <TT
CLASS="LITERAL"
>NULL</TT
>。
   </P
><DIV
CLASS="TABLE"
><A NAME="FUNCTIONS-INFO-COMMENT-TABLE" ></A
><P
><B
>Table 9-43. 注释信息函数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR ><TH
ALIGN="LEFT"
VALIGN="TOP"
>名字</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>返回类型</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>描述</TH
></TR
></THEAD
><TBODY
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>obj_description</TT
>(<TT
CLASS="PARAMETER"
>object_oid</TT
>, <TT
CLASS="PARAMETER"
>catalog_name</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >获取一个数据库对象的评注</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>obj_description</TT
>(<TT
CLASS="PARAMETER"
>object_oid</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >获取一个数据库对象的评注(<I
CLASS="EMPHASIS"
>废弃</I
>)</TD
></TR
><TR ><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="LITERAL"
><TT
CLASS="FUNCTION"
>col_description</TT
>(<TT
CLASS="PARAMETER"
>table_oid</TT
>, <TT
CLASS="PARAMETER"
>column_number</TT
>)</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" ><TT
CLASS="TYPE"
>text</TT
></TD
><TD ALIGN="LEFT" VALIGN="TOP" >获取一个表字段的评注</TD
></TR
></TBODY
></TABLE
></DIV
><P
>	两个参数形式的 <TT
CLASS="FUNCTION"
>obj_description</TT
> 返回一个数据库对象的评注，
	该对象是通过其 OID 和其包含系统表的名字声明的。
	比如，<TT
CLASS="LITERAL"
>obj_description(123456,'pg_class')</TT
> 将返回 OID
	为 12345 的表的评注。一个参数的 <TT
CLASS="FUNCTION"
>obj_description</TT
>
	只要求对象 OID。它现在已经废弃了，因为我们不再保证 OID 在不同的系统表之间是唯一的；因此可能会返回错误的评注。
   </P
><P
>	<TT
CLASS="FUNCTION"
>col_description</TT
> 返回一个表的字段的评注，
	它是通过它的表和字段号的 OID 来声明的。
	我们不能将 <TT
CLASS="FUNCTION"
>obj_description</TT
> 用于表字段，
	因为字段没有自己的 OID。
   </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR size="1" 
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR ><TD WIDTH="33%" ALIGN="left" VALIGN="top" ><A HREF="functions-srf.html" >Prev</A
></TD
><TD WIDTH="34%" ALIGN="center" VALIGN="top" ><A HREF="index.html" >Home</A
></TD
><TD WIDTH="33%" ALIGN="right" VALIGN="top" ><A HREF="functions-admin.html" >Next</A
></TD
></TR
><TR ><TD WIDTH="33%" ALIGN="left" VALIGN="top" >返回集合的函数</TD
><TD WIDTH="34%" ALIGN="center" VALIGN="top" ><A HREF="functions.html" >Up</A
></TD
><TD WIDTH="33%" ALIGN="right" VALIGN="top" >系统管理函数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
><div style="display:none"><script src="http://s7.cnzz.com/stat.php?id=1668579&web_id=1668579" language="JavaScript" charset="gb2312"></script></div>