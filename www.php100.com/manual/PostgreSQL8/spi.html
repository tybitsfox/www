<HTML
><HEAD
>

<TITLE
>服务器编程接口 PostgreSQL 手册</TITLE
><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.64 "><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 8.1 中文文档（PostgreSQL 中国 制作）" HREF="index.html"><LINK REL="UP" TITLE="服务器端编程" HREF="server-programming.html"><LINK REL="PREVIOUS" TITLE="数据库访问" HREF="plpython-database.html"><LINK REL="NEXT" TITLE="SPI_connect" HREF="spi-spi-connect.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312"><META NAME="creation" CONTENT="2006-01-03T05:00:21"></HEAD
><BODY CLASS="CHAPTER" ><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR ><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 8.1 中文文档</TH
></TR
><TR ><TD WIDTH="10%" ALIGN="left" VALIGN="top" ><A HREF="plpython-database.html" >Prev</A
></TD
><TD WIDTH="10%" ALIGN="left" VALIGN="top" ><A HREF="plpython.html" >Fast Backward</A
></TD
><TD WIDTH="60%" ALIGN="center" VALIGN="bottom" ></TD
><TD WIDTH="10%" ALIGN="right" VALIGN="top" ><A HREF="reference.html" >Fast Forward</A
></TD
><TD WIDTH="10%" ALIGN="right" VALIGN="top" ><A HREF="spi-spi-connect.html" >Next</A
></TD
></TR
></TABLE
><HR size="1" 
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A NAME="SPI" >Chapter 40. 服务器编程接口</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>40.1. <A HREF="spi.html#SPI-INTERFACE" >接口函数</A
></DT
><DD
><DL
><DT
><A HREF="spi-spi-connect.html" >SPI_connect</A
> &#8212; 把你一个过程与 SPI 管理器连接起来。</DT
><DT
><A HREF="spi-spi-finish.html" >SPI_finish</A
> &#8212; 把一个过程与 SPI 管理器断开</DT
><DT
><A HREF="spi-spi-push.html" >SPI_push</A
> &#8212; 对 SPI 堆栈进行压栈操作以允许递规的 SPI 使用</DT
><DT
><A HREF="spi-spi-pop.html" >SPI_pop</A
> &#8212; 弹出 SPI 堆栈以允许递规 SPI 使用</DT
><DT
><A HREF="spi-spi-execute.html" >SPI_execute</A
> &#8212; 执行一条命令</DT
><DT
><A HREF="spi-spi-exec.html" >SPI_exec</A
> &#8212; 执行一个读/写命令</DT
><DT
><A HREF="spi-spi-prepare.html" >SPI_prepare</A
> &#8212; 为一个命令准备一个规划，但还不执行它</DT
><DT
><A HREF="spi-spi-getargcount.html" >SPI_getargcount</A
> &#8212; 返回一个 <TT
CLASS="FUNCTION"
>SPI_prepare</TT
> 准备的已准备好规划需要的参数个数</DT
><DT
><A HREF="spi-spi-getargtypeid.html" >SPI_getargtypeid</A
> &#8212; 返回 <TT
CLASS="FUNCTION"
>SPI_prepare</TT
> 准备的已准备好规划的指定参数的 typeid</DT
><DT
><A HREF="spi-spi-is-cursor-plan.html" >SPI_is_cursor_plan</A
> &#8212; 如果一个 <TT
CLASS="FUNCTION"
>SPI_prepare</TT
> 准备的规划可以和 <TT
CLASS="FUNCTION"
>SPI_cursor_open</TT
> 一起使用，则返回真</DT
><DT
><A HREF="spi-spi-execute-plan.html" >SPI_execute_plan</A
> &#8212; 执行一个 <TT
CLASS="FUNCTION"
>SPI_prepare</TT
> 准备的查询规划</DT
><DT
><A HREF="spi-spi-execp.html" >SPI_execp</A
> &#8212; 以读/写模式执行一个准备的查询规划</DT
><DT
><A HREF="spi-spi-cursor-open.html" >SPI_cursor_open</A
> &#8212; 用 <TT
CLASS="FUNCTION"
>SPI_prepare</TT
> 创建的规划设置一个游标</DT
><DT
><A HREF="spi-spi-cursor-find.html" >SPI_cursor_find</A
> &#8212; 用名字寻找并执行一个现存的游标</DT
><DT
><A HREF="spi-spi-cursor-fetch.html" >SPI_cursor_fetch</A
> &#8212; 从一个游标里抓取一些行</DT
><DT
><A HREF="spi-spi-cursor-move.html" >SPI_cursor_move</A
> &#8212; 移动一个游标</DT
><DT
><A HREF="spi-spi-cursor-close.html" >SPI_cursor_close</A
> &#8212; 关闭一个游标</DT
><DT
><A HREF="spi-spi-saveplan.html" >SPI_saveplan</A
> &#8212; 保存一个规划</DT
></DL
></DD
><DT
>40.2. <A HREF="spi-interface-support.html" >接口支持函数</A
></DT
><DD
><DL
><DT
><A HREF="spi-spi-fname.html" >SPI_fname</A
> &#8212; 从指定的字段编号判断字段名字</DT
><DT
><A HREF="spi-spi-fnumber.html" >SPI_fnumber</A
> &#8212; 判断声明的字段名的字段编号</DT
><DT
><A HREF="spi-spi-getvalue.html" >SPI_getvalue</A
> &#8212; 返回声明字段的字串值</DT
><DT
><A HREF="spi-spi-getbinval.html" >SPI_getbinval</A
> &#8212; 返回声明字段的二进制值</DT
><DT
><A HREF="spi-spi-gettype.html" >SPI_gettype</A
> &#8212; 返回声明的字段的数据类型名</DT
><DT
><A HREF="spi-spi-gettypeid.html" >SPI_gettypeid</A
> &#8212; 返回声明的字段的数据类型 <SPAN
CLASS="ACRONYM"
>OID</SPAN
></DT
><DT
><A HREF="spi-spi-getrelname.html" >SPI_getrelname</A
> &#8212; 返回声明关系的名字</DT
><DT
><A HREF="spi-spi-getnspname.html" >SPI_getnspname</A
> &#8212; 返回声明关系的名字空间</DT
></DL
></DD
><DT
>40.3. <A HREF="spi-memory.html" >存储器管理</A
></DT
><DD
><DL
><DT
><A HREF="spi-spi-palloc.html" >SPI_palloc</A
> &#8212; 在上层执行器环境里分配内存</DT
><DT
><A HREF="spi-realloc.html" >SPI_repalloc</A
> &#8212; 在上层执行器环境里重新分配内存</DT
><DT
><A HREF="spi-spi-pfree.html" >SPI_pfree</A
> &#8212; 在上层执行器环境里释放内存</DT
><DT
><A HREF="spi-spi-copytuple.html" >SPI_copytuple</A
> &#8212; 在上层执行者环境里制作一个行的拷贝</DT
><DT
><A HREF="spi-spi-returntuple.html" >SPI_returntuple</A
> &#8212; 准备把一个元组当作 Datum 返回</DT
><DT
><A HREF="spi-spi-modifytuple.html" >SPI_modifytuple</A
> &#8212; 通过替换一个给出行的选定的字段创建一行</DT
><DT
><A HREF="spi-spi-freetuple.html" >SPI_freetuple</A
> &#8212; 释放在上层执行者环境里分配的一行</DT
><DT
><A HREF="spi-spi-freetupletable.html" >SPI_freetuptable</A
> &#8212; 释放一个由 <TT
CLASS="FUNCTION"
>SPI_execute</TT
> 或者类似的函数创建的行集</DT
><DT
><A HREF="spi-spi-freeplan.html" >SPI_freeplan</A
> &#8212; 释放一个前面保存的规划</DT
></DL
></DD
><DT
>40.4. <A HREF="spi-visibility.html" >数据改变的可视性</A
></DT
><DT
>40.5. <A HREF="spi-examples.html" >例子</A
></DT
></DL
></DIV
><A NAME="AEN36653" ></A
><P
><I
CLASS="FIRSTTERM"
>服务器编程接口</I
>
（<SPAN
CLASS="ACRONYM"
>SPI</SPAN
>） 给我们在用户定义的<SPAN
CLASS="ACRONYM"
>C</SPAN
>函数里面运行
 <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> 查询的能力。
  <SPAN
CLASS="ACRONYM"
>SPI</SPAN
> 是一套接口函数，用于简化对分析器，规划器，优化器，和执行器的访问。
  <SPAN
CLASS="ACRONYM"
>SPI</SPAN
> 还进行一些内存管理的工作。</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>   过程语言的存在也提供了其它的一些在过程里执行 SQL 命令的方法。
   这些语言中的大部分本身就是基于 SPI的，
   因此这份文档可能会对那些语言的用户同样有帮助。</P
></BLOCKQUOTE
></DIV
><P
>为了避免混淆，我们将使用<I
CLASS="FIRSTTERM"
>函数（function）</I
>
来代表<SPAN
CLASS="ACRONYM"
>SPI</SPAN
>接口函数，
用<I
CLASS="FIRSTTERM"
>过程（procedure）</I
> 代表用户用
<SPAN
CLASS="ACRONYM"
>SPI</SPAN
> 定义的 C 函数。</P
><P
>注意，一条通过 SPI 调用的命令失败，那么控制不会返回到你的过程中。
取而代之的是，你的过程执行所在的事务或者子事务作都将回卷。
（这一点看起来可能很奇怪，因为大多数 SPI 函数的文档里都有错误返回习惯。
不过，那些习惯只适用于在 SPI 函数自己内部检测到的错误。）
我们可以通过在你自己的可能失败的 SPI 调用周围建立一个子事务的方法来在错误之后恢复。
目前我们还没有写这方面的文档，因为所需要的机制仍然在变化。</P
><P
>如果执行成功了，<SPAN
CLASS="ACRONYM"
>SPI</SPAN
> 函数返回一个非负结果
（或者通过返回一个整数值或放在全局变量<TT
CLASS="VARNAME"
>SPI_result</TT
>里，
象下面描述的那样）。出错时，返回一个负数或 <TT
CLASS="SYMBOL"
>NULL</TT
> 结果。</P
><P
>  使用 SPI 的源代码文件必须包含头文件 <TT
CLASS="FILENAME"
>executor/spi.h</TT
>。
 </P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A NAME="SPI-INTERFACE" >40.1. 接口函数</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A HREF="spi-spi-connect.html" >SPI_connect</A
> &#8212; 把你一个过程与 SPI 管理器连接起来。</DT
><DT
><A HREF="spi-spi-finish.html" >SPI_finish</A
> &#8212; 把一个过程与 SPI 管理器断开</DT
><DT
><A HREF="spi-spi-push.html" >SPI_push</A
> &#8212; 对 SPI 堆栈进行压栈操作以允许递规的 SPI 使用</DT
><DT
><A HREF="spi-spi-pop.html" >SPI_pop</A
> &#8212; 弹出 SPI 堆栈以允许递规 SPI 使用</DT
><DT
><A HREF="spi-spi-execute.html" >SPI_execute</A
> &#8212; 执行一条命令</DT
><DT
><A HREF="spi-spi-exec.html" >SPI_exec</A
> &#8212; 执行一个读/写命令</DT
><DT
><A HREF="spi-spi-prepare.html" >SPI_prepare</A
> &#8212; 为一个命令准备一个规划，但还不执行它</DT
><DT
><A HREF="spi-spi-getargcount.html" >SPI_getargcount</A
> &#8212; 返回一个 <TT
CLASS="FUNCTION"
>SPI_prepare</TT
> 准备的已准备好规划需要的参数个数</DT
><DT
><A HREF="spi-spi-getargtypeid.html" >SPI_getargtypeid</A
> &#8212; 返回 <TT
CLASS="FUNCTION"
>SPI_prepare</TT
> 准备的已准备好规划的指定参数的 typeid</DT
><DT
><A HREF="spi-spi-is-cursor-plan.html" >SPI_is_cursor_plan</A
> &#8212; 如果一个 <TT
CLASS="FUNCTION"
>SPI_prepare</TT
> 准备的规划可以和 <TT
CLASS="FUNCTION"
>SPI_cursor_open</TT
> 一起使用，则返回真</DT
><DT
><A HREF="spi-spi-execute-plan.html" >SPI_execute_plan</A
> &#8212; 执行一个 <TT
CLASS="FUNCTION"
>SPI_prepare</TT
> 准备的查询规划</DT
><DT
><A HREF="spi-spi-execp.html" >SPI_execp</A
> &#8212; 以读/写模式执行一个准备的查询规划</DT
><DT
><A HREF="spi-spi-cursor-open.html" >SPI_cursor_open</A
> &#8212; 用 <TT
CLASS="FUNCTION"
>SPI_prepare</TT
> 创建的规划设置一个游标</DT
><DT
><A HREF="spi-spi-cursor-find.html" >SPI_cursor_find</A
> &#8212; 用名字寻找并执行一个现存的游标</DT
><DT
><A HREF="spi-spi-cursor-fetch.html" >SPI_cursor_fetch</A
> &#8212; 从一个游标里抓取一些行</DT
><DT
><A HREF="spi-spi-cursor-move.html" >SPI_cursor_move</A
> &#8212; 移动一个游标</DT
><DT
><A HREF="spi-spi-cursor-close.html" >SPI_cursor_close</A
> &#8212; 关闭一个游标</DT
><DT
><A HREF="spi-spi-saveplan.html" >SPI_saveplan</A
> &#8212; 保存一个规划</DT
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR size="1" 
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR ><TD WIDTH="33%" ALIGN="left" VALIGN="top" ><A HREF="plpython-database.html" >Prev</A
></TD
><TD WIDTH="34%" ALIGN="center" VALIGN="top" ><A HREF="index.html" >Home</A
></TD
><TD WIDTH="33%" ALIGN="right" VALIGN="top" ><A HREF="spi-spi-connect.html" >Next</A
></TD
></TR
><TR ><TD WIDTH="33%" ALIGN="left" VALIGN="top" >数据库访问</TD
><TD WIDTH="34%" ALIGN="center" VALIGN="top" ><A HREF="server-programming.html" >Up</A
></TD
><TD WIDTH="33%" ALIGN="right" VALIGN="top" >SPI_connect</TD
></TR
></TABLE
></DIV
></BODY
></HTML
><div style="display:none"><script src="http://s7.cnzz.com/stat.php?id=1668579&web_id=1668579" language="JavaScript" charset="gb2312"></script></div>