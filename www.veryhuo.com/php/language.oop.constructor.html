<HTML><HEAD><TITLE>构造函数</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK REL="HOME" TITLE="PHP 手册" HREF="index-2.html"><LINK REL="UP" TITLE="类与对象" HREF="language.oop.html"><LINK REL="PREVIOUS" TITLE="继承" HREF="keyword.extends.html"><LINK REL="NEXT" TITLE="::" HREF="keyword.paamayim-nekudotayim.html"><META HTTP-EQUIV="Content-type" CONTENT="text/html; charset=gb2312"><LINK REL="stylesheet" HREF="style.css"></HEAD><BODY TOPMARGIN="0" LEFTMARGIN="0" CLASS="sect1" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#840084" ALINK="#0000FF"><TABLE BORDER="0" WIDTH="100%" HEIGHT="100%" CELLSPACING="0" CELLPADDING="0"><TR><TD COLSPAN="3"><DIV CLASS="NAVHEADER"><TABLE BGCOLOR="#CCCCFF" BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="3" CELLSPACING="0"><TR><TH COLSPAN="3" ALIGN="center">PHP 手册</TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="bottom"><A HREF="keyword.extends.html" ACCESSKEY="P">后退</A></TD><TD WIDTH="80%" ALIGN="center" VALIGN="bottom">章 13. 类与对象</TD><TD WIDTH="10%" ALIGN="right" VALIGN="bottom"><A HREF="keyword.paamayim-nekudotayim.html" ACCESSKEY="N">前进</A></TD></TR></TABLE></TD></TR><TR BGCOLOR="#333366"><TD><IMG SRC="spacer.gif" BORDER="0" WIDTH="1" HEIGHT="1"><BR></TD></TR></TABLE></DIV></TD></TR><TR><TD><IMG SRC="spacer.gif" WIDTH="10" HEIGHT="1"></TD><TD HEIGHT="100%" VALIGN="TOP" WIDTH="100%"><BR><DIV CLASS="sect1"><H1 CLASS="sect1"><A NAME="language.oop.constructor"></A><TT CLASS="literal">构造函数</TT></H1><DIV CLASS="caution"><P></P><TABLE CLASS="caution" BORDER="1" WIDTH="100%"><TR><TD ALIGN="CENTER"><B>注意</B></TD></TR><TR><TD ALIGN="LEFT"><P>&#13; PHP 3 和 PHP4 的构造函数有所不同。PHP 4 的语义更可取。
</P></TD></TR></TABLE></DIV><P>&#13; 构造函数是类中的一个特殊函数，当使用 <TT CLASS="literal">new</TT>
操作符创建一个类的实例时，构造函数将会自动调用。PHP 3
中，当函数与类同名时，这个函数将成为构造函数。PHP 4
中，在类里定义的函数与类同名时，这个函数将成为一个构造函数 － 区别很微妙，但非常关键（见下文）。
</P><DIV CLASS="informalexample"><A NAME="AEN5755"></A><P></P><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><code><font color="#000000">
<font color="#0000BB">&lt;?php<br /></font><font color="#FF8000">// PHP 3 和 PHP 4 中都能用<br /></font><font color="#007700">class </font><font color="#0000BB">Auto_Cart </font><font color="#007700">extends </font><font color="#0000BB">Cart<br /></font><font color="#007700">{<br />&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000BB">Auto_Cart</font><font color="#007700">()<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000BB">$this</font><font color="#007700">-&gt;</font><font color="#0000BB">add_item </font><font color="#007700">(</font><font color="#DD0000">"10"</font><font color="#007700">, </font><font color="#0000BB">1</font><font color="#007700">);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /></font><font color="#0000BB">?&gt;</font>
</font>
</code></TD></TR></TABLE><P></P></DIV><P>&#13; 上文定义了一个 Auto_Cart 类，即 Cart 类加上一个构造函数，当每次使用“new”创建一个新的 Auto_Cart
类实例时，构造函数将自动调用并将一件商品的数目初始化为“10”。构造函数可以使用参数，而且这些参数可以是可选的，它们可以使构造函数更加有用。为了依然可以不带参数地使用类，所有构造函数的参数应该提供默认值，使其可选。
</P><DIV CLASS="informalexample"><A NAME="AEN5758"></A><P></P><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><code><font color="#000000">
<font color="#0000BB">&lt;?php<br /></font><font color="#FF8000">// PHP 3 和 PHP 4 中都能用<br /></font><font color="#007700">class </font><font color="#0000BB">Constructor_Cart </font><font color="#007700">extends </font><font color="#0000BB">Cart<br /></font><font color="#007700">{<br />&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000BB">Constructor_Cart</font><font color="#007700">(</font><font color="#0000BB">$item </font><font color="#007700">= </font><font color="#DD0000">"10"</font><font color="#007700">, </font><font color="#0000BB">$num </font><font color="#007700">= </font><font color="#0000BB">1</font><font color="#007700">)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000BB">$this</font><font color="#007700">-&gt;</font><font color="#0000BB">add_item </font><font color="#007700">(</font><font color="#0000BB">$item</font><font color="#007700">, </font><font color="#0000BB">$num</font><font color="#007700">);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br /></font><font color="#FF8000">// 买些同样无聊的老货<br /><br /></font><font color="#0000BB">$default_cart </font><font color="#007700">= new </font><font color="#0000BB">Constructor_Cart</font><font color="#007700">;<br /><br /></font><font color="#FF8000">// 买些新东西...<br /><br /></font><font color="#0000BB">$different_cart </font><font color="#007700">= new </font><font color="#0000BB">Constructor_Cart</font><font color="#007700">(</font><font color="#DD0000">"20"</font><font color="#007700">, </font><font color="#0000BB">17</font><font color="#007700">);<br /></font><font color="#0000BB">?&gt;</font>
</font>
</code></TD></TR></TABLE><P></P></DIV><P>&#13; 你也可以使用 <TT CLASS="literal">@</TT>
操作符来<SPAN CLASS="emphasis"><I CLASS="emphasis">消除</I></SPAN>发生在构造函数中的错误。例如 <TT CLASS="literal">@new</TT>。
</P><DIV CLASS="caution"><P></P><TABLE CLASS="caution" BORDER="1" WIDTH="100%"><TR><TD ALIGN="CENTER"><B>注意</B></TD></TR><TR><TD ALIGN="LEFT"><P>&#13; PHP 3 中派生类和构造函数有许多限制。仔细阅读下列范例以理解这些限制。
</P></TD></TR></TABLE></DIV><DIV CLASS="informalexample"><A NAME="AEN5766"></A><P></P><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><code><font color="#000000">
<font color="#0000BB">&lt;?php<br /></font><font color="#007700">class </font><font color="#0000BB">A<br /></font><font color="#007700">{<br />&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000BB">A</font><font color="#007700">()<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#DD0000">"I am the constructor of A.&lt;br&gt;\n"</font><font color="#007700">;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br />class </font><font color="#0000BB">B </font><font color="#007700">extends </font><font color="#0000BB">A<br /></font><font color="#007700">{<br />&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000BB">C</font><font color="#007700">()<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#DD0000">"I am a regular function.&lt;br&gt;\n"</font><font color="#007700">;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br /></font><font color="#FF8000">// PHP 3 中没有构造函数被调用<br /></font><font color="#0000BB">$b </font><font color="#007700">= new </font><font color="#0000BB">B</font><font color="#007700">;<br /></font><font color="#0000BB">?&gt;</font>
</font>
</code></TD></TR></TABLE><P></P></DIV><P>&#13; PHP 3 中，在上面的示例中将不会有构造函数被调用。PHP 3
的规则是：“构造函数是与类同名的函数”。这里，类的名字是 B，但是类 B
中没有函数 B()。什么也不会发生。
</P><P>&#13; PHP 4 修正了这个问题，并介绍了另外的新规则：如果一个类没有构造函数，如果父类有构造函数的话，父类的构造函数将会被调用。PHP 4
中，上面的例子将会输出“I am the constructor of A.&#60;br&#62;”。
</P><DIV CLASS="informalexample"><A NAME="AEN5770"></A><P></P><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><code><font color="#000000">
<font color="#0000BB">&lt;?php<br /></font><font color="#007700">class </font><font color="#0000BB">A<br /></font><font color="#007700">{<br />&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000BB">A</font><font color="#007700">()<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#DD0000">"I am the constructor of A.&lt;br&gt;\n"</font><font color="#007700">;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000BB">B</font><font color="#007700">()<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#DD0000">"I am a regular function named B in class A.&lt;br&gt;\n"</font><font color="#007700">;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#DD0000">"I am not a constructor in A.&lt;br&gt;\n"</font><font color="#007700">;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br />class </font><font color="#0000BB">B </font><font color="#007700">extends </font><font color="#0000BB">A<br /></font><font color="#007700">{<br />&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000BB">C</font><font color="#007700">()<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#DD0000">"I am a regular function.&lt;br&gt;\n"</font><font color="#007700">;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br /></font><font color="#FF8000">// 调用 B() 作为构造函数<br /></font><font color="#0000BB">$b </font><font color="#007700">= new </font><font color="#0000BB">B</font><font color="#007700">;<br /></font><font color="#0000BB">?&gt;</font>
</font>
</code></TD></TR></TABLE><P></P></DIV><P>&#13; 如果是 PHP 3，类 A 中的函数 B() 将立即成为类 B
中的构造函数，虽然并不是有意如此。PHP 3
中的规则是：“构造函数是与类同名的函数”。PHP 3
并不关心函数是不是在类 B
中定义的，或者是否已经被继承。
</P><P>&#13; PHP 4 修改了规则：“构造函数与定义其自身的类同名”。因而在 PHP 4
中，类 B 将不会有属于自身的构造函数，并且父类的构造函数将会被调用，输出“I
am the constructor of A.&#60;br&#62;”。
</P><P>&#13; 【译者注】这里似乎有问题，实际输出的结果，并不象这里说的那样。实际输出的内容是“I
am a regular function named B in class A......”，输出的是 B()
的内容。也就是说，例子中的注释“This will call B() as a constructor”是正确的。如果从 A
类中移除函数 B()，那么将输出 A() 的内容。
</P><DIV CLASS="caution"><P></P><TABLE CLASS="caution" BORDER="1" WIDTH="100%"><TR><TD ALIGN="CENTER"><B>注意</B></TD></TR><TR><TD ALIGN="LEFT"><P>&#13; 不管是 PHP 3 还是 PHP 4
都不会从派生类的构造函数中自动调用基类的构造函数。恰当地逐次调用上一级的构造函数是用户的责任。
</P></TD></TR></TABLE></DIV><DIV CLASS="note"><BLOCKQUOTE CLASS="note"><P><B>注: </B>
PHP 3 或者 PHP 4 中都没有析构函数。你可以使用 <A HREF="function.register-shutdown-function.html"><B CLASS="function">register_shutdown_function()</B></A>
函数来模拟多数析构函数的效果。
</P></BLOCKQUOTE></DIV><P>&#13; 析构函数是一种当对象被销毁时，无论使用了 <A HREF="function.unset.html"><B CLASS="function">unset()</B></A>
或者简单的脱离范围，都会被自动调用的函数。但 PHP 中没有析构函数。
</P></DIV><BR></TD><TD><IMG SRC="spacer.gif" WIDTH="10" HEIGHT="1"></TD></TR><TR><TD COLSPAN="3"><DIV CLASS="NAVFOOTER"><TABLE BGCOLOR="#CCCCFF" BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR BGCOLOR="#333366"><TD><IMG SRC="spacer.gif" BORDER="0" WIDTH="1" HEIGHT="1"><BR></TD></TR><TR><TD><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="3" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="keyword.extends.html" ACCESSKEY="P">后退</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="index-2.html" ACCESSKEY="H">起点</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="keyword.paamayim-nekudotayim.html" ACCESSKEY="N">前进</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><TT CLASS="literal">继承</TT></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="language.oop.html" ACCESSKEY="U">上一级</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><TT CLASS="literal">::</TT></TD></TR></TABLE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<p style="text-align:center;"><script type="text/javascript" src="http://www.veryhuo.com/plus/js/manual.js"></script></p>
<div style="display:none;">
<script type="text/javascript" src="/liehuo.net/js/stat.js"></script>
</div>
</body>
</html>
