<HTML><HEAD><TITLE>安装为 CGI 程序</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK REL="HOME" TITLE="PHP 手册" HREF="index-2.html"><LINK REL="UP" TITLE="安全" HREF="security.index.html"><LINK REL="PREVIOUS" TITLE="安全" HREF="security.index.html"><LINK REL="NEXT" TITLE="安装为 Apache 模块" HREF="security.apache.html"><META HTTP-EQUIV="Content-type" CONTENT="text/html; charset=gb2312"><LINK REL="stylesheet" HREF="style.css"></HEAD><BODY TOPMARGIN="0" LEFTMARGIN="0" CLASS="sect1" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#840084" ALINK="#0000FF"><TABLE BORDER="0" WIDTH="100%" HEIGHT="100%" CELLSPACING="0" CELLPADDING="0"><TR><TD COLSPAN="3"><DIV CLASS="NAVHEADER"><TABLE BGCOLOR="#CCCCFF" BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="3" CELLSPACING="0"><TR><TH COLSPAN="3" ALIGN="center">PHP 手册</TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="bottom"><A HREF="security.index.html" ACCESSKEY="P">后退</A></TD><TD WIDTH="80%" ALIGN="center" VALIGN="bottom">章 15. 安全</TD><TD WIDTH="10%" ALIGN="right" VALIGN="bottom"><A HREF="security.apache.html" ACCESSKEY="N">前进</A></TD></TR></TABLE></TD></TR><TR BGCOLOR="#333366"><TD><IMG SRC="spacer.gif" BORDER="0" WIDTH="1" HEIGHT="1"><BR></TD></TR></TABLE></DIV></TD></TR><TR><TD><IMG SRC="spacer.gif" WIDTH="10" HEIGHT="1"></TD><TD HEIGHT="100%" VALIGN="TOP" WIDTH="100%"><BR><DIV CLASS="sect1"><H1 CLASS="sect1"><A NAME="security.cgi-bin"></A>安装为 CGI 程序</H1><DIV CLASS="sect2"><H2 CLASS="sect2"><A NAME="security.cgi-bin.attacks"></A>可能受到的攻击</H2><P>&#13; 如果您不希望将 PHP 以模块的方式集成到服务器软件（例如 Apache）中，或者希望将 PHP 用于不同的 CGI 外壳来建立安全的 chroot 和 setuid 脚本环境，将 PHP 用作 <SPAN CLASS="acronym">CGI</SPAN> 程序是安装时的一种选择。这样的安装通常都需要将可执行的 PHP 程序放置到 cgi-bin 目录。CERT 顾问 <A HREF="http://www.cert.org/advisories/CA-1996-11.html" TARGET="_top">CA-96.11</A> 的建议反对将任何解释器放入 cgi-bin 目录。尽管 PHP 的可执行程序能够被用作独立的解释器，PHP 的安全机制也能防止由这样的安装所导致的可能的攻击：
</P><P></P><UL><LI><P>&#13; 访问系统文件：<TT CLASS="filename">http://my.host/cgi-bin/php?/etc/passwd</TT>
</P><P>&#13; 在 URL 中问号（?）后面的查询信息将被 CGI 接口作为命令行参数传给解释器。通常情况下，解释器会打开并运行由命令行第一个参数所指明的文件。
</P><P>&#13; 当 PHP 以 CGI 程序的方式被激活时，它将拒绝解释该命令行参数。
</P></LI><LI><P>&#13; 访问服务器上的任何 WEB 文档：<TT CLASS="filename">http://my.host/cgi-bin/php/secret/doc.html</TT>
</P><P>&#13; URL 中 PHP 程序名称后面的路径信息 <TT CLASS="filename">/secret/doc.html</TT> 习惯上是用来指明由 <SPAN CLASS="acronym">CGI</SPAN> 程序打开并解释的文件名。通常 WEB 服务器会通过一些的配置选项（Apache: Action）将对类似于 <TT CLASS="filename">http://my.host/secret/script.php</TT> 文档的请求重定向到 PHP 解释器。WEB 服务器先检查目录 <TT CLASS="filename">/secret</TT> 的访问权限，然后再建立请求的重定向 <TT CLASS="filename">http://my.host/cgi-bin/php/secret/script.php</TT>。但不幸的是，如果请求直接以这种形式给出，那么 WEB 服务器就不会执行对文件 <TT CLASS="filename">/secret/script.php</TT> 的访问权限检查，而仅仅只检查文件 <TT CLASS="filename">/cgi-bin/php</TT> 的访问权限。这样一来，任何可以访问 <TT CLASS="filename">/cgi-bin/php</TT> 的用户都可以访问任何 WEB 服务器上收到保护的文档。
</P><P>&#13; 在 PHP 中，编译时设置选项 <A HREF="install.configure.html#install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</A> 以及运行时设置选项 <A HREF="configuration.directives.html#ini.doc-root">doc_root</A> 和 <A HREF="configuration.directives.html#ini.user-dir">user_dir</A> 能够用来防止这种攻击，如果服务端的目录树存在有访问限制的目录。以下将详细解释各种不同的组合。
</P></LI></UL></DIV><DIV CLASS="sect2"><H2 CLASS="sect2"><A NAME="security.cgi-bin.default"></A>方法一：仅就公众文件提供服务</H2><P>&#13; 如果您的服务器上没有任何不被密码或者基于 IP 访问限制控制的内容，则这些选项配置对您并没有作用。如果您的 WEB 服务器不允许您进行重定向，或者服务器无法和 PHP 程序通信以识别安全的重定向请求，您可以在运行配置脚本的时候使用 <A HREF="install.configure.html#install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</A> 参数。您还需要确认您的 PHP 脚本不仅仅只依赖某一种方法来调用脚本，不管是直接调用 <TT CLASS="filename">http://my.host/cgi-bin/php/dir/script.php</TT>，还是重定向到 <TT CLASS="filename">http://my.host/dir/script.php</TT>。
</P><P>&#13; 在 Apache 中重定向可以使用选项 AddHandler 和 Action 来配置（请参考下文）。
</P></DIV><DIV CLASS="sect2"><H2 CLASS="sect2"><A NAME="security.cgi-bin.force-redirect"></A>方法二：使用 --enable-force-cgi-redirect 参数</H2><P>&#13; 该编译时参数防止任何人通过直接访问类似于 <TT CLASS="filename">http://my.host/cgi-bin/php/secretdir/script.php</TT> 的 URL 来调用 PHP。也就是说，只有当脚本基于合法的重定向规则被访问时，PHP 才对它们进行解析。
</P><P>&#13; 通常 Apache 的重定向设置是通过以下选项完成的：
</P><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE CLASS="apache-conf">Action php-script /cgi-bin/php
AddHandler php-script .php</PRE></TD></TR></TABLE><P>&#13; 该选项仅仅在 Apache WEB 服务器下做过测试，并且依赖 Apache 为被重定向的请求设置非标准的 CGI 环境变量 <TT CLASS="envar">REDIRECT_STATUS</TT>。如果您的 WEB 服务器不支持任何方式以获悉请求是直接的还是被重定向的，您将无法使用该选项。您必须使用本文提及的其它运行 CGI 版本的方法。
</P></DIV><DIV CLASS="sect2"><H2 CLASS="sect2"><A NAME="security.cgi-bin.doc-root"></A>方法三：设置 doc_root 或者 user_dir</H2><P>&#13; 在 WEB 服务器的文档目录中放置诸如脚本和可执行程序等主动的内容，常常被认为是一种不安全的做法。如果由于一些设置的错误，这些脚本没有被执行而像通常的 HTML 文档一样被显示，这将可能导致知识产权或者诸如密码等安全信息的泄漏。因此很多系统管理员宁愿为脚本建立另外一个只能被 PHP CGI 访问的目录结构，使得它们能够被正确解析，又不会出现上述的问题。
</P><P>&#13; 同样，如果如前面章节描述的确保请求不被重定向的方法无效，那么我们就有必要建立一个区别于 WEB 文档根目录脚本的 doc_root 目录。
</P><P>&#13; 您可以通过<A HREF="configuration.html#configuration.file">配置文件</A>中的选项 <A HREF="configuration.directives.html#ini.doc-root">doc_root</A> 或者环境变量 <TT CLASS="envar">PHP_DOCUMENT_ROOT</TT> 来设置 PHP 脚本文档的根目录。如果该选项被设置，那么 PHP 的 CGI 版本将总是只通过 <TT CLASS="parameter"><I>doc_root</I></TT> 和请求的路径信息来打开文档，这样您就可以确保脚本不会在该目录以外执行（除了以下将提及的 <TT CLASS="parameter"><I>user_dir</I></TT> 目录）。
</P><P>&#13; 另外一个这里可能用得到的选项是 <A HREF="configuration.directives.html#ini.user-dir">user_dir</A>。如果 user_dir 没有被设置，那么唯一控制被打开的文件名的选项就是 <TT CLASS="parameter"><I>doc_root</I></TT>。打开一个类似于 <TT CLASS="filename">http://my.host/~user/doc.php</TT> 将不会导致打开一个用户主目录中的文件，而是 doc_root 下一个名为 <TT CLASS="filename">~user/doc.php</TT> 的文件（即一个以波浪号[<TT CLASS="literal">~</TT>]开头的目录名）。
</P><P>&#13; 如果 user_dir 被设置为，例如， <TT CLASS="filename">public_php</TT>，那么类似于 <TT CLASS="filename">http://my.host/~user/doc.php</TT> 地请求将打开一个该用户主目录下名为 <TT CLASS="filename">public_php</TT> 的目录下的名为 <TT CLASS="filename">doc.php</TT> 的文件。如果用户的主目录是 <TT CLASS="filename">/home/user</TT>，那么被执行的文件是 <TT CLASS="filename">/home/user/public_php/doc.php</TT>。
</P><P>&#13; <TT CLASS="parameter"><I>user_dir</I></TT> 扩展并不依赖于 <TT CLASS="parameter"><I>doc_root</I></TT> 选项的设定，因此您可以独立控制文档根目录和用户访问目录。
</P></DIV><DIV CLASS="sect2"><H2 CLASS="sect2"><A NAME="security.cgi-bin.shell"></A>方法四：在 WEB 目录树以外进行 PHP 解析</H2><P>&#13; 一种安全性非常高的方法是把 PHP 解析程序放置到 WEB 文件目录树以外的某个地方，例如，放置到 <TT CLASS="filename">/usr/local/bin</TT>。这种做法唯一的弊病就是您现在需要在所有含有 PHP 标记符文件的第一行添加类似于以下的内容：
<DIV CLASS="informalexample"><A NAME="AEN6103"></A><P></P><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE CLASS="programlisting">#!/usr/local/bin/php</PRE></TD></TR></TABLE><P></P></DIV>
您需要使得这些文件成为可执行文件。也就是说，像对待任何其它 CGI 脚本一样来对待它们。这些 CGI 脚本可能是用 Perl、sh 或者任何其它使用的 <TT CLASS="literal">#!</TT> shell-escape 机制来启动它们自身的脚本语言来编写的。
</P><P>&#13; 要使这个方法中 PHP 能够正确处理 <TT CLASS="envar">PATH_INFO</TT> 和 <TT CLASS="envar">PATH_TRANSLATED</TT> 信息，在编译 PHP 解析器时必须使用配置参数 <A HREF="install.configure.html#install.configure.enable-discard-path">--enable-discard-path</A>。
</P></DIV></DIV><BR></TD><TD><IMG SRC="spacer.gif" WIDTH="10" HEIGHT="1"></TD></TR><TR><TD COLSPAN="3"><DIV CLASS="NAVFOOTER"><TABLE BGCOLOR="#CCCCFF" BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR BGCOLOR="#333366"><TD><IMG SRC="spacer.gif" BORDER="0" WIDTH="1" HEIGHT="1"><BR></TD></TR><TR><TD><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="3" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="security.index.html" ACCESSKEY="P">后退</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="index-2.html" ACCESSKEY="H">起点</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="security.apache.html" ACCESSKEY="N">前进</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">安全</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="security.index.html" ACCESSKEY="U">上一级</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">安装为 Apache 模块</TD></TR></TABLE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<p style="text-align:center;"><script type="text/javascript" src="http://www.veryhuo.com/plus/js/manual.js"></script></p>
<div style="display:none;">
<script type="text/javascript" src="/liehuo.net/js/stat.js"></script>
</div>
</body>
</html>
