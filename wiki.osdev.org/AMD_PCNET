<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>AMD PCNET - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"32c66880ad5c844ffa7a7804","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"AMD_PCNET","wgTitle":"AMD PCNET","wgCurRevisionId":28252,"wgRevisionId":28252,"wgArticleId":3177,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Network Hardware"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"AMD_PCNET","wgRelevantArticleId":3177,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{
"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-AMD_PCNET rootpage-AMD_PCNET skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">AMD PCNET</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="AMD_PCNET#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="AMD_PCNET#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>The <b>AMD PCNET</b> family of network interface chips are supported by most popular virtual machines and emulators, including QEMU, VMware and VirtualBox. While not as simple as the <a href="RTL8139" title="RTL8139">RTL8139</a> it is easier to test with an emulator, as the RTL8139 is only supported in QEMU, and getting QEMU's full network support running is sometimes difficult. This article will focus on the Am79C970A a.k.a. the AMD PCnet-PCI II in VirtualBox.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="AMD_PCNET#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="AMD_PCNET#Initialization_and_Register_Access"><span class="tocnumber">2</span> <span class="toctext">Initialization and Register Access</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="AMD_PCNET#PCI_Configuration"><span class="tocnumber">2.1</span> <span class="toctext">PCI Configuration</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="AMD_PCNET#Card_register_access"><span class="tocnumber">2.2</span> <span class="toctext">Card register access</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="AMD_PCNET#Interrupt_handling"><span class="tocnumber">2.3</span> <span class="toctext">Interrupt handling</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="AMD_PCNET#SWSTYLE"><span class="tocnumber">2.4</span> <span class="toctext">SWSTYLE</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="AMD_PCNET#ASEL"><span class="tocnumber">2.5</span> <span class="toctext">ASEL</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="AMD_PCNET#Ring_buffers"><span class="tocnumber">2.6</span> <span class="toctext">Ring buffers</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="AMD_PCNET#Card_registers_setup"><span class="tocnumber">2.7</span> <span class="toctext">Card registers setup</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="AMD_PCNET#Sending_packets"><span class="tocnumber">3</span> <span class="toctext">Sending packets</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="AMD_PCNET#Handling_interrupts_and_receiving_packets"><span class="tocnumber">4</span> <span class="toctext">Handling interrupts and receiving packets</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="AMD_PCNET#Important_Registers"><span class="tocnumber">5</span> <span class="toctext">Important Registers</span></a>
<ul>
<li class="toclevel-2 tocsection-13"><a href="AMD_PCNET#CSR0:_&quot;The_Controller_Status_Register&quot;"><span class="tocnumber">5.1</span> <span class="toctext">CSR0: "The Controller Status Register"</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="AMD_PCNET#CSR1_and_CSR2:_&quot;Initialization_Block_Addresses&quot;"><span class="tocnumber">5.2</span> <span class="toctext">CSR1 and CSR2: "Initialization Block Addresses"</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="AMD_PCNET#CSR3:_&quot;Interrupt_Masks_and_Deferral_Control&quot;"><span class="tocnumber">5.3</span> <span class="toctext">CSR3: "Interrupt Masks and Deferral Control"</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="AMD_PCNET#CSR58:_&quot;Software_Style&quot;"><span class="tocnumber">5.4</span> <span class="toctext">CSR58: "Software Style"</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-17"><a href="AMD_PCNET#See_Also"><span class="tocnumber">6</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="AMD_PCNET#External_Links"><span class="tocnumber">6.1</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Overview">Overview</span></h2>
<p>The PCnet-PCI II is a PCI network adapter.  It has built-in support for CRC checks and can automatically pad short packets to the minimum Ethernet length.
</p><p>It supports PCI bus mastering and can operate in both 32-bit mode and a legacy 16-bit compatibility mode (this mode is from now on referred to as software style, or SWSTYLE).  Access to the card's registers are through an index/data register system in either IO port space or memory mapped IO.  Given that the MMIO access is sometimes absent on emulators or certain systems, this article will focus on the IO port access.  A final distinction is made between the actual accesses to the index/data registers, which can either be 16-bit or 32-bit.  The 32-bit mode is referred to as DWIO in the specifications (as it implies the DWIO bit is set in a particular register).  Note that any combination of DWIO and SWSTYLE can be selected.
</p>
<h2><span class="mw-headline" id="Initialization_and_Register_Access">Initialization and Register Access</span></h2>
<h3><span class="mw-headline" id="PCI_Configuration">PCI Configuration</span></h3>
<p>In the PCI configuration space, the card has vendor ID 0x1022 and device ID 0x2000.  A separate similar device (PCnet-PCI III and clones) has device ID 0x2001 and is programmed similarly.
</p><p>
The first task of the driver should be to enable the IO ports and bus mastering ability of the device in PCI configuration space.  This is done by setting bits 0 and 2 of the control register, e.g. </p><div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pciConfigReadDWord</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">slot</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span><span class="w"></span>
<span class="n">conf</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="mh">0xffff0000</span><span class="p">;</span><span class="w"> </span><span class="c1">// preserve status register, clear config register</span>
<span class="n">conf</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mh">0x5</span><span class="p">;</span><span class="w">        </span><span class="c1">// set bits 0 and 2</span>
<span class="n">pciConfigWriteDWord</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">slot</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">conf</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>You will then want to read the IO base address of the first BAR from configuration space.  We will assume this has the value io_base.
</p>
<h3><span class="mw-headline" id="Card_register_access">Card register access</span></h3>
<p>As stated above, the card supports a index/data system of accessing its internal registers.  This means that the index of the register you wish to access is first written to an index port, followed by either writing a new value to or reading the old value from a data register.  To make things slightly more complex, however, the card splits its internal registers into two groups - Control and Status Registers (CSR) and Bus Control Registers (BCR).  Both share a common index port (called Register Address Port - RAP), but use separate data ports: the Register Data Port (RDP) for CSRs and the BCR Data Port (BDP) for BCRs.  During normal initialization and use of the cards, the CSRs are used exclusively.  A further important register exists in the IO space called the reset register.
</p><p>A further complication exists in that the offsets of the RAP, Reset register and BDP (but not RDP) relative to io_base vary depending on the current value of DWIO:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th colspan="2">DWIO = 0 (16-bit access)
</th>
<th colspan="2">DWIO = 1 (32-bit access)
</th>
<th>Register
</th></tr>
<tr>
<th>Offset
</th>
<th>Length
</th>
<th>Offset
</th>
<th>Length
</th>
<th>
</th></tr>
<tr>
<td>0</td>
<td>16</td>
<td>0</td>
<td>16</td>
<td>First 16 bytes of EPROM (the first 6 bytes are MAC address)
</td></tr>
<tr>
<td>0x10</td>
<td>2</td>
<td>0x10</td>
<td>4</td>
<td>RDP - data register for CSRs
</td></tr>
<tr>
<td>0x12</td>
<td>2</td>
<td>0x14</td>
<td>4</td>
<td>RAP - index register for both CSR and BCR access
</td></tr>
<tr>
<td>0x14</td>
<td>2</td>
<td>0x18</td>
<td>4</td>
<td>Reset register
</td></tr>
<tr>
<td>0x16</td>
<td>2</td>
<td>0x1c</td>
<td>4</td>
<td>BDP - data register for BCRs
</td></tr></tbody></table><p>
In addition, the card requires different length data accesses to the registers depending on the setting of DWIO: if DWIO=0, then offsets 0x0 through 0xf are read as single bytes, all others read/written as 16-bit words; if DWIO=1, then all registers (including 0x0 through 0xf) are read/written as 32-bit double words (and with accesses aligned on 32-bit boundaries).  We can write functions to access the registers:</p><div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">writeRAP32</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">outd</span><span class="p">(</span><span class="n">io_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x14</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">writeRAP16</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">outw</span><span class="p">(</span><span class="n">io_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x12</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">readCSR32</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">csr_no</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">writeRAP32</span><span class="p">(</span><span class="n">csr_no</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ind</span><span class="p">(</span><span class="n">io_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x10</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">uint16_t</span><span class="w"> </span><span class="nf">readCSR16</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">csr_no</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">writeRAP32</span><span class="p">(</span><span class="n">csr_no</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">inw</span><span class="p">(</span><span class="n">io_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x10</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">writeCSR32</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">csr_no</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">writeRAP32</span><span class="p">(</span><span class="n">csr_no</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">outd</span><span class="p">(</span><span class="n">io_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x10</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">writeCSR16</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">csr_no</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">writeRAP16</span><span class="p">(</span><span class="n">csr_no</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">outw</span><span class="p">(</span><span class="n">io_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x10</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>and similar functions for BCRs.
</p><p>
Unfortunately it is difficult to determine the current state of DWIO (and therefore know which state the card is in when the driver initializes) as the only way of reporting it is to read BCR18 bit 7, which in turn requires knowledge of the BDP, which requires knowledge of DWIO etc.  Fortunately, following a reset (either hard or soft), the card is in a known state with DWIO=0 (16-bit access).  Normally, therefore, when your driver takes control of the card, it would expect to assume it is in 16-bit mode.  However, it may be the case that firmware or a boot-loader has already initialized the card into 32-bit mode, which you didn't know about.  You should, therefore, reset the card when your driver takes control.  This is accomplished by a read of the reset register:</p><div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">ind</span><span class="p">(</span><span class="n">io_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x18</span><span class="p">);</span><span class="w"></span>
<span class="n">inw</span><span class="p">(</span><span class="n">io_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x14</span><span class="p">);</span><span class="w"></span>
</pre></div><p>Note this snippet reads first from the 32-bit reset register: if the card is in 32-bit mode this will trigger a reset, if in 16-bit mode it will simply read garbage without affecting the card.  It then reads from the 16-bit reset register: if the card was initially in 32-bit mode, it has since been reset and will now be reset again, otherwise it will reset for the first time.
</p><p>You should now wait 1 microsecond for the reset to complete (using your OSs timing functions).
</p><p>
Then, if desired, you can program the card into 32-bit mode (the rest of this article assumes this, but you can easily substitute read/writeCSR32 with read/writeCSR16 if you like).  To do this, we simply need to perform a 32 bit write of 0 to the RDP.  After reset, RAP points to CSR0, so we are effectively writing 0 to CSR0.  This will not cause any harm as we completely reprogram CSR0 later anyway.</p><div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">outd</span><span class="p">(</span><span class="n">io_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x10</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Interrupt_handling">Interrupt handling</span></h3>
<p>The next section will enable some interrupts on the card.  We will flesh out the interrupt handler later, but you should install the interrupt handler here as otherwise you will get crashes due to unhandled interrupts.  You need to parse <a href="ACPI" title="ACPI">ACPI</a> tables etc. to determine the proper interrupt routing for your device.
</p>
<h3><span class="mw-headline" id="SWSTYLE">SWSTYLE</span></h3><p>
We now need to set the value of SWSTYLE to 2.  After reset, it defaults to 0 representing 16-bit legacy compatibility mode.  We want the card to be able to access all of the first 4 GiB of (physical) memory for its buffers, so need to set it to 32-bit mode.</p><div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">csr58</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readCSR32</span><span class="p">(</span><span class="mi">58</span><span class="p">);</span><span class="w"></span>
<span class="n">csr58</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="mh">0xFF00</span><span class="p">;</span><span class="w">  </span><span class="c1">// SWSTYLE is 8 bits (7:0)</span>
<span class="n">csr58</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">writeCSR32</span><span class="p">(</span><span class="mi">58</span><span class="p">,</span><span class="w"> </span><span class="n">csr58</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="ASEL">ASEL</span></h3><p>
The card has both 10/100baseT and coaxial outputs.  It has functionality to automatically select whichever is attached which is normally enabled by default.  This snippet simply ensures this functionality is enabled by setting the ASEL bit in BCR2 just in case firmware has altered this for some reason.</p><div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bcr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readBCR32</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="n">bcr2</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mh">0x2</span><span class="p">;</span><span class="w"></span>
<span class="n">writeBCR32</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">bcr2</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Ring_buffers">Ring buffers</span></h3>
<p>The card uses two ring buffers to store packets: one for packets received and one for packets to be transmitted.  The actual ring buffers themselves are regions of physical memory containing a set number of descriptor entries (DEs) which are fixed 16 bytes in length (for SWSTYLE=2).  Each of these then contains a pointer to the actual physical address of the memory used for the packet.
</p><p>For example, if you wish to define 32 receive buffers and 8 transmit buffers (similar to what the Linux driver does), then you would need to allocate 32 * 16 bytes for the receive DEs, 8 * 16 bytes for the transmit DEs, 32 * packet length (1544 is used in Linux, but we will use 1520 as it is a multiple of 16) for the actual receive buffers and 8 * packet length for the actual transmit buffers.
</p><p>The DEs contain a number of important bits for sending/receiving packets, e.g. destination MAC address, error bits etc. but they also contain an important bit called the ownership bit (bit 7 of byte 7).  If this is cleared, it means the driver 'owns' that particular ring buffer entry.  If it is set, it means the card owns it (and the driver should not touch the entire entry).  The way this works is that the only party (driver or card) that can read/write the entry is the one that owns it, and particularly only the owning party can flip ownership back to the other party.  At initialization, you would want the card to 'own' all the receive buffers (OWN = 1) (so it can write new packets into them that it receives, then flip ownership to the driver), and the driver to 'own' all the transmit buffers (OWN = 0) (so it can write packets to be transmitted, then flip ownership to the card).  For the Transmit Ring, remember to not set the OWNer bit until you have a buffer to transmit.
</p><p>You should also have a variable that stores the current 'pointer' into each buffer (i.e. what is the next one the driver expects to read/write).  The card maintains separate pointers internally.  You also need a simple way of incrementing the pointer (and wrapping back to the start if necessary).
</p><p>
Thus to initialize the ring buffers you'd want something like:</p><div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">rx_buffer_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">tx_buffer_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                 </span><span class="c1">// pointers to transmit/receive buffers</span>

<span class="kt">int</span><span class="w"> </span><span class="n">rx_buffer_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w">              </span><span class="c1">// total number of receive buffers</span>
<span class="kt">int</span><span class="w"> </span><span class="n">tx_buffer_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">               </span><span class="c1">// total number of transmit buffers</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1520</span><span class="p">;</span><span class="w">          </span><span class="c1">// length of each packet buffer</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">de_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w">                </span><span class="c1">// length of descriptor entry</span>

<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">rdes</span><span class="p">;</span><span class="w">                         </span><span class="c1">// pointer to ring buffer of receive DEs</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">tdes</span><span class="p">;</span><span class="w">                         </span><span class="c1">// pointer to ring buffer of transmit DEs</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">rx_buffers</span><span class="p">;</span><span class="w">                   </span><span class="c1">// physical address of actual receive buffers (&lt; 4 GiB)</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">tx_buffers</span><span class="p">;</span><span class="w">                   </span><span class="c1">// physical address of actual transmit buffers (&lt; 4 GiB)</span>

<span class="c1">// does the driver own the particular buffer?</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">driverOwns</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">des</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">des</span><span class="p">[</span><span class="n">de_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x80</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// get the next transmit buffer index</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">nextTxIdx</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cur_tx_idx</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur_tx_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tx_buffer_count</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// get the next receive buffer index</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">nextRxIdx</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cur_rx_idx</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur_rx_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rx_buffer_count</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// initialize a DE</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">initDE</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">des</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">is_tx</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">des</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">de_size</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">de_size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// first 4 bytes are the physical address of the actual buffer</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">buf_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx_buffers</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">is_tx</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">buf_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tx_buffers</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">des</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">de_size</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf_addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">buffer_size</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// next 2 bytes are 0xf000 OR&#39;d with the first 12 bits of the 2s complement of the length</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">bcnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="o">-</span><span class="n">buffer_size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">bcnt</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="mh">0x0fff</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bcnt</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mh">0xf000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">des</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">de_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcnt</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// finally, set ownership bit - transmit buffers are owned by us, receive buffers by the card</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">is_tx</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">des</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">de_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x80</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Card_registers_setup">Card registers setup</span></h3>
<p>Finally, once all our ring buffers are set up, we need to give their addresses to the card.  There are two ways of setting up the card registers: we can either program them all directly, or set up a special initialization structure and then pass that to the card.  In this article we will use the latter.
</p><p>You will need to allocate a 28 byte region of physical memory, aligned on a 32-bit boundary.  The members are:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Offset (bytes)
</th>
<th>Byte 3
</th>
<th>Byte 2
</th>
<th>Byte 1
</th>
<th>Byte 0
</th></tr>
<tr>
<td>0</td>
<td>TLEN(7:4)*</td>
<td>RLEN(7:4)*</td>
<td colspan="2">MODE
</td></tr>
<tr>
<td>4</td>
<td>MAC[3]</td>
<td>MAC[2]</td>
<td>MAC [1]</td>
<td>MAC[0]
</td></tr>
<tr>
<td>8</td>
<td colspan="2">Reserved (0)</td>
<td>MAC[5]</td>
<td>MAC[4]
</td></tr>
<tr>
<td>12</td>
<td>LADR[3]</td>
<td>LADR[2]</td>
<td>LADR[1]</td>
<td>LADR[0]
</td></tr>
<tr>
<td>16</td>
<td>LADR[7]</td>
<td>LADR[6]</td>
<td>LADR[5]</td>
<td>LADR[4]
</td></tr>
<tr>
<td>20</td>
<td colspan="4">Physical address of first receive descriptor entry
</td></tr>
<tr>
<td>24</td>
<td colspan="4">Physical address of first transmit descriptor entry
</td></tr></tbody></table>
<p>Note that TLEN and RLEN are the log2 of the number of transmit and receive descriptor entries respectively and are in the high order nibble of the byte while the lower nibble of the byte is reserved.  For example, if you have 8 transmit descriptor entries, TLEN would be 3 (as 2^3 = 8). The maximum value of TLEN and RLEN is 9 (i.e. 512 buffers).  However, after initialization, you may change this to a maximum of 65535 byte writing to the CSR76 and CSR78 registers.
</p><p>MODE provides various functions to control how the card works with regards to sending and receiving packets, and running loop-back tests.  You probably want to set it to zero (enable transmit and receive functionality, receive broadcast packets and those sent this physical address, disable promiscuous mode).  See the spec description of CSR15 for further details.
</p><p>You also need to specify the physical address (MAC address) you want the card to use.  If you want to keep the current one, you will need to first read it from the EPROM of the card (it is exposed as the first 6 bytes of the IO space that the registers are in).
</p><p>LADR is the logical address filter you want the card to use when deciding to accept Ethernet packets with logical addressing.  If you do not wish to use logical addressing (the default), then set these bytes to zero.
</p><p>To actually set up the card registers, we provide it with the address of our initialization structure by writing the low 16-bits of its address to CSR1 and the high 16-bits to CSR2.
</p><p>You can also set up other registers at this point, e.g. CSR3 (only interesting bits shown):
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bit number
</th>
<th>Functionality
</th></tr>
<tr>
<td>10</td>
<td>Receive interrupt mask - if set then incoming packets won't trigger an interrupt
</td></tr>
<tr>
<td>9</td>
<td>Transmit interrupt mask - if set then an interrupt won't be triggered when a packet has completed sending.  Depending on your design this may be preferable.
</td></tr>
<tr>
<td>8</td>
<td>Interrupt done mask - if set then you won't get an interrupt when the card has finished initializing.  You probably want this as it is far easier to poll for this situation (which only occurs once anyway).
</td></tr>
<tr>
<td>2</td>
<td>Big-endian enable - you will want to ensure this is cleared to zero
</td></tr></tbody></table>
<p>And you may want to set bit 11 of CSR4 which automatically pads Ethernet packets which are too short to be at least 64 bytes.
</p><p>Once all the control registers are set up, you set bit 0 of CSR0, and then wait for initialization to be done.  You can do this by either waiting for an interrupt (if you didn't disable the initialization done interrupt in CSR3) or by polling until CSR0 bit 8 is set.  Note that if you want to wait for an interrupt you will also need to set bit 6 of CSR0 or interrupts won't be generated (you will need to enable this anyway to get notification of received packets, so it makes sense to set it at the same time as the initialization bit).
</p><p>Once initialization has completed, you can finally start the card.  This is accomplished by clearing both the INIT bit (bit 0) and STOP bit (bit 2) in CSR0 and setting the STRT bit (bit 1) at the same time.
</p>
<h2><span class="mw-headline" id="Sending_packets">Sending packets</span></h2>
<p>Sending packets involves simply writing the packet details to the next available transmit buffer, then flipping the ownership for the particular ring buffer entry to the card.  The card regularly scans all the transmit buffers looking for one it hasn't sent, and then will transmit those it finds.
</p><p>
For example:</p><div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">sendPacket</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">packet</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// the next available descriptor entry index is in tx_buffer_ptr</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">driverOwns</span><span class="p">(</span><span class="n">tdes</span><span class="p">,</span><span class="w"> </span><span class="n">tx_buffer_ptr</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// we don&#39;t own the next buffer, this implies all the transmit</span>
<span class="w">        </span><span class="c1">//  buffers are full and the card hasn&#39;t sent them yet.</span>
<span class="w">        </span><span class="c1">// A fully functional driver would therefore add the packet to</span>
<span class="w">        </span><span class="c1">//  a queue somewhere, and wait for the transmit done interrupt</span>
<span class="w">        </span><span class="c1">//  then try again.  We simply fail and return.  You can set</span>
<span class="w">        </span><span class="c1">//  bit 3 of CSR0 here to encourage the card to send all buffers.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// copy the packet data to the transmit buffer.  An alternative would</span>
<span class="w">    </span><span class="c1">//  be to update the appropriate transmit DE to point to &#39;packet&#39;, but</span>
<span class="w">    </span><span class="c1">//  then you would need to ensure that packet is not invalidated before</span>
<span class="w">    </span><span class="c1">//  the card has a chance to send the data.</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">tx_buffers</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tx_buffer_ptr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">buffer_size</span><span class="p">),</span><span class="w"> </span><span class="n">packet</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// set the STP bit in the descriptor entry (signals this is the first</span>
<span class="w">    </span><span class="c1">//  frame in a split packet - we only support single frames)</span>
<span class="w">    </span><span class="n">tdes</span><span class="p">[</span><span class="n">tx_buffer_ptr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">de_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mh">0x2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// similarly, set the ENP bit to state this is also the end of a packet</span>
<span class="w">    </span><span class="n">tdes</span><span class="p">[</span><span class="n">tx_buffer_ptr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">de_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mh">0x1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// set the BCNT member to be 0xf000 OR&#39;d with the first 12 bits of the</span>
<span class="w">    </span><span class="c1">//  two&#39;s complement of the length of the packet</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">bcnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="o">-</span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">bcnt</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="mh">0xfff</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bcnt</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mh">0xf000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tdes</span><span class="p">[</span><span class="n">tx_buffer_ptr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">de_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcnt</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// finally, flip the ownership bit back to the card</span>
<span class="w">    </span><span class="n">tdes</span><span class="p">[</span><span class="n">tx_buffer_ptr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">de_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mh">0x80</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// update the next transmit pointer</span>
<span class="w">    </span><span class="n">tx_buffer_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nextTxIdx</span><span class="p">(</span><span class="n">tx_buffer_ptr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Handling_interrupts_and_receiving_packets">Handling interrupts and receiving packets</span></h2>
<p>Receiving packets is normally done in your interrupt handler - the card will signal an interrupt whenever it receives a packet and has written it to the receive buffer.
</p><p>Note that interrupts can come from many sources (other than new packets).  If a new packet has been signaled then CSR0 bit 10 will be set.  There are other bits in CSR0 than can be set (depending on how you set up interrupt masks in CSR3) and additionally other bits in CSR4 that can signal interrupts (although these are usually masked out on reset).  After you have properly handled an interrupt, you will need to write a 1 back to the appropriate bit in CSR0 or CSR4 before sending EOI to you interrupt controller (or the interrupt will continue to be signaled).  Bitwise OR CSR0 with 0x7F00 and bitwise OR CSR4 with 0x022A will reset all interrupts.  Remember to preserve bit 6 in CSR0 and bit 11 in CSR4.
</p><p>
Once a receive packet interrupt has been received, you need to loop through the receive descriptor entries (starting at rx_buffer_ptr) handling each packet until you find an entry which the driver doesn't own, then stop.  e.g. </p><div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">handleReceiveInterrupt</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">driverOwns</span><span class="p">(</span><span class="n">rdes</span><span class="p">,</span><span class="w"> </span><span class="n">rx_buffer_ptr</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// packet length is given by bytes 8 and 9 of the descriptor</span>
<span class="w">        </span><span class="c1">//  (no need to negate it unlike BCNT above)</span>
<span class="w">        </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">plen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rdes</span><span class="p">[</span><span class="n">rx_buffer_ptr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">de_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">8</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="c1">// the packet itself is written somewhere in the receive buffer</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pbuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">rx_buffers</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rx_buffer_ptr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">buffer_size</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// do something with the packet (i.e. hand to the next layer in the</span>
<span class="w">        </span><span class="c1">//  network stack).  You probably don&#39;t want to do any extensive</span>
<span class="w">        </span><span class="c1">//  processing here (as this is within an interrupt handler) - just</span>
<span class="w">        </span><span class="c1">//  copy the data somewhere to a queue and continue so that the</span>
<span class="w">        </span><span class="c1">//  system is interrupted for as little time as possible</span>
<span class="w">        </span><span class="n">handlePacket</span><span class="p">(</span><span class="n">pbuf</span><span class="p">,</span><span class="w"> </span><span class="n">plen</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// hand the buffer back to the card</span>
<span class="w">        </span><span class="n">rdes</span><span class="p">[</span><span class="n">rx_buffer_ptr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">de_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x80</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// increment rx_buffer_ptr;</span>
<span class="w">        </span><span class="n">rx_buffer_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nextRxIdx</span><span class="p">(</span><span class="n">rx_buffer_ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// set interrupt as handled</span>
<span class="w">    </span><span class="n">writeCSR32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">readCSR32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x0400</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// don&#39;t forget to send EOI</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Important_Registers">Important Registers</span></h2>
<h3><span id="CSR0:_.22The_Controller_Status_Register.22"></span><span class="mw-headline" id="CSR0:_&quot;The_Controller_Status_Register&quot;">CSR0: "The Controller Status Register"</span></h3>
<p>The CSR0 is a register that contains flags indicating the cause of an interrupt. Writing a 1 to a flag's bit position clears the corresponding flag, allowing drivers to clear the interrupt flags by simple reading and writing back the read value to the register.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bit</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>31-16</td>
<td>RES</td>
<td>Reserved. Written as ZEROs and read as undefined.
</td></tr>
<tr>
<td>15</td>
<td>ERR</td>
<td>Error flag that is set when any of the error flags (BABL, CERR, MISS, MERR and ERR) are true.
</td></tr>
<tr>
<td>14</td>
<td>BABL</td>
<td>Babble flag indicating a transmitter timeout error.
</td></tr>
<tr>
<td>13</td>
<td>CERR</td>
<td>Collision Error flag indicating a failure in collision detection.
</td></tr>
<tr>
<td>12</td>
<td>MISS</td>
<td>Missed Frame flag indicating the loss of an incoming receive frame.
</td></tr>
<tr>
<td>11</td>
<td>MERR</td>
<td>Memory Error flag indicating a timeout waiting for the bus.
</td></tr>
<tr>
<td>10</td>
<td>RINT</td>
<td>Receive Interrupt flag indicating the completion of a receive frame.
</td></tr>
<tr>
<td>9</td>
<td>TINT</td>
<td>Transmit Interrupt flag indicating the completion of a transmit frame.
</td></tr>
<tr>
<td>8</td>
<td>IDON</td>
<td>Initialization Done flag indicating the completion of the initialization sequence.
</td></tr>
<tr>
<td>7</td>
<td>INTR</td>
<td>Interrupt Flag indicating the occurrence of one or more interrupt-causing conditions.
</td></tr>
<tr>
<td>6</td>
<td>IENA</td>
<td>Interrupt Enable flag enabling INTA to be active if the Interrupt Flag is set.
</td></tr>
<tr>
<td>5</td>
<td>RXON</td>
<td>Receive On flag indicating that the receive function is enabled.
</td></tr>
<tr>
<td>4</td>
<td>TXON</td>
<td>Transmit On flag indicating that the transmit function is enabled.
</td></tr>
<tr>
<td>3</td>
<td>TDMD</td>
<td>Transmit Demand flag causing buffer management unit access without waiting for the poll-time counter.
</td></tr>
<tr>
<td>2</td>
<td>STOP</td>
<td>Stop flag disabling the chip from all DMA and network activity.
</td></tr>
<tr>
<td>1</td>
<td>STRT</td>
<td>Start flag enabling the PCnet-PCI II controller to send and receive frames and perform buffer management operations.
</td></tr>
<tr>
<td>0</td>
<td>INIT</td>
<td>Initialization flag enabling the PCnet-PCI II controller to begin the initialization procedure.
</td></tr></tbody></table>
<h3><span id="CSR1_and_CSR2:_.22Initialization_Block_Addresses.22"></span><span class="mw-headline" id="CSR1_and_CSR2:_&quot;Initialization_Block_Addresses&quot;">CSR1 and CSR2: "Initialization Block Addresses"</span></h3>
<p>As mentioned in <a href="AMD_PCNET#Card_registers_setup">Card registers setup</a> these registers are used to provide the physical address of the initialization struct.
</p>
<table class="wikitable">
<caption>CSR1
</caption>
<tbody><tr>
<th>Bit</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>31–16</td>
<td>RES</td>
<td>Reserved.
</td></tr>
<tr>
<td>15–0</td>
<td>IADR[15:0]</td>
<td>Lower 16 bits of the initialization block address. Read/Write accessible when STOP or SPND bit is set.
</td></tr></tbody></table>
<table class="wikitable">
<caption>CSR2
</caption>
<tbody><tr>
<th>Bit</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>31–16</td>
<td>RES</td>
<td>Reserved.
</td></tr>
<tr>
<td>15–0</td>
<td>IADR[15:0]</td>
<td>Upper 16 bits of the initialization block address. Read/Write accessible when STOP or SPND bit is set.
</td></tr></tbody></table>
<h3><span id="CSR3:_.22Interrupt_Masks_and_Deferral_Control.22"></span><span class="mw-headline" id="CSR3:_&quot;Interrupt_Masks_and_Deferral_Control&quot;">CSR3: "Interrupt Masks and Deferral Control"</span></h3>
<p>This register is used to control the various masks of the interrupts the card generates. 
</p>
<table class="wikitable">

<tbody><tr>
<th>Bit</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>15</td>
<td>RES</td>
<td>Reserved. Read and written as ZERO.
</td></tr>
<tr>
<td>14</td>
<td>BABLM</td>
<td>Babble Mask. If BABLM is set, the BABL bit will be masked and unable to set the INTR bit.
</td></tr>
<tr>
<td>13</td>
<td>RES</td>
<td>Reserved. Read and written as ZERO.
</td></tr>
<tr>
<td>12</td>
<td>MISSM</td>
<td>Missed Frame Mask. If MISSM is set, the MISS bit will be masked and unable to set the INTR bit.
</td></tr>
<tr>
<td>11</td>
<td>MERRM</td>
<td>Memory Error Mask. If MERRM is set, the MERR bit will be masked and unable to set the INTR bit.
</td></tr>
<tr>
<td>10</td>
<td>RINTM</td>
<td>Receive Interrupt Mask. If RINTM is set, the RINT bit will be masked and unable to set the INTR bit.
</td></tr>
<tr>
<td>9</td>
<td>TINTM</td>
<td>Transmit Interrupt Mask. If TINTM is set, the TINT bit will be masked and unable to set the INTR bit.
</td></tr>
<tr>
<td>8</td>
<td>IDONM</td>
<td>Initialization Done Mask. If IDONM is set, the IDON bit will be masked and unable to set the INTR bit.
</td></tr>
<tr>
<td>7</td>
<td>RES</td>
<td>Reserved. Read and written as ZERO.
</td></tr>
<tr>
<td>6</td>
<td>DXSUFLO</td>
<td>Disable Transmit Stop on Underflow error.
</td></tr>
<tr>
<td>5</td>
<td>LAPPEN</td>
<td>Look Ahead Packet Processing Enable.
</td></tr>
<tr>
<td>4</td>
<td>DXMT2PD</td>
<td>Disable Transmit Two Part Deferral.
</td></tr>
<tr>
<td>3</td>
<td>EMBA</td>
<td>Enable Modified Back-off Algorithm.
</td></tr>
<tr>
<td>2</td>
<td>BSWP</td>
<td>Byte Swap (Endianness control, 1 for big-endian, 0 for little endian).
</td></tr>
<tr>
<td>1</td>
<td>RES</td>
<td>Reserved. The default value of this bit is a ZERO.
</td></tr>
<tr>
<td>0</td>
<td>RES</td>
<td>Reserved. The default value of this bit is a ZERO.
</td></tr></tbody></table>
<h3><span id="CSR58:_.22Software_Style.22"></span><span class="mw-headline" id="CSR58:_&quot;Software_Style&quot;">CSR58: "Software Style"</span></h3>
<p>As mentioned in <a href="AMD_PCNET#SWSTYLE">SWSTYLE</a> allows the driver to set various behaviors of the card. In the above example we set bit 2 and clear the other bits 0-7 to set SWSTYLE=2, ie. use 32-bit structures. 
</p>
<table class="wikitable">

<tbody><tr>
<th>Bit</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>31–16</td>
<td>RES</td>
<td>Reserved. Written as ZEROs and read as undefined.
</td></tr>
<tr>
<td>15–11</td>
<td>RES</td>
<td>Reserved. Written as ZEROs and read as undefined.
</td></tr>
<tr>
<td>10</td>
<td>APERREN</td>
<td>Advanced Parity Error Handling Enable. When set, indicates that the BPE bits (RMD1 and TMD1, bit 23) are used to indicate parity errors in data transfers to the receive and transmit buffers.
</td></tr>
<tr>
<td>9</td>
<td>CSRPCNET</td>
<td>CSR PCnet-ISA Configuration. When set, indicates that the PCnet-PCI II controller register bits of CSR4 and CSR3 will map directly to the CSR4 and CSR3 bits of the PCnet-ISA (Am79C960) device.
</td></tr>
<tr>
<td>8</td>
<td>SSIZE32</td>
<td>32-Bit Software Size. When set, indicates that the controller should use 32-bit structures for the initialization block and the transmit and receive descriptor entries, as set above.
</td></tr>
<tr>
<td>7–0</td>
<td>SWSTYLE</td>
<td>Software Style Register. Determines the style of register and memory resources used by the controller.
</td></tr></tbody></table>
<p><br />
</p>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="https://pdf1.alldatasheet.com/datasheet-pdf/view/89876/AMD/AM79C970.html">Specification</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250212010719
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.074 seconds
Real time usage: 1.228 seconds
Preprocessor visited node count: 117/1000000
Post‐expand include size: 648/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 33731/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00% 1054.576      1 -total
  0.09%    0.938      4 Template:Wikitable
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:3177-0!canonical and timestamp 20250212010717 and revision id 28252.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=AMD_PCNET&amp;oldid=28252">https://wiki.osdev.org/index.php?title=AMD_PCNET&amp;oldid=28252</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Network_Hardware" title="Category:Network Hardware">Network Hardware</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=AMD+PCNET" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="AMD_PCNET#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="AMD_PCNET" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Talk:AMD_PCNET&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="AMD_PCNET"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=AMD_PCNET&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=AMD_PCNET&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/AMD_PCNET" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/AMD_PCNET" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=AMD_PCNET&amp;oldid=28252" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=AMD_PCNET&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/AMD_PCnet" title="AMD PCnet – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 18 July 2023, at 00:32.</li>
	<li id="footer-info-0">This page has been accessed 6,808 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=AMD_PCNET&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.074","walltime":"1.228","ppvisitednodes":{"value":117,"limit":1000000},"postexpandincludesize":{"value":648,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":33731,"limit":5000000},"timingprofile":["100.00% 1054.576      1 -total","  0.09%    0.938      4 Template:Wikitable"]},"cachereport":{"timestamp":"20250212010719","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":1321});});</script>
</body>
</html>