<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>User:Mduft/HigherHalf Kernel with 32-bit Paging - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"d8e827abe5d586a562ee187b","wgCSPNonce":false,"wgCanonicalNamespace":"User","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":2,"wgPageName":"User:Mduft/HigherHalf_Kernel_with_32-bit_Paging","wgTitle":"Mduft/HigherHalf Kernel with 32-bit Paging","wgCurRevisionId":11041,"wgRevisionId":11041,"wgArticleId":2942,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["In Progress"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"User:Mduft/HigherHalf_Kernel_with_32-bit_Paging","wgRelevantArticleId":2942,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,
"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRelevantUserName":"Mduft","wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head","mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="../favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="../opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="../api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-2 ns-subject page-User_Mduft_HigherHalf_Kernel_with_32-bit_Paging rootpage-User_Mduft skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-namespace">User</span><span class="mw-page-title-separator">:</span><span class="mw-page-title-main">Mduft/HigherHalf Kernel with 32-bit Paging</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="HigherHalf_Kernel_with_32-bit_Paging#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="HigherHalf_Kernel_with_32-bit_Paging#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><center>
<table style="border: 1px solid #cfcfbf; margin-top: 25px; margin-bottom: 25px; background-color: #f0f0ff; text-align: center;">
<tbody><tr>
<td>
<p><a href="../File:Under_Construction.png" class="image" title="This page is under construction!"><img alt="This page is under construction!" src="../images/1/14/Under_Construction.png" decoding="async" width="50" height="50" data-file-width="50" data-file-height="50" /></a>
This page or section is a work in progress and may thus be incomplete. Its content may be changed in the near future.
</p>
</td>
<td>
</td></tr></tbody></table>
</center>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="HigherHalf_Kernel_with_32-bit_Paging#Welcome"><span class="tocnumber">1</span> <span class="toctext">Welcome</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="HigherHalf_Kernel_with_32-bit_Paging#QEMU"><span class="tocnumber">1.1</span> <span class="toctext">QEMU</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-3"><a href="HigherHalf_Kernel_with_32-bit_Paging#Boot_code_Structure"><span class="tocnumber">2</span> <span class="toctext">Boot code Structure</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="HigherHalf_Kernel_with_32-bit_Paging#Thinking_about_it"><span class="tocnumber">3</span> <span class="toctext">Thinking about it</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="HigherHalf_Kernel_with_32-bit_Paging#boot.S"><span class="tocnumber">4</span> <span class="toctext">boot.S</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="HigherHalf_Kernel_with_32-bit_Paging#Global_symbols"><span class="tocnumber">4.1</span> <span class="toctext">Global symbols</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="HigherHalf_Kernel_with_32-bit_Paging#The_required_.data_stuff"><span class="tocnumber">4.2</span> <span class="toctext">The required .data stuff</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="HigherHalf_Kernel_with_32-bit_Paging#Use_the_.data_section"><span class="tocnumber">4.2.1</span> <span class="toctext">Use the .data section</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="HigherHalf_Kernel_with_32-bit_Paging#Make_room_for_the_PD_and_PTs"><span class="tocnumber">4.2.2</span> <span class="toctext">Make room for the PD and PTs</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="HigherHalf_Kernel_with_32-bit_Paging#Make_room_for_the_Stack"><span class="tocnumber">4.2.3</span> <span class="toctext">Make room for the Stack</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="HigherHalf_Kernel_with_32-bit_Paging#Strings"><span class="tocnumber">4.2.4</span> <span class="toctext">Strings</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="HigherHalf_Kernel_with_32-bit_Paging#The_actual_code"><span class="tocnumber">4.3</span> <span class="toctext">The actual code</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="HigherHalf_Kernel_with_32-bit_Paging#Use_the_.text_Section"><span class="tocnumber">4.3.1</span> <span class="toctext">Use the .text Section</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="HigherHalf_Kernel_with_32-bit_Paging#Now_for_the_exception_to_the_rule"><span class="tocnumber">4.3.2</span> <span class="toctext">Now for the exception to the rule</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="HigherHalf_Kernel_with_32-bit_Paging#Required_symbols_for_the_screen_buffer"><span class="tocnumber">4.3.3</span> <span class="toctext">Required symbols for the screen buffer</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="HigherHalf_Kernel_with_32-bit_Paging#The_entry_point"><span class="tocnumber">4.3.4</span> <span class="toctext">The entry point</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="HigherHalf_Kernel_with_32-bit_Paging#The_simple_printing_function"><span class="tocnumber">4.3.5</span> <span class="toctext">The simple printing function</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="HigherHalf_Kernel_with_32-bit_Paging#Initialize_Paging"><span class="tocnumber">4.3.6</span> <span class="toctext">Initialize Paging</span></a>
<ul>
<li class="toclevel-4 tocsection-19"><a href="HigherHalf_Kernel_with_32-bit_Paging#Getting_the_PD_and_PTs_right"><span class="tocnumber">4.3.6.1</span> <span class="toctext">Getting the PD and PTs right</span></a></li>
<li class="toclevel-4 tocsection-20"><a href="HigherHalf_Kernel_with_32-bit_Paging#The_real_mapping"><span class="tocnumber">4.3.6.2</span> <span class="toctext">The real mapping</span></a></li>
<li class="toclevel-4 tocsection-21"><a href="HigherHalf_Kernel_with_32-bit_Paging#Enable_paging"><span class="tocnumber">4.3.6.3</span> <span class="toctext">Enable paging</span></a></li>
<li class="toclevel-4 tocsection-22"><a href="HigherHalf_Kernel_with_32-bit_Paging#Cleanup"><span class="tocnumber">4.3.6.4</span> <span class="toctext">Cleanup</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-23"><a href="HigherHalf_Kernel_with_32-bit_Paging#Mapping_single_pages"><span class="tocnumber">4.3.7</span> <span class="toctext">Mapping single pages</span></a>
<ul>
<li class="toclevel-4 tocsection-24"><a href="HigherHalf_Kernel_with_32-bit_Paging#Setup"><span class="tocnumber">4.3.7.1</span> <span class="toctext">Setup</span></a></li>
<li class="toclevel-4 tocsection-25"><a href="HigherHalf_Kernel_with_32-bit_Paging#Find_the_PT_in_the_PD"><span class="tocnumber">4.3.7.2</span> <span class="toctext">Find the PT in the PD</span></a></li>
<li class="toclevel-4 tocsection-26"><a href="HigherHalf_Kernel_with_32-bit_Paging#Calculate_PTE_address"><span class="tocnumber">4.3.7.3</span> <span class="toctext">Calculate PTE address</span></a></li>
<li class="toclevel-4 tocsection-27"><a href="HigherHalf_Kernel_with_32-bit_Paging#Settings_the_PTE"><span class="tocnumber">4.3.7.4</span> <span class="toctext">Settings the PTE</span></a></li>
<li class="toclevel-4 tocsection-28"><a href="HigherHalf_Kernel_with_32-bit_Paging#Cleanup_2"><span class="tocnumber">4.3.7.5</span> <span class="toctext">Cleanup</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-29"><a href="HigherHalf_Kernel_with_32-bit_Paging#Conclusion"><span class="tocnumber">4.4</span> <span class="toctext">Conclusion</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-30"><a href="HigherHalf_Kernel_with_32-bit_Paging#link.ld"><span class="tocnumber">5</span> <span class="toctext">link.ld</span></a>
<ul>
<li class="toclevel-2 tocsection-31"><a href="HigherHalf_Kernel_with_32-bit_Paging#Basic_setup"><span class="tocnumber">5.1</span> <span class="toctext">Basic setup</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="HigherHalf_Kernel_with_32-bit_Paging#The_output_Sections"><span class="tocnumber">5.2</span> <span class="toctext">The output Sections</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-33"><a href="HigherHalf_Kernel_with_32-bit_Paging#Compile_and_link"><span class="tocnumber">6</span> <span class="toctext">Compile and link</span></a></li>
<li class="toclevel-1 tocsection-34"><a href="HigherHalf_Kernel_with_32-bit_Paging#Running"><span class="tocnumber">7</span> <span class="toctext">Running</span></a></li>
<li class="toclevel-1 tocsection-35"><a href="HigherHalf_Kernel_with_32-bit_Paging#Thanks"><span class="tocnumber">8</span> <span class="toctext">Thanks</span></a></li>
</ul>
</div>

<h1><span class="mw-headline" id="Welcome">Welcome</span></h1>
<p>Hi, and welcome to this small tutorial. It is assembled from the code, that i have written for my own hobby OS. As a prerequisite i recommend that you make yourself familiar with the AT&amp;T x86 assembler syntax used by the GNU assembler (which i will be using here). I will try to explain everything i do in very much detail, but still - it's not trivial&#160;:)
</p><p>I also suggest you have the Intel Processor Documentation(s) at hand, especially Volume 3a, which explains 32-bit paging and all the related structure, etc.
</p>
<h2><span class="mw-headline" id="QEMU">QEMU</span></h2>
<p>As a side note, i want to use this to advertise <a href="../Qemu" class="mw-redirect" title="Qemu">qemu</a> as a development utility (no i'm not affiliated with 'em&#160;;)). I use it very much, and it is really, really useful. For example you can investigate the current page tables of your kernel right after loading CR3, which prove very usefull when writing this code. Also having a symbolic debugger (although "symbolic" is not so much usefull in assembler ;p) is the bare minimum you should be equipped with when going on the kernel development route...
</p><p>Additionally, you don't have to worry about boot loaders and such, as long as your kernel is multiboot compliant.
</p>
<h1><span class="mw-headline" id="Boot_code_Structure">Boot code Structure</span></h1>
<p>I will give a rough outline of the kernel (if you can call my 3-filer a kernel ;p) as i will explain it here:
</p>
<ul><li>boot.S: This is the main meat of the startup code. it will contain code to:
<ul><li>setup a initial stack.</li>
<li>setup initial paging structures (the kernel PD, and two PTs)</li>
<li>identity map the low 1MB, and all of the kernel.</li>
<li>map all the kernel to the higher half</li>
<li>enable paging</li>
<li>call the C kernel</li>
<li>write "PANIC!" on the screen in nice white-on-red letters
<dl><dd>(this is why you read this, right?)</dd></dl></li></ul></li>
<li>link.ld: This will contain the instructions for the linker.</li></ul>
<p>Also, i plan to provide the original files i use in my kernel, so you can have a closer look at them. When reading through them, you will mention, that i have (basic) C++ support in them. You either don't have to worry about it, or can use it to extend your own kernel in this direction.
</p><p>(you can find <a rel="nofollow" class="external text" href="http://dev.gentoo.org/~mduft/osdev/boot.S">boot.s here</a>, and <a rel="nofollow" class="external text" href="http://dev.gentoo.org/~mduft/osdev/link.ld">link.ld here</a>)
</p>
<h1><span class="mw-headline" id="Thinking_about_it">Thinking about it</span></h1>
<p>At first, i want you to think a little about what we will need, and what we want to accomplish.
</p><p>We want to have a kernel, which runs (not loads!) at a high address. At such a high address, that it may be, that there is not so much <b>physical</b> memory, that this address is available. So we need virtual memory (or a segmentation trick, described in <i><a href="https://wiki.osdev.org/index.php?title=Higher_Half_With_GDT&amp;action=edit&amp;redlink=1" class="new" title="Higher Half With GDT (page does not exist)">Higher Half With GDT</a></i>). We will use paging, to map our kernel to a high address after it has been loaded to a low address (which should be always available physically).
</p><p>For this to work correctly, the <i>code</i> in our kernel needs to know about this. Most of the kernel will have to be <i>linked</i> to a high address, so we don't need to worry about this anymore, once we're over the bootstrap phase. The initial bootstrap code, in contrast, needs to be linked to a low address, <b>or</b> be completely position independent.
</p><p>For the paging stuff, we will need to have at least a PD (Page Directory) for the kernel, and two PTs (Page Tables). Why two, you might ask. The reason is, we need one PT for the low addresses (the lower 1MB, and the kernel in lower half), and one for the addresses in the higher half. If your kernel grows larger and larger, it might even require more PTs, and you will for sure need to deal with PDs and PTs a lot when it comes to processes, where probably each process will have it's own PD and associated PTs.
</p><p>For this tutorial i chose some very common addresses: 
</p>
<ul><li>0x100000 as the physical load address of the kernel. This is the location the bootloader will load our kernel to.</li>
<li>0xC0000000 as the <i>offset</i> into the higher half.</li></ul>
<p>Those two added together, are the address where the kernel will finally be running (so 0xC0100000). You will see the use of KERNEL_HIGH_VMA all through the code to take into account the offset to the higher half. This is, because the linker assigns higher half addresses to some of the symbols. Since our kernel is loaded to lower half and "thinks" it is running in higher half, we need to be careful when using the addresses of symbols assigned by the linker. During the initial bootstrap, i'm doing a lot of adjustments from higher to lower half, so things are accessible as long as we don't have paging set up.
</p>
<h1><span class="mw-headline" id="boot.S">boot.S</span></h1>
<p>Now for the real code. i will go through it, and explain every section as thorough as possible.
</p>
<h2><span class="mw-headline" id="Global_symbols">Global symbols</span></h2>
<p>We will have only one single global symbol for this file, and thats the entry point of the kernel. So the file starts with the following line:
</p>
<pre>.global bootstrap_ia32
</pre>
<h2><span class="mw-headline" id="The_required_.data_stuff">The required .data stuff</span></h2>
<p>We will need some room in our kernel to do the things we want to. However, we don't (yet) have means to dynamically allocate things, and we don't want to worry too much, so we will simple reserve all the required space in the executable itself. this way, the linker will take care of the kernels bounds, and the bootloader (or qemu in our case), will take care about loading, and checking for enough room, etc., etc.
</p>
<h3><span class="mw-headline" id="Use_the_.data_section">Use the .data section</span></h3>
<p>First, we'll tell the assembler, that we want to put the following stuff in the .data section of the output file:
</p>
<pre>.section .data
</pre>
<h3><span class="mw-headline" id="Make_room_for_the_PD_and_PTs">Make room for the PD and PTs</span></h3>
<p>Then, we need room for the PD and PTs. I'll reserve some space for them like this:
</p>
<pre># the kernel page directory, lowest page table (for the low 1MB identity 
# mapping in kernel space) and the kernel page table, used to map the
# kernel itself from physical 0x100000 to 0xC0000000).

.align 0x1000
_kernel_pd:
   .space 0x1000, 0x00
_kernel_pt:
   .space 0x1000, 0x00
_kernel_low_pt:
   .space 0x1000, 0x00
</pre>
<p>The above tells the assembler to pad the current position in the output file until it is aligned to 4K (0x1000 -&gt; 4096). The we reserver three times 4K of space for the PD and PTs. These symbols will end up in the .data section of the kernel, and thus will be there as soon as the bootloader loaded the kernel. No need to worry about allocating those from "somewhere".
</p>
<h3><span class="mw-headline" id="Make_room_for_the_Stack">Make room for the Stack</span></h3>
<p>Another thing we will need from the very start, is the stack. we won't have time to defer it's creation until we can allocate memory, so we need to put it in here too. Of course you can make it way smaller if you like; Linux uses 16K or 8K if you tell it to do so.
</p>
<pre># a whopping 64K of initial stack space.
.set INITSTACKSIZE, 0x10000
initstack:
   .space INITSTACKSIZE, 0x00
</pre>
<h3><span class="mw-headline" id="Strings">Strings</span></h3>
<p>The last thing in the .data section are our strings we will be using from within the assembler code. There are not many of them, just the "PANIC!" i promised above&#160;:)
</p>
<pre>_msg_panic:
   .asciz "PANIC!"
</pre>
<h2><span class="mw-headline" id="The_actual_code">The actual code</span></h2>
<p>... or not quite yet. At least we tell the assembler to put the following things in the .text section.
</p>
<h3><span class="mw-headline" id="Use_the_.text_Section">Use the .text Section</span></h3>
<p>The following tells the assembler to use the .text section. Also, i tell it to produce 32-bit code, which is not really a necessety, but i like to make it clear.
</p>
<pre>.section .text
.code32
</pre>
<h3><span class="mw-headline" id="Now_for_the_exception_to_the_rule">Now for the exception to the rule</span></h3>
<p>... the MultiBoot Header. It is put in the .text section for a special reason. The multiboot specification states, that the header <b>must</b> appear longword-aligned aligned somewher in the first 8192 bytes of the kernel. As you will see later on in the linker script, the .text section is the first section in the kernel, and thus has to contain the header.
</p>
<pre>.set ALIGN,         1&lt;&lt;0             # align loaded modules on page boundaries
.set MEMINFO,       1&lt;&lt;1             # provide memory map
.set FLAGS,         ALIGN | MEMINFO  # this is the Multiboot 'flag' field
.set MAGIC,         0x1BADB002       # 'magic number' lets bootloader find the header
.set CHECKSUM,      -(MAGIC + FLAGS) # checksum required

.align 4

multiboot_header:
   .long MAGIC
   .long FLAGS
   .long CHECKSUM
</pre>
<p>The above first sets some "absolute" symbols. They have a fixed value, and can be used as constants. The it sets the alignment of the following to 4 (longword; remember? the header has to be aligned like this... most likely, we could omit this, since it is the first thing in the file anyway, and the chance that we are misaligned here is very small to impossible. but still.. better be on the safe side).
</p><p>A good thing to know is, that the ".set symbols" are present in the symbol table of the output file, but <i>do not take up any space</i> in the file at the current location. This means, for example, that the current alignment does not change because of their declaration. We're still at the very same position in the output file.
</p>
<h3><span class="mw-headline" id="Required_symbols_for_the_screen_buffer">Required symbols for the screen buffer</span></h3>
<p>We also need some helpers for handling the screen (clearing it, and then, the point of the whole tutorial: printing "PANIC!"):
</p>
<pre>.set VIDEO_RAM,     0xB8000          # Video Memory, used to print to the screen.
.set VIDEO_DWORDS,  0x3E8            # The count of DWORDs (!) the screen buffer is large.
</pre>
<h3><span class="mw-headline" id="The_entry_point">The entry point</span></h3>
<p>Now the entry point function, the one that will be visible from the outside world. We will start by setting up the inital stack. Because (as we all know, right?) the stack grows downwards in memory, we need to set the ESP register to point to <i>the end</i> of the stack space.
</p>
<pre>bootstrap_ia32:
   # setup the stack
   mov   $(initstack + INITSTACKSIZE), %esp

   # adjust address to be physical, stack is in data segment, which is linked to
   # the kernels virtual higher half address.
   subl  $KERNEL_HIGH_VMA, %esp
</pre>
<p>This will put the address of the <i>initstack</i> symbol, with the length of the stack added to it, into ESP, the stack pointer. What you do not know yet (and what i will explain in detail when we come to the linker script): the stack symbol (as it is in the .data section) is assigned a higher half address by the linker. Thus we cannot yet access it, because we're still running in the lower half now. If we would not subtract the offset into the higher half, where the kernel will be mapped after paging is enabled, the kernel would <b>maybe</b> still run fine - as long as the machine has enough memory, so accessing the higher half address works (however i haven't tried this!).
</p><p>Next, we'll want to setup some form of initial paging, which enables the kernel to run code off the higher half addresses, and use all the other things that will be linked there.
</p>
<pre>   # setup boot paging to map kernel to higher half
   call init_boot_paging_ia32
</pre>
<p>I will discuss the init_boot_paging_ia32 function in detail just a few lines further down. Let's first finish the entry point, as it is not so complex.
</p><p>Imagine, we have paging setup all right (the init_boot_paging_ia32 function did it's job, whatever this means), and can now use the correct higher half addresses all over the place. The first thing we'll want to do, is to try whether it really works, and relocate the stack from the lower to the higher half.
</p><p>"Relocate" is maybe a bad word for what we're doing. Either way, we're accessing the same <b>physical</b> memory, because we mapped the higher half to the lower half physical addresses. In fact, we can use <b>both</b> addresses just fine. Also, if you, say, write a byte to 0x100000 (please don't&#160;;)), it will immediately appear at 0xC0100000 too; it's the same memory location.
</p>
<pre>   # adjust stack registers to point to the now mapped stack as virtual address
   addl  $KERNEL_HIGH_VMA, %esp
   mov   %esp, %ebp
</pre>
<p>Now the stack is used from it's higher half mapped address.
</p><p>Since we have all set up now, we can test the lower 1MB mapping very easily, by trying to clear the screen, which will access the screen buffer at 0xB8000. If the mapping doesn't work, this will cause one or the other exception, double fault and tripple fault&#160;:)
</p>
<pre>   mov $VIDEO_RAM, %edi
   mov $VIDEO_DWORDS, %ecx
   mov $0x07200720, %eax
   rep stosl
</pre>
<p>This fill all the screen buffer with light-grey-on-black colored blanks, and thus clear it. (Each word is built like this: 0x0000 -&gt; background (0 = black), 0x0700 -&gt; foreground (7 = light grey), 0x0020 -&gt; " " (blank)).
</p><p>The only thing left to do (except error handling), is to call the main C kernel from here. First we push the parameters passed by the Multiboot compliant bootloader on the stack.
</p>
<pre>   # push parameters to the entry point (grub parameters)
   push  %eax
   push  %ebx

   #call boot # uncomment this if you have a C kernel entry function at hand&#160;:)
</pre>
<p>My kernel main C function happens to be named "boot", but thats of course up to you. Now, actually there is all we need. Still we will want to make sure, that if boot ever returns, the CPU does not continue to execute junk or code it shouldn't, so we will halt the CPU. <b>Note:</b> You'll probably want to halt all APs too, if you put SMP support in your kernel...
</p>
<pre>the_end:
   mov $_msg_panic, %eax
   call boot_print_msg
   # halt the cpu... the kernel stopped.
   cli
   hlt
</pre>
<p>I think it is pretty obvious: the above loads the "PANIC!" message into EAX, calls the print function (i will show it to you in a second...), then disables interupts and halts the CPU.
</p>
<h3><span class="mw-headline" id="The_simple_printing_function">The simple printing function</span></h3>
<p>Ok, before we start with the paging code, here is the printing function i have to write the "PANIC!" on the screen. I'll leave it to you to figure out how it works, i guess things like these are described a lot in th wiki&#160;:)
</p>
<pre>boot_print_msg:
   # eax: address of the string to print.
   push %edx
   push %ebx

   mov $VIDEO_RAM, %edx

   _print_loop:
       movb (%eax), %bl
       xorb %bh, %bh
       cmpb $0x0, %bl
       je _end_print
       orw $0x4F00, %bx
       movw %bx, (%edx)
       add $0x2, %edx
       inc %eax
       jmp _print_loop
   _end_print:

   pop %ebx
   pop %edx
</pre>
<h3><span class="mw-headline" id="Initialize_Paging">Initialize Paging</span></h3>
<p>The following is my init function for the paging. It makes the PD point to the correct PTs. It also calls another function to fill the PTs with the correct entries (it "maps" virtual to physical addresses). Let's start with the top of the function:
</p>
<pre>init_boot_paging_ia32:
   # save registers used here.
   push %eax
   push %ebx
   push %edx
   push %ecx
</pre>
<p>At the end of the function, we will restore the registers, so the code behaves nicely, and doe not overwrite reigsters set by the bootloader (remember: grub passes two parameters in EAX and EBX).
</p>
<h4><span class="mw-headline" id="Getting_the_PD_and_PTs_right">Getting the PD and PTs right</span></h4>
<p>Now, to insert the PDEs in the PD, we need to have the correct physical addresses of the PD and PTs. Those symbols (_kernel_pd, _kernel_pt, _kernel_low_pt; we declared those above in the .data section, remember?) are assigned <b>higher half</b> addresses by the linker, as you will see later on, when i explain the linker script. Since the higher half addresses are merely an "alias" to the lower half addresses, we can simply subtract the offset into higher half, to get the actual physical load address of those symbols. This way, we can access them without paging enabled.
</p>
<pre>   mov  $_kernel_pd, %eax          # get virtual address of kernel pd
   sub  $KERNEL_HIGH_VMA, %eax     # adjust to physical address
</pre>
<p>EAX now contains the <i>physical</i> address of the kernels PD. Now the same for the "low" PT (the one mapping the first 1MB of the memory, and all the physical kernel addresses, as the kernel is loaded right above 1MB. With this single PT, we can map up to 4MB, that makes room for a approximately 3MB kernel above the 1MB low memory).
</p>
<pre>   mov  $_kernel_low_pt, %ebx      # get virtual address of kernel low pt
   sub  $KERNEL_HIGH_VMA, %ebx     # adjust to physical address
</pre>
<p>If we want to set a PDE containing this PT, we just need to set the present flag. (<b>Note:</b> i <i>don't</i> clear the lower 12 bits of the address intentionally; it is not required, as i can be sure, that the structures are correctly aligned the way i declared them in the .data section - just in case you wonder if i forgot it&#160;;)).
</p>
<pre>   or   $0x1, %ebx                 # set present flag
</pre>
<p>EBX is now in the correct form for a PDE, the only thing left to do, is actually set the entry in the PD (whos address is loaded into EAX):
</p>
<pre>   mov  %ebx, (%eax)               # set the pde
</pre>
<p>This was easy. The next one is a little more tricky. The low PT has the advantage of beeing at index zero of the PD. The higher half PT for the kernel doesn't have this advantage; we will first have to calculate the offset into the PD, where we want to set the PDE.
</p>
<pre>   push %eax
   mov  $KERNEL_HIGH_VMA, %eax     # get virtual address offset
   shr  $22,  %eax                 # calculate index in the pd
   mov  $4, %ecx
   mul  %ecx                       # calculate byte offset (4bytes each entry)
   mov  %eax, %edx
   pop  %eax
</pre>
<p>The above code does this: It first saves the EAX register, as we'll need it's value again later (and restores it at the end, see?). Then it loads the higher half kernel offset into EAX. I need this for a special reason: I assume, that all the kernel fits entirely into the one PT for now. I need to have <i>any</i> virtual address that should be mapped by the kernel PT. From there i can extract the Index that the PDE should have in the PD. It is not really required to load the actual offset here (although it's the clearest way i can think of). Anything linked to higher half will do (for example the address of the _kernel_pd or _kernel_pt symbols themselves). Next, EAX is right shifted by 22 bits to extract the <i>index</i> into the PD. Since all entries are 4 bytes each, we need to multiply the index with 4, to get the offset of the PDE from the PD base address. This offset is saved in the EDX register for later use.
</p><p>To get the right position for our PDE, we now just have to add the offset to the PD base pointer, we loaded before.
</p>
<pre>   push %eax                       # save the real address for later
   add  %edx, %eax                 # move the pointer in the pd to the correct entry.
</pre>
<p>Now that we know the correct location, the code to set the _kernel_pt PDE entry is very similar to the one used for the _kernel_low_pt, so i'll leave it up to you to figure out those four lines:
</p>
<pre>   mov  $_kernel_pt, %ebx          # get virtual address of kernel main pt
   sub  $KERNEL_HIGH_VMA, %ebx     # adjust to physical address
   or   $0x1, %ebx                 # mark present
   mov  %ebx, (%eax)               # set the pde
</pre>
<p>If we reach this position in the code, the PD and it's PDEs are don. It points to the correct physical addresses, and we don't need to worry about it anymore, except when enabling paging below, where we will move the pointer to the PD into the CR3 register.
</p>
<h4><span class="mw-headline" id="The_real_mapping">The real mapping</span></h4>
<p>For this code, we will, again, have to assume for a moment, that we have a working function called <i>boot_map_page_ia32</i> which takes the following parameters:
</p>
<ol><li>EBX: the physical address of the kernel PD</li>
<li>ECX: the virtual address which we want to map</li>
<li>EDX: the physical address that the virtual address should be "redirected" to.</li></ol>
<p>After calling the function with the correct parameters, accessing the given virtual address will really access the physical memory we passed in EDX. We'll come to the real implementation of the function a little further down the road (not too long to wait, don't worry&#160;;)).
</p><p>We need to map 3 things:
</p>
<ol><li>We have to "identity map" the lowest MB in memory (except the first page! we don't want to be able to access 0x0; this should cause an exception!). Identity mapping means that the virtual and physical address are the same. We need this to be able to use some fixed addresses (video buffer at 0xB8000 for example). We could, of course, also map the low MB somewhere else, and adjust all pointers to the new location.</li>
<li>We have to identity map all the kernel in lower half. If we wouldn't do this, enabling paging would lead to an immediate page fault, then double fault, then tripple fault the CPU. This is because our EIP is currently somewhere in the physical load range of the kernel. after enabling paging, the CPU tries to fetch the next instruction, but the address it tries to read is a <i>virtual</i> one now! if the virtual address is not the same as the physical one, the CPU won't get the next instruction. (In fact, it will probably page fault, if nothing is mapped at that location).</li>
<li>Last but not least, we have to map all the kernel into higher half, so we can call the C kernel entry later on. This mapping is merely an "alias" to the lower half kernel. After all mappings are complete, we can access the <i>same</i> physical memory through <i>both</i> the higher and lower half addresses. If we like to, we can later on remove the lower half mapping, so that the only way to access the kernel's memory is through the higher half pointers.</li></ol>
<p>Ok, let's go. first, we need to have the physical address of the kernel PD in EBX. A few lines up, i pushed EAX, which contained the address we want. So all we have to do, is pop it off the stack now.
</p>
<pre>   pop  %ebx                       # pop saved address of the kernel PD
</pre>
<p>Now we're ready to loop over the first MB. I'll set 0x100000 (1MB) into ECX, which will contain the virtual address we want to map. Each iteration will decrease ECX by 0x1000 (one page, 4K), and call the mapping function. We stop (without calling the mapping function), if ECX reaches zero.
</p>
<pre>   mov  $0x100000, %ecx            # map the low 1MB

   _idmap_first_mb_loop:
       mov %ecx, %edx              # phys == virt (identity mapping)
       call boot_map_page_ia32     # do the mapping
       sub $0x1000, %ecx           # one page down.
       jnz _idmap_first_mb_loop    # if not zero, continue (DON'T map zero&#160;:))
</pre>
<p>As you can see, the loop sets EDX to the same value as ECX, and thus "identity maps" all of those addresses. (<b>Hint:</b> later on, when you run your kernel in qemu, you can look at the mappings easily by typing "info tlb" in the qemu monitor).
</p><p>That was easy, right? Now for something slightly more sophisticated. We'll identity map <i>and</i> "high-map" the kernel in one go. For this, we'll have to know the bounds of the kernel. The linker script provides a few additional symbols, which help us there. The KERNEL_BOOT_VMA symbol is the absolute physical start address of the kernel, so we'll start there (i put it into ECX and increment by a page each loop run, until we reach the end of the kernel). The end of the kernel is determined by looking at the _core_end symbol. <b>But</b>: carefull; the _core_end symbol (as you will see when looking at the linker script) is linked to higher half, so to get the <i>physical</i> end of the kernel, we need to subtract the higher half offset again.
</p>
<pre>   mov  $KERNEL_BOOT_VMA, %ecx     # this is the _very_ beginning&#160;:)
   mov  $_core_end, %eax           # virtual address of end
   sub  $KERNEL_HIGH_VMA, %eax     # now it is physical.
</pre>
<p>Now that we have all values set up (EBX, which is required too, wasn't changed in the meantime, so no need to worry about it; it has the correct value), we can go for the actual loop:
</p>
<pre>   _map_kernel:
       mov %ecx, %edx              # phys == virt (identity mapping)
       call boot_map_page_ia32     # do the mapping

       push %ecx
       add $KERNEL_HIGH_VMA, %ecx  # now map the virtual address to the same physical one
       call boot_map_page_ia32     # do it
       pop %ecx

       add $0x1000, %ecx           # on to the next page.
       cmp %eax, %ecx
       jle _map_kernel             # continue untill all the kernel is mapped.
</pre>
<p>This first sets EDX to identity map ECX, and creates the mapping (like in the last loop). But then, surprise, surprise, something more happens: I save ECX, as i need it's value as is a few lines further down. The i adjust ECX to point to the same address as before, <i>but in higher half</i>. Calling the mapping function now creates a mapping from higher half (virtual) to lower half (physical) memory. Then, ECX is restored, so we can check for the kernel bounds and continue the loop. ECX is moved on to the next page we want to map. ECX is less-or-equal to the upper kernel bounds, we continue, otherwise we're done.
</p>
<h4><span class="mw-headline" id="Enable_paging">Enable paging</span></h4>
<p>That's it. We're nearly done. All the mappings are in place, all the PD and PTs are ready to be used (hopefully&#160;;)). Now we can give it a try by activating all of this, which is really simple:
</p>
<pre>   mov  %ebx, %cr3                 # use the kernel pd
   mov  %cr0, %eax                 # get the current cr0 value
   or   $(1 &lt;&lt; 31), %eax           # enable paging
   mov  %eax, %cr0                 # now re-set the cr0 register.
</pre>
<p>First, EBX is moved to CR3, which is the PD base pointer in 32-bit paging. Then, the paging bit is set in CR0, and that's it. Lets keep our fingers crossed that things continue to work&#160;;)
</p>
<h4><span class="mw-headline" id="Cleanup">Cleanup</span></h4>
<p>Last thing to do for this function is to restore all the registers and return to the bootstrap_ia32 function. The first thing there will be, if you remember, adjusting the stack to use the virtual higher half addresses...
</p>
<pre>   # restore register values.
   pop  %ecx
   pop  %edx
   pop  %ebx
   pop  %eax

   ret
</pre>
<h3><span class="mw-headline" id="Mapping_single_pages">Mapping single pages</span></h3>
<p>Oh - wait; we're not quite there, right? i think there is one more function we deferred for later implementation... the one that maps a single page, which we used above in the loops: boot_map_page_ia32.
</p>
<h4><span class="mw-headline" id="Setup">Setup</span></h4>
<p>Always the same boring function starts...
</p>
<pre>boot_map_page_ia32:
   # ebx: physical addr of kernel PD
   # ecx: the virtual address to map
   # edx: the physical address to map to

   push %eax
   push %ebx
   push %ecx
   push %edx
</pre>
<p>Additionally, we will immediately push some of the parameters, as we need to calculate offsets from them, and later have those values unmodified.
</p>
<pre>   push %edx                       # push physical address
   push %ecx                       # push virtual address
</pre>
<h4><span class="mw-headline" id="Find_the_PT_in_the_PD">Find the PT in the PD</span></h4>
<p>The first real code will find out, which PT we will have to use to be able to map the virtual address. If the given address is not within the two PTs we have already set up, the kernel will panic immediately (of course; there is no logic to create new PTs on the fly).
</p>
<pre>   mov  %ecx, %eax
   shr  $22, %eax
   mov  $4, %ecx
   mul  %ecx                       # now we have the offset in eax
   add  %eax, %ebx                 # now ebx points to the phys addr of a pt if present
   mov  (%ebx), %eax
</pre>
<p>To get the correct index, the above first loads the virtual address from ECX into EAX, then shifts it 22 bits to the right, as this will, again, result in the index into the PD, required to find the PT for this address. Then again, we have to multiply it by four, as each entry in the PD is four bytes long. Finally the calculated offset (now in EAX) is added to the physical address of the PD, which is passed in EBX (remember?). From this address, we can now load the PDE into EAX. Please remember that this now is <b>not</b> and address yet, as it has flags ORed into it. We'll have to clear those flags before we can use it.
</p><p>But first, just to be sure, we check if the present flag is set in the PDE, otherwise the given virtual address is out of bounds.
</p>
<pre>   mov  %eax, %ecx
   and  $0x1, %ecx                 # check present flag
   cmp  $0x0, %ecx
   je the_end                      # if zero, PANIC!
</pre>
<p>Now, as i said, we'll have to extract the physical PT address from the PDE.
</p>
<pre>   and  $0xFFFFF000, %eax          # clear off possible flags from the PDE.
</pre>
<h4><span class="mw-headline" id="Calculate_PTE_address">Calculate PTE address</span></h4>
<p>Finally, we have the correct physical address of a valid PT in EAX. We no can use this to find the correct slot in there, and set a PTE for our virtual address.
</p><p>Remember, at the entrance of the function, we pushed both the physical, and then the virtual address passed in; now we need the virtual address again to calculate the correct index into the PT from it, so pop it off the stack:
</p>
<pre>   pop  %edx                       # the virtual address.
</pre>
<p>The following code will calculate the index, and put it into EBX:
</p>
<pre>   push %eax
   mov  %edx, %eax
   shr  $0xC, %eax                 # shift right to discard non-significant bits.
   and  $0x3FF, %eax               # and away not-relevant bits on the left.
   mov  $0x4, %ecx                 # each entry is 4 bytes
   mul  %ecx
   mov  %eax, %ebx                 # now in ebx: the offset into the PT for the PTE.
   pop  %eax
</pre>
<p>EAX is preserved (first pushed, then poped at the end of this section), as you can see. Then, I put the virtual address to map (in EDX) into EAX. After that, right-shift the whole thing by twelve bits. Now clear off the uninteresting bits on the left side, so only the range described in the intel manuals is left over. This is the part of the address that serves as index into the PT. As always, we now have to multiply it by four, since all PT entries are (exactly like the PD entries) 4 bytes long. The result is put into the EBX register.
</p>
<h4><span class="mw-headline" id="Settings_the_PTE">Settings the PTE</span></h4>
<p>Let's evaluate our current state. EBX contains the <i>offset</i> from the PT base address for our virtual address to map. EAX still contains the base address of the PT. What we now additionally need is the physical address we have to map to. At the start of the function we pushed it on the stack, so pop it off now.
</p>
<pre>   pop  %edx                       # the phsyical target address
</pre>
<p>Now calculate the final location of the PTE, by adding up the base address and the offset, in EAX and EBX respectively.
</p>
<pre>   add  %ebx, %eax                 # add offset to pt. this is the final location now.
</pre>
<p>To get a valid (and more important: <i>present</i>) PTE, we need to OR some flags, in this case only the present flag to the final physical address. Then we can put the PTE (made up of the address and the present flag) to the location we just looked up in the PT (which is in EAX).
</p>
<pre>   or   $0x1, %edx                 # mark present...
   mov  %edx, (%eax)               # and insert into pt.
</pre>
<h4><span class="mw-headline" id="Cleanup_2">Cleanup</span></h4>
<p>The rest is cleanup (restore registers), and return.
</p>
<pre>   pop %edx
   pop %ecx
   pop %ebx
   pop %eax
   ret
</pre>
<h2><span class="mw-headline" id="Conclusion">Conclusion</span></h2>
<p>Wow. That was quite some code. i know, it is hard to get all this into the head&#160;;)
</p><p>Please also note, that some of the code is not exactly the best, fastest way to do things, but the one how i understood the concepts best. If you have suggestions, feel free to tell me! I'm eager to hear how you would improve the code!
</p>
<h1><span class="mw-headline" id="link.ld">link.ld</span></h1>
<p>To be able to actually <i>build</i> the kernel, you'll need one more file: the linker script, which tells the linker where to put things, which addresses to assign, and what symbols to create to help the boot code... Let's have a look at the contents:
</p>
<h2><span class="mw-headline" id="Basic_setup">Basic setup</span></h2>
<p>The file starts with a few global symbols and instructions for the linker:
</p>
<pre>OUTPUT_FORMAT(elf32-i386)
ENTRY(bootstrap_ia32)
KERNEL_BOOT_VMA = 0x00100000;
KERNEL_HIGH_VMA = 0xC0000000;
</pre>
<p>This tells the linker, that we want a 32-bit elf executable, containig i386 code, that our entry-point function is named "bootstrap_ia32" (as defined in boot.S). Also two very important absolute symbols are defined: KERNEL_BOOT_VMA, which denotes the physical start address of the kernel, and KERNEL_HIGH_VMA, which denotes the <b>offset</b> from the BOOT_VMA to the higher half (It is important to understand, that these are <i>symbols</i>, not just constants you can use from withing the linker script. Those symbols are usable from the code (which we did alread)).
</p>
<h2><span class="mw-headline" id="The_output_Sections">The output Sections</span></h2>
<p>Next comes the definition of the sections <i>in the output file</i>. This is only indirectly related to the sections in the <i>input files</i>. We can more or less freely move/rename and merge sections from the input to the output. Also, we can tell the linker that special files should be treated specially, which is of great value.
</p><p>Let's have a look at the beginning of the section definition:
</p>
<pre>SECTIONS{
   . = KERNEL_BOOT_VMA;
</pre>
<p>This tells the linker, that the current physical address in the output file (denoted by '.') should be set to KERNEL_BOOT_VMA, which we defined as the start of the kernel.
</p><p>The next thing tells the linker how to handle the <i>code</i> from our boot.S file (but not the data!):
</p>
<pre>   .boot&#160;:{ 
       */boot.o (.text)
   }  
</pre>
<p>This creates a section called .boot in the output file. The linker puts into this section the contents of all .text section from all input files <i>whos name ends in '/boot.o'</i> (This means that passing our boot.o to the linker as 'boot.o' doesn't work, we'll need './boot.o' or some other <i>path</i> to the file). We'll only have one single of those objects, so thats cool with us&#160;:)
</p><p>Also the above make the linker assign addresses from KERNEL_BOOT_VMA onwards to the .text symbols from boot.o, so we're linked to lower half here.
</p><p><b>Note:</b> it would have been cool to have the PD and PT structures in the .boot section too, so we don't have to mess with KERNEL_HIGH_VMA offsets in the code all the time. However all i could come up with failed, so i had to put them into the .data section (and i tried a lot...)
</p><p>The next instructions tell the linker, to set the current offset from which addresses are assigned to the higher half, which means, from here on, all symbols will be linked to higher half. Also, a symbol (_core_start) is assigned the current address. This symbol can be used from the C code if required.
</p>
<pre>   . += KERNEL_HIGH_VMA;
   _core_start = .;
</pre>
<p>Now, let's define the rest of the sections. First, we'll need a .text section, containing all the kernel code. The section is aligned on a page boundary, and the <i>physical</i> address is set to lower half, by subtracting the higher half offset again.
</p>
<pre>   .text ALIGN(0x1000)&#160;: AT(ADDR(.text) - KERNEL_HIGH_VMA) {
       _core_code = .;
       *(EXCLUDE_FILE (*/boot.o) .text)

       /* all readonly data is merged with this section, too */
       *(.rodata*)
   }
</pre>
<p>One more noteworthy thing from above is, that the 'boot.o' file is now <i>excluded</i> from the .text section, as it's .text contents is already in the .boot section, linked to lower half.
</p><p>The next section to define, is the .data section, which contains read/write data symbols.
</p>
<pre>   .data ALIGN (0x1000)&#160;: AT(ADDR(.data) - KERNEL_HIGH_VMA) {
       _core_data = .;
       *(.data)
   }
</pre>
<p>This should be pretty clear now, given what we know from above. The section is page aligned, and the physical load address is set to the lower half. A symbol is declared, denoting the start of the section, and all .data sections from all input files (also 'boot.o'!) are included here.
</p><p>The last section to define is the .bss section. It will also contain common symbols, if there are some (currently there should not we any; one can create those with the .comm and .lcomm gnu assembler pseudo directives):
</p>
<pre>   .bss ALIGN (0x1000)&#160;: AT(ADDR(.bss) - KERNEL_HIGH_VMA) {
       _core_bss = .;
       *(COMMON)
       *(.bss)
       . = ALIGN(4096);
       _core_ebss = .;
   }
</pre>
<p>Again, page aligned, and the address is adjusted to lower half. Multiple input sections are merged into this one output section (COMMON is special and means all symbols that are marked *COM* if you look at a objdump -x output for a given object file).
</p><p>This section is padded until the current page is full, and an "end-symbol" is declared. this is, so that we could be able to clear the .bss section (but with elf, this is not necessary, as the bootloader has to do this already for us...).
</p><p>finally, another symbol is declared to denote the end of the kernel. We use this symbol in the code to determine the size of the kernel, and thus the amount of memory we need to map for the kernel to work.
</p>
<pre>   /* 4K alignment is guaranteed! */
   _core_end = .;
}
</pre>
<p>That's it. You should be able to compile and link the boot code now.
</p>
<h1><span class="mw-headline" id="Compile_and_link">Compile and link</span></h1>
<p>You should be able to compile and link the kernel like this:
</p><p>gcc -Wall -Werror -Wextra -ffreestanding -fno-rtti -fno-exceptions  -O0 -g -c -o boot.o boot.S
ld -T link.ld  -o kernel ./boot.o
</p>
<h1><span class="mw-headline" id="Running">Running</span></h1>
<p>I suggest using qemu:
</p><p>qemu -kernel kernel
</p><p>if things worked out, you should see "PANIC!" on the screen now! congratulations, paging worked. If nothing seems to happen, you did something wrong, and if the screen constantly flickers, you have done somethings wrong too (and the machine triple faults and resets continuously). I hope though, that there are no errors in the code i showed here.
</p>
<h1><span class="mw-headline" id="Thanks">Thanks</span></h1>
<p>Thanks for reading, and <b>Good luck!</b>
</p>
<!-- 
NewPP limit report
Cached time: 20250212013047
Cache expiry: 86400
Reduced expiry: false
Complications: [showtoc]
CPU time usage: 0.031 seconds
Real time usage: 0.033 seconds
Preprocessor visited node count: 110/1000000
Postexpand include size: 358/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.861      1 Template:In_Progress
100.00%    0.861      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2942-0!canonical and timestamp 20250212013047 and revision id 11041.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=User:Mduft/HigherHalf_Kernel_with_32-bit_Paging&amp;oldid=11041">https://wiki.osdev.org/index.php?title=User:Mduft/HigherHalf_Kernel_with_32-bit_Paging&amp;oldid=11041</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="../Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="../Category:In_Progress" title="Category:In Progress">In Progress</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=User%3AMduft%2FHigherHalf+Kernel+with+32-bit+Paging" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="HigherHalf_Kernel_with_32-bit_Paging#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-user" class="selected mw-list-item"><a href="HigherHalf_Kernel_with_32-bit_Paging" title="View the user page [c]" accesskey="c"><span>User page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User_talk:Mduft/HigherHalf_Kernel_with_32-bit_Paging&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="HigherHalf_Kernel_with_32-bit_Paging"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Mduft/HigherHalf_Kernel_with_32-bit_Paging&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Mduft/HigherHalf_Kernel_with_32-bit_Paging&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="../index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="../index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="../Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="../Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="../OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="../OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="../OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="../Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="https://wiki.osdev.org/Special:WhatLinksHere/User:Mduft/HigherHalf_Kernel_with_32-bit_Paging" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/User:Mduft/HigherHalf_Kernel_with_32-bit_Paging" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-contributions" class="mw-list-item"><a href="../Special:Contributions/Mduft" title="A list of contributions by this user"><span>User contributions</span></a></li><li id="t-log" class="mw-list-item"><a href="../Special:Log/Mduft"><span>Logs</span></a></li><li id="t-userrights" class="mw-list-item"><a href="../Special:UserRights/Mduft"><span>View user groups</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="../Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Mduft/HigherHalf_Kernel_with_32-bit_Paging&amp;oldid=11041" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Mduft/HigherHalf_Kernel_with_32-bit_Paging&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 11 December 2010, at 08:02.</li>
	<li id="footer-info-0">This page has been accessed 1,960 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="../OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="../OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="../OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=User:Mduft/HigherHalf_Kernel_with_32-bit_Paging&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="../resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="../resources/assets/poweredby_mediawiki_132x47.png 1.5x, ../resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.031","walltime":"0.033","ppvisitednodes":{"value":110,"limit":1000000},"postexpandincludesize":{"value":358,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    0.861      1 Template:In_Progress","100.00%    0.861      1 -total"]},"cachereport":{"timestamp":"20250212013047","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":168});});</script>
</body>
</html>