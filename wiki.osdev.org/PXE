<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>PXE - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"9066b59595736d0b276f4f48","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"PXE","wgTitle":"PXE","wgCurRevisionId":28035,"wgRevisionId":28035,"wgArticleId":3013,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Booting","Bootloaders","Network Protocols"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"PXE","wgRelevantArticleId":3013,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],
"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-PXE rootpage-PXE skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">PXE</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="PXE#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="PXE#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>Preboot eXecution Environment, or PXE, is the only way for <a href="Diskless_Booting" title="Diskless Booting">Diskless Booting</a> in PCs, and the standard is developed by Intel. It allows the Network Bootstrap Program (NBP) or the Bootloader to interface with the PXE, and load files via TFTP.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="PXE#State_of_the_Machine"><span class="tocnumber">1</span> <span class="toctext">State of the Machine</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="PXE#PXENV+"><span class="tocnumber">1.1</span> <span class="toctext">PXENV+</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="PXE#Recommended_Usage"><span class="tocnumber">1.1.1</span> <span class="toctext">Recommended Usage</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-4"><a href="PXE#!PXE"><span class="tocnumber">1.2</span> <span class="toctext">!PXE</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="PXE#Recommended_Usage_2"><span class="tocnumber">1.2.1</span> <span class="toctext">Recommended Usage</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="PXE#PXE_API"><span class="tocnumber">2</span> <span class="toctext">PXE API</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="PXE#Files,_via_TFTP"><span class="tocnumber">3</span> <span class="toctext">Files, via TFTP</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="PXE#Getting_&quot;Cached_Information&quot;"><span class="tocnumber">3.1</span> <span class="toctext">Getting "Cached Information"</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="PXE#Opening"><span class="tocnumber">3.2</span> <span class="toctext">Opening</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="PXE#Reading"><span class="tocnumber">3.3</span> <span class="toctext">Reading</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="PXE#Closing"><span class="tocnumber">3.4</span> <span class="toctext">Closing</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="PXE#Performance"><span class="tocnumber">3.5</span> <span class="toctext">Performance</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="PXE#TFTP_Block_Size"><span class="tocnumber">3.5.1</span> <span class="toctext">TFTP Block Size</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="PXE#TFTP_&quot;Sliding_Window&quot;"><span class="tocnumber">3.5.2</span> <span class="toctext">TFTP "Sliding Window"</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="PXE#Advanced/Non-standard_Approaches"><span class="tocnumber">3.5.3</span> <span class="toctext">Advanced/Non-standard Approaches</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="PXE#Cleaning_up"><span class="tocnumber">4</span> <span class="toctext">Cleaning up</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="PXE#See_Also"><span class="tocnumber">5</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="PXE#Articles"><span class="tocnumber">5.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="PXE#External_Links"><span class="tocnumber">5.2</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="State_of_the_Machine">State of the Machine</span></h2>
<p>Described by Section 4.4.5, Client State at Bootstrap Execution Time, the PXE is responsible for getting the boot code in the Client Machine. This is entirely similar to other boot devices, however, the BIOS Magic Signature, 0xAA55 isn't required, and the size of the boot file is limited to 32KiB, instead of the familiar 512 bytes.
</p><p>Prior to Version 2.1 of the PXE specification, a PXENV+ Structure was given to the NBP. The PXE Entry Structure, or the !PXE structure, was introduced in Version 2.1, while the PXENV+ Structure has become obsolete. However, the address of the PXENV+ Structure is still given to the NBP during boot, to maintain compatibility with older NBPs.
</p><p>The PXE Specification promises that the boot file is loaded at the address 0x0000:0x7C00, though it isn't trustable. Moreover,
</p>
<ul><li><b>ES:BX</b>       ES:BX should point to the PXENV+ structure, to maintain backward compatibility.</li>
<li><b>SS:SP</b>       SS:SP points to a valid stack, with at least 1.5KiB of free stack.</li>
<li><b>SS:SP + 4</b>   SS:SP + 4 points to the newer !PXE structure, if and only the PXE Version is greater than or equal to 1.5.</li></ul>
<h3><span id="PXENV.2B"></span><span class="mw-headline" id="PXENV+">PXENV+</span></h3>
<p>The structure of the PXENV+ structure is as follows:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">    </span><span class="c1">// The Signature of the PXENV+ structure - contains &quot;PXENV+&quot;.</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">Signature</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// The MSB contains the Major version number, while the LSB contains the minor version number.</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Version</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// The Length and the checksum of the structure, used for calculating the checksum.</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">Length</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">Checksum</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// A Far Pointer to the real mode PXE API entry point. </span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">RMEntry</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 32-bit offset to the protected mode API entry point. Instead of this, the !PXE structure is recommended.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">PMOffset</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// The rest of the fields don&#39;t matter much, and the Specifications can be referred.</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">PMSelector</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">StackSeg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">StackSize</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">BCCodeSeg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">BCCodeSize</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">BCDataSeg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">BCDataSize</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">UNDIDataSeg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">UNDIDataSize</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">UNDICodeSeg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">UNDICodeSize</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// This is a far pointer to the &quot;!PXE&quot; structure, only present when the structure is present.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">PXEPtr</span><span class="p">;</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Recommended_Usage">Recommended Usage</span></h4>
<p>First of all, the integrity of the PXENV+ structure should be checked. This can be done by:
</p>
<ul><li>Checking the PXENV+ signature at the starting.</li>
<li>And, by checking the checksum of the structure.</li></ul>
<p>If the structure fails to pass either of the above, boot should be aborted.
</p><p>If the structure is good, the Version number should be checked. If it is higher than or equal to 0x0201 then the !PXE structure should be used. On the other hand, if it isn't, the PXENV+ structure should be used.
</p>
<h3><span id=".21PXE"></span><span class="mw-headline" id="!PXE">!PXE</span></h3>
<p>The structure of the !PXE structure is as follows:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">    </span><span class="c1">// The Signature of the !PXE structure - contains &quot;!PXE&quot;.</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">Signature</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// The Length and the checksum of the structure, used for calculating the checksum.</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">Length</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">Checksum</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span>
<span class="w">    </span><span class="c1">// Contains zero - both of them.</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">Revision</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">Reserved</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Far pointer to UNDI ROM ID structure and BC ROM ID structure.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">UNDIROMID</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">BCROMID</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// A Far Pointer to the real mode PXE API entry point. </span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">RMEntry</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// A Far Pointer to the protected mode API entry point. </span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">PMEntry</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// The rest of the fields don&#39;t matter much (in the rest of the article), and the Specifications can be referred.</span>
</pre></div>
<h4><span class="mw-headline" id="Recommended_Usage_2">Recommended Usage</span></h4>
<p>If the PXENV+ lists the revision as greater than or equal to 0x0201, then only must the !PXE stucture be relied upond. Then, the integrity of the !PXE structure should be checked. This can be done by:
</p>
<ul><li>Checking the !PXE signature at the starting.</li>
<li>And, by checking the checksum of the structure.</li></ul>
<p>If the structure fails to pass either of the above, the PXENV+ structure should be used.
</p>
<h2><span class="mw-headline" id="PXE_API">PXE API</span></h2>
<p>The PXE Entry Point uses the __cdecl calling convention - push the parameters on the stack (rightmost pushed first, leftmost pushed last), far call the entry point, clean up the stack - while the older PXENV+ Entry Point uses registers.
</p><p>To access the API, a generic CallAPI function can be created, which eases out the calling. To do this, first of all, the address of the Entry Point, from either of the structures should be stored in a location (PXEAPI in the example). The PXE API accept the same parameters:
</p>
<ul><li>Opcode, or the API function number.</li>
<li>Segment:Offset address to a structure containing input data.</li></ul>
<p>A example generic call function is as follows:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">; Calls the PXE API, and abstracts things such that it works on both old and new APIs.</span>
<span class="c1">; @ds:di          The address of the input buffer.</span>
<span class="c1">; @bx             The opcode.</span>
<span class="c1">; NOTE: The above registers are what the legacy API also used, so it should cause no problem with it.</span>
<span class="nl">UsePXEAPI:</span><span class="w"></span>
<span class="w">    </span><span class="c1">; And we push it over here, so that we have no problems with the new API.</span>
<span class="w">    </span><span class="nf">push</span><span class="w"> </span><span class="no">ds</span><span class="w"></span>
<span class="w">    </span><span class="nf">push</span><span class="w"> </span><span class="no">di</span><span class="w"></span>
<span class="w">    </span><span class="nf">push</span><span class="w"> </span><span class="no">bx</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="nf">call</span><span class="w"> </span><span class="no">far</span><span class="w"> </span><span class="p">[</span><span class="no">PXEAPI</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="nf">add</span><span class="w"> </span><span class="no">sp</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="w">                         </span><span class="c1">; Clean up the stack.</span>
<span class="w">    </span><span class="nf">ret</span><span class="w"></span>
</pre></div>
<p>The PXE API returns a status flag in AX and the beginning of the input buffer passed. It is recommended to test both of these, where a non zero value indicates failure.
</p>
<h2><span id="Files.2C_via_TFTP"></span><span class="mw-headline" id="Files,_via_TFTP">Files, via TFTP</span></h2>
<p>Getting the files via TFTP require the TFTP server's IP address. Along with that, you might want the client machine's IP address, the DHCP server's IP address, the client's MAC address, and perhaps several other things.
</p><p>While this might seem daunting at first, PXE defines a neat way to do this.
</p>
<h3><span id="Getting_.22Cached_Information.22"></span><span class="mw-headline" id="Getting_&quot;Cached_Information&quot;">Getting "Cached Information"</span></h3>
<p>The PXE API's Get Cached Information function, with opcode 0x0071, requires a "t_PXENV_CACHED_INFO" passed to it, and returns a "bootph" structure. This "bootph" structure contains important information about the client and server machine, which is what is exactly wanted.
</p><p>The "t_PXENV_CACHED_INFO" follows the following structure:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">; Note - due to comfort reasons, the author has decided to provide the following snippet</span>
<span class="c1">; in Intel (NASM) Assembly. If someone wishes to change it to a more generic format, he is welcome.</span>
<span class="nl">t_PXENV_GET_CACHED:</span><span class="w"></span>
<span class="w">    </span><span class="na">.Status</span><span class="w">       </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="na">.PacketType</span><span class="w">   </span><span class="no">dw</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">    </span><span class="na">.BufferSize</span><span class="w">   </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">       </span><span class="na">.BufferOff</span><span class="w"> </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span>
<span class="w">       </span><span class="no">.BufferSeg</span><span class="w"> </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="na">.BufferLimit</span><span class="w">  </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
<ul><li><b>.Status</b>. This should be zero, and returns the status after the function call.</li></ul>
<ul><li><b>.PacketType</b>. This is the type of the packet, and 2 means "PXENV_PACKET_TYPE_DHCP_ACK", which is what we require. For further information, read the specifications.</li></ul>
<ul><li><b>.BufferSize</b>. The number of bytes copied into the segment and offset field given.</li></ul>
<ul><li><b>.BufferOff/Seg</b>. This gives the output buffer, to which to copy the bootph structure to. If you want, keep this to zero, and PXE would return the address of the Bootph structure in the BC data segment.</li></ul>
<p>To do a call, put the address of the above structure in ES:DI, put the opcode, 0x0071, in BX, and call the generic call function. A example call to the above function is, as follows:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">di</span><span class="p">,</span><span class="w"> </span><span class="no">t_PXENV_GET_CACHED</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">bx</span><span class="p">,</span><span class="w"> </span><span class="no">GET_CACHED_INFO</span><span class="w">           </span><span class="c1">; 0x0071.</span>
<span class="w">    </span>
<span class="w">    </span><span class="nf">call</span><span class="w"> </span><span class="no">UsePXEAPI</span><span class="w">                    </span><span class="c1">; Ask for the cached info.</span>
<span class="w">    </span>
<span class="w">    </span><span class="nf">or</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">t_PXENV_GET_CACHED</span><span class="p">]</span><span class="w">       </span><span class="c1">; Get the status into AX.</span>
<span class="w">    </span><span class="nf">test</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">    </span><span class="nf">jnz</span><span class="w"> </span><span class="no">.Error</span><span class="w"></span>
</pre></div>
<p>Bootph has a little complex structure, and the Specification should be referenced to know more about it. For now, the following is what you may require:
</p>
<ul><li>uint8_t CIP[4].  The Client IP address, at offset 12.</li>
<li>uint8_t YIP[4].  "Your" IP address, at offset 16.</li>
<li>uint8_t SIP[4].  Server IP address, at offset 20.</li>
<li>uint8_t GIP[4].  Relay agent IP address, at offset 24.</li>
<li>uint8_t MAC[16]. The MAC IP address, present at offset 28.</li>
<li>uint8_t SER[64]. The server host name, a asciiz string, at offset 40.</li>
<li>uint8_t BOO[128]. The Boot File name, a asciiz string, at offset 104.</li></ul>
<h3><span class="mw-headline" id="Opening">Opening</span></h3>
<p>PXE offers "TFTP Open", "TFTP Read" and "TFTP Close", which could be used like other common file I/O operations. It also offers a "TFTP Read File" - but it is recommended to use the former, which is more <i>configurable</i>.
</p><p>PXENV_TFTP_OPEN, with opcode 0x0020 is required to open a file via TFTP. It takes a t_PXENV_TFTP_OPEN structure as a parameter, which has the following format:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="nl">t_PXENV_TFTP_OPEN:</span><span class="w"></span>
<span class="w">    </span><span class="na">.Status</span><span class="w">       </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="na">.SIP</span><span class="w">          </span><span class="no">dd</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="na">.GIP</span><span class="w">          </span><span class="no">dd</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="na">.Filename</span><span class="w">     </span><span class="no">times</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="no">db</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="na">.Port</span><span class="w">         </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="na">.PacketSize</span><span class="w">   </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
<ul><li><b>.Status</b>. The status word.</li></ul>
<ul><li><b>.SIP</b>. The Server IP, which we just obtained.</li></ul>
<ul><li><b>.Filename</b>. A null terminated string, of the name of the file to open.</li></ul>
<ul><li><b>.Port</b>. This should contain 69, or the UDP Port.</li></ul>
<ul><li><b>.PacketSize</b>.  This contains the size of each packet read. Sizes of 512, 1024 and something small are recommended. Usually, bigger sizes load the file faster, but aren't supported much. See the section on performance below for more information relating to packet size.</li></ul>
<p>NOTE: The SIP, GIP (0 means default) and Port are all big endian.
</p>
<h3><span class="mw-headline" id="Reading">Reading</span></h3>
<p>The PXENV_TFTP_READ function, with opcode 0x0022, reads a single packet from the currently opened file. The size of the packet is set in the Open call, while the function requires a t_PXENV_TFTP_READ structure.
</p><p>The t_PXENV_TFTP_READ has the following structure:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="nl">t_PXENV_TFTP_READ:</span><span class="w"></span>
<span class="w">    </span><span class="na">.Status</span><span class="w">       </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="na">.PacketNumber</span><span class="w"> </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="na">.BufferSize</span><span class="w">   </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="na">.BufferOff</span><span class="w">    </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="na">.BufferSeg</span><span class="w">    </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
<ul><li><b>.Status</b>. This contains the status returned after the function call.</li></ul>
<ul><li><b>.PacketNumber</b>. This contains the packet number sent by the TFTP server. This is used to read packets in a order. Think of it like a index into the packets of the file - used to track of the current index.</li></ul>
<ul><li><b>.BufferSize</b>. The buffer size - number of bytes written in the packet buffer. It is the last packet if this is less than the size of the packet negotiated.</li></ul>
<ul><li><b>.BufferOff/Seg</b>. The address where you want to read the file packet.</li></ul>
<p>What you want to do here is to keep reading packets from the file by increasing the '.BufferOff/Seg' address, and checking if the size of the packet read is less than the size negotiated in TFTP_OPEN. It can be concluded that several implementations use 0 to indicate EOF, while other implementations give a 'packet read' size less than the size negotiated.
</p><p>With the above point in mind, the following pseudo code can be used to read a file:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">bytes_left</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">call_api</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// AX register contains whether it failed or not, while Status contains the detailed status.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;ax&quot;</span><span class="p">))</span><span class="w">                  </span>
<span class="w">        </span><span class="n">panic</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bytes_read</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">PACKET_SIZE</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">bytes_left</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">PACKET_SIZE</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Closing">Closing</span></h3>
<p>The PXENV_TFTP_CLOSE, with opcode 0x0021, is perhaps the simplest function. It requires a input buffer, with the following format, to be passed to it:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="nl">t_PXENV_TFTP_CLOSE:</span><span class="w"></span>
<span class="w">    </span><span class="na">.Status</span><span class="w">       </span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
<ul><li><b>.Status</b>. The Status returned after calling the function. The function would most probably ONLY fail if there is no active TFTP connection.</li></ul>
<h3><span class="mw-headline" id="Performance">Performance</span></h3>
<p>The original TFTP protocol is a very simple protocol (mostly because it was designed to be implemented easily on tiny embedded systems). The consequence is that it's relative slow (the "stop and wait" nature of it means that the network connection's bandwidth is significantly under-utilised). For larger files this can noticeably effect boot times.
</p><p>There are 3 approaches for improving performance.
</p>
<h4><span class="mw-headline" id="TFTP_Block_Size">TFTP Block Size</span></h4>
<p>In 1998 a "TFTP Blocksize option" was introduced. The basic idea is to improve performance by increasing the block/packet size (and reducing the number of data packets and the number of acknowledgement packets). This is supported by the PXE specification.
</p><p>In theory when you open a file via "TFTP Open" you're supposed to set the "PacketSize" field to what you're requesting, and (where possible) PXE is supposed to negotiate an appropriate packet size with the TFTP server and then set the  "PacketSize" field to size of the packet that both the PXE code in the client and the TFTP server agreed upon. This means that (e.g.) you should be able to set "PacketSize" to 65535 bytes and PXE will change it to the maximum size that is supported.
</p><p>In practice this only works on some/most network cards, and some networking cards are broken and don't work correctly. For example, the implementation of PXE that comes with various RealTek cards will simply return an "Unknown error" if the requested packet size is too large (even though the PXE specification says otherwise, and even though PXE defines more appropriate status codes).
</p><p>It is possible to work around this. The recommended work-around is:
</p>
<ul><li>If the "Version" field of the PXENV+ structure is less than "version 2.1"; be cautious and use a 512 byte packet size.</li>
<li>Use the "UNDI GET INFORMATION" function to get information about the network adapter. The returned information includes an MTU (Max. Transmission Unit) field. If this fails be cautious and use a 512 byte packet size.</li>
<li>Check if the MTU field is sane (within a reasonable range). If it's not within a reasonable range be cautious and use a 512 byte packet size.</li>
<li>Subtract the size of an IPv4 header (20 bytes), the size of the UDP header (8 byte), the size of the TFTP header (4 bytes) and 16 more bytes just in case from the MTU. This gives you the maximum packet size you can safely use.</li></ul>
<h4><span id="TFTP_.22Sliding_Window.22"></span><span class="mw-headline" id="TFTP_&quot;Sliding_Window&quot;">TFTP "Sliding Window"</span></h4>
<p>In 2015 a "TFTP Window Size" option was introduced. The basic idea here is to use "sliding window" (like TCP) instead of "stop and wait" to increase network bandwidth utilisation. Unfortunately, at this time I doubt any network cards support this.
</p>
<h4><span id="Advanced.2FNon-standard_Approaches"></span><span class="mw-headline" id="Advanced/Non-standard_Approaches">Advanced/Non-standard Approaches</span></h4>
<p>The PXE API exposes lower level functionality, including the ability to send arbitrary packets and to intercept received packets (via. a callback/"ISR"). In theory it would be possible for a boot loader to use these to implement any protocol it likes (e.g. use FTP or HTTP instead of TFTP) as long as the server is setup to support the protocol (in addition to TFTP that would still be needed to download the boot loader).
</p><p>The most extreme approach would be to design your own protocol and implement your own server. In this case (in theory) you would be able to maximize network bandwidth utilisation, and the client could also offload processing to the server. With a massive amount of over-engineering you could significantly reduce boot times this way.
</p>
<h2><span class="mw-headline" id="Cleaning_up">Cleaning up</span></h2>
<p>After you have finished reading files via PXE, the best idea would be to shutdown PXE and reclaim any memory it was using. PXE support is unloaded by using the "PXEAPI_UNDI_SHUTDOWN" function to restore the network adapter to it's default state, followed by the "PXENV_UNLOAD_STACK" function to unhook any IRQ handlers. 
</p><p>Lastly, PXE needs to prepare itself to be removed from memory (unhook interrupt 0x1A) using the "PXENV_STOP_UNDI" function (for PXE) or the "PXENV_UNDI_CLEANUP" function (for PXENV+).
</p><p>Once PXE is unloaded, memory can be reclaimed by checking the UNDI code segment and UNDI data segment start addresses and sizes (in the PXENV+ data structure), calculating "start address + size" and selecting the highest value. This value is the "new" number of bytes of RAM starting at 0x00000000 (or the amount of conventional memory), and can be used directly and/or the value at 0x40:0x13 (or 0x00000413) can be changed to reflect the new number of 1 KB blocks of conventional memory. 
</p><p>Please note that it's probably a good idea to calculate the amount of conventional memory before you unload PXE, because some of the functions above may clear the segment addresses and sizes in the PXENV+ structure.
</p><p><br />
</p>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="Diskless_Booting" title="Diskless Booting">Diskless Booting</a></li></ul>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="http://download.intel.com/design/archives/wfm/downloads/pxespec.pdf">PXE Specification</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250212011308
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.060 seconds
Real time usage: 1.243 seconds
Preprocessor visited node count: 104/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 16309/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:3013-0!canonical and timestamp 20250212011307 and revision id 28035.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=PXE&amp;oldid=28035">https://wiki.osdev.org/index.php?title=PXE&amp;oldid=28035</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Booting" title="Category:Booting">Booting</a></li><li><a href="./Category:Bootloaders" title="Category:Bootloaders">Bootloaders</a></li><li><a href="./Category:Network_Protocols" title="Category:Network Protocols">Network Protocols</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=PXE" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="PXE#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="PXE" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Talk:PXE&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="PXE"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PXE&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PXE&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/PXE" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/PXE" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PXE&amp;oldid=28035" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PXE&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/PXE" title="PXE – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 9 July 2023, at 18:46.</li>
	<li id="footer-info-0">This page has been accessed 3,601 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=PXE&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.060","walltime":"1.243","ppvisitednodes":{"value":104,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":16309,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20250212011308","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":1347});});</script>
</body>
</html>