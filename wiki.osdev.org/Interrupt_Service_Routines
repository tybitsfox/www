<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Interrupt Service Routines - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"4affe0606afa3197cc60de86","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Interrupt_Service_Routines","wgTitle":"Interrupt Service Routines","wgCurRevisionId":29237,"wgRevisionId":29237,"wgArticleId":1719,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Interrupts","X86"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Interrupt_Service_Routines","wgRelevantArticleId":1719,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],
"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Interrupt_Service_Routines rootpage-Interrupt_Service_Routines skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Interrupt Service Routines</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="Interrupt_Service_Routines#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="Interrupt_Service_Routines#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>The <a href="./Category:X86" title="Category:X86">x86</a> architecture is an <a href="Interrupt" class="mw-redirect" title="Interrupt">interrupt</a> driven system. External events trigger an interrupt — the normal control flow is interrupted and an <b>Interrupt Service Routine</b> (ISR) is called.
</p><p>Such events can be triggered by hardware or software. An example of a hardware interrupt is the keyboard: every time you press a key, the keyboard triggers IRQ1 (Interrupt Request 1), and the corresponding interrupt handler is called. Timers and disk request completion are other possible sources of hardware interrupts.
</p><p>Software driven interrupts are triggered by the <tt>int</tt> opcode; e.g. the services provided by MS-DOS are called by the software triggering <tt>INT 21h</tt> and passing the applicable parameters in CPU registers.
</p><p>For the system to know which interrupt service routine to call when a certain interrupt occurs, offsets to the ISRs are stored in the <a href="IDT" class="mw-redirect" title="IDT">Interrupt Descriptor Table</a> when you're in <a href="Protected_mode" class="mw-redirect" title="Protected mode">Protected mode</a>, or in the <a href="Interrupt_Vector_Table" title="Interrupt Vector Table">Interrupt Vector Table</a> when you're in <a href="Real_Mode" title="Real Mode">Real Mode</a>.
</p><p>An ISR is called directly by the CPU, and the protocol for calling an ISR differs from calling e.g. a C function. Most importantly, an ISR has to end with the <tt>iret</tt> opcode (or <tt>iretq</tt> in long mode—yes, even when using intel syntax), whereas usual C functions end with <tt>ret</tt> or <tt>retf</tt>. The obvious but nevertheless wrong solution leads to one of the most "popular" triple-fault errors among OS programmers.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Interrupt_Service_Routines#When_the_Handlers_are_Called"><span class="tocnumber">1</span> <span class="toctext">When the Handlers are Called</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="Interrupt_Service_Routines#x86"><span class="tocnumber">1.1</span> <span class="toctext">x86</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="Interrupt_Service_Routines#x86-64"><span class="tocnumber">1.2</span> <span class="toctext">x86-64</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="Interrupt_Service_Routines#The_Problem"><span class="tocnumber">2</span> <span class="toctext">The Problem</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="Interrupt_Service_Routines#Solutions"><span class="tocnumber">3</span> <span class="toctext">Solutions</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="Interrupt_Service_Routines#Plain_Assembly"><span class="tocnumber">3.1</span> <span class="toctext">Plain Assembly</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="Interrupt_Service_Routines#Two-Stage_Assembly_Wrapping"><span class="tocnumber">3.2</span> <span class="toctext">Two-Stage Assembly Wrapping</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="Interrupt_Service_Routines#Compiler_Specific_Interrupt_Directives"><span class="tocnumber">3.3</span> <span class="toctext">Compiler Specific Interrupt Directives</span></a>
<ul>
<li class="toclevel-3 tocsection-9"><a href="Interrupt_Service_Routines#Clang"><span class="tocnumber">3.3.1</span> <span class="toctext">Clang</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="Interrupt_Service_Routines#Borland_C"><span class="tocnumber">3.3.2</span> <span class="toctext">Borland C</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="Interrupt_Service_Routines#Watcom_C/C++"><span class="tocnumber">3.3.3</span> <span class="toctext">Watcom C/C++</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="Interrupt_Service_Routines#Naked_Functions"><span class="tocnumber">3.3.4</span> <span class="toctext">Naked Functions</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="Interrupt_Service_Routines#Visual_C++"><span class="tocnumber">3.3.5</span> <span class="toctext">Visual C++</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="Interrupt_Service_Routines#GCC_/_G++"><span class="tocnumber">3.3.6</span> <span class="toctext">GCC / G++</span></a>
<ul>
<li class="toclevel-4 tocsection-15"><a href="Interrupt_Service_Routines#Black_Magic"><span class="tocnumber">3.3.6.1</span> <span class="toctext">Black Magic</span></a></li>
<li class="toclevel-4 tocsection-16"><a href="Interrupt_Service_Routines#Assembly_Goto"><span class="tocnumber">3.3.6.2</span> <span class="toctext">Assembly Goto</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="When_the_Handlers_are_Called">When the Handlers are Called</span></h2>
<h3><span class="mw-headline" id="x86">x86</span></h3>
<p>When the CPU calls the interrupt handlers, the CPU pushes these values onto the stack in this order:
</p>
<pre>EFLAGS -&gt; CS -&gt; EIP
</pre>
<p>The CS value is padded with two bytes to form a doubleword.
</p><p>If the gate type is not a trap gate, the CPU will clear the interrupt flag. If the interrupt is an exception, the CPU will push an error code onto the stack, as a doubleword.
</p><p>The CPU will load the segment-selector value from the associated IDT descriptor into CS.
</p>
<h3><span class="mw-headline" id="x86-64">x86-64</span></h3>
<p>When the CPU calls the interrupt handlers, it changes the value in the RSP register to the value specified in the IST, and if there is none, the stack stays the same. Onto the new stack, the CPU pushes these values in this order:
</p>
<pre>SS:RSP (original RSP) -&gt; RFLAGS -&gt; CS -&gt; RIP
</pre>
<p>CS is padded to form a quadword.
</p><p>If the interrupt is called from a different ring, SS is set to 0, indicating a null selector. The CPU will modify the RFLAGS register, setting the TF, NT, and RF bits to 0. If the gate type is an interrupt gate, the CPU will clear the interrupt flag.
</p><p>If the interrupt is an exception, the CPU will push an error code onto the stack, padded with bytes to form a quadword.
</p><p>The CPU will load the segment-selector value from the associated IDT descriptor into CS, and check to ensure that CS is a valid code segment selector.
</p>
<h2><span class="mw-headline" id="The_Problem">The Problem</span></h2>
<p>Many people shy away from assembly, and want to do as much as possible in their favorite high-level language. <a href="GCC" title="GCC">GCC</a> (as well as other compilers) allow you to add inline assembly, so many programmers are tempted to write an ISR like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* How NOT to write an interrupt handler */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">interrupt_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;pushad&quot;</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Save registers. */</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* do something */</span><span class="w"></span>
<span class="w">    </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;popad&quot;</span><span class="p">);</span><span class="w">  </span><span class="cm">/* Restore registers. */</span><span class="w"></span>
<span class="w">    </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;iret&quot;</span><span class="p">);</span><span class="w">   </span><span class="cm">/* This will triple-fault! */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This cannot work. The compiler doesn't understand what is going on. It doesn't understand that the registers and stack are required to be preserved between the asm statements; the optimizer will likely corrupt the function. Additionally, the compiler adds stack handling code before and after your function, which together with the iret results in assembly code resembling this:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">push</span><span class="w">   </span><span class="nv">%ebp</span><span class="w"></span>
<span class="nf">mov</span><span class="w">    </span><span class="nv">%esp</span><span class="p">,</span><span class="nv">%ebp</span><span class="w"></span>
<span class="nf">sub</span><span class="w">    </span><span class="no">$</span><span class="err">&lt;</span><span class="no">size</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">local</span><span class="w"> </span><span class="no">variables</span><span class="err">&gt;</span><span class="p">,</span><span class="nv">%esp</span><span class="w"></span>
<span class="nf">pushad</span><span class="w"></span>
<span class="c1"># C code comes here</span>
<span class="nf">popad</span><span class="w"></span>
<span class="nf">iret</span><span class="w"></span>
<span class="c1"># &#39;leave&#39; if you use local variables, &#39;pop %ebp&#39; otherwise.</span>
<span class="nf">leave</span><span class="w"></span>
<span class="nf">ret</span><span class="w"></span>
</pre></div>
<p>It should be obvious how this messes up the stack (ebp gets pushed but never popped). Don't do this. Instead, these are your options.
</p>
<h2><span class="mw-headline" id="Solutions">Solutions</span></h2>
<h3><span class="mw-headline" id="Plain_Assembly">Plain Assembly</span></h3>
<p>Learn enough about assembly to write your interrupt handlers in it.&#160;;-)
</p>
<h3><span class="mw-headline" id="Two-Stage_Assembly_Wrapping">Two-Stage Assembly Wrapping</span></h3>
<p>Write an assembly wrapper calling the C function to do the real work, and then doing the iret.
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">; filename: isr_wrapper.s</span>
<span class="na">.globl</span><span class="w">   </span><span class="no">isr_wrapper</span><span class="w"></span>
<span class="na">.align</span><span class="w">   </span><span class="mi">4</span><span class="w"></span>

<span class="nl">isr_wrapper:</span><span class="w"></span>
<span class="w">    </span><span class="nf">pushad</span><span class="w"></span>
<span class="w">    </span><span class="nf">cld</span><span class="w">    </span><span class="c1">; C code following the sysV ABI requires DF to be clear on function entry</span>
<span class="w">    </span><span class="nf">call</span><span class="w"> </span><span class="no">interrupt_handler</span><span class="w"></span>
<span class="w">    </span><span class="nf">popad</span><span class="w"></span>
<span class="w">    </span><span class="nf">iret</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* filename: interrupt_handler.c */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">interrupt_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* do something */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Compiler_Specific_Interrupt_Directives">Compiler Specific Interrupt Directives</span></h3>
<p>Some compilers for some processors have directives allowing you to declare a routine interrupt, offer a #pragma interrupt, or a dedicated macro. Clang 3.9, Borland C, Watcom C/C++, Microsoft C 6.0 and Free Pascal Compiler 1.9.* upward and GCC offer this. Visual C++ offers an alternative shown under <b>Naked Functions</b>:
</p>
<h4><span class="mw-headline" id="Clang">Clang</span></h4>
<p>As of version 3.9 it supports <a rel="nofollow" class="external text" href="https://clang.llvm.org/docs/AttributeReference.html#interrupt-x86">interrupt attribute</a> for x86/x86-64 targets.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">interrupt_frame</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">uword_t</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">uword_t</span><span class="w"> </span><span class="n">cs</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">uword_t</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">uword_t</span><span class="w"> </span><span class="n">sp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">uword_t</span><span class="w"> </span><span class="n">ss</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">interrupt</span><span class="p">))</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">interrupt_handler</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">interrupt_frame</span><span class="w"> </span><span class="o">*</span><span class="n">frame</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* do something */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Borland_C">Borland C</span></h4>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* Borland C */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">interrupt</span><span class="w"> </span><span class="nf">interrupt_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* do something */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h4><span id="Watcom_C.2FC.2B.2B"></span><span class="mw-headline" id="Watcom_C/C++">Watcom C/C++</span></h4>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* Watcom C/C++ */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">_interrupt</span><span class="w"> </span><span class="nf">interrupt_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* do something */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Naked_Functions">Naked Functions</span></h4>
<p>Some compilers can be used to make interrupt routines, but require you to manually handle the stack and return operations. Doing so requires that the function is generated without an epilogue or prologue. This is called making the function <i>naked</i> — this is done in Visual C++ by adding the attribute <i>_declspec(naked)</i> to the function. You need to verify that you do include a return operation (such as <i>iretd</i>) as that is part of the epilogue that the compiler has now been instructed to not include.
</p><p>If you intend to use local variables, you must set up the stack frame in the manner which the compiler expects; as ISRs are non-reentrant, however, you can simply use static variables.
</p>
<h4><span id="Visual_C.2B.2B"></span><span class="mw-headline" id="Visual_C++">Visual C++</span></h4>
<p>Visual C++ also supplies the __LOCAL_SIZE assembler macro, which notifies you how much space is required by the objects on the stack for the function.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* Microsoft Visual C++ */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">_declspec</span><span class="p">(</span><span class="kr">naked</span><span class="p">)</span><span class="w"> </span><span class="n">interrupt_handler</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">_asm</span><span class="w"> </span><span class="n">pushad</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* do something */</span><span class="w"></span>

<span class="w">    </span><span class="n">_asm</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">popad</span><span class="w"></span>
<span class="w">        </span><span class="n">iretd</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h4><span id="GCC_.2F_G.2B.2B"></span><span class="mw-headline" id="GCC_/_G++">GCC / G++</span></h4>
<p><a rel="nofollow" class="external text" href="https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html#x86-Function-Attributes">The online docs</a> say that by using GCC's function attributes, they have added the ability to write interrupt handlers in C interface by using __attribute__((interrupt)). So instead of:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* BLACK MAGIC – strongly discouraged! */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">interrupt_handler</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;pushad&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* do something */</span><span class="w"></span>
<span class="w">    </span><span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;popad; leave; iret&quot;</span><span class="p">);</span><span class="w"> </span><span class="cm">/* BLACK MAGIC! */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>You can have the correct (GCC) form:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">interrupt_frame</span><span class="p">;</span><span class="w"></span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">interrupt</span><span class="p">))</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">interrupt_handler</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">interrupt_frame</span><span class="o">*</span><span class="w"> </span><span class="n">frame</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* do something */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The documentation for GCC states that if the interrupt attribute is used, the iret instruction will be used instead of ret on x86 and x86-64 architectures. It also says, "Since GCC doesn’t preserve SSE, MMX nor x87 states, the GCC option -mgeneral-regs-only should be used to compile interrupt and exception handlers."
</p>
<h5><span class="mw-headline" id="Black_Magic">Black Magic</span></h5>
<p>Look at the faulty code <a href="Interrupt_Service_Routines#The_Problem" title="Interrupt Service Routines">above</a>, where the proper C function exit code was skipped, screwing up the stack. Now, consider this code snippet, where the exit code is added manually:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* BLACK MAGIC – strongly discouraged! */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">interrupt_handler</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;pushad&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* do something */</span><span class="w"></span>
<span class="w">    </span><span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;popad; leave; iret&quot;</span><span class="p">);</span><span class="w"> </span><span class="cm">/* BLACK MAGIC! */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The corresponding output would look somewhat like this:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">push</span><span class="w">   </span><span class="nv">%ebp</span><span class="w"></span>
<span class="nf">mov</span><span class="w">    </span><span class="nv">%esp</span><span class="p">,</span><span class="nv">%ebp</span><span class="w"></span>
<span class="nf">sub</span><span class="w">    </span><span class="no">$</span><span class="err">&lt;</span><span class="no">size</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">local</span><span class="w"> </span><span class="no">variables</span><span class="err">&gt;</span><span class="p">,</span><span class="nv">%esp</span><span class="w"></span>
<span class="nf">pushad</span><span class="w"></span>
<span class="c1"># C code comes here</span>
<span class="nf">popad</span><span class="w"></span>
<span class="nf">leave</span><span class="w"></span>
<span class="nf">iret</span><span class="w"></span>
<span class="nf">leave</span><span class="w"> </span><span class="c1"># dead code</span>
<span class="nf">ret</span><span class="w">   </span><span class="c1"># dead code</span>
</pre></div>
<p>This assumes that <tt>leave</tt> is the correct end-of-function handling — you are doing the function return code "by hand", and leave the compiler-generated handling as "dead code". Needless to say, such assumptions on compiler internals are dangerous. This code can break on a different compiler, or even a different version of the same compiler. It is therefore strongly discouraged, and listed only for completeness.
</p>
<h5><span class="mw-headline" id="Assembly_Goto">Assembly Goto</span></h5>
<dl><dd><i>Full article: <a href="https://wiki.osdev.org/index.php?title=ISRs_PIC_And_Multitasking&amp;action=edit&amp;redlink=1" class="new" title="ISRs PIC And Multitasking (page does not exist)">ISRs, PIC, And Multitasking</a></i></dd></dl>
<p>Since version 4.5, GCC supports the "asm goto" statement. It can be used to make ISRs as functions which return the correct address of the ISR entry point.
</p>
<!-- 
NewPP limit report
Cached time: 20250211122352
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.067 seconds
Real time usage: 1.519 seconds
Preprocessor visited node count: 126/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 12826/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1719-0!canonical and timestamp 20250211122350 and revision id 29237.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Interrupt_Service_Routines&amp;oldid=29237">https://wiki.osdev.org/index.php?title=Interrupt_Service_Routines&amp;oldid=29237</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Interrupts" title="Category:Interrupts">Interrupts</a></li><li><a href="./Category:X86" title="Category:X86">X86</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Interrupt+Service+Routines" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="Interrupt_Service_Routines#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Interrupt_Service_Routines" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Talk:Interrupt_Service_Routines&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Interrupt_Service_Routines"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Interrupt_Service_Routines&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Interrupt_Service_Routines&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Interrupt_Service_Routines" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/Interrupt_Service_Routines" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Interrupt_Service_Routines&amp;oldid=29237" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Interrupt_Service_Routines&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 5 September 2024, at 14:03.</li>
	<li id="footer-info-0">This page has been accessed 15,523 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Interrupt_Service_Routines&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.067","walltime":"1.519","ppvisitednodes":{"value":126,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":12826,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20250211122352","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":1631});});</script>
</body>
</html>