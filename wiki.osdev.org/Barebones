<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Bare Bones - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"fd88c84c790a1013c2d179bb","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Bare_Bones","wgTitle":"Bare Bones","wgCurRevisionId":29250,"wgRevisionId":29250,"wgArticleId":1741,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using duplicate arguments in template calls","Pages using deprecated source tags","Level 1 Tutorials","Bare bones tutorials","C","C++"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Bare_Bones","wgRelevantArticleId":1741,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable"
:false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":"Barebones","wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgInternalRedirectTargetUrl":"/Bare_Bones","wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head","mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve",
"ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="Bare_Bones"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Bare_Bones rootpage-Bare_Bones skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Bare Bones</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"><span class="mw-redirectedfrom">(Redirected from <a href="https://wiki.osdev.org/index.php?title=Barebones&amp;redirect=no" class="mw-redirect" title="Barebones">Barebones</a>)</span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="Barebones#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="Barebones#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><center>
<table style="border: 1px solid #cfcfbf; margin-top: 25px; margin-bottom: 25px; background-color: #f0f0ff; text-align: center;">
<tbody><tr>
<td>
<p><big><b>WAIT! Have you read <a href="Getting_Started" title="Getting Started">Getting Started</a>, <a href="Beginner_Mistakes" title="Beginner Mistakes">Beginner Mistakes</a>, and some of the related <a href="./Category:OS_theory" title="Category:OS theory">OS theory</a>?</b></big>
</p>
</td></tr></tbody></table>
</center><table style="font-size:95%; line-height:1.5em; padding:0.25em; float:right; margin: 0 0 8px 15px; clear:right; border:1px solid #aaaaaa; background:#eee; text-align:center;;"><tbody><tr><th>Difficulty level</th></tr><tr><td><a href="./File:Difficulty_1.png" class="image"><img alt="Difficulty 1.png" src="images/d/d3/Difficulty_1.png" decoding="async" width="46" height="14" data-file-width="46" data-file-height="14" /></a><br />Beginner</td></tr></tbody></table>
<table style="font-size:95%; line-height:1.5em; padding:0.25em; float:right; margin: 0 0 8px 15px; clear: right; border:1px solid #aaaaaa; background:#eee; text-align:center; width:200px; ;"><tbody><tr><th style="background:#ffce7b; padding:0.3em; font-size:1.1em;"><a href="Kernels" class="mw-redirect" title="Kernels">Kernel Designs</a></th></tr><tr><th>Models</th></tr><tr><td><div>
<p><a href="Monolithic_Kernel" title="Monolithic Kernel">Monolithic Kernel</a><br />
<a href="Microkernel" title="Microkernel">Microkernel</a><br />
<a href="Hybrid_Kernel" title="Hybrid Kernel">Hybrid Kernel</a><br />
<a href="Exokernel" title="Exokernel">Exokernel</a><br />
<a href="Nanokernel" class="mw-redirect" title="Nanokernel">Nano/Picokernel</a><br />
<a href="Exokernel#Cache_Kernel" title="Exokernel">Cache Kernel</a><br />
<a href="Exokernel#Virtualizing_Kernel" title="Exokernel">Virtualizing Kernel</a><br />
<a href="Megalithic_Kernel" title="Megalithic Kernel">Megalithic Kernel</a><br />
</p>
</div></td></tr><tr><th>Other Concepts</th></tr><tr><td><div>
<p><a href="Modular_Kernel" title="Modular Kernel">Modular Kernel</a><br />
<a href="Higher_Half_Kernel" title="Higher Half Kernel">Higher Half Kernel</a><br />
<a href="Creating_a_64-bit_kernel" title="Creating a 64-bit kernel">64-bit Kernel</a><br />
</p>
</div></td></tr></tbody></table>
<p>In this tutorial you will write a simple kernel for <a href="IA32_Architecture_Family" title="IA32 Architecture Family">32-bit x86</a> and boot it. This is the first step in creating your own operating system. This tutorial serves as an example of how to create a minimal system, but not as an example of how to properly structure your project. These instructions are community reviewed and follow the current recommendations for good reasons. Beware of the many other tutorials available online as they do not follow modern advice and were written by the inexperienced.
</p><p>You are about to begin development of a new operating system. Perhaps one day, your new operating system can be developed under itself. This is a process known as bootstrapping or going self-hosted. Today, you will simply set up a system that can compile your new operating system from an existing operating system. This process is known as <a href="Why_do_I_need_a_Cross_Compiler?" title="Why do I need a Cross Compiler?">cross-compiling</a> and it is the first step in operating systems development.
</p><p>This tutorial uses existing technology to get you started and straight into <a href="Kernel" title="Kernel">kernel</a> development, rather than developing your own <a href="Languages" title="Languages">programming language</a>, your own <a href="Compiler" title="Compiler">compiler</a>, and your own <a href="Bootloader" title="Bootloader">bootloader</a>. In this tutorial, you will use:
</p>
<ul><li>The <a href="LD" title="LD">GNU Linker</a> from <a href="Binutils" title="Binutils">Binutils</a> to link your <a href="Object_File" class="mw-redirect" title="Object File">object files</a> into the final kernel.</li>
<li>The <a href="GAS" title="GAS">GNU Assembler</a> from <a href="Binutils" title="Binutils">Binutils</a> (or optionally <a href="NASM" title="NASM">NASM</a>) to <a href="Assembly" title="Assembly">assemble instructions</a> into object files containing machine code.</li>
<li>The <a href="GCC" title="GCC">GNU Compiler Collection</a> to compile your high level code into assembly.</li>
<li>The <a href="C" title="C">C</a> programming language (or optionally <a href="C++" title="C++">C++</a>) to write the high level parts of your <a href="Kernel" title="Kernel">kernel</a>.</li>
<li>The <a href="GRUB" title="GRUB">GRUB</a> bootloader to <a href="Bootloader" title="Bootloader">bootload</a> your kernel using the <a href="Multiboot" title="Multiboot">Multiboot</a> boot protocol that loads us into 32-bit protected mode with <a href="Paging" title="Paging">paging</a> disabled.</li>
<li>The <a href="ELF" title="ELF">ELF</a> as the <a href="Executable_Formats" title="Executable Formats">executable format</a> that gives us control of where and how the kernel is loaded.</li></ul>
<p>This article assumes you are using a Unix-like operating system such as Linux which supports operating systems development well. Windows users should be able to complete it from a <a href="WSL" class="mw-redirect" title="WSL">WSL</a>, <a href="MinGW" title="MinGW">MinGW</a>, or <a href="Cygwin" title="Cygwin">Cygwin</a> environment.
</p><p>Succeeding at operating systems development requires becoming an expert, having patience, and reading all the instructions very carefully. You need to read everything in this article before proceeding. If you run into problems, you need to reread the article even more carefully and then do it thrice more for good measure. If you still have issues, the OSDev community is experienced and will gladly help at the <a rel="nofollow" class="external text" href="http://forum.osdev.org">forums</a> or on <a href="Chat" title="Chat">IRC</a>.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Barebones#Building_a_Cross-Compiler"><span class="tocnumber">1</span> <span class="toctext">Building a Cross-Compiler</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Barebones#Overview"><span class="tocnumber">2</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="Barebones#Booting_the_Operating_System"><span class="tocnumber">3</span> <span class="toctext">Booting the Operating System</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="Barebones#Bootstrap_Assembly"><span class="tocnumber">3.1</span> <span class="toctext">Bootstrap Assembly</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="Barebones#Implementing_the_Kernel"><span class="tocnumber">4</span> <span class="toctext">Implementing the Kernel</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="Barebones#Freestanding_and_Hosted_Environments"><span class="tocnumber">4.1</span> <span class="toctext">Freestanding and Hosted Environments</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="Barebones#Writing_a_kernel_in_C"><span class="tocnumber">4.2</span> <span class="toctext">Writing a kernel in C</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="Barebones#Writing_a_kernel_in_C++"><span class="tocnumber">4.3</span> <span class="toctext">Writing a kernel in C++</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="Barebones#Linking_the_Kernel"><span class="tocnumber">5</span> <span class="toctext">Linking the Kernel</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="Barebones#Verifying_Multiboot"><span class="tocnumber">6</span> <span class="toctext">Verifying Multiboot</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="Barebones#Booting_the_Kernel"><span class="tocnumber">7</span> <span class="toctext">Booting the Kernel</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="Barebones#Building_a_bootable_cdrom_image"><span class="tocnumber">7.1</span> <span class="toctext">Building a bootable cdrom image</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="Barebones#Testing_your_operating_system_(QEMU)"><span class="tocnumber">7.2</span> <span class="toctext">Testing your operating system (QEMU)</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="Barebones#Testing_your_operating_system_(Real_Hardware)"><span class="tocnumber">7.3</span> <span class="toctext">Testing your operating system (Real Hardware)</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-15"><a href="Barebones#Moving_Forward"><span class="tocnumber">8</span> <span class="toctext">Moving Forward</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="Barebones#Adding_Support_for_Newlines_to_Terminal_Driver"><span class="tocnumber">8.1</span> <span class="toctext">Adding Support for Newlines to Terminal Driver</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="Barebones#Implementing_Terminal_Scrolling"><span class="tocnumber">8.2</span> <span class="toctext">Implementing Terminal Scrolling</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="Barebones#Rendering_Colorful_ASCII_Art"><span class="tocnumber">8.3</span> <span class="toctext">Rendering Colorful ASCII Art</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="Barebones#Calling_Global_Constructors"><span class="tocnumber">8.4</span> <span class="toctext">Calling Global Constructors</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="Barebones#Meaty_Skeleton"><span class="tocnumber">8.5</span> <span class="toctext">Meaty Skeleton</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="Barebones#Going_Further"><span class="tocnumber">8.6</span> <span class="toctext">Going Further</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="Barebones#Bare_Bones_II"><span class="tocnumber">8.7</span> <span class="toctext">Bare Bones II</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-23"><a href="Barebones#Frequently_Asked_Questions"><span class="tocnumber">9</span> <span class="toctext">Frequently Asked Questions</span></a></li>
<li class="toclevel-1 tocsection-24"><a href="Barebones#See_Also"><span class="tocnumber">10</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-25"><a href="Barebones#Articles"><span class="tocnumber">10.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="Barebones#External_Links"><span class="tocnumber">10.2</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Building_a_Cross-Compiler">Building a Cross-Compiler</span></h2>
<dl><dd><i>Main article: <a href="GCC_Cross-Compiler" title="GCC Cross-Compiler">GCC Cross-Compiler</a>, <a href="Why_do_I_need_a_Cross_Compiler?" title="Why do I need a Cross Compiler?">Why do I need a Cross Compiler?</a></i></dd></dl>
<p>The first thing you should do is set up a <a href="GCC_Cross-Compiler" title="GCC Cross-Compiler">GCC Cross-Compiler</a> for <b>i686-elf</b>. You have not yet modified your compiler to know about the existence of your operating system, so you will use a generic target called i686-elf, which provides you with a toolchain targeting the System V ABI. This setting is well tested and understood by the osdev community and will allow you to easily set up a bootable kernel using GRUB and Multiboot. (Note that if you are already using an ELF platform, such as Linux, you may already have a GCC that produces ELF programs. This is not suitable for osdev work, as this compiler will produce programs for Linux, and your operating system is <b>not</b> Linux, no matter how similar it is. You will certainly run into trouble if you don't use a cross-compiler.)
</p><p>You will <i>not</i> be able to correctly compile your operating system without a cross-compiler.
</p><p>You will <i>not</i> be able to correctly complete this tutorial with a x86_64-elf cross-compiler, as GRUB is only able to load 32-bit multiboot kernels. If this is your first operating system project, you should do a 32-bit kernel first. If you use a x86_64 compiler instead and somehow bypass the later sanity check, you will end up with a kernel that GRUB doesn't know how to boot.
</p>
<h2><span class="mw-headline" id="Overview">Overview</span></h2>
<p>By now, you should have set up your <a href="GCC_Cross-Compiler" title="GCC Cross-Compiler">cross-compiler</a> for i686-elf (as described above). This tutorial provides a minimal solution for creating an operating system for x86. It doesn't serve as a recommend skeleton for project structure, but rather as an example of a minimal kernel. In this simple case, you just need three input files:
</p>
<ul><li>boot.s - kernel entry point that sets up the processor environment</li>
<li>kernel.c - your actual kernel routines</li>
<li>linker.ld - for linking the above files</li></ul>
<h2><span class="mw-headline" id="Booting_the_Operating_System">Booting the Operating System</span></h2>
<p>To start the operating system, an existing piece of software will be needed to load it. This is called the bootloader and in this tutorial you will be using <a href="GRUB" title="GRUB">GRUB</a>. Writing your own bootloader is an advanced subject, but it is commonly done. We'll later configure the bootloader, but the operating system needs to handle when the bootloader passes control to it. The kernel is passed a very minimal environment, in which the stack is not set up yet, virtual memory is not yet enabled, hardware is not initialized, and so on.
</p><p>The first task you will deal with is how the bootloader starts the kernel. OSDevers are lucky because there exists a Multiboot Standard, which describes an easy interface between the bootloader and the operating system kernel. It works by putting a few magic values in some global variables (known as a multiboot header), which is searched for by the bootloader. When it sees these values, it recognizes the kernel as multiboot compatible and it knows how to load us, and it can even forward us important information such as memory maps, but you won't need that yet.
</p><p>Since there is no stack yet and you need to make sure the global variables are set correctly, you will do this in assembly.
</p>
<h3><span class="mw-headline" id="Bootstrap_Assembly">Bootstrap Assembly</span></h3>
<dl><dd><i>Alternatively, you can use <a href="Bare_Bones_with_NASM" title="Bare Bones with NASM">NASM</a> as your assembler.</i></dd></dl>
<p>You will now create a file called boot.s and discuss its contents. In this example, you are using the GNU assembler, which is part of the cross-compiler toolchain you built earlier. This assembler integrates very well with the rest of the GNU toolchain.
</p><p>The very most important piece to create is the multiboot header, as it must be very early in the kernel binary, or the bootloader will fail to recognize us. 
</p>
<pre>/* Declare constants for the multiboot header. */
.set ALIGN,    1&lt;&lt;0             /* align loaded modules on page boundaries */
.set MEMINFO,  1&lt;&lt;1             /* provide memory map */
.set FLAGS,    ALIGN | MEMINFO  /* this is the Multiboot 'flag' field */
.set MAGIC,    0x1BADB002       /* 'magic number' lets bootloader find the header */
.set CHECKSUM, -(MAGIC + FLAGS) /* checksum of above, to prove we are multiboot */

/* 
Declare a multiboot header that marks the program as a kernel. These are magic
values that are documented in the multiboot standard. The bootloader will
search for this signature in the first 8 KiB of the kernel file, aligned at a
32-bit boundary. The signature is in its own section so the header can be
forced to be within the first 8 KiB of the kernel file.
*/
.section .multiboot
.align 4
.long MAGIC
.long FLAGS
.long CHECKSUM

/*
The multiboot standard does not define the value of the stack pointer register
(esp) and it is up to the kernel to provide a stack. This allocates room for a
small stack by creating a symbol at the bottom of it, then allocating 16384
bytes for it, and finally creating a symbol at the top. The stack grows
downwards on x86. The stack is in its own section so it can be marked nobits,
which means the kernel file is smaller because it does not contain an
uninitialized stack. The stack on x86 must be 16-byte aligned according to the
System V ABI standard and de-facto extensions. The compiler will assume the
stack is properly aligned and failure to align the stack will result in
undefined behavior.
*/
.section .bss
.align 16
stack_bottom:
.skip 16384 # 16 KiB
stack_top:

/*
The linker script specifies _start as the entry point to the kernel and the
bootloader will jump to this position once the kernel has been loaded. It
doesn't make sense to return from this function as the bootloader is gone.
*/
.section .text
.global _start
.type _start, @function
_start:
	/*
	The bootloader has loaded us into 32-bit protected mode on a x86
	machine. Interrupts are disabled. Paging is disabled. The processor
	state is as defined in the multiboot standard. The kernel has full
	control of the CPU. The kernel can only make use of hardware features
	and any code it provides as part of itself. There's no printf
	function, unless the kernel provides its own &lt;stdio.h&gt; header and a
	printf implementation. There are no security restrictions, no
	safeguards, no debugging mechanisms, only what the kernel provides
	itself. It has absolute and complete power over the
	machine.
	*/

	/*
	To set up a stack, we set the esp register to point to the top of the
	stack (as it grows downwards on x86 systems). This is necessarily done
	in assembly as languages such as C cannot function without a stack.
	*/
	mov $stack_top, %esp

	/*
	This is a good place to initialize crucial processor state before the
	high-level kernel is entered. It's best to minimize the early
	environment where crucial features are offline. Note that the
	processor is not fully initialized yet: Features such as floating
	point instructions and instruction set extensions are not initialized
	yet. The GDT should be loaded here. Paging should be enabled here.
	C++ features such as global constructors and exceptions will require
	runtime support to work as well.
	*/

	/*
	Enter the high-level kernel. The ABI requires the stack is 16-byte
	aligned at the time of the call instruction (which afterwards pushes
	the return pointer of size 4 bytes). The stack was originally 16-byte
	aligned above and we've pushed a multiple of 16 bytes to the
	stack since (pushed 0 bytes so far), so the alignment has thus been
	preserved and the call is well defined.
	*/
	call kernel_main

	/*
	If the system has nothing more to do, put the computer into an
	infinite loop. To do that:
	1) Disable interrupts with cli (clear interrupt enable in eflags).
	   They are already disabled by the bootloader, so this is not needed.
	   Mind that you might later enable interrupts and return from
	   kernel_main (which is sort of nonsensical to do).
	2) Wait for the next interrupt to arrive with hlt (halt instruction).
	   Since they are disabled, this will lock up the computer.
	3) Jump to the hlt instruction if it ever wakes up due to a
	   non-maskable interrupt occurring or due to system management mode.
	*/
	cli
1:	hlt
	jmp 1b

/*
Set the size of the _start symbol to the current location '.' minus its start.
This is useful when debugging or when you implement call tracing.
*/
.size _start, . - _start
</pre>
<p>You can then assemble boot.s using:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>i686-elf-as boot.s -o boot.o
</pre></div>
<h2><span class="mw-headline" id="Implementing_the_Kernel">Implementing the Kernel</span></h2>
<p>So far you have written the bootstrap assembly stub that sets up the processor such that high level languages such as C can be used. It is also possible to use other languages such as C++.
</p>
<h3><span class="mw-headline" id="Freestanding_and_Hosted_Environments">Freestanding and Hosted Environments</span></h3>
<p>If you have done C or C++ programming in user-space, you have used a so-called Hosted Environment. Hosted means that there is a C standard library and other useful runtime features. Alternatively, there is the Freestanding version, which is what you are using here. Freestanding means that there is no C standard library, only what you provide yourself. However, some header files are actually not part of the C standard library, but rather the compiler. These remain available even in freestanding C source code. In this case you use &lt;stdbool.h&gt; to get the bool datatype, &lt;stddef.h&gt; to get size_t and NULL, and &lt;stdint.h&gt; to get the intx_t and uintx_t datatypes which are invaluable for operating systems development, where you need to make sure that the variable is of an exact size (if you used a short instead of uint16_t and the size of short changed, your VGA driver here would break!). Additionally you can access the &lt;float.h&gt;, &lt;iso646.h&gt;, &lt;limits.h&gt;, and &lt;stdarg.h&gt; headers, as they are also freestanding. GCC actually ships a few more headers, but these are special purpose.
</p>
<h3><span class="mw-headline" id="Writing_a_kernel_in_C">Writing a kernel in C</span></h3>
<p>The following shows how to create a simple kernel in C. This kernel uses the VGA text mode buffer (located at <code>0xB8000</code>) as the output device. It sets up a simple driver that remembers the location of the next character in this buffer and provides a primitive for adding a new character. Notably, there is no support for line breaks ('\n') (and writing that character will show some VGA-specific character instead) and no support for scrolling when the screen is filled up. Adding this will be your first task. Please take a few moments to understand the code.
</p><p><b>IMPORTANT NOTE</b>: the VGA text mode (as well as the BIOS) is deprecated on newer machines, and UEFI only supports pixel buffers. For forward compatibility you might want to start with that. Ask <a href="GRUB" title="GRUB">GRUB</a> to set up a framebuffer using appropriate Multiboot flags or call <a href="Vesa" class="mw-redirect" title="Vesa">VESA VBE</a> yourself. Unlike VGA text mode, a framebuffer has pixels, so you have to draw each glyph yourself. This means you'll need a different <code>terminal_putchar</code>, and you'll need a font (bitmap images for each character). All Linux distro ships <a href="PC_Screen_Font" title="PC Screen Font">PC Screen Fonts</a> that you can use, and the wiki article has a simple putchar() example. Otherwise everything else described here still stands (you have to keep track of the cursor position, implement line breaks and scrolling etc.)
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdbool.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stddef.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="cm">/* Check if the compiler thinks you are targeting the wrong operating system. */</span><span class="w"></span>
<span class="cp">#if defined(__linux__)</span>
<span class="cp">#error &quot;You are not using a cross-compiler, you will most certainly run into trouble&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/* This tutorial will only work for the 32-bit ix86 targets. */</span><span class="w"></span>
<span class="cp">#if !defined(__i386__)</span>
<span class="cp">#error &quot;This tutorial needs to be compiled with a ix86-elf compiler&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/* Hardware text mode color constants. */</span><span class="w"></span>
<span class="k">enum</span><span class="w"> </span><span class="n">vga_color</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_BLACK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_BLUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_GREEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_CYAN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_RED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_MAGENTA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_BROWN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_LIGHT_GREY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_DARK_GREY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_LIGHT_BLUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_LIGHT_GREEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_LIGHT_CYAN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_LIGHT_RED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_LIGHT_MAGENTA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_LIGHT_BROWN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">VGA_COLOR_WHITE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="nf">vga_entry_color</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="n">vga_color</span><span class="w"> </span><span class="n">fg</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">vga_color</span><span class="w"> </span><span class="n">bg</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">fg</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">bg</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">vga_entry</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">uc</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">color</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="w"> </span><span class="n">uc</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">size_t</span><span class="w"> </span><span class="nf">strlen</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">len</span><span class="p">])</span><span class="w"></span>
<span class="w">		</span><span class="n">len</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">VGA_WIDTH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">80</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">VGA_HEIGHT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">25</span><span class="p">;</span><span class="w"></span>

<span class="kt">size_t</span><span class="w"> </span><span class="n">terminal_row</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">terminal_column</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">terminal_color</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="o">*</span><span class="w"> </span><span class="n">terminal_buffer</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">terminal_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">terminal_row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">terminal_column</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">terminal_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vga_entry_color</span><span class="p">(</span><span class="n">VGA_COLOR_LIGHT_GREY</span><span class="p">,</span><span class="w"> </span><span class="n">VGA_COLOR_BLACK</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">terminal_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mh">0xB8000</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">VGA_HEIGHT</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">VGA_WIDTH</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VGA_WIDTH</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">terminal_buffer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vga_entry</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">terminal_color</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">terminal_setcolor</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">color</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">terminal_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">terminal_putentryat</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VGA_WIDTH</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">terminal_buffer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vga_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">terminal_putchar</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">terminal_putentryat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">terminal_color</span><span class="p">,</span><span class="w"> </span><span class="n">terminal_column</span><span class="p">,</span><span class="w"> </span><span class="n">terminal_row</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">terminal_column</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VGA_WIDTH</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">terminal_column</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">terminal_row</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VGA_HEIGHT</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">terminal_row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">terminal_write</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">terminal_putchar</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">terminal_writestring</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">terminal_write</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">kernel_main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* Initialize terminal interface */</span><span class="w"></span>
<span class="w">	</span><span class="n">terminal_initialize</span><span class="p">();</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Newline support is left as an exercise. */</span><span class="w"></span>
<span class="w">	</span><span class="n">terminal_writestring</span><span class="p">(</span><span class="s">&quot;Hello, kernel World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Notice how in the code you wished to use the common C function <tt>strlen</tt>, but this function is part of the C standard library that you don't have available. Instead, you relied on the freestanding header &lt;stddef.h&gt; to provide <tt>size_t</tt> and you simply declared your own implementation of <tt>strlen</tt>. You will have to do this for every function you wish to use (as the freestanding headers only provide macros and data types).
</p><p>Compile using:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>i686-elf-gcc -c kernel.c -o kernel.o -std<span class="o">=</span>gnu99 -ffreestanding -O2 -Wall -Wextra
</pre></div>
<p>Note that the above code uses a few extensions and hence you build as the GNU version of C99.
</p>
<h3><span id="Writing_a_kernel_in_C.2B.2B"></span><span class="mw-headline" id="Writing_a_kernel_in_C++">Writing a kernel in C++</span></h3>
<p>Writing a kernel in <a href="C++" title="C++">C++</a> is easy. Note that not all features from the language is available. For instance, exception support requires special runtime support and so does memory allocation. To write a kernel in C++, simply adopt code above: Add an extern "C" declaration to the main method. Notice how the kernel_main function has to be declared with C linkage, as otherwise the compiler would include type information in the assembly name (name mangling). This complicates calling the function from your above assembly stub and you therefore use C linkage, where the symbol name is the same as the name of the function (with no additional type information). Save the code as kernel.c++ (or what your favorite C++ filename extension is). 
</p><p>You can compile the file kernel.c++ using:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>i686-elf-g++ -c kernel.c++ -o kernel.o -ffreestanding -O2 -Wall -Wextra -fno-exceptions -fno-rtti
</pre></div>
<p>Note that you must have also built a cross C++ compiler for this work.
</p>
<h2><span class="mw-headline" id="Linking_the_Kernel">Linking the Kernel</span></h2>
<p>You can now assemble boot.s and compile kernel.c. This produces two object files that each contain part of the kernel. To create the full and final kernel you will have to link these object files into the final kernel program, usable by the bootloader. When developing user-space programs, your toolchain ships with default scripts for linking such programs. However, these are unsuitable for kernel development and you need to provide your own customized linker script. Save the following in linker.ld:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* The bootloader will look at this image and start execution at the symbol</span>
<span class="cm">   designated as the entry point. */</span><span class="w"></span>
<span class="n">ENTRY</span><span class="p">(</span><span class="n">_start</span><span class="p">)</span><span class="w"></span>

<span class="cm">/* Tell where the various sections of the object files will be put in the final</span>
<span class="cm">   kernel image. */</span><span class="w"></span>
<span class="n">SECTIONS</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* It used to be universally recommended to use 1M as a start offset,</span>
<span class="cm">	   as it was effectively guaranteed to be available under BIOS systems.</span>
<span class="cm">	   However, UEFI has made things more complicated, and experimental data</span>
<span class="cm">	   strongly suggests that 2M is a safer place to load. In 2016, a new</span>
<span class="cm">	   feature was introduced to the multiboot2 spec to inform bootloaders</span>
<span class="cm">	   that a kernel can be loaded anywhere within a range of addresses and</span>
<span class="cm">	   will be able to relocate itself to run from such a loader-selected</span>
<span class="cm">	   address, in order to give the loader freedom in selecting a span of</span>
<span class="cm">	   memory which is verified to be available by the firmware, in order to</span>
<span class="cm">	   work around this issue. This does not use that feature, so 2M was</span>
<span class="cm">	   chosen as a safer option than the traditional 1M. */</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="n">M</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* First put the multiboot header, as it is required to be put very early</span>
<span class="cm">	   in the image or the bootloader won&#39;t recognize the file format.</span>
<span class="cm">	   Next we&#39;ll put the .text section. */</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">text</span><span class="w"> </span><span class="n">BLOCK</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ALIGN</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="o">*</span><span class="p">(.</span><span class="n">multiboot</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="o">*</span><span class="p">(.</span><span class="n">text</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Read-only data. */</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">rodata</span><span class="w"> </span><span class="n">BLOCK</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ALIGN</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="o">*</span><span class="p">(.</span><span class="n">rodata</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Read-write data (initialized) */</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="n">BLOCK</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ALIGN</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="o">*</span><span class="p">(.</span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Read-write data (uninitialized) and stack */</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">bss</span><span class="w"> </span><span class="n">BLOCK</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ALIGN</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="o">*</span><span class="p">(</span><span class="n">COMMON</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="o">*</span><span class="p">(.</span><span class="n">bss</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* The compiler may produce other sections, by default it will put them in</span>
<span class="cm">	   a segment with the same name. Simply add stuff here as needed. */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>With these components you can now actually build the final kernel. We use the compiler as the linker as it allows it greater control over the link process. Note that if your kernel is written in C++, you should use the C++ compiler instead. 
</p><p>You can then link your kernel using:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>i686-elf-gcc -T linker.ld -o myos.bin -ffreestanding -O2 -nostdlib boot.o kernel.o -lgcc
</pre></div>
<p>Note: Some tutorials suggest linking with i686-elf-ld rather than the compiler, however this prevents the compiler from performing various tasks during linking.
</p><p>The file myos.bin is now your kernel (all other files are no longer needed). Note that we are linking against <a href="Libgcc" title="Libgcc">libgcc</a>, which implements various runtime routines that your cross-compiler depends on. Leaving it out will give you problems in the future. If you did not build and install <a href="Libgcc" title="Libgcc">libgcc</a> as part of your cross-compiler, you should go back now and build a cross-compiler with <a href="Libgcc" title="Libgcc">libgcc</a>. The compiler depends on this library and will use it regardless of whether you provide it or not.
</p>
<h2><span class="mw-headline" id="Verifying_Multiboot">Verifying Multiboot</span></h2>
<p>If you have <a href="GRUB" title="GRUB">GRUB</a> installed, you can check whether a file has a valid <a href="Multiboot" title="Multiboot">Multiboot</a> version 1 header, which is the case for your kernel. It's important that the Multiboot header is within the first 8 KiB of the actual program file at 4 byte alignment. This can potentially break later if you make a mistake in the boot assembly, the linker script, or anything else that might go wrong. If the header isn't valid, GRUB will give an error that it can't find a Multiboot header when you try to boot it. This code fragment will help you diagnose such cases:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>grub-file --is-x86-multiboot myos.bin
</pre></div>
<p><tt>grub-file</tt> is quiet but will exit 0 (successfully) if it is a valid multiboot kernel and exit 1 (unsuccessfully) otherwise. You can type <tt>echo $?</tt> in your shell immediately afterwards to see the exit status. You can add this grub-file check to your build scripts as a sanity test to catch the problem at compile time. Multiboot version 2 can be checked with the <tt>--is-x86-multiboot2</tt> option instead. If you invoke the <tt>grub-file</tt> command manually in a shell, it is convenient to wrap it in a conditional to easily see the status. This command should work now:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span><span class="k">if</span> grub-file --is-x86-multiboot myos.bin<span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> multiboot confirmed
<span class="k">else</span>
  <span class="nb">echo</span> the file is not multiboot
<span class="k">fi</span>
</pre></div>
<h2><span class="mw-headline" id="Booting_the_Kernel">Booting the Kernel</span></h2>
<p>In a few moments, you will see your kernel in action.
</p>
<h3><span class="mw-headline" id="Building_a_bootable_cdrom_image">Building a bootable cdrom image</span></h3>
<p>You can easily create a bootable CD-ROM image containing the GRUB bootloader and your kernel using the program <tt>grub-mkrescue</tt>. You may need to install the GRUB utility programs and the program <tt>xorriso</tt> (version 0.5.6 or higher). First you should create a file called grub.cfg containing the contents:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">menuentry</span><span class="w"> </span><span class="s">&quot;myos&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">multiboot</span><span class="w"> </span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">myos</span><span class="p">.</span><span class="n">bin</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Note that the braces must be placed as shown here. You can now create a bootable image of your operating system by typing these commands:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>mkdir -p isodir/boot/grub
cp myos.bin isodir/boot/myos.bin
cp grub.cfg isodir/boot/grub/grub.cfg
grub-mkrescue -o myos.iso isodir
</pre></div>
<p>Congratulations! You have now created a file called myos.iso that contains your Hello World operating system. If you don't have the program <tt>grub-mkrescue</tt> installed, now is a good time to install GRUB. It should already be installed on Linux systems. Windows users will likely want to use a Cygwin variant if no native grub-mkrescue program is available.
</p><p><b>Warning:</b> GNU GRUB, the bootloader used by <tt>grub-mkrescue</tt>, is licensed under the GNU General Public License. Your iso file contains copyrighted material under that license and redistributing it in violation of the GPL constitutes copyright infringement. The GPL requires you publish the source code corresponding to the bootloader. You need to get the exact source package corresponding to the GRUB package you have installed from your distribution, at the time <tt>grub-mkrescue</tt> is invoked (as distro packages are occasionally updated). You then need to publish that source code along with your ISO to satisfy the GPL. Alternative, you can build GRUB from source code yourself. Extract it somewhere, then build GRUB from it, and install it in a isolated prefix in your PATH to ensure its <tt>grub-mkrescue</tt> program is used to produce your iso. You can then publish the official GRUB tarball along with your OS release. You're not required to publish the source code of your OS at all, only the code for the bootloader that's inside the iso.
</p>
<h3><span id="Testing_your_operating_system_.28QEMU.29"></span><span class="mw-headline" id="Testing_your_operating_system_(QEMU)">Testing your operating system (QEMU)</span></h3>
<p>Virtual Machines are very useful for development operating systems, as they allow you to quickly test your code and have access to the source code during the execution. Otherwise, you would be in for an endless cycle of reboots that would only annoy you. They start very quickly, especially combined with small operating systems such as yours.
</p><p>In this tutorial, we will be using QEMU. You can also use other virtual machines if you please. Simply adding the ISO to the CD drive of an empty virtual machine will do the trick.
</p><p>Install QEMU from your repositories, and then use the following command to start your new operating system.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>qemu-system-i386 -cdrom myos.iso
</pre></div>
<p>This should start a new virtual machine containing only your ISO as a cdrom. If all goes well, you will be met with a menu provided by the bootloader. Simply select myos and if all goes well, you should see the happy words "Hello, Kernel World!" followed by some mysterious character.
</p><p>Additionally, QEMU supports booting multiboot kernels directly without bootable medium:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>qemu-system-i386 -kernel myos.bin
</pre></div>
<h3><span id="Testing_your_operating_system_.28Real_Hardware.29"></span><span class="mw-headline" id="Testing_your_operating_system_(Real_Hardware)">Testing your operating system (Real Hardware)</span></h3>
<p>The program grub-mkrescue is nice because it makes a bootable ISO that works on both real computers and virtual machines. You can then build an ISO and use it everywhere. To boot your kernel on your local computer you can install myos.bin to your /boot directory and configure your bootloader appropriately.
</p><p>Or alternatively, you can burn it to an USB stick (erasing all data on it!). To do so, simply find out the name of the USB block device, in my case /dev/sdb but this may vary, and using the wrong block device (your harddisk, gasp!) may be disastrous. If you are using Linux and /dev/sdx is your block name, simply:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>sudo dd <span class="k">if</span><span class="o">=</span>myos.iso <span class="nv">of</span><span class="o">=</span>/dev/sdx <span class="o">&amp;&amp;</span> sync
</pre></div>
<p>Your operating system will then be installed on your USB stick. If you configure your BIOS to boot from USB first, you can insert the USB stick and your computer should start your operating system.
</p><p>Alternatively, the .iso is a normal cdrom image. Simply burn it to a CD or DVD if you feel like wasting one of those on a few kilobytes large kernel.
</p>
<h2><span class="mw-headline" id="Moving_Forward">Moving Forward</span></h2>
<p>Now that you can run your new shiny operating system, congratulations! Of course, depending on how much this interests you, it may just be the beginning. Here's a few things to get going.
</p>
<h3><span class="mw-headline" id="Adding_Support_for_Newlines_to_Terminal_Driver">Adding Support for Newlines to Terminal Driver</span></h3>
<p>The current terminal driver does not handle newlines. The VGA text mode font stores another character at the location, since newlines are never meant to be actually rendered: they are logical entities. Rather, in terminal_putchar check if c == '\n' and increment terminal_row and reset terminal_column.
</p>
<h3><span class="mw-headline" id="Implementing_Terminal_Scrolling">Implementing Terminal Scrolling</span></h3>
<p>In case the terminal is filled up, it will just go back to the top of the screen. This is unacceptable for normal use. Instead, it should move all rows up one row and discard the upper most, and leave a blank row at the bottom ready to be filled up with characters. Implement this.
</p>
<h3><span class="mw-headline" id="Rendering_Colorful_ASCII_Art">Rendering Colorful ASCII Art</span></h3>
<p>Use the existing terminal driver to render some pretty stuff in all the glorious 16 colors you have available. Note that only 8 colors may be available for the background color, as the uppermost bit in the entries by default means something other than background color. You'll need a real VGA driver to fix this.
</p>
<h3><span class="mw-headline" id="Calling_Global_Constructors">Calling Global Constructors</span></h3>
<dl><dd><i>Main article:</i> <a href="Calling_Global_Constructors" title="Calling Global Constructors">Calling Global Constructors</a></dd></dl>
<p>This tutorial showed a small example of how to create a minimal environment for C and C++ kernels. Unfortunately, you don't have everything set up yet. For instance, C++ with global objects will not have their constructors called because you never do it. The compiler uses a special mechanism for performing tasks at program initialization time through the <tt>crt*.o</tt> objects, which may be valuable even for C programmers. If you combine the <tt>crt*.o</tt> files correctly, you will create an <tt>_init</tt> function that invokes all the program initialization tasks. Your boot.o object file can then invoke <tt>_init</tt> before calling <tt>kernel_main</tt>.
</p>
<h3><span class="mw-headline" id="Meaty_Skeleton">Meaty Skeleton</span></h3>
<dl><dd><i>Main article:</i> <a href="Meaty_Skeleton" title="Meaty Skeleton">Meaty Skeleton</a></dd></dl>
<p>This tutorial is meant as a minimal example to give impatient beginners a quick hello world operating system. It is deliberately minimal and doesn't show the best practices on how to organize your operating system. The Meaty Skeleton tutorial shows an example of how to organize a minimal operating system with a kernel, room for a standard library to grow, and prepared for a user-space to appear.
</p>
<h3><span class="mw-headline" id="Going_Further">Going Further</span></h3>
<dl><dd><i>Main article:</i> <a href="Going_Further_on_x86" title="Going Further on x86">Going Further on x86</a></dd></dl>
<p>This guide is meant as an overview of what to do, so you have a kernel ready for more features, without actually redesigning it radically when adding them.
</p>
<h3><span class="mw-headline" id="Bare_Bones_II">Bare Bones <tt>II</tt></span></h3>
<p>Make your operating system self-hosting and then complete Bare Bones under your own operating system while following all the instructions. This is a five star exercise and you may need a couple of years to solve it.
</p>
<h2><span class="mw-headline" id="Frequently_Asked_Questions">Frequently Asked Questions</span></h2>
<dl><dt>Why the Multiboot header? Wouldn't a pure <a href="ELF" title="ELF">ELF</a> file be loadable by GRUB anyway?</dt>
<dd>GRUB is capable of loading a variety of formats. However, in this tutorial we are creating a Multiboot compliant kernel that could be loaded by any other compliant bootloader. To achieve this, the multiboot header is mandatory.</dd></dl>
<dl><dt>Is the AOUT kludge required for my kernel?</dt>
<dd>The AOUT kludge is not necessary for kernels in ELF format: a multiboot-compliant loader will recognize an ELF executable as such and use the program header to load things in their proper place. You can provide an AOUT kludge with your ELF kernel, in which case the headers of the ELF file are ignored. With any other format, such as AOUT, COFF or PE kernels, the AOUT kludge it is required, however.</dd></dl>
<dl><dt>Can the Multiboot header be anywhere in the kernel file, or does it have to be in a specific offset?</dt>
<dd>The Multiboot header must be in the first 8kb of the kernel file and must be aligned to a 32-bit (4 byte) boundary for GRUB to find it. You can ensure that this is the case by putting the header in its own source code file and passing that as the first object file to LD.</dd></dl>
<dl><dt>Will GRUB wipe the BSS section before loading the kernel?</dt>
<dd>Yes. For ELF kernels, the .bss section is automatically identified and cleared (despite the Multiboot specification being a bit vague about it). For other formats, if you ask it politely to do so, that is if you use the 'address override' information from the Multiboot header (flag #16) and give a non-zero value to the bss_end_addr field. Note that using "address override" with an ELF kernel will disable the default behavior and do what is described by the "address override" header instead.</dd></dl>
<dl><dt>What is the state of registers/memory/etc. when GRUB calls my kernel?</dt>
<dd>GRUB is an implementation of the Multiboot specification. Anything not specified there is "undefined behavior", which should ring a bell (not only) with C/C++ programmers... Better check the Machine State section of Multiboot documentation, and assume nothing else.</dd></dl>
<dl><dt>I still get <tt>Error 13: Invalid or unsupported executable format from GRUB</tt>...</dt>
<dd>Chances are the Multiboot header is missing from the final executable, or it is not at the right location.</dd>
<dd>If you are using some other format than ELF (such as PE), you should specify the AOUT kludge in the Multiboot header. The <tt>grub-file</tt> program describe aboveand "objdump -h" should give you more hints about what is going on.</dd>
<dd>It may also happen if you use an ELF object file instead of an executable (e.g. you have an ELF file with unresolved symbols or unfixable relocations). Try to link your ELF file to a binary executable to get more accurate error messages.</dd>
<dd>A common problem when your kernel size increases, is that the Multiboot header does no longer appear at the start of the output binary. The common solutions is to put the Multiboot header in a separate section and make sure that section is first in the output binary, or to include the Multiboot header itself in the linker script.</dd></dl>
<dl><dt>I get <tt>Boot failed: Could not read from CD-ROM (code 0009)</tt> when trying to boot the iso image in QEMU</dt>
<dd>If your development system is booted from EFI it may be that you don't have the PC-BIOS version of the grub binaries installed anywhere.  If you install them then grub-mkrescue will by default produce a hybrid ISO that will work in QEMU.  On Ubuntu this can be achieved with: <b>apt-get install grub-pc-bin</b>.</dd></dl>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="Books" title="Books">Books</a></li>
<li><a href="Limine_Bare_Bones" title="Limine Bare Bones">Limine Bare Bones</a></li>
<li><a href="BOOTBOOT" title="BOOTBOOT">BOOTBOOT</a></li></ul>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="https://github.com/limine-bootloader/limine/blob/trunk/PROTOCOL.md">Limine Boot Protocol Specification</a></li>
<li><a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html">Multiboot Specification</a></li>
<li><a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html">Multiboot2 Specification</a></li>
<li><a rel="nofollow" class="external text" href="https://gitlab.com/bztsrc/bootboot/raw/master/bootboot_spec_1st_ed.pdf">BOOTBOOT Specification</a></li>
<li><a rel="nofollow" class="external text" href="https://pubs.opengroup.org/onlinepubs/9699919799/">The POSIX Standard</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250211164656
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.052 seconds
Real time usage: 0.053 seconds
Preprocessor visited node count: 592/1000000
Post‐expand include size: 3256/2097152 bytes
Template argument size: 2443/2097152 bytes
Highest expansion depth: 15/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 34298/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%   12.105      1 -total
 47.62%    5.765     22 Template:If
 35.09%    4.248     22 Template:Show1
 34.56%    4.183      1 Template:Kernel_designs
 30.74%    3.721      1 Template:Rating
 30.62%    3.706      1 Template:SmallNavBox
 12.75%    1.543      1 Template:BeginnersWarning
  7.00%    0.847      2 Template:Eq
  3.86%    0.467      1 Template:NoteBox
  3.46%    0.419      2 Template:Eq1
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1741-0!canonical and timestamp 20250211164656 and revision id 29250.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Bare_Bones&amp;oldid=29250">https://wiki.osdev.org/index.php?title=Bare_Bones&amp;oldid=29250</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_duplicate_arguments_in_template_calls&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using duplicate arguments in template calls (page does not exist)">Pages using duplicate arguments in template calls</a></li><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Level_1_Tutorials" title="Category:Level 1 Tutorials">Level 1 Tutorials</a></li><li><a href="./Category:Bare_bones_tutorials" title="Category:Bare bones tutorials">Bare bones tutorials</a></li><li><a href="./Category:C" title="Category:C">C</a></li><li><a href="./Category:C++" title="Category:C++">C++</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Bare+Bones" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="Barebones#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Bare_Bones" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:Bare_Bones" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Bare_Bones"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Bare_Bones&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Bare_Bones&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Bare_Bones" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="./Special:RecentChangesLinked/Bare_Bones" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Bare_Bones&amp;oldid=29250" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Bare_Bones&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 29 September 2024, at 19:27.</li>
	<li id="footer-info-0">This page has been accessed 86,843 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Bare_Bones&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.052","walltime":"0.053","ppvisitednodes":{"value":592,"limit":1000000},"postexpandincludesize":{"value":3256,"limit":2097152},"templateargumentsize":{"value":2443,"limit":2097152},"expansiondepth":{"value":15,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":34298,"limit":5000000},"timingprofile":["100.00%   12.105      1 -total"," 47.62%    5.765     22 Template:If"," 35.09%    4.248     22 Template:Show1"," 34.56%    4.183      1 Template:Kernel_designs"," 30.74%    3.721      1 Template:Rating"," 30.62%    3.706      1 Template:SmallNavBox"," 12.75%    1.543      1 Template:BeginnersWarning","  7.00%    0.847      2 Template:Eq","  3.86%    0.467      1 Template:NoteBox","  3.46%    0.419      2 Template:Eq1"]},"cachereport":{"timestamp":"20250211164656","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":99});});</script>
</body>
</html>