<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Serial Ports - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"d076bd7954c66528acba3b1e","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Serial_Ports","wgTitle":"Serial Ports","wgCurRevisionId":28920,"wgRevisionId":28920,"wgArticleId":1662,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Network Hardware","Common Devices"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Serial_Ports","wgRelevantArticleId":1662,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],
"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Serial_Ports rootpage-Serial_Ports skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Serial Ports</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="Serial_Ports#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="Serial_Ports#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>Serial ports are a legacy communications port common on IBM-PC compatible computers. Use of serial ports for connecting peripherals has largely been deprecated in favor of <a href="USB" class="mw-redirect" title="USB">USB</a> and other modern peripheral interfaces, however it is still commonly used in certain industries for interfacing with industrial hardware such as CNC machines or commercial devices such as POS terminals. Historically it was common for many dial-up modems to be connected via a computer's serial port, and the design of the underlying <a href="UART" title="UART">UART</a> hardware itself reflects this.
</p><p>Serial ports are typically controlled by <a href="UART" title="UART">UART</a> hardware. This is the hardware chip responsible for encoding and decoding the data sent over the serial interface. Modern serial ports typically implement the <a href="https://wikipedia.org/wiki/RS-232" class="extiw" title="wikipedia:RS-232">RS-232</a> standard, and can use a variety of different connector interfaces. The DE-9 interface is the one most commonly used connector for serial ports in modern systems.
</p><p>Serial ports are of particular interest to operating-system developers since they are much easier to implement drivers for than USB, and are still commonly found in many x86 systems. It is common for operating-system developers to use a system's serial ports for debugging purposes, since they do not require sophisticated hardware setups and are useful for transmitting information in the early stages of an operating-system's initialization. Many emulators such as <a href="QEMU" title="QEMU">QEMU</a> and <a href="Bochs" title="Bochs">Bochs</a> allow the redirection of serial output to either stdio or a file on the host computer.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Serial_Ports#Wires,_Pins,_Connectors_and_the_like"><span class="tocnumber">1</span> <span class="toctext">Wires, Pins, Connectors and the like</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Serial_Ports#Why_Use_a_Serial_Port?"><span class="tocnumber">2</span> <span class="toctext">Why Use a Serial Port?</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="Serial_Ports#Programming_the_Serial_Communications_Port"><span class="tocnumber">3</span> <span class="toctext">Programming the Serial Communications Port</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="Serial_Ports#Port_Addresses"><span class="tocnumber">3.1</span> <span class="toctext">Port Addresses</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="Serial_Ports#Line_Protocol"><span class="tocnumber">3.2</span> <span class="toctext">Line Protocol</span></a>
<ul>
<li class="toclevel-3 tocsection-6"><a href="Serial_Ports#Baud_Rate"><span class="tocnumber">3.2.1</span> <span class="toctext">Baud Rate</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="Serial_Ports#Line_Control_Register"><span class="tocnumber">3.2.2</span> <span class="toctext">Line Control Register</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="Serial_Ports#Data_Bits"><span class="tocnumber">3.2.3</span> <span class="toctext">Data Bits</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="Serial_Ports#Stop_Bits"><span class="tocnumber">3.2.4</span> <span class="toctext">Stop Bits</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="Serial_Ports#Parity_Bits"><span class="tocnumber">3.2.5</span> <span class="toctext">Parity Bits</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-11"><a href="Serial_Ports#Interrupt_enable_register"><span class="tocnumber">3.3</span> <span class="toctext">Interrupt enable register</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="Serial_Ports#First_In_First_Out_Control_Register"><span class="tocnumber">3.4</span> <span class="toctext">First In First Out Control Register</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="Serial_Ports#Clear_Transmit_FIFO_and_Clear_Receive_FIFO"><span class="tocnumber">3.4.1</span> <span class="toctext">Clear Transmit FIFO and Clear Receive FIFO</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="Serial_Ports#Interrupt_Trigger_Level"><span class="tocnumber">3.4.2</span> <span class="toctext">Interrupt Trigger Level</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-15"><a href="Serial_Ports#Interrupt_Identification_Register"><span class="tocnumber">3.5</span> <span class="toctext">Interrupt Identification Register</span></a>
<ul>
<li class="toclevel-3 tocsection-16"><a href="Serial_Ports#Interrupt_State"><span class="tocnumber">3.5.1</span> <span class="toctext">Interrupt State</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="Serial_Ports#FIFO_Buffer_State"><span class="tocnumber">3.5.2</span> <span class="toctext">FIFO Buffer State</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-18"><a href="Serial_Ports#Modem_Control_Register"><span class="tocnumber">3.6</span> <span class="toctext">Modem Control Register</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="Serial_Ports#Line_Status_Register"><span class="tocnumber">3.7</span> <span class="toctext">Line Status Register</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="Serial_Ports#Modem_Status_Register"><span class="tocnumber">3.8</span> <span class="toctext">Modem Status Register</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="Serial_Ports#Terminals"><span class="tocnumber">3.9</span> <span class="toctext">Terminals</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-22"><a href="Serial_Ports#Example_Code"><span class="tocnumber">4</span> <span class="toctext">Example Code</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="Serial_Ports#Initialization"><span class="tocnumber">4.1</span> <span class="toctext">Initialization</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="Serial_Ports#Receiving_data"><span class="tocnumber">4.2</span> <span class="toctext">Receiving data</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="Serial_Ports#Sending_data"><span class="tocnumber">4.3</span> <span class="toctext">Sending data</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-26"><a href="Serial_Ports#Glossary"><span class="tocnumber">5</span> <span class="toctext">Glossary</span></a></li>
<li class="toclevel-1 tocsection-27"><a href="Serial_Ports#Related_Links"><span class="tocnumber">6</span> <span class="toctext">Related Links</span></a></li>
</ul>
</div>

<h2><span id="Wires.2C_Pins.2C_Connectors_and_the_like"></span><span class="mw-headline" id="Wires,_Pins,_Connectors_and_the_like">Wires, Pins, Connectors and the like</span></h2>
<p>The Wikipedia page on <a href="https://wikipedia.org/wiki/Serial_port" class="extiw" title="wikipedia:Serial port">Serial ports</a> has a lot of information, and it is summarised here. The serial interface is very simple. There are actually two kinds of serial port: 25-pin and 9-pin. 25-pin ports are not any better, they just have more pins (most unused) and are bigger. 9-pin is smaller and is used more often though in the past the 25-pin ones were used more often. The 9-pin ones are called DE-9 (or more commonly, DB-9 even though DE-9 is its technical name) and the 25-pin ones are called DB-25. They plug in to your computer using a female plug (unless your computer is odd and has a female port, in which case your cable will need a male plug). <a href="https://wikipedia.org/wiki/D-subminiature" class="extiw" title="wikipedia:D-subminiature">This Wikipedia page</a> has more information on the plug used. 
</p><p>Both have the same basic types of pins. A DB-25 has most of the pins as ground pins or simply unconnected, whereas a DE-9 has only one ground pin. There is a transmitting pin (for sending information away) and a receiving pin (for getting information). Most serial ports run in a duplex mode--that is, they can send and receive simultaneously. There are a few other pins, used for hardware handshaking. In the past, there was no duplex mode, so if a computer wanted to send something it had to tell the other device or computer that it was about to transmit, using one of the hardware handshaking pins. The other device would then use another handshaking pin to tell it to send whatever it wanted to send. Today there is duplex mode, but the handshaking pins are still used.
</p><p>If you want to connect two computers, you need two things in your cable:
</p>
<ol><li>The cable needs to have two female plugs so it can plug into both computers.</li>
<li>The cable needs to have its transmit-receive wires and it's handshaking wires switched. This can be done in the cable itself, or as an extension called a <a href="https://wiki.osdev.org/index.php?title=Null_Modem&amp;action=edit&amp;redlink=1" class="new" title="Null Modem (page does not exist)">Null Modem</a></li></ol>
<p>For serial devices, you don't need to setup the cable this way. The receiving end of the device has the wires switched and it has a female port, which means you can plug a male plug into it.
</p>
<h2><span id="Why_Use_a_Serial_Port.3F"></span><span class="mw-headline" id="Why_Use_a_Serial_Port?">Why Use a Serial Port?</span></h2>
<p>During the early stages of kernel development, you might wonder why you would bother writing a serial driver. There are several reasons why you might:
</p>
<dl><dt><a href="GDB" title="GDB">GDB</a> debugging</dt>
<dd>You can use the serial port to connect to a host computer, and use the GDB debugger to debug your operating system. This involves writing a stub for GDB within your OS.</dd>
<dt>Headless console</dt>
<dd>You can operate the computer without a monitor, keyboard or mouse and instead use the serial port as a console using a protocol such as TTY or VT100.</dd>
<dt>External logging</dt>
<dd>When the system itself is in danger of potentially crashing at times, it's nice to get debugging outputs safe to another computer before the test system triple-faults.</dd>
<dt>Networking and File transfers</dt>
<dd>Serial ports are useful for transferring information between systems when other more traditional methods are unavailable.</dd></dl>
<h2><span class="mw-headline" id="Programming_the_Serial_Communications_Port">Programming the Serial Communications Port</span></h2>
<p>If you want to use the serial port for communications, you first have to initialize it. You tell it how fast your connection speed between the other computer or device will be (this is called the baud rate)--you must have the same speed as the other device or computer is setup to use, or you will have problems. It is probably safer to use the slower speeds unless you need the faster speeds for some reason, for example if you are playing a multi-player game over a serial connection. You also need to setup the parity type and the number of bits in a character. Once again, your computer must be setup with the same values for these things as the other computer or device has, or communication will not work.
</p><p>Once you have setup these things, you still need to setup the interrupt handlers. You can poll the port to see if any new things have arrived, or if it's time to send another character, but this slows things down and will not work very well in most real-time applications or multi-threaded environments. In the case of a game, this is not a good idea at all.
</p><p>You use IRQ #4 for COM ports 1 or 3, and IRQ #3 for COM ports 2 or 4 (you can tell which port sent the interrupt when you receive the interrupt). The IRQ handlers check if you are receiving something, and if so they receive the character and handle it somehow, such as placing it into a buffer. They also check if the other side is ready to receive something from you, and if you have something to send, it is sent.
</p>
<h3><span class="mw-headline" id="Port_Addresses">Port Addresses</span></h3>
<p>The addresses for COM ports can vary depending on how they are connected to the machine and how the BIOS is configured.  Some BIOS configuration utilities allow you to see and set what these are, so if you in doubt for a test machine, this might be a good place to look to get you started.
</p><p>For the most part, the first two COM ports will be at the addresses specified, the addresses for further COM ports are less reliable.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>COM Port
</th>
<th>IO Port
</th></tr>
<tr>
<td>COM1</td>
<td>0x3F8
</td></tr>
<tr>
<td>COM2</td>
<td>0x2F8
</td></tr>
<tr>
<td>COM3</td>
<td>0x3E8
</td></tr>
<tr>
<td>COM4</td>
<td>0x2E8
</td></tr>
<tr>
<td>COM5</td>
<td>0x5F8
</td></tr>
<tr>
<td>COM6</td>
<td>0x4F8
</td></tr>
<tr>
<td>COM7</td>
<td>0x5E8
</td></tr>
<tr>
<td>COM8</td>
<td>0x4E8
</td></tr></tbody></table>
<p>You might be able to find the IO port addresses of the COM ports in the <a href="Memory_Map_(x86)#BIOS_Data_Area_.28BDA.29" title="Memory Map (x86)">BIOS Data Area</a>; however be warned that this won't work on modern/UEFI systems, can tell you about serial ports that only exist in the chipset (and lack any kind of connector that anything can be plugged into), won't tell you about any additional serial ports (e.g. on expansion cards, etc) that firmware doesn't/can't know about, and will make your OS susceptible to "BIOS quirks/bugs". Because the serial ports have relatively standard IO ports it's far more effective to use manual probing techniques instead; specifically, see if the scratch pad register can store a value, then try the loopback test (that you should use to determine if the serial port is faulty anyway).
</p><p>Once you have the base address of your COM port, you add an offset value to get to one of the data registers.  One of the registers hold what is termed the DLAB or Divisor Latch Access Bit.  When this bit is set, offsets 0 and 1 are mapped to the low and high bytes of the Divisor register for setting the baud rate of the port.  When this bit is clear, offsets 0 and 1 are mapped to their normal registers.  The DLAB bit only affects port offsets 0 and 1, the other offsets ignore this setting.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>IO Port Offset
</th>
<th>Setting of DLAB
</th>
<th>I/O Access
</th>
<th>Register mapped to this port
</th></tr>
<tr>
<td>+0</td>
<td>0</td>
<td>Read</td>
<td>Receive buffer.
</td></tr>
<tr>
<td>+0</td>
<td>0</td>
<td>Write</td>
<td>Transmit buffer.
</td></tr>
<tr>
<td>+1</td>
<td>0</td>
<td>Read/Write</td>
<td>Interrupt Enable Register.
</td></tr>
<tr>
<td>+0</td>
<td>1</td>
<td>Read/Write</td>
<td>With DLAB set to 1, this is the least significant byte of the divisor value for setting the baud rate.
</td></tr>
<tr>
<td>+1</td>
<td>1</td>
<td>Read/Write</td>
<td>With DLAB set to 1, this is the most significant byte of the divisor value.
</td></tr>
<tr>
<td>+2</td>
<td>-</td>
<td>Read</td>
<td>Interrupt Identification
</td></tr>
<tr>
<td>+2</td>
<td>-</td>
<td>Write</td>
<td>FIFO control registers
</td></tr>
<tr>
<td>+3</td>
<td>-</td>
<td>Read/Write</td>
<td>Line Control Register.  The most significant bit of this register is the DLAB.
</td></tr>
<tr>
<td>+4</td>
<td>-</td>
<td>Read/Write</td>
<td>Modem Control Register.
</td></tr>
<tr>
<td>+5</td>
<td>-</td>
<td>Read</td>
<td>Line Status Register.
</td></tr>
<tr>
<td>+6</td>
<td>-</td>
<td>Read</td>
<td>Modem Status Register.
</td></tr>
<tr>
<td>+7</td>
<td>-</td>
<td>Read/Write</td>
<td>Scratch Register.
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Line_Protocol">Line Protocol</span></h3>
<p>The serial data transmitted across the wire can have a number of different parameters set.  As a rule, the sending device and the receiving device require the same protocol parameter values written to each serial controller in order for communication to be successful.
</p><p>These days you could consider 8N1 (8 bits, no parity, one stop bit) pretty much the default.
</p>
<h4><span class="mw-headline" id="Baud_Rate">Baud Rate</span></h4>
<p>The serial controller (UART) has an internal clock which runs at 115200 ticks per second and a clock divisor which is used to control the baud rate.  This is exactly the same type of system used by the Programmable Interrupt Timer (PIT).
</p><p>In order to set the speed of the port, calculate the divisor required for the given baud rate and program that in to the divisor register.  For example, a divisor of 1 will give 115200 baud, a divisor of 2 will give 57600 baud, 3 will give 38400 baud, etc.
</p><p>Do not be tempted to use a divisor of 0 to try to get an infinite baud rate, it won't work.  Most serial controllers will generate a unspecified and unpredictable baud rate (and anyway infinite baud would mean infinite transmission errors as they are proportional.)
</p><p>To set the divisor to the controller:
</p>
<ol><li>Set the most significant bit of the Line Control Register.  This is the DLAB bit, and allows access to the divisor registers.</li>
<li>Send the least significant byte of the divisor value to [PORT + 0].</li>
<li>Send the most significant byte of the divisor value to [PORT + 1].</li>
<li>Clear the most significant bit of the Line Control Register.</li></ol>
<h4><span class="mw-headline" id="Line_Control_Register">Line Control Register</span></h4>
<p>The Line Control register sets the general connection parameters.
</p>
<table class="wikitable">

<tbody><tr>
<th>Bit 7
</th>
<th>Bit 6
</th>
<th>Bits 5-3
</th>
<th>Bit 2
</th>
<th>Bits 1-0
</th></tr>
<tr>
<td>Divisor Latch Access Bit
</td>
<td>Break Enable Bit
</td>
<td>Parity Bits
</td>
<td>Stop Bits
</td>
<td>Data Bits
</td></tr></tbody></table>
<h4><span class="mw-headline" id="Data_Bits">Data Bits</span></h4>
<p>The number of bits in a character is variable. Having fewer bits is, of course, faster, but they store less information. If you are only sending ASCII text, you probably only need 7 bits.
</p><p>Set this value by writing to the two least significant bits of the Line Control Register [PORT + 3].
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bit 1
</th>
<th>Bit 0
</th>
<th>Character Length (bits)
</th></tr>
<tr>
<td>0</td>
<td>0</td>
<td>5
</td></tr>
<tr>
<td>0</td>
<td>1</td>
<td>6
</td></tr>
<tr>
<td>1</td>
<td>0</td>
<td>7
</td></tr>
<tr>
<td>1</td>
<td>1</td>
<td>8
</td></tr></tbody></table>
<h4><span class="mw-headline" id="Stop_Bits">Stop Bits</span></h4>
<p>The serial controller can be configured to send a number of bits after each character of data.  These reliable bits can be used to by the controller to verify that the sending and receiving devices are in phase.
</p><p>If the character length is specifically 5 bits, the stop bits can only be set to 1 or 1.5.  For other character lengths, the stop bits can only be set to 1 or 2.
</p><p>To set the number of stop bits, set bit 2 of the Line Control Register [PORT + 3].
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bit 2
</th>
<th>Stop bits
</th></tr>
<tr>
<td>0</td>
<td>1
</td></tr>
<tr>
<td>1</td>
<td>1.5 / 2 (depending on character length)
</td></tr></tbody></table>
<h4><span class="mw-headline" id="Parity_Bits">Parity Bits</span></h4>
<p>The controller can be made to add or expect a parity bit at the end of each character of data transmitted.  With this parity bit, if a single bit of data is inverted by interference, a parity error can be raised.  The parity type can be NONE, EVEN, ODD, MARK or SPACE.
</p><p>If parity is set to NONE, no parity bit will be added and none will be expected.  If one is sent by the transmitter and not expected by the receiver, it will likely cause an error.
</p><p>If the parity is MARK or SPACE, the parity bit will be expected to be always set to 1 or 0 respectively.
</p><p>If the parity is set to EVEN or ODD, the controller calculates the accuracy of the parity by adding together the values of all the data bits and the parity bit.  If the port is set to have EVEN parity, the result must be even.  If it is set to have ODD parity, the result must be odd.
</p><p>To set the port parity, set bits 3, 4 and 5 of the Line Control Register [PORT + 3].
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bit 5
</th>
<th>Bit 4
</th>
<th>Bit 3
</th>
<th>Parity
</th></tr>
<tr>
<td>-</td>
<td>-</td>
<td>0</td>
<td>NONE
</td></tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>ODD
</td></tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>EVEN
</td></tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>MARK
</td></tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>SPACE
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Interrupt_enable_register">Interrupt enable register</span></h3>
<p>To communicate with a serial port in interrupt mode, the interrupt-enable-register (see table above) must be set correctly. To determine which interrupts should be enabled, a value with the following bits (0 = disabled, 1 = enabled) must be written to the interrupt-enable-register:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bit 7-4
</th>
<th>Bit 3
</th>
<th>Bit 2
</th>
<th>Bit 1
</th>
<th>Bit 0
</th></tr>
<tr>
<td>Reserved
</td>
<td>Modem Status
</td>
<td>Receiver Line Status
</td>
<td>Transmitter Holding Register Empty
</td>
<td>Received Data Available
</td></tr></tbody></table>
<h3><span class="mw-headline" id="First_In_First_Out_Control_Register">First In First Out Control Register</span></h3>
<p>The First In / First Out Control Register (FCR) is for controlling the FIFO buffers. Access this register by writing to port offset +2.
</p>
<table class="wikitable">

<tbody><tr>
<th>Bits 7-6
</th>
<th>Bits 5-4
</th>
<th>Bit 3
</th>
<th>Bit 2
</th>
<th>Bit 1
</th>
<th>Bit 0
</th></tr>
<tr>
<td>Interrupt Trigger Level
</td>
<td>Reserved
</td>
<td>DMA Mode Select
</td>
<td>Clear Transmit FIFO
</td>
<td>Clear Receive FIFO
</td>
<td>Enable FIFO's
</td></tr></tbody></table>
<h4><span class="mw-headline" id="Clear_Transmit_FIFO_and_Clear_Receive_FIFO">Clear Transmit FIFO and Clear Receive FIFO</span></h4>
<p>Bit 2 being set clears the Transmit FIFO buffer while Bit 1 being set clears the Receive FIFO buffer. Both bits will set themselves back to 0 after they are done being cleared.
</p>
<h4><span class="mw-headline" id="Interrupt_Trigger_Level">Interrupt Trigger Level</span></h4>
<p>The Interrupt Trigger Level is used to configure how much data must be received in the FIFO Receive buffer before triggering a Received Data Available Interrupt.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bit 7
</th>
<th>Bit 6
</th>
<th>Trigger Level
</th></tr>
<tr>
<td>0</td>
<td>0</td>
<td>1 Byte
</td></tr>
<tr>
<td>0</td>
<td>1</td>
<td>4 Bytes
</td></tr>
<tr>
<td>1</td>
<td>0</td>
<td>8 Bytes
</td></tr>
<tr>
<td>1</td>
<td>1</td>
<td>14 Bytes
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Interrupt_Identification_Register">Interrupt Identification Register</span></h3>
<p>The Interrupt Identification Register (IIR) is for identifying pending interrupts. Access this register by reading from port offset +2.
</p>
<table class="wikitable">

<tbody><tr>
<th>Bits 7-6
</th>
<th>Bits 5-4
</th>
<th>Bit 3
</th>
<th>Bit 2-1
</th>
<th>Bit 0
</th></tr>
<tr>
<td>FIFO Buffer State
</td>
<td>Reserved
</td>
<td>Timeout Interrupt Pending (UART 16550) or Reserved
</td>
<td>Interrupt State
</td>
<td>Interrupt Pending
</td></tr></tbody></table>
<h4><span class="mw-headline" id="Interrupt_State">Interrupt State</span></h4>
<p>After Interrupt Pending is set, the Interrupt State shows the interrupt that has occurred. They have varying levels of priority, with high-value interrupts handled first, and low-value interrupts being handled last.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bit 2
</th>
<th>Bit 1
</th>
<th>Interrupt
</th>
<th>Priority
</th></tr>
<tr>
<td>0</td>
<td>0</td>
<td>Modem Status</td>
<td>4 (Lowest)
</td></tr>
<tr>
<td>0</td>
<td>1</td>
<td>Transmitter Holding Register Empty</td>
<td>3
</td></tr>
<tr>
<td>1</td>
<td>0</td>
<td>Received Data Available</td>
<td>2
</td></tr>
<tr>
<td>1</td>
<td>1</td>
<td>Receiver Line Status</td>
<td>1 (Highest)
</td></tr></tbody></table>
<h4><span class="mw-headline" id="FIFO_Buffer_State">FIFO Buffer State</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bit 7
</th>
<th>Bit 6
</th>
<th>State
</th></tr>
<tr>
<td>0</td>
<td>0</td>
<td>No FIFO
</td></tr>
<tr>
<td>0</td>
<td>1</td>
<td>FIFO Enabled but Unusable
</td></tr>
<tr>
<td>1</td>
<td>0</td>
<td>FIFO Enabled
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Modem_Control_Register">Modem Control Register</span></h3>
<p>The Modem Control Register is one half of the hardware handshaking registers. 
While most serial devices no longer use hardware handshaking, The lines are still included in all 16550 compatible UARTS. 
These can be used as general purpose output ports, or to actually perform handshaking. 
By writing to the Modem Control Register, it will set those lines active.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bit
</th>
<th>Name
</th>
<th>Meaning
</th></tr>
<tr>
<td>0</td>
<td>Data Terminal Ready (DTR)</td>
<td>Controls the Data Terminal Ready Pin
</td></tr>
<tr>
<td>1</td>
<td>Request to Send (RTS)</td>
<td>Controls the Request to Send Pin
</td></tr>
<tr>
<td>2</td>
<td>Out 1</td>
<td>Controls a hardware pin (OUT1) which is unused in PC implementations
</td></tr>
<tr>
<td>3</td>
<td>Out 2</td>
<td>Controls a hardware pin (OUT2) which is used to enable the IRQ in PC implementations
</td></tr>
<tr>
<td>4</td>
<td>Loop</td>
<td>Provides a local loopback feature for diagnostic testing of the UART
</td></tr>
<tr>
<td>5</td>
<td>0</td>
<td>Unused
</td></tr>
<tr>
<td>6</td>
<td>0</td>
<td>Unused
</td></tr>
<tr>
<td>7</td>
<td>0</td>
<td>Unused
</td></tr></tbody></table>
<p>Most PC serial ports use OUT2 to control a circuit that disconnects (tristates) the IRQ line. This makes it possible for multiple serial ports to share a single IRQ line, as long as only one port is enabled at a time.
Loopback mode is a diagnostic feature. When bit 4 is set to logic 1,
the following occur the transmitter Serial Output (SOUT) is set to the Marking (logic 1) state; the receiver Serial
Input (SIN) is disconnected; the output of the Transmitter Shift Register is ‘‘looped back’’ into the Receiver Shift
Register input; the four MODEM Control inputs (DSR, CTS, RI, and DCD) are disconnected; and the four
MODEM Control outputs (DTR, RTS, OUT 1, and OUT 2) are internally connected to the four MODEM Control
inputs, and the MODEM Control output pins are forced to their inactive state (high). In the loopback mode, data
that is transmitted is immediately received. This feature allows the processor to verify the transmit-and received-
data paths of the UART. In the loopback mode, the receiver and transmitter interrupts are fully operational. Their sources are external to
the part. The MODEM Control Interrupts are also operational, but the interrupts’ sources are now the lower four
bits of the MODEM Control Register instead of the four MODEM Control inputs. The interrupts are still controlled
by the Interrupt Enable Register.
</p>
<h3><span class="mw-headline" id="Line_Status_Register">Line Status Register</span></h3>
<p>The line status register is useful to check for errors and enable polling.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bit
</th>
<th>Name
</th>
<th>Meaning
</th></tr>
<tr>
<td>0</td>
<td>Data ready (DR)</td>
<td>Set if there is data that can be read
</td></tr>
<tr>
<td>1</td>
<td>Overrun error (OE)</td>
<td>Set if there has been data lost
</td></tr>
<tr>
<td>2</td>
<td>Parity error (PE)</td>
<td>Set if there was an error in the transmission as detected by parity
</td></tr>
<tr>
<td>3</td>
<td>Framing error (FE)</td>
<td>Set if a stop bit was missing
</td></tr>
<tr>
<td>4</td>
<td>Break indicator (BI)</td>
<td>Set if there is a break in data input
</td></tr>
<tr>
<td>5</td>
<td>Transmitter holding register empty (THRE)</td>
<td>Set if the transmission buffer is empty (i.e. data can be sent)
</td></tr>
<tr>
<td>6</td>
<td>Transmitter empty (TEMT)</td>
<td>Set if the transmitter is not doing anything
</td></tr>
<tr>
<td>7</td>
<td>Impending Error</td>
<td>Set if there is an error with a word in the input buffer
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Modem_Status_Register">Modem Status Register</span></h3>
<p>This register provides the current state of the control lines from a peripheral device. 
In addition to this current-state information, four bits of the MODEM Status Register provide change information.
These bits are set to a logic 1 whenever a control input from the MODEM changes state. They are reset to logic
0 whenever the CPU reads the MODEM Status Register
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bit
</th>
<th>Name
</th>
<th>Meaning
</th></tr>
<tr>
<td>0</td>
<td>Delta Clear to Send (DCTS)</td>
<td>Indicates that CTS input has changed state since the last time it was read
</td></tr>
<tr>
<td>1</td>
<td>Delta Data Set Ready (DDSR)</td>
<td>Indicates that DSR input has changed state since the last time it was read
</td></tr>
<tr>
<td>2</td>
<td>Trailing Edge of Ring Indicator (TERI)</td>
<td>Indicates that RI input to the chip has changed from a low to a high state
</td></tr>
<tr>
<td>3</td>
<td>Delta Data Carrier Detect (DDCD)</td>
<td>Indicates that DCD input has changed state since the last time it ware read
</td></tr>
<tr>
<td>4</td>
<td>Clear to Send (CTS)</td>
<td>Inverted CTS Signal
</td></tr>
<tr>
<td>5</td>
<td>Data Set Ready (DSR)</td>
<td>Inverted DSR Signal
</td></tr>
<tr>
<td>6</td>
<td>Ring Indicator (RI)</td>
<td>Inverted RI Signal
</td></tr>
<tr>
<td>7</td>
<td>Data Carrier Detect (DCD)</td>
<td>Inverted DCD Signal
</td></tr></tbody></table>
<p>If Bit 4 of the MCR (LOOP bit) is set, the upper 4 bits will mirror the 4 status output lines set in the Modem Control Register.
</p>
<h3><span class="mw-headline" id="Terminals">Terminals</span></h3>
<dl><dd><i>Main article: <a href="Terminals" title="Terminals">Terminals</a></i></dd></dl>
<p>Once you can send and receive bytes with confidence, you probably want to connect the serial port to a terminal (or more likely a terminal emulator these days). Those send specific byte sequences when a key is pressed, and can interpret codes to move the cursor on the screen and change color for example.
</p><p><br />
</p>
<h2><span class="mw-headline" id="Example_Code">Example Code</span></h2>
<h3><span class="mw-headline" id="Initialization">Initialization</span></h3>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define PORT 0x3f8          </span><span class="c1">// COM1</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">init_serial</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">outb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">);</span><span class="w">    </span><span class="c1">// Disable all interrupts</span>
<span class="w">   </span><span class="n">outb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80</span><span class="p">);</span><span class="w">    </span><span class="c1">// Enable DLAB (set baud rate divisor)</span>
<span class="w">   </span><span class="n">outb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">);</span><span class="w">    </span><span class="c1">// Set divisor to 3 (lo byte) 38400 baud</span>
<span class="w">   </span><span class="n">outb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">);</span><span class="w">    </span><span class="c1">//                  (hi byte)</span>
<span class="w">   </span><span class="n">outb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">);</span><span class="w">    </span><span class="c1">// 8 bits, no parity, one stop bit</span>
<span class="w">   </span><span class="n">outb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mh">0xC7</span><span class="p">);</span><span class="w">    </span><span class="c1">// Enable FIFO, clear them, with 14-byte threshold</span>
<span class="w">   </span><span class="n">outb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0B</span><span class="p">);</span><span class="w">    </span><span class="c1">// IRQs enabled, RTS/DSR set</span>
<span class="w">   </span><span class="n">outb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1E</span><span class="p">);</span><span class="w">    </span><span class="c1">// Set in loopback mode, test the serial chip</span>
<span class="w">   </span><span class="n">outb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xAE</span><span class="p">);</span><span class="w">    </span><span class="c1">// Test serial chip (send byte 0xAE and check if serial returns same byte)</span>

<span class="w">   </span><span class="c1">// Check if serial is faulty (i.e: not same byte as sent)</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0xAE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">// If serial is not faulty set it in normal operation mode</span>
<span class="w">   </span><span class="c1">// (not-loopback with IRQs enabled and OUT#1 and OUT#2 bits enabled)</span>
<span class="w">   </span><span class="n">outb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Notice that the initialization code above writes to [PORT + 1] twice with different values.  This is once to write to the Divisor register along with [PORT + 0] and once to write to the Interrupt register as detailed in the previous section.  The second write to the Line Control register [PORT + 3] clears the DLAB again as well as setting various other bits.
</p>
<h3><span class="mw-headline" id="Receiving_data">Receiving data</span></h3>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">serial_received</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">char</span><span class="w"> </span><span class="nf">read_serial</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">serial_received</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Sending_data">Sending data</span></h3>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">is_transmit_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="n">PORT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x20</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">write_serial</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">is_transmit_empty</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="n">outb</span><span class="p">(</span><span class="n">PORT</span><span class="p">,</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Glossary">Glossary</span></h2>
<dl><dt>Baud Rate</dt>
<dd>The speed at which the serial line switches between it's two states. This is not equivalent to bps, due to the fact there are start and stop bits. On an 8/N/1 line, 10 baud = 1 byte. Modems are more complex than plain serial lines due to having multiple waveforms, but for the purposes of OSDev this is irrelevant.</dd>
<dd>The fastest baud rate a serial port can reliably run at is generally 115200 baud.</dd>
<dt>Baud Rate Divisor</dt>
<dd>The value the is used by the UART to divide its internal clock by in order to get the actual intended baud rate.</dd>
<dt>Stop Bits</dt>
<dd>The NULL bit(s) sent between each character to synchronize the transmitter and the receiver.</dd>
<dt>UART</dt>
<dd>For Universal Asynchronous Receiver/Transceiver: the chip that picks a byte a send it bit per bit on the serial line and vice versa.</dd></dl>
<h2><span class="mw-headline" id="Related_Links">Related Links</span></h2>
<ul><li><a rel="nofollow" class="external text" href="http://www.nondot.org/sabre/os/articles/CommunicationDevices/">OSRC's "communication" section</a></li>
<li><a rel="nofollow" class="external text" href="http://www.sci.muni.cz/docs/pc/serport.txt">A summary of the PC serial port (with programming info).</a>, <a rel="nofollow" class="external text" href="http://www.webcitation.org/5ugQv5JOw">An archive of that document</a></li>
<li><a rel="nofollow" class="external text" href="https://en.wikibooks.org/wiki/Serial_Programming">A Wikibook about programming the serial port</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250211122550
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.051 seconds
Real time usage: 0.441 seconds
Preprocessor visited node count: 146/1000000
Post‐expand include size: 1944/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 8807/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    1.212      1 -total
 60.10%    0.728     12 Template:Wikitable
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1662-0!canonical and timestamp 20250211122550 and revision id 28920.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Serial_Ports&amp;oldid=28920">https://wiki.osdev.org/index.php?title=Serial_Ports&amp;oldid=28920</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Network_Hardware" title="Category:Network Hardware">Network Hardware</a></li><li><a href="./Category:Common_Devices" title="Category:Common Devices">Common Devices</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Serial+Ports" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="Serial_Ports#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Serial_Ports" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:Serial_Ports" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Serial_Ports"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Serial_Ports&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Serial_Ports&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Serial_Ports" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="./Special:RecentChangesLinked/Serial_Ports" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Serial_Ports&amp;oldid=28920" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Serial_Ports&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/Serielle_Schnittstelle" title="Serielle Schnittstelle – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 6 June 2024, at 16:27.</li>
	<li id="footer-info-0">This page has been accessed 21,342 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Serial_Ports&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.051","walltime":"0.441","ppvisitednodes":{"value":146,"limit":1000000},"postexpandincludesize":{"value":1944,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":8807,"limit":5000000},"timingprofile":["100.00%    1.212      1 -total"," 60.10%    0.728     12 Template:Wikitable"]},"cachereport":{"timestamp":"20250211122550","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":555});});</script>
</body>
</html>