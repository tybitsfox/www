<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>CMOS - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"88c2a1990961241e71e1d489","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"CMOS","wgTitle":"CMOS","wgCurRevisionId":28632,"wgRevisionId":28632,"wgArticleId":1717,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","X86","Time"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"CMOS","wgRelevantArticleId":1717,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{"search":false,
"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-CMOS rootpage-CMOS skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">CMOS</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="CMOS#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="CMOS#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>"CMOS" is a tiny bit of very low power static memory that lives on the same chip as the Real-Time Clock (RTC). 
It was introduced to IBM PC AT in 1984 which used Motorola MC146818A RTC.
</p><p>CMOS (and the Real-Time Clock) can only be accessed through IO Ports 0x70 and 0x71. The function of the CMOS
memory is to store 50 (or 114) bytes of "Setup" information for the BIOS while the computer is turned off --
because there is a separate battery that keeps the Clock and the CMOS information active.
</p><p>CMOS values are accessed a byte at a time, and each byte is individually addressable. Each CMOS address is
traditionally called a "register". The first 14 CMOS registers access and control the Real-Time Clock. In
fact, the only truly useful registers remaining in CMOS are the Real-Time Clock registers, and register 0x10.
All other registers in CMOS are almost entirely obsolete (or are not standardized), and are therefore useless.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="CMOS#Non-Maskable_Interrupts"><span class="tocnumber">1</span> <span class="toctext">Non-Maskable Interrupts</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="CMOS#CMOS_Registers"><span class="tocnumber">2</span> <span class="toctext">CMOS Registers</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="CMOS#Accessing_CMOS_Registers"><span class="tocnumber">2.1</span> <span class="toctext">Accessing CMOS Registers</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="CMOS#Checksums"><span class="tocnumber">2.1.1</span> <span class="toctext">Checksums</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-5"><a href="CMOS#Register_0x10"><span class="tocnumber">2.2</span> <span class="toctext">Register 0x10</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="CMOS#Memory_Size_Registers"><span class="tocnumber">2.3</span> <span class="toctext">Memory Size Registers</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="CMOS#Hard_Disk_Registers"><span class="tocnumber">2.4</span> <span class="toctext">Hard Disk Registers</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="CMOS#The_Real-Time_Clock"><span class="tocnumber">3</span> <span class="toctext">The Real-Time Clock</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="CMOS#Getting_Current_Date_and_Time_from_RTC"><span class="tocnumber">3.1</span> <span class="toctext">Getting Current Date and Time from RTC</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="CMOS#Century_Register"><span class="tocnumber">3.2</span> <span class="toctext">Century Register</span></a>
<ul>
<li class="toclevel-3 tocsection-11"><a href="CMOS#Century_Register_As_Time_and_Date_Sanity_Check"><span class="tocnumber">3.2.1</span> <span class="toctext">Century Register As Time and Date Sanity Check</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="CMOS#Weekday_Register"><span class="tocnumber">3.3</span> <span class="toctext">Weekday Register</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="CMOS#RTC_Update_In_Progress"><span class="tocnumber">3.4</span> <span class="toctext">RTC Update In Progress</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="CMOS#Format_of_Bytes"><span class="tocnumber">3.5</span> <span class="toctext">Format of Bytes</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="CMOS#Interpreting_RTC_Values"><span class="tocnumber">3.6</span> <span class="toctext">Interpreting RTC Values</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="CMOS#Examples"><span class="tocnumber">4</span> <span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="CMOS#Reading_from_the_CMOS"><span class="tocnumber">4.1</span> <span class="toctext">Reading from the CMOS</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="CMOS#Writing_to_the_CMOS"><span class="tocnumber">4.2</span> <span class="toctext">Writing to the CMOS</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="CMOS#Reading_All_RTC_Time_and_Date_Registers"><span class="tocnumber">4.3</span> <span class="toctext">Reading All RTC Time and Date Registers</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-20"><a href="CMOS#See_Also"><span class="tocnumber">5</span> <span class="toctext">See Also</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="CMOS#External_Links"><span class="tocnumber">6</span> <span class="toctext">External Links</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Non-Maskable_Interrupts">Non-Maskable Interrupts</span></h2>
<p>For frugality in the olden days, many functions were merged together on chips where there was "room" -- even
if they did not belong together. An example is putting the <a href="A20" class="mw-redirect" title="A20">A20</a> address enable on the PS2 keyboard controller.
In the same way, the "NMI disable" control was put together with the CMOS controller and the Real-Time Clock.
</p><p>NMI is meant to communicate a "panic" status from the hardware to the CPU in a way that the CPU cannot
ignore. It is typically used to signal memory errors. For more information about NMI, see the <a href="NMI" class="mw-redirect" title="NMI">NMI</a> article.
</p><p>Whenever you send a byte to IO port 0x70, the high order bit tells the hardware whether to disable NMIs from
reaching the CPU. If the bit is on, NMI is disabled (until the next time you send a byte to Port 0x70).
The low order 7 bits of any byte sent to Port 0x70 are used to address CMOS registers.
</p>
<h2><span class="mw-headline" id="CMOS_Registers">CMOS Registers</span></h2>
<p>The most updated CMOS register map, showing all of the conflicting register definitions between the various
BIOSes, is in <a href="RBIL" class="mw-redirect" title="RBIL">RBIL</a> in the file called CMOS.LST.
</p>
<h3><span class="mw-headline" id="Accessing_CMOS_Registers">Accessing CMOS Registers</span></h3>
<p>Accessing CMOS is extremely simple, but you always need to take into account how you want to handle NMI.
You "select" a CMOS register (for reading or writing) by sending the register number to IO Port 0x70.
Since the 0x80 bit of Port 0x70 controls NMI, you always end up setting that, too. So your CMOS controller
always needs to know whether your OS wants NMI to be enabled or not. Selecting a CMOS register is done
as follows:
</p>
<ul><li><tt>outb (0x70, (NMI_disable_bit &lt;&lt; 7) | (selected CMOS register number));</tt></li></ul>
<p>Once a register is selected, you either read the value of that register on Port 0x71 (with inb or an equivalent
function), or you write a new value to that register -- also on Port 0x71 (with outb, for example):
</p>
<ul><li><tt>val_8bit = inb (0x71);</tt></li></ul>
<p>Note1: Reading or writing Port 0x71 seems to default the "selected register" back to 0xD. So you need to
<b>reselect</b> the register every single time you want to access a CMOS register.
</p><p>Note2: It is probably a good idea to have a reasonable delay after selecting a CMOS register on Port 0x70,
before reading/writing the value on Port 0x71.
</p>
<h4><span class="mw-headline" id="Checksums">Checksums</span></h4>
<p>The proper functioning of the BIOS during bootup depends on the values in CMOS. So the values are protected
against random changes with checksums. It is very unwise ever to write a value into any of the CMOS registers
(except for the RTC) -- because when you change a value you also have to go fix a BIOS-specific checksum in a
different register -- or else the next boot will crash with an "invalid checksum" error. And since the checksum
is located at a proprietary BIOS-specific register number, good luck finding it.
</p>
<h3><span class="mw-headline" id="Register_0x10">Register 0x10</span></h3>
<p>This register contains the only CMOS value that an OS might ever find to be useful. It describes the "type"
of each of the two floppy drives that may be attached to the system. The high nibble describes the "master"
floppy drive on the primary bus, and the low nibble has an identical description for the "slave" floppy drive.
</p><p>Value of each 4 bit nibble, and associated floppy drive type:
</p>
<pre>Value   Drive Type
 00h	no drive
 01h	360 KB 5.25 Drive
 02h	1.2 MB 5.25 Drive
 03h	720 KB 3.5 Drive
 04h	1.44 MB 3.5 Drive
 05h	2.88 MB 3.5 drive
</pre>
<p>Bits 0 to 3 = slave floppy type, bits 4 to 7 = master floppy type
</p>
<h3><span class="mw-headline" id="Memory_Size_Registers">Memory Size Registers</span></h3>
<p>There are several CMOS registers that are standardized, and that seem to report useful information about the
total memory on the system. However, each of them is lacking vital information that your OS will need. It is
always better to use a BIOS function call to get information about memory than to use the information in CMOS.
See <a href="Detecting_Memory_(x86)" title="Detecting Memory (x86)">Detecting Memory (x86)</a>.
</p><p>(Register 0x16 (high byte) | Register 0x15 (low byte)) &lt;&lt; 10 = 640K = size of low memory (without taking the
<a href="Memory_Map_(x86)#EBDA" title="Memory Map (x86)">EBDA</a> into account.
</p><p>(Register 0x18 (high byte) | Register 0x17 (low byte)) &lt;&lt; 10 = total memory between 1M and 16M, or maybe 65M
... usually. But this number is extra untrustworthy when the system has more than 64M, it ignores "memory
holes", it ignores memory mapped hardware, and it ignores memory reserved for important ACPI system tables.
</p><p>(Register 0x31 (high byte) | Register 0x30 (low byte)) &lt;&lt; 16 = total memory between 16M and 4G ... usually.
But this number is untrustworthy when the system has more than 4G, it ignores "memory holes", it ignores
memory mapped hardware, and it ignores memory reserved for important ACPI system tables.
</p>
<h3><span class="mw-headline" id="Hard_Disk_Registers">Hard Disk Registers</span></h3>
<p>There are many CMOS registers in various locations, used by various ancient BIOSes, to store a "hard disk type" or
other hard disk information. Any such information is strictly for use on obsolete CHS-based disk drives.
Better information can always be obtained via BIOS function INT13h AH=8, or by sending an ATA 'Identify'
command to the disk in <a href="ATA_PIO_Mode" title="ATA PIO Mode">ATA PIO Mode</a>.
</p>
<h2><span class="mw-headline" id="The_Real-Time_Clock">The Real-Time Clock</span></h2>
<p>The RTC keeps track of the date and time, even when the computer's power is off. The only other way that a
computer used to be able to do this was to ask a human for the date/time on every bootup. Now, if the computer
has an internet connection, an OS has another (arguably better) way to get the same information.
</p><p>The RTC also can generate clock ticks on IRQ8 (similarly to what the <a href="PIT" class="mw-redirect" title="PIT">PIT</a> does on IRQ0). The highest feasible
clock frequency is 8KHz. Using the RTC clock this way may actually generate more stable clock pulses than the PIT
can generate. It also frees up the PIT for timing events that really need near-microsecond accuracy.
Additionally, the RTC can generate an IRQ8 at a particular time of day. See the <a href="RTC" title="RTC">RTC</a> article for more
detailed information about using RTC interrupts.
</p>
<h3><span class="mw-headline" id="Getting_Current_Date_and_Time_from_RTC">Getting Current Date and Time from RTC</span></h3>
<p>To get each of the following date/time values from the RTC, you should first ensure that you won't be effected by an update (<a href="CMOS#RTC_Update_In_Progress">see below</a>). Then select the associated "CMOS register" in the
<a href="CMOS#Accessing_CMOS_Registers">usual way</a>, and read the value from Port 0x71.
</p>
<pre>Register  Contents            Range
 0x00      Seconds             0–59
 0x02      Minutes             0–59
 0x04      Hours               0–23 in 24-hour mode, 
                               1–12 in 12-hour mode, highest bit set if pm
 0x06      Weekday             1–7, Sunday = 1
 0x07      Day of Month        1–31
 0x08      Month               1–12
 0x09      Year                0–99
 0x32      Century (maybe)     19–20?
 0x0A      Status Register A
 0x0B      Status Register B
</pre>
<h3><span class="mw-headline" id="Century_Register">Century Register</span></h3>
<p>Originally the RTC didn't have a century register at all. In the 1990s (as the year 2000 got closer) hardware manufacturers started realising that this might become a problem; so they starting adding century registers to their RTC. Unfortunately, because there was no official standard to follow, different manufacturers used different registers.
</p><p>This meant that software didn't know if there was a century register, and (if there is) which register it might be. To fix that problem the ACPI specification included a "RTC century register" field at offset 108 in its "Fixed ACPI Description Table". If this field contains zero then the RTC doesn't have a century register, and if the field is non-zero then it contains the number of the RTC register to use for century.
</p><p>If there is no century register then software can guess. For example, a piece of software written in 1990 can use the (2 digit) year register to determine the most likely century - if the RTC year register is higher than or equal to 90 then the year is probably be "19YY" and if the RTC year register is less than 90 than the year must be "20YY". In this way, software can correctly determine the century for up to 99 years after the software is written.
</p>
<h4><span class="mw-headline" id="Century_Register_As_Time_and_Date_Sanity_Check">Century Register As Time and Date Sanity Check</span></h4>
<p>If the CMOS/RTC has a century register, your software was released 2014, and the CMOS/RTC says the century and year are 2008; then obviously the CMOS/RTC must be wrong.
</p><p>Similarly, people tend to update their OS occasionally. If the CMOS/RTC has a century register, your software was released 2014, and the CMOS/RTC says the century and year are 2154; then it's unlikely that the OS hasn't been updated for 140 years, and far more likely that the CMOS/RTC is wrong.
</p><p>Essentially; the method (described above) for guessing the century when there is no century register is much more reliable than the CMOS/RTC century register (if it exists). This means that the century register (if/when present) can be used in reverse, as a way to check if the CMOS/RTC time and date are sane (or if the CMOS/RTC has a flat battery or something).
</p><p>Basically, you'd guess the century (based on the software's release date and RTC's year), then check if the CMOS/RTC century is the same as your guess and if it's not then assume all CMOS/RTC time and date fields are invalid.
</p>
<h3><span class="mw-headline" id="Weekday_Register">Weekday Register</span></h3>
<p>The RTC chip is able to keep track of the current day of the week. All it does is increment its "Weekday" register at midnight and reset it to 1 if the incremented value would go above 7<a rel="nofollow" class="external autonumber" href="https://groups.google.com/d/msg/alt.os.development/qPxWHKC48rw/yjAt-c8IAQAJ">[1]</a>. Unfortunately there is no guarantee that this register was ever set correctly by anything (including when the user changes the time and date using the BIOS configuration screen). It is entirely unreliable and should not be used.
</p><p>The correct way to determine the current day of the week is to calculate it from the date (see <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Weekday_determination">the article on Wikipedia</a> for details of this calculation).
</p>
<h3><span class="mw-headline" id="RTC_Update_In_Progress">RTC Update In Progress</span></h3>
<p>When the chip updates the time and date (once per second) it increases "seconds" and checks if it rolled over. If "seconds" did roll over it increases "minutes" and checks if that rolled over. This can continue through all the time and date registers (e.g. all the way up to "if year rolled over, increase century"). However, the RTC circuitry is typically relatively slow. This means that it's entirely possible to read the time and date while an update is in progress and get dodgy/inconsistent values (for example, at 9:00 o'clock you might read 8:59, or 8:60, or 8:00, or 9:00).
</p><p>To help guard against this problem the RTC has an "Update in progress" flag (bit 7 of Status Register A). To read the time and date properly you have to wait until the "Update in progress" flag goes from "set" to "clear". This is not the same as checking that the "Update in progress" flag is clear.
</p><p>For example, if code does "<i>while(update_in_progress_flag&#160;!= clear)</i>" and then starts reading all the time and date registers, then the update could begin immediately after the "Update in progress" flag was checked and the code could still read dodgy/inconsistent values. To avoid this, code should wait until the flag becomes set and then wait until the flag becomes clear. That way there's almost 1 second of time to read all of the registers correctly.
</p><p>Unfortunately, doing it correctly (waiting until the "Update in progress" flag becomes set and then waiting until it becomes clear) is very slow - it may take an entire second of waiting/polling before you can read the registers. There are 2 alternatives.
</p><p>The first alternative is to rely on the "update interrupt". When the RTC finishes an update it generates an "update interrupt" (if it's enabled), and the IRQ handler can safely read the time and date registers without worrying about the update at all (and without checking the "Update in progress" flag); as long as the IRQ handler doesn't take almost a full second to do it. In this case you're not wasting up to 1 second of CPU time waiting/polling, but it may still take a full second before the time and date has been read. Despite this it can be a useful technique during OS boot - e.g. setup the "update interrupt" and its IRQ handler as early as you can and then do other things (e.g. loading files from disk), in the hope that the IRQ occurs before you need the time and date.
</p><p>The second alternative is to be prepared for dodgy/inconsistent values and cope with them if they occur. To do this, make sure the "Update in progress" flag is clear (e.g. "<i>while(update_in_progress_flag&#160;!= clear)</i>") then read all the time and date registers; then make sure the "Update in progress" flag is clear again (e.g. "<i>while(update_in_progress_flag&#160;!= clear)</i>") and read all the time and date registers again. If the values that were read the first time are the same as the value that were read the second time then the values must be correct. If any of the values are different you need to do it again, and keep doing it again until the newest values are the same as the previous values.
</p>
<h3><span class="mw-headline" id="Format_of_Bytes">Format of Bytes</span></h3>
<p>There are 4 formats possible for the date/time RTC bytes:
</p>
<ul><li>Binary or BCD Mode</li>
<li>Hours in 12 hour format or 24 hour format</li></ul>
<p>The format is controlled by Status Register B. On some CMOS/RTC chips, the format bits in Status Reg B
<b>cannot be changed</b>. So your code needs to be able to handle all four possibilities, and it should
not try to modify Status Register B's settings. So you always need to read Status Register B first, to
find out what format your date/time bytes will arrive in.
</p>
<ul><li>Status Register B, Bit 1 (value = 2): Enables 24 hour format if set</li>
<li>Status Register B, Bit 2 (value = 4): Enables Binary mode if set</li></ul>
<p>Binary mode is exactly what you would expect the value to be. If the time is 1:59:48 AM, then the value
of hours would be 1, minutes would be 59 = 0x3b, and seconds would be 48 = 0x30.
</p><p>In BCD mode, each of the two hex nibbles of the byte is modified to "display" a <b>decimal</b> number.
So 1:59:48 has hours = 1, minutes = 0x59 = 89, seconds = 0x48 = 72. To convert BCD back into a "good" binary value, use: binary = ((bcd / 16) * 10) + (bcd &amp; 0xf) <i>[Optimised: binary = ( (bcd &amp; 0xF0) &gt;&gt; 1) + ( (bcd &amp; 0xF0) &gt;&gt; 3) + (bcd &amp; 0xf)]</i>.
</p><p>24 hour time is exactly what you would expect. Hour 0 is midnight to 1am, hour 23 is 11pm.
</p><p>12 hour time is annoying to convert back to 24 hour time. If the hour is pm, then the 0x80 bit is set on the hour byte. So you need to
mask that off. (This is true for <b>both</b> binary and BCD modes.) Then, midnight is 12, 1am is 1, etc.
Note that carefully: midnight is not 0 -- it is 12 -- this needs to be handled as a special
case in the calculation from 12 hour format to 24 hour format (by setting 12 back to 0)!
</p><p>For the weekday format: Sunday = 1, Saturday = 7.
</p>
<h3><span class="mw-headline" id="Interpreting_RTC_Values">Interpreting RTC Values</span></h3>
<p>On the surface, these values from the RTC seem extremely obvious. The main difficulty comes in deciding which timezone the values represent. The two possibilities are usually UTC, or the system's timezone, including Daylight Savings. See the <a href="Time_And_Date" title="Time And Date">Time And Date</a> article for a much more complete discussion of how to handle this issue.
</p>
<h2><span class="mw-headline" id="Examples">Examples</span></h2>
<h3><span class="mw-headline" id="Reading_from_the_CMOS">Reading from the CMOS</span></h3>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">ReadFromCMOS</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">tvalue</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">_asm</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">cli</span><span class="w">             </span><span class="cm">/* Disable interrupts*/</span><span class="w"></span>
<span class="w">         </span><span class="n">mov</span><span class="w"> </span><span class="n">al</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="w">   </span><span class="cm">/* Move index address*/</span><span class="w"></span>
<span class="w">         </span><span class="cm">/* since the 0x80 bit of al is not set, NMI is active */</span><span class="w"></span>
<span class="w">         </span><span class="n">out</span><span class="w"> </span><span class="mh">0x70</span><span class="p">,</span><span class="n">al</span><span class="w">     </span><span class="cm">/* Copy address to CMOS register*/</span><span class="w"></span>
<span class="w">         </span><span class="cm">/* some kind of real delay here is probably best */</span><span class="w"></span>
<span class="w">         </span><span class="n">in</span><span class="w"> </span><span class="n">al</span><span class="p">,</span><span class="mh">0x71</span><span class="w">      </span><span class="cm">/* Fetch 1 byte to al*/</span><span class="w"></span>
<span class="w">         </span><span class="n">sti</span><span class="w">             </span><span class="cm">/* Enable interrupts*/</span><span class="w"></span>
<span class="w">         </span><span class="n">mov</span><span class="w"> </span><span class="n">tvalue</span><span class="p">,</span><span class="n">al</span><span class="w"></span>
<span class="w">       </span><span class="p">}</span><span class="w"></span>

<span class="w">       </span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tvalue</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Writing_to_the_CMOS">Writing to the CMOS</span></h3>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">WriteTOCMOS</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">array</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">tvalue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">_asm</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">cli</span><span class="w">             </span><span class="cm">/* Clear interrupts*/</span><span class="w"></span>
<span class="w">         </span><span class="n">mov</span><span class="w"> </span><span class="n">al</span><span class="p">,</span><span class="n">index</span><span class="w">    </span><span class="cm">/* move index address*/</span><span class="w"></span>
<span class="w">         </span><span class="n">out</span><span class="w"> </span><span class="mh">0x70</span><span class="p">,</span><span class="n">al</span><span class="w">     </span><span class="cm">/* copy address to CMOS register*/</span><span class="w"></span>
<span class="w">         </span><span class="cm">/* some kind of real delay here is probably best */</span><span class="w"></span>
<span class="w">         </span><span class="n">mov</span><span class="w"> </span><span class="n">al</span><span class="p">,</span><span class="n">tvalue</span><span class="w">   </span><span class="cm">/* move value to al*/</span><span class="w"></span>
<span class="w">         </span><span class="n">out</span><span class="w"> </span><span class="mh">0x71</span><span class="p">,</span><span class="n">al</span><span class="w">     </span><span class="cm">/* write 1 byte to CMOS*/</span><span class="w"></span>
<span class="w">         </span><span class="n">sti</span><span class="w">             </span><span class="cm">/* Enable interrupts*/</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Reading_All_RTC_Time_and_Date_Registers">Reading All RTC Time and Date Registers</span></h3>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define CURRENT_YEAR        2023                            </span><span class="c1">// Change this each year!</span>

<span class="kt">int</span><span class="w"> </span><span class="n">century_register</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w">                                </span><span class="c1">// Set by ACPI table parsing code if possible</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">minute</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">hour</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">day</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">month</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">out_byte</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">in_byte</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">port</span><span class="p">);</span><span class="w"></span>

<span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">cmos_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x70</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">cmos_data</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mh">0x71</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">get_update_in_progress_flag</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">out_byte</span><span class="p">(</span><span class="n">cmos_address</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0A</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">in_byte</span><span class="p">(</span><span class="n">cmos_data</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x80</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">get_RTC_register</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">out_byte</span><span class="p">(</span><span class="n">cmos_address</span><span class="p">,</span><span class="w"> </span><span class="n">reg</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">in_byte</span><span class="p">(</span><span class="n">cmos_data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">read_rtc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">century</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">last_second</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">last_minute</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">last_hour</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">last_day</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">last_month</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">last_year</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">last_century</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">registerB</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Note: This uses the &quot;read registers until you get the same values twice in a row&quot; technique</span>
<span class="w">      </span><span class="c1">//       to avoid getting dodgy/inconsistent values due to RTC updates</span>

<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">get_update_in_progress_flag</span><span class="p">());</span><span class="w">                </span><span class="c1">// Make sure an update isn&#39;t in progress</span>
<span class="w">      </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">minute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x02</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">hour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x07</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">month</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x08</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x09</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">century_register</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">century</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="n">century_register</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">last_second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">last_minute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">minute</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">last_hour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hour</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">last_day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">day</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">last_month</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">month</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">last_year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">year</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">last_century</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">century</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">get_update_in_progress_flag</span><span class="p">());</span><span class="w">           </span><span class="c1">// Make sure an update isn&#39;t in progress</span>
<span class="w">            </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">minute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x02</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">hour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x07</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">month</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x08</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x09</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">century_register</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                  </span><span class="n">century</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="n">century_register</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">last_second</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">last_minute</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">minute</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">last_hour</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">hour</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">               </span><span class="p">(</span><span class="n">last_day</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">day</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">last_month</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">month</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">last_year</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">year</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">               </span><span class="p">(</span><span class="n">last_century</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">century</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="n">registerB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_RTC_register</span><span class="p">(</span><span class="mh">0x0B</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Convert BCD to binary values if necessary</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">registerB</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x04</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">second</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">second</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">minute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">minute</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">minute</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">hour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">hour</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(((</span><span class="n">hour</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x70</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">hour</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x80</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">day</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">day</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">month</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">month</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">month</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">year</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">year</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">century_register</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                  </span><span class="n">century</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">century</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">century</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Convert 12 hour clock to 24 hour clock if necessary</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">registerB</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x02</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">hour</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x80</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">hour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">hour</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x7F</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">24</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Calculate the full (4-digit) year</span>

<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">century_register</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">year</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">century</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">year</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">CURRENT_YEAR</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">year</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">CURRENT_YEAR</span><span class="p">)</span><span class="w"> </span><span class="n">year</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<ul><li><a href="RTC" title="RTC">RTC</a></li></ul>
<h2><span class="mw-headline" id="External_Links">External Links</span></h2>
<ul><li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20111209041013/http://www-ivs.cs.uni-magdeburg.de/~zbrog/asm/cmos.html">Old CMOS Map</a></li>
<li><a rel="nofollow" class="external text" href="http://www.bioscentral.com/misc/cmosmap.htm">Better CMOS Map</a></li>
<li><a rel="nofollow" class="external text" href="http://bitsavers.trailing-edge.com/pdf/ibm/pc/at/1502494_PC_AT_Technical_Reference_Mar84.pdf">IBM PC AT Technical Reference</a></li>
<li><a rel="nofollow" class="external text" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/mc146818a.pdf">MC146818A REAL-TIME CLOCK PLUS RAM (RTC)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.bitsavers.org/pdf/ibm/pc/ps2/PS2_Model_50_Technical_Reference_May88.pdf">IBM PS/2 Technical Reference</a></li>
<li><a rel="nofollow" class="external text" href="https://www.singlix.com/trdos/archive/pdf_archive/real-time-clock-nmi-enable-paper.pdf">Intel Application Note: Accessing the Real Time Clock Registers and NMI Enable Bit</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250211122423
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.046 seconds
Real time usage: 0.449 seconds
Preprocessor visited node count: 100/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 33649/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1717-0!canonical and timestamp 20250211122422 and revision id 28632.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=CMOS&amp;oldid=28632">https://wiki.osdev.org/index.php?title=CMOS&amp;oldid=28632</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:X86" title="Category:X86">X86</a></li><li><a href="./Category:Time" title="Category:Time">Time</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=CMOS" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="CMOS#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="CMOS" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:CMOS" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="CMOS"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=CMOS&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=CMOS&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/CMOS" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="./Special:RecentChangesLinked/CMOS" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=CMOS&amp;oldid=28632" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=CMOS&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/CMOS" title="CMOS – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 17 February 2024, at 17:54.</li>
	<li id="footer-info-0">This page has been accessed 18,383 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=CMOS&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.046","walltime":"0.449","ppvisitednodes":{"value":100,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":33649,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20250211122423","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":562});});</script>
</body>
</html>