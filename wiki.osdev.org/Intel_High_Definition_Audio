<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Intel High Definition Audio - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"4525cc641f6093ab66641da6","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Intel_High_Definition_Audio","wgTitle":"Intel High Definition Audio","wgCurRevisionId":28688,"wgRevisionId":28688,"wgArticleId":3313,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["In Progress","Sound"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Intel_High_Definition_Audio","wgRelevantArticleId":3313,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],
"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head","mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Intel_High_Definition_Audio rootpage-Intel_High_Definition_Audio skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Intel High Definition Audio</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="Intel_High_Definition_Audio#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="Intel_High_Definition_Audio#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><center>
<table style="border: 1px solid #cfcfbf; margin-top: 25px; margin-bottom: 25px; background-color: #f0f0ff; text-align: center;">
<tbody><tr>
<td>
<p><a href="./File:Under_Construction.png" class="image" title="This page is under construction!"><img alt="This page is under construction!" src="images/1/14/Under_Construction.png" decoding="async" width="50" height="50" data-file-width="50" data-file-height="50" /></a>
This page or section is a work in progress and may thus be incomplete. Its content may be changed in the near future.
</p>
</td>
<td>
</td></tr></tbody></table>
</center>
<p>Intel High Definition Audio refers to the specification released by Intel for delivering high-definition audio that is capable of playing back more channels at higher quality than previous integrated audio codecs like <a href="AC97" title="AC97">AC97</a>.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Intel_High_Definition_Audio#Identifying_HDA_on_a_machine"><span class="tocnumber">1</span> <span class="toctext">Identifying HDA on a machine</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Intel_High_Definition_Audio#Overview"><span class="tocnumber">2</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="Intel_High_Definition_Audio#Device_Registers"><span class="tocnumber">3</span> <span class="toctext">Device Registers</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="Intel_High_Definition_Audio#0x00_(4_bytes)_Global_Capabilities"><span class="tocnumber">3.1</span> <span class="toctext">0x00 (4 bytes) Global Capabilities</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="Intel_High_Definition_Audio#0x02_(1_byte)_Minor_Version_/_0x03_(1_byte)_Major_Version"><span class="tocnumber">3.2</span> <span class="toctext">0x02 (1 byte) Minor Version / 0x03 (1 byte) Major Version</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="Intel_High_Definition_Audio#0x08_(2_bytes)_Global_Control"><span class="tocnumber">3.3</span> <span class="toctext">0x08 (2 bytes) Global Control</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="Intel_High_Definition_Audio#0x20_(4_bytes)_Interrupt_Control"><span class="tocnumber">3.4</span> <span class="toctext">0x20 (4 bytes) Interrupt Control</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="Intel_High_Definition_Audio#0x34_(4_bytes)_Stream_Synchronization"><span class="tocnumber">3.5</span> <span class="toctext">0x34 (4 bytes) Stream Synchronization</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="Intel_High_Definition_Audio#0x40_(4_bytes)_CORB_Lower_Base_Address"><span class="tocnumber">3.6</span> <span class="toctext">0x40 (4 bytes) CORB Lower Base Address</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="Intel_High_Definition_Audio#0x44_(4_bytes)_CORB_Upper_Base_Address"><span class="tocnumber">3.7</span> <span class="toctext">0x44 (4 bytes) CORB Upper Base Address</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="Intel_High_Definition_Audio#0x48_(2_bytes)_CORB_Write_Pointer"><span class="tocnumber">3.8</span> <span class="toctext">0x48 (2 bytes) CORB Write Pointer</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="Intel_High_Definition_Audio#0x4A_(2_bytes)_CORB_Read_Pointer"><span class="tocnumber">3.9</span> <span class="toctext">0x4A (2 bytes) CORB Read Pointer</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="Intel_High_Definition_Audio#0x4C_(1_byte)_CORB_Control"><span class="tocnumber">3.10</span> <span class="toctext">0x4C (1 byte) CORB Control</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="Intel_High_Definition_Audio#0x4E_(1_byte)_CORB_Size"><span class="tocnumber">3.11</span> <span class="toctext">0x4E (1 byte) CORB Size</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="Intel_High_Definition_Audio#0x50_(4_bytes)_RIRB_Lower_Base_Address"><span class="tocnumber">3.12</span> <span class="toctext">0x50 (4 bytes) RIRB Lower Base Address</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="Intel_High_Definition_Audio#0x54_(4_bytes)_RIRB_Upper_Base_Address"><span class="tocnumber">3.13</span> <span class="toctext">0x54 (4 bytes) RIRB Upper Base Address</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="Intel_High_Definition_Audio#0x58_(2_bytes)_RIRB_Write_Pointer"><span class="tocnumber">3.14</span> <span class="toctext">0x58 (2 bytes) RIRB Write Pointer</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="Intel_High_Definition_Audio#0x5A_(2_bytes)_RIRB_Response_Interrupt_Count"><span class="tocnumber">3.15</span> <span class="toctext">0x5A (2 bytes) RIRB Response Interrupt Count</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="Intel_High_Definition_Audio#0x5C_(1_byte)_RIRB_Control"><span class="tocnumber">3.16</span> <span class="toctext">0x5C (1 byte) RIRB Control</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="Intel_High_Definition_Audio#0x5E_(1_byte)_RIRB_Size"><span class="tocnumber">3.17</span> <span class="toctext">0x5E (1 byte) RIRB Size</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="Intel_High_Definition_Audio#0x70_(4_bytes)_DMA_Position_Lower_Base_Address"><span class="tocnumber">3.18</span> <span class="toctext">0x70 (4 bytes) DMA Position Lower Base Address</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="Intel_High_Definition_Audio#0x74_(4_bytes)_DMA_Position_Upper_Base_Address"><span class="tocnumber">3.19</span> <span class="toctext">0x74 (4 bytes) DMA Position Upper Base Address</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="Intel_High_Definition_Audio#0x80+_Registers_of_Stream_Descriptors"><span class="tocnumber">3.20</span> <span class="toctext">0x80+ Registers of Stream Descriptors</span></a>
<ul>
<li class="toclevel-3 tocsection-24"><a href="Intel_High_Definition_Audio#Stream_Control_byte_0"><span class="tocnumber">3.20.1</span> <span class="toctext">Stream Control byte 0</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="Intel_High_Definition_Audio#Stream_Control_byte_2"><span class="tocnumber">3.20.2</span> <span class="toctext">Stream Control byte 2</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-26"><a href="Intel_High_Definition_Audio#CODECs_and_Nodes"><span class="tocnumber">4</span> <span class="toctext">CODECs and Nodes</span></a></li>
<li class="toclevel-1 tocsection-27"><a href="Intel_High_Definition_Audio#Node_Commands"><span class="tocnumber">5</span> <span class="toctext">Node Commands</span></a></li>
<li class="toclevel-1 tocsection-28"><a href="Intel_High_Definition_Audio#Node_Parameters"><span class="tocnumber">6</span> <span class="toctext">Node Parameters</span></a></li>
<li class="toclevel-1 tocsection-29"><a href="Intel_High_Definition_Audio#Initalizing_sound_card"><span class="tocnumber">7</span> <span class="toctext">Initalizing sound card</span></a></li>
<li class="toclevel-1 tocsection-30"><a href="Intel_High_Definition_Audio#Initalizing_CODEC"><span class="tocnumber">8</span> <span class="toctext">Initalizing CODEC</span></a>
<ul>
<li class="toclevel-2 tocsection-31"><a href="Intel_High_Definition_Audio#Setting_up_the_AFG_codec"><span class="tocnumber">8.1</span> <span class="toctext">Setting up the AFG codec</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="Intel_High_Definition_Audio#Finding_all_useful_paths_through_the_codec"><span class="tocnumber">8.2</span> <span class="toctext">Finding all useful paths through the codec</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-33"><a href="Intel_High_Definition_Audio#Playing_Audio"><span class="tocnumber">9</span> <span class="toctext">Playing Audio</span></a>
<ul>
<li class="toclevel-2 tocsection-34"><a href="Intel_High_Definition_Audio#Set_Audio_Output_node"><span class="tocnumber">9.1</span> <span class="toctext">Set Audio Output node</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="Intel_High_Definition_Audio#Create_Buffer_Descriptor_List"><span class="tocnumber">9.2</span> <span class="toctext">Create Buffer Descriptor List</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="Intel_High_Definition_Audio#Set_Stream_Descriptor"><span class="tocnumber">9.3</span> <span class="toctext">Set Stream Descriptor</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-37"><a href="Intel_High_Definition_Audio#External_links"><span class="tocnumber">10</span> <span class="toctext">External links</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Identifying_HDA_on_a_machine">Identifying HDA on a machine</span></h2>
<p>All HDA devices appear on the PCI bus with a specific VendorID and DeviceID.  Many HDA devices have a Vendor ID of 8086 (Intel), and a Device ID such as 2668 or 27D8, but other Vendor IDs are also in use, e.g. Vendor ID 1002 (AMD) and Device ID 4383. If you find any others, please add them into this page. The best way to identify HDA is probably just to look for the Class code (4h) and subclass (3h), but the HDA specification doesn't tell you to do this.
</p>
<h2><span class="mw-headline" id="Overview">Overview</span></h2>
<p>The HDA specification (link at the bottom of this page) spells out how to set up devices at the two ends of a link and there is no substitute for working from it, but it takes several readings through its 200+ pages before a clear picture eventually begins to emerge from it, so this overview is aimed at making the most frustrating parts clear from the outset.
</p><p>You can communicate with the HDA device via memory-mapped ports, but much of the action takes place further away in hardware codecs containing many widgets, and the communication link through to them is rather slow. Setting things up at the near end is relatively easy, part of it being done by keyhole surgery through a couple of ordinary ports in the PCI device configuration space, while the rest is done through the memory mapped ports located at an address found at index 10-17h (though the lowest four bits should be taken as zeros). You may not need to change anything in the PCI configuration space at all, but there's a fair bit to do with the memory mapped ports to set up and control several DMA engines. Setting things up at the codec end is much more complicated though as you have to interrogate them to find out what they are and what functionality they offer, and then you have to work out how to set them up correctly to create active paths between devices (speakers and mic.s) and DACs/ADCs. All your communications with the codecs and the many widgets they contain will be done by sending special commands via the link.
</p><p>Data and commands are sent across the link in frames with strict timings and bit limits, but the work of packaging the different kinds of data into packets to go into these frames is all done for you, so all you need to do is set up a number of buffers. Two of these buffers are called CORB (command output ring buffer) and RIRB (response input ring buffer) - each buffer has a DMA engine dedicated to it which will in one case send commands from the CORB buffer across the link to codecs, and in the other case will write responses from codecs into the RIRB buffer. There will in many implementations also be an immediate command port which allows you to send commands to codecs/widgets and to receive responses from them without going through the CORB and RIRB mechanisms, but this route should not be used at the same time as CORB/RIRB as they may conflict, so it should really be reserved for initial exploration while designing your driver. The purpose of CORB and RIRB is to allow large numbers of these relatively slow communications to take place in the background while the processor goes off to do something else.
</p><p>There are also buffers and DMA engines dedicated to four input streams and four output streams (or at least, it's four of each in current implementations, but your software ought to check the actual number), each stream needing a descriptor buffer which must contain two or more descriptors (up to 256) which define a list of data buffers used by that stream, and the data buffers which these descriptors define will contain the actual sound samples (or have samples written into them) structured like the content of .wav files (though 20 and 24-bit samples must be padded out with zeros at the LSB end to make them all 32-bits long). The combined length of the sound data buffers can be anything up to 4GiB, so you could set things up to play or record a very long sound file and leave it going all by itself. In reality though, you'll probably work with chunks of memory a just few megabytes in size (or smaller) as one megabyte gives you room for about six seconds of 16-bit stereo data at 41.1KHz. For performance reasons, making the length of these data buffers a multiple of 128 bytes is recommended.
</p><p>With all these buffers, the DMA engines jump back to the start and carry on running from there infinitely until you stop them, although with CORB there is a register which stores the last valid command which the DMA engine must stop at (after sending that command) and it will only move on again when that register is modified (by you) to enable more commands to be sent. It is the job of your software to collect data from input buffers before they are overwritten on the next lap. The set of sound data buffers defined by descriptors for a single stream collectively comprise a cyclic stream buffer, but it's divided up into chunks defined by descriptors to enable an interrupt to be generated at the end of each chunk (interrupt optional) to help you write new data into an output buffer that's just been sent before the DMA engine returns to that buffer on the next lap, or to copy data out of an input buffer that's just been written by a DMA engine to make way for more data to be written on the next lap.
</p><p>At the codec end, you will need to start out by interrogating the root node of each of 15 possible codecs. The STATESTS register at offset 0Eh indicates which codec addresses have codecs at the end of them. The verb F00h will then be used with an 8-bit parameter to request information such as vendor ID, device ID and the starting node number and number of nodes for the function groups in the codec. Having found the function groups, you can use the same verb to interrogate them to find out the starting node number and number of nodes of their widgets, and also the type of the function group itself - AFG (audio function group) is the one you want (unless you're looking for a modem). You can then interrogate each widget to ask it what its type is (e.g. output converter (DAC), input converter (ADC), mixer, selector, pin complex, power widget, volume knob). Another verb, F02h, allows you to get a connection list of other widgets in the same function group directly connected to the widget you're interrogating, though you need to use verb F00h first and the parameter at 0Eh to get the connection list length. On the Netbook I program on there is only one codec, one function group (AFG) and 37 widgets (about half of which are vendor defined audio widgets, though many of those don't exist on the codec manufacturer's datasheet as they are just holding places for real widgets used on more advanced sound cards). Don't be surprised if you don't find a volume control widget - the volume can also be controlled by setting different amplifier levels at the input and output controllers.
</p>
<h2><span class="mw-headline" id="Device_Registers">Device Registers</span></h2>
<p>Base address of these registers can be found in BAR0 in PCI. Full description of these registers can be found in specification, descriptions below do not aim to explain every register or every single bit, only relevant ones.
</p>
<h4><span id="0x00_.284_bytes.29_Global_Capabilities"></span><span class="mw-headline" id="0x00_(4_bytes)_Global_Capabilities">0x00 (4 bytes) Global Capabilities</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>15:12</td>
<td>Number of Output streams
</td></tr>
<tr>
<td>11:8</td>
<td>Number of Input streams
</td></tr>
<tr>
<td>7:3</td>
<td>Number of Bidirectional streams
</td></tr>
<tr>
<td>0</td>
<td>1 = 64 bit addressing is supported
</td></tr>
</tbody></table>
<h4><span id="0x02_.281_byte.29_Minor_Version_.2F_0x03_.281_byte.29_Major_Version"></span><span class="mw-headline" id="0x02_(1_byte)_Minor_Version_/_0x03_(1_byte)_Major_Version">0x02 (1 byte) Minor Version / 0x03 (1 byte) Major Version</span></h4>
<p>As names suggests, from these registers you can read version of High Definition Audio specification that is implemented by sound card.
</p>
<h4><span id="0x08_.282_bytes.29_Global_Control"></span><span class="mw-headline" id="0x08_(2_bytes)_Global_Control">0x08 (2 bytes) Global Control</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>8</td>
<td>1 = Unsolicited responses from Codec are allowed
</td></tr>
<tr>
<td>0</td>
<td>0 = Controller is in reset state 1 = Controller is in operational state
</td></tr>
</tbody></table>
<h4><span id="0x20_.284_bytes.29_Interrupt_Control"></span><span class="mw-headline" id="0x20_(4_bytes)_Interrupt_Control">0x20 (4 bytes) Interrupt Control</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>31</td>
<td>0 = All interrupts are disabled 1 = Interrupts are enabled
</td></tr>
<tr>
<td>30</td>
<td>1 = Controller will generate interrupt due to Response interrupt, Response Buffer overrun and wake events
</td></tr>
<tr>
<td>29:0</td>
<td>If is particular bit set, it mean that corresponding stream will be able to generate interrupts. Bits for streams are sorted in order: Input Streams, Output Streams, Bidirectional streams. So for example if there is one stream from each category, bit 0 will control Input Stream, bit 1 Output Stream and bit 2 Bidirectional Stream. Unused bits are reserved.
</td></tr>
</tbody></table>
<h4><span id="0x34_.284_bytes.29_Stream_Synchronization"></span><span class="mw-headline" id="0x34_(4_bytes)_Stream_Synchronization">0x34 (4 bytes) Stream Synchronization</span></h4>
<p>Note: The HD Audio specifications list this register at offset 0x38, but this appears to be incorrect.
</p><p>This register allows to start or stop more streams at same time. You can do it by setting bits of these streams what will stop them, then start DMA engine on each of them and finally clear their bits to allow DMA engines to start working with data.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>29:0</td>
<td>If is particular bit clear, it mean that corresponding stream will be able to sent or receive data. Bits for streams are sorted in same order as in register 0x20 Interrupt Control.
</td></tr>
</tbody></table>
<h4><span id="0x40_.284_bytes.29_CORB_Lower_Base_Address"></span><span class="mw-headline" id="0x40_(4_bytes)_CORB_Lower_Base_Address">0x40 (4 bytes) CORB Lower Base Address</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>31:7</td>
<td>Lower Base Address of CORB ring
</td></tr>
<tr>
<td>6:0</td>
<td>Reserved to force 1 KB alignment
</td></tr>
</tbody></table>
<h4><span id="0x44_.284_bytes.29_CORB_Upper_Base_Address"></span><span class="mw-headline" id="0x44_(4_bytes)_CORB_Upper_Base_Address">0x44 (4 bytes) CORB Upper Base Address</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>31:0</td>
<td>Upper Base Address of CORB ring
</td></tr>
</tbody></table>
<h4><span id="0x48_.282_bytes.29_CORB_Write_Pointer"></span><span class="mw-headline" id="0x48_(2_bytes)_CORB_Write_Pointer">0x48 (2 bytes) CORB Write Pointer</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>7:0</td>
<td>Number of last valid CORB entry
</td></tr>
</tbody></table>
<h4><span id="0x4A_.282_bytes.29_CORB_Read_Pointer"></span><span class="mw-headline" id="0x4A_(2_bytes)_CORB_Read_Pointer">0x4A (2 bytes) CORB Read Pointer</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>15</td>
<td>1 = Reset CORB read pointer (this bit is not self-clearing, you have to wait for it to be set, then clear it and wait for it to be clear)
</td></tr>
<tr>
<td>7:0</td>
<td>Number of last CORB entry that controller processed
</td></tr>
</tbody></table>
<h4><span id="0x4C_.281_byte.29_CORB_Control"></span><span class="mw-headline" id="0x4C_(1_byte)_CORB_Control">0x4C (1 byte) CORB Control</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>1</td>
<td>0 = CORB is stopped 1 = CORB is running
</td></tr>
<tr>
<td>0</td>
<td>1 = Interrupt will be generated if there is memory error
</td></tr>
</tbody></table>
<h4><span id="0x4E_.281_byte.29_CORB_Size"></span><span class="mw-headline" id="0x4E_(1_byte)_CORB_Size">0x4E (1 byte) CORB Size</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>6</td>
<td>1 = CORB ring can be programmed to have 256 entries
</td></tr>
<tr>
<td>5</td>
<td>1 = CORB ring can be programmed to have 16 entries
</td></tr>
<tr>
<td>4</td>
<td>1 = CORB ring can be programmed to have 2 entries
</td></tr>
<tr>
<td>1:0</td>
<td>Number of CORB ring entries. 0b00 = 2 entries 0b01 = 16 entries 0b10 = 256 entries 0b11 = Reserved
</td></tr>
</tbody></table>
<h4><span id="0x50_.284_bytes.29_RIRB_Lower_Base_Address"></span><span class="mw-headline" id="0x50_(4_bytes)_RIRB_Lower_Base_Address">0x50 (4 bytes) RIRB Lower Base Address</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>31:7</td>
<td>Lower Base Address of RIRB ring
</td></tr>
<tr>
<td>6:0</td>
<td>Reserved to force 1 KB alignment
</td></tr>
</tbody></table>
<h4><span id="0x54_.284_bytes.29_RIRB_Upper_Base_Address"></span><span class="mw-headline" id="0x54_(4_bytes)_RIRB_Upper_Base_Address">0x54 (4 bytes) RIRB Upper Base Address</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>31:0</td>
<td>Upper Base Address of RIRB ring
</td></tr>
</tbody></table>
<h4><span id="0x58_.282_bytes.29_RIRB_Write_Pointer"></span><span class="mw-headline" id="0x58_(2_bytes)_RIRB_Write_Pointer">0x58 (2 bytes) RIRB Write Pointer</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>15</td>
<td>1 = Reset write pointer (note: this bit always reads as 0)
</td></tr>
<tr>
<td>7:0</td>
<td>Number of last RIRB entry that was written by controller
</td></tr>
</tbody></table>
<h4><span id="0x5A_.282_bytes.29_RIRB_Response_Interrupt_Count"></span><span class="mw-headline" id="0x5A_(2_bytes)_RIRB_Response_Interrupt_Count">0x5A (2 bytes) RIRB Response Interrupt Count</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>7:0</td>
<td>How many responses have to be written by RIRB to generate interrupt
</td></tr>
</tbody></table>
<h4><span id="0x5C_.281_byte.29_RIRB_Control"></span><span class="mw-headline" id="0x5C_(1_byte)_RIRB_Control">0x5C (1 byte) RIRB Control</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>0</td>
<td>1 = Interrupt will be generated if there is response overrun
</td></tr>
<tr>
<td>1</td>
<td>0 = RIRB is stopped 1 = RIRB is running
</td></tr>
<tr>
<td>0</td>
<td>1 = Interrupt will be generated if there is memory error
</td></tr>
</tbody></table>
<h4><span id="0x5E_.281_byte.29_RIRB_Size"></span><span class="mw-headline" id="0x5E_(1_byte)_RIRB_Size">0x5E (1 byte) RIRB Size</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>6</td>
<td>1 = RIRB ring can be programmed to have 256 entries
</td></tr>
<tr>
<td>5</td>
<td>1 = RIRB ring can be programmed to have 16 entries
</td></tr>
<tr>
<td>4</td>
<td>1 = RIRB ring can be programmed to have 2 entries
</td></tr>
<tr>
<td>1:0</td>
<td>Number of RIRB ring entries. 0b00 = 2 entries 0b01 = 16 entries 0b10 = 256 entries 0b11 = Reserved
</td></tr>
</tbody></table>
<h4><span id="0x70_.284_bytes.29_DMA_Position_Lower_Base_Address"></span><span class="mw-headline" id="0x70_(4_bytes)_DMA_Position_Lower_Base_Address">0x70 (4 bytes) DMA Position Lower Base Address</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>31:7</td>
<td>Lower Base Address of DMA position buffer
</td></tr>
<tr>
<td>6:1</td>
<td>Reserved to force 1 KB alignment
</td></tr>
<tr>
<td>0</td>
<td>1 = DMA position buffer is enabled
</td></tr>
</tbody></table>
<h4><span id="0x74_.284_bytes.29_DMA_Position_Upper_Base_Address"></span><span class="mw-headline" id="0x74_(4_bytes)_DMA_Position_Upper_Base_Address">0x74 (4 bytes) DMA Position Upper Base Address</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>31:0</td>
<td>Upper Base Address of DMA position buffer
</td></tr>
</tbody></table>
<h3><span id="0x80.2B_Registers_of_Stream_Descriptors"></span><span class="mw-headline" id="0x80+_Registers_of_Stream_Descriptors">0x80+ Registers of Stream Descriptors</span></h3>
<p>Sound card has as many Stream Descriptors as many streams it have. Registers of every Stream Control occupies 0x20 bytes. As first there are Stream Descriptors for Input Streams, then for Output Streams and then for Bidirectional Streams. Number of streams can be readed from 0x00 Global Capabilities register.
</p><p>For example, if there are 4 Input Streams, 3 Output Streams and 1 Bidirectional Stream, base address for registers of first Stream Descriptor for Input Stream is at (mmio_base + 0x80), first Stream Descriptor for Output Stream is at (mmio_base + 0x80 + 0x20*4) and first Stream Descriptor for Bidirectional Stream is at (mmio_base + 0x80 + 0x20*4 + 0x20*3).
</p><p>Offsets in table below should be added to particular Stream Descriptor base.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Offset
</th>
<th>Size
</th>
<th>Description
</th></tr>
<tr>
<td>0x00</td>
<td>1 byte</td>
<td>Stream Control byte 0
</td></tr>
<tr>
<td>0x02</td>
<td>1 byte</td>
<td>Stream Control byte 2
</td></tr>
<tr>
<td>0x03</td>
<td>1 byte</td>
<td>Stream Status
</td></tr>
<tr>
<td>0x04</td>
<td>4 bytes</td>
<td>Link position in buffer entry
</td></tr>
<tr>
<td>0x08</td>
<td>4 bytes</td>
<td>Cyclic Buffer Length (size of all entries in Buffer Descriptor List added together)
</td></tr>
<tr>
<td>0x0C</td>
<td>2 bytes</td>
<td>Last Valid Index (number of entries in Buffer Descriptor List + 1)
</td></tr>
<tr>
<td>0x12</td>
<td>2 bytes</td>
<td>Stream Format
</td></tr>
<tr>
<td>0x18</td>
<td>4 bytes</td>
<td>Lower Base Address of Buffer Descriptor List
</td></tr>
<tr>
<td>0x1C</td>
<td>4 bytes</td>
<td>Upper Base Address of Buffer Descriptor List
</td></tr>
</tbody></table>
<h4><span class="mw-headline" id="Stream_Control_byte_0">Stream Control byte 0</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>4</td>
<td>1 = Generate interrupt if there is Descriptor error
</td></tr>
<tr>
<td>3</td>
<td>1 = Generate interrupt if there is FIFO error
</td></tr>
<tr>
<td>2</td>
<td>1 = Generate interrupt if was transferred buffer with IOC bit set
</td></tr>
<tr>
<td>1</td>
<td>1 = Stream is running (transferring data)
</td></tr>
<tr>
<td>0</td>
<td>1 = Reset all registers of Stream Descriptor, must not be set when Stream is running (this bit is not self-clearing, you have to wait for it to be set, then clear it and wait for it to be clear)
</td></tr>
</tbody></table>
<h4><span class="mw-headline" id="Stream_Control_byte_2">Stream Control byte 2</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>7:4</td>
<td>Number of stream to which this Stream Descriptor will send data. Value 0 is reserved and indicate that this Stream Descriptor is unused.
</td></tr>
<tr>
<td>3</td>
<td>Relevant only for Bidirectional streams to set their behaviour 0 = Select Input engine 1 = Select Output engine
</td></tr>
<tr>
<td>2</td>
<td>This bit may be read-only. 0 = Stream will be handled on „best effort“ basis 1 = Stream will be transferred as preferred traffic
</td></tr>
</tbody></table>
<h2><span class="mw-headline" id="CODECs_and_Nodes">CODECs and Nodes</span></h2>
<p>Each HD Audio device contains one or more CODECs, and each CODEC contains a list of "nodes" that are connected together in a hierarchical structure.  You can find the available CODECs by sending a GetParameter command to the codec's root node (node 0) using the CORB ring buffer (or the Immediate Command Output Interface, if available). If response is not 0x00000000, it mean that CODEC is present.
</p>
<h2><span class="mw-headline" id="Node_Commands">Node Commands</span></h2>
<p>Each entry in the CORB ring buffer has the following structure:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Bits
</th>
<th>Description
</th></tr>
<tr>
<td>31:28</td>
<td>Codec Address
</td></tr>
<tr>
<td>27:20</td>
<td>Node Index
</td></tr>
<tr>
<td>19:8</td>
<td>Command
</td></tr>
<tr>
<td>7:0</td>
<td>Data
</td></tr>
</tbody></table>
<p>The following list contain some useful verbs that could be send to CODEC nodes:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Hex
</th>
<th>Command
</th>
<th>Notes
</th></tr>
<tr>
<td>F00</td>
<td>Get Parameter</td>
<td>Data is number of requested parameter
</td></tr>
<tr>
<td>F02</td>
<td>Get Connection List Entry</td>
<td>
</td></tr>
<tr>
<td>701</td>
<td>Set Selected Input</td>
<td>
</td></tr>
<tr>
<td>705</td>
<td>Set Power State</td>
<td>0 in data mean full power
</td></tr>
<tr>
<td>706</td>
<td>Set Converter Stream, Channel</td>
<td>
</td></tr>
<tr>
<td>707</td>
<td>Set Pin Widget Control</td>
<td>
</td></tr>
<tr>
<td>F09</td>
<td>Get Pin Widget Sense</td>
<td>Used to detect if headphone/microphone is plugged into Pin
</td></tr>
<tr>
<td>70C</td>
<td>Set EAPD/BTL</td>
<td>
</td></tr>
<tr>
<td>F1C</td>
<td>Get Pin Widget Configuration Default</td>
<td>
</td></tr>
<tr>
<td>72D</td>
<td>Set Output Converter Channel Count</td>
<td>
</td></tr>
<tr>
<td>7FF</td>
<td>Audio Function Node Reset</td>
<td>Reset all nodes in particular Audio Function Group
</td></tr>
<tr>
<td>0x3</td>
<td>Set Amplifier Gain</td>
<td>(16-bit payload)
</td></tr>
<tr>
<td>0x2</td>
<td>Set Stream Converter Format</td>
<td>(16-bit payload) Data have same format as Stream Format register
</td></tr>
</tbody></table>
<h2><span class="mw-headline" id="Node_Parameters">Node Parameters</span></h2>
<p>The following parameters can be read using the Get Parameter verb above:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Hex
</th>
<th>Description
</th>
<th>Notes
</th></tr>
<tr>
<td>00</td>
<td>Vendor ID / Device ID</td>
<td>
</td></tr>
<tr>
<td>02</td>
<td>Revision ID</td>
<td>
</td></tr>
<tr>
<td>04</td>
<td>Node Count</td>
<td>
</td></tr>
<tr>
<td>05</td>
<td>Function Group Type</td>
<td>
</td></tr>
<tr>
<td>08</td>
<td>Audio Group Capabilities</td>
<td>
</td></tr>
<tr>
<td>09</td>
<td>Audio Widget Capabilities</td>
<td>
</td></tr>
<tr>
<td>0A</td>
<td>Supported PCM Rates</td>
<td>
</td></tr>
<tr>
<td>0B</td>
<td>Supported Formats</td>
<td>
</td></tr>
<tr>
<td>0C</td>
<td>Pin Capabilities</td>
<td>
</td></tr>
<tr>
<td>0D</td>
<td>Input Amplifier Capabilities</td>
<td>
</td></tr>
<tr>
<td>12</td>
<td>Output Amplifier Capabilities</td>
<td>
</td></tr>
<tr>
<td>0E</td>
<td>Connection List Length</td>
<td>
</td></tr>
<tr>
<td>0F</td>
<td>Supported Power States</td>
<td>
</td></tr>
<tr>
<td>10</td>
<td>Processing Capabilities</td>
<td>
</td></tr>
<tr>
<td>11</td>
<td>GPIO Count</td>
<td>
</td></tr>
<tr>
<td>13</td>
<td>Volume Capabilities</td>
<td>
</td></tr>
</tbody></table>
<h2><span class="mw-headline" id="Initalizing_sound_card">Initalizing sound card</span></h2>
<p>TODO
</p>
<h2><span class="mw-headline" id="Initalizing_CODEC">Initalizing CODEC</span></h2>
<h3><span class="mw-headline" id="Setting_up_the_AFG_codec">Setting up the AFG codec</span></h3>
<p>Each programmer will likely have their own way of going about this, but the main aim will be to set out to identify which pin complexes are connected to actual speakers, headphone sockets, microphones and microphone sockets before following the trail of connections back to the most appropriate DAC or ADC to handle the stream. How you end up connecting things up will depend on what you want to do: you could, for example, use the same DAC for the speakers as for the headphone jack, but there might be occasions when you want to send different sound streams to each. Similarly, you might use the same ADC for the built-in microphone as for the microphone jack, but you could use a different ADC for each if you need to collect different inputs from different microphones (perhaps using one to collect background noise to subtract from the other input). You might also want to send sound out through the microphone socket so that two people can listen to the same music at the same time on headphones, or you might want to use the headphone socket as an extra microphone socket, perhaps to set up a pair of stereo microphones in a tetrahedron arrangement in order to calculate the direction a sound is coming from. Try to make your driver flexible enough to cover all those cases, or at least to make it easy to adapt it to cover them later.
</p><p>Here's an suggestion as to how the initial task might be broken down, but use it only as a rough guide:-
</p><p>(1) Use verb F00h with parameter 4 and NID 0 (the root node) to find the number of function groups in the codec, then check those nodes using their NID and with verb F00h and parameter 5 to hunt for an AFG function group.
</p><p>(2) Use verb F00h with parameter 4 and the correct NID for the AFG function group to get the start node (first widget) and number of nodes (widgets).
</p><p>(3) Collect the following data for each widget: param 9h (primarily to get the widget type); Ch (pin capabilities); Dh (input amplifier details); 12h (output amplifier details); Eh (connection list length); 13h (volume knob capabilities). Also, use verb F1Ch to collect the configuration defaults, and verb F02h to collect the first few entries in the connection list. Don't worry about whether useful responses are available for each widget - they will send back all zeros wherever they are not relevant.
</p><p>(4) Sort the results into groups of DACs, ADCs, mixers, pins, etc.
</p><p>(5) Identify the pins with actual speakers, microphone and sockets for jacks by using the configuration defaults which you collected earlier. Bits 31-30 state which pins have devices attached to them, telling you whether they are integrated devices or sockets into which things can be plugged. Bits 23-20 tell you what the integrated device is or what kind of device will normally be plugged into the socket. Some machines may have multiple output sockets for sound and may in rare cases have more than one set of integrated speakers to play surround sound, so you might need to look at bits 7-4 (default-association) to find out which ones are grouped together as a set, and bits 3-1 (sequence) to determine which are the main speakers in that set. In a few badly configured machines which fail to provide correct information in some of these bits, EAPD capability may serve as an additional clue for tracking down the speakers.
</p><p>(6) Make two lists of pins: one for those you want to send outputs to, and the other for inputs.
</p><p>(7) Try to find the shortest paths from the speakers and headphone jacks back to DACs, though you may wish to use different DACs for different pins. See the section "Finding all useful paths through the codec" below for guidance on this, but the first connection in the connection list for a widgit should help you find the right paths for the most common uses, although you may need to explore more items in the connection lists for some of the widgets.
</p><p>(8) Try to find the shortest paths from the ADCs to any built-in microphone and microphone jack. Again you may wish to use different ADCs for the different inputs or you may wish to share the same one.
</p><p>(9) Set up the paths you want to use by setting an intitial volume/gain and turning off the mutes at every widget in the chain wherever there is one needing to be set. Use verb 2h to set Format for any DACs and ADCs you're going to use, and verb 706h to set the stream and the lowest channel. Verb 707 must be used to enable input/output at the pins (and read up on VrefEn for mic.s, if you can find any good information on this - I'm still searching for it). Remember to set Unsol for the jacks too if you want pins to report headphones/microphone being plugged in or removed, but you can poll them if you prefer.
</p><p>(10) For each path, create a list of volume controls, mutes and the range of numbers that can be used with each volume/gain control to guide the creation of suitable controls for the user to manipulate in order to control each input/output.
</p><p>(11) Set EAPD to enable the external amp for the speakers.
</p><p>After you've done all that, get the near end of the link set up to get the DMA engines to handle the streams (read the specification carefully and act on it) and with luck you'll soon have sound coming in and out. If it doesn't happen that easily, you can set up the DMA position buffer to see if the DMA engines are actually running and looping correctly through the cyclic stream buffers. If all is well there, you might find it useful to use the codec ID to find the datasheet for it just to make sure you aren't missing anything out in the way you're setting it up. Also, feel free to improve the instructions on this page so that others can gain from your solutions to any problems you encounter.
</p>
<h3><span class="mw-headline" id="Finding_all_useful_paths_through_the_codec">Finding all useful paths through the codec</span></h3>
<p>The paths that are potentially useful are the ones that lead from pins with output devices connected to them back to a DAC, plus all the paths from those same pins back to all other pins with an input device connected to them (some codecs allow inputs to be mixed into outputs for such purposes as karaoke, so your device driver might as well make this option available if the codec supports it), plus all the paths from ADCs to all pins with an input device connected. A socket for a jack can be both an output and input device, but not at the same time.
</p><p>An algorithm guaranteed to find all useful paths is as follows. Write a routine to start at a pin with an attached output device and then call it for each such pin in turn. The routine will look at the association list for the pin it's starting at and follow the path to the first widget listed there. If it finds a DAC (or a pin with an input device attached), the path can be stored. Else, look at the association list for this widget and repeat the process to examine the next widget in the path. The search will backtrack to the previous widget in the chain once a DAC or pin has been reached, and then the next item in the association list for that previous widget tells you which widget to examine next. If there isn't a next item in the association list, backtrack again to the widget before it. In this way, all paths are explored, and the task is complete once you've run out of items in the association list to explore for the pin you started at. It may be wise to keep count of the number of links in the path just in case a codec sends you round in circles - you should abandon any paths that get too long (perhaps a ten link limit would be safe). For inputs the algorithm is much the same, but you start at each ACD and store any paths that link through to a pin which has an input device attached.
</p><p>Once you have your list, you can select the first suitable one found for each purpose, while the rest can be offered to the user as alternative options accessed either via a user-interface for the device driver or from the interface of an advanced application which directly offers these other paths whenever they exist on the machine. An audio player could, for example, allow you to sing along with the music it's playing such that you hear your voice in the headphones (without any delay from the input being put through a conversion to digital and back).
</p>
<h2><span class="mw-headline" id="Playing_Audio">Playing Audio</span></h2>
<p>If you successfully initalized all nodes that are in path, you can play audio by following steps:
</p>
<h4><span class="mw-headline" id="Set_Audio_Output_node">Set Audio Output node</span></h4>
<p>You have to set Audio Output node to format of your data by verb 0x2, and also set stream number and channel you will use to transfer data by verb 0x706. Node will remember these values, so you need to set them only when you want to change them.
</p>
<h4><span class="mw-headline" id="Create_Buffer_Descriptor_List">Create Buffer Descriptor List</span></h4>
<p>Buffer Descriptor List has to be 1 KB aligned, what mean that first seven bits must be zero. It has to contain at least 2 entries. Every entry is 16 bytes long and has following format:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Offset
</th>
<th>Length
</th>
<th>Description
</th></tr>
<tr>
<td>0x00</td>
<td>8 bytes</td>
<td>Address of Audio Data
</td></tr>
<tr>
<td>0x08</td>
<td>4 bytes</td>
<td>Length of Audio Data in bytes
</td></tr>
<tr>
<td>0x0C</td>
<td>4 bytes</td>
<td>Bit 0 = IOC (Interrupt On Completion), if set, interrupt will be generated after transferring this entry. Rest is reserved.
</td></tr>
</tbody></table>
<p>NOTE: Sound Card will read Buffer Descriptor List data directly from RAM memory, so you have to be sure, that you really wrote it into RAM memory and not only to processor cache. You can do it by flushing processor cache by assembly command „wbinvd“
</p>
<h4><span class="mw-headline" id="Set_Stream_Descriptor">Set Stream Descriptor</span></h4>
<p>Now you have to select Stream Descriptor that you do not already use and program it to transfer your Buffer Descriptor List.
</p><p>(1) Stop Stream Descriptor (clear bit 1 in Control register)
</p><p>(2) Reset Stream Descriptor (set bit 0 in Control register, wait until it is set, then clear it and wait for it to be cleared)
</p><p>(3) Write Buffer Descriptor List physical address
</p><p>(4) Add up length of all entries in Buffer Descriptor List and write it to register
</p><p>(5) Set number of Buffer Descriptor List entries
</p><p>(6) Set Stream Format register by same format you sended to Audio Output node
</p><p>(7) Set number of stream you want to use for streaming data (in byte 2 of Control register)
</p><p>(8) Start transfer (set bit 1 in Control register)
</p><p>If you configured everything properly, DMA engine should start transfer your audio data and you should hear sound from PIN(s) you enabled and connected them to Audio Output(s) that are receiving data from your stream number. The audio will play until the end of the last buffer in the buffer list, then it will begin playing the beginning of the first buffer again. You can enable the proper interrupt to be notified when a buffer has been played, so that you can refill the buffer with the next block of audio data.
</p>
<h2><span class="mw-headline" id="External_links">External links</span></h2>
<ul><li><a rel="nofollow" class="external text" href="http://www.intel.co.uk/content/www/us/en/standards/high-definition-audio-specification.html">Intel High Definition Audio Specification</a></li></ul>
<ul><li><a rel="nofollow" class="external text" href="https://forum.osdev.org/viewtopic.php?f=1&amp;t=34525">Thread about playing sound through Intel HD Audio</a></li></ul>
<ul><li><a rel="nofollow" class="external free" href="https://forum.osdev.org/viewtopic.php?f=1&amp;t=28944">https://forum.osdev.org/viewtopic.php?f=1&amp;t=28944</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250211131144
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.034 seconds
Real time usage: 0.035 seconds
Preprocessor visited node count: 192/1000000
Post‐expand include size: 4408/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    2.461      1 -total
 34.94%    0.860      1 Template:In_Progress
 22.40%    0.551     25 Template:Wikitable
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:3313-0!canonical and timestamp 20250211131144 and revision id 28688.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Intel_High_Definition_Audio&amp;oldid=28688">https://wiki.osdev.org/index.php?title=Intel_High_Definition_Audio&amp;oldid=28688</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="./Category:In_Progress" title="Category:In Progress">In Progress</a></li><li><a href="./Category:Sound" title="Category:Sound">Sound</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Intel+High+Definition+Audio" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="Intel_High_Definition_Audio#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Intel_High_Definition_Audio" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:Intel_High_Definition_Audio" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Intel_High_Definition_Audio"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Intel_High_Definition_Audio&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Intel_High_Definition_Audio&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Intel_High_Definition_Audio" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/Intel_High_Definition_Audio" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Intel_High_Definition_Audio&amp;oldid=28688" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Intel_High_Definition_Audio&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 11 March 2024, at 16:12.</li>
	<li id="footer-info-0">This page has been accessed 5,887 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Intel_High_Definition_Audio&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.034","walltime":"0.035","ppvisitednodes":{"value":192,"limit":1000000},"postexpandincludesize":{"value":4408,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    2.461      1 -total"," 34.94%    0.860      1 Template:In_Progress"," 22.40%    0.551     25 Template:Wikitable"]},"cachereport":{"timestamp":"20250211131144","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":100});});</script>
</body>
</html>