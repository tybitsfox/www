<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Programmable Interval Timer - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"66fcdec3f811d97f2dad2255","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Programmable_Interval_Timer","wgTitle":"Programmable Interval Timer","wgCurRevisionId":29325,"wgRevisionId":29325,"wgArticleId":1560,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Common Devices","Timers"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Programmable_Interval_Timer","wgRelevantArticleId":1560,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[
],"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Programmable_Interval_Timer rootpage-Programmable_Interval_Timer skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Programmable Interval Timer</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="Programmable_Interval_Timer#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="Programmable_Interval_Timer#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>The <b>Programmable Interval Timer</b> (<b>PIT</b>) chip (Intel 8253/8254) basically consists of an oscillator, a prescaler and 3 independent frequency dividers. Each frequency divider has an output, which is used to allow the timer to control external circuitry (for example, IRQ 0).
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Programmable_Interval_Timer#The_Oscillator"><span class="tocnumber">1</span> <span class="toctext">The Oscillator</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Programmable_Interval_Timer#Frequency_Dividers"><span class="tocnumber">2</span> <span class="toctext">Frequency Dividers</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="Programmable_Interval_Timer#PIT_Timer_Accuracy"><span class="tocnumber">3</span> <span class="toctext">PIT Timer Accuracy</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="Programmable_Interval_Timer#Outputs"><span class="tocnumber">4</span> <span class="toctext">Outputs</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="Programmable_Interval_Timer#Channel_0"><span class="tocnumber">4.1</span> <span class="toctext">Channel 0</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="Programmable_Interval_Timer#Channel_1"><span class="tocnumber">4.2</span> <span class="toctext">Channel 1</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="Programmable_Interval_Timer#Channel_2"><span class="tocnumber">4.3</span> <span class="toctext">Channel 2</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="Programmable_Interval_Timer#I/O_Ports"><span class="tocnumber">5</span> <span class="toctext">I/O Ports</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="Programmable_Interval_Timer#Operating_Modes"><span class="tocnumber">6</span> <span class="toctext">Operating Modes</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="Programmable_Interval_Timer#Mode_0_–_Interrupt_On_Terminal_Count"><span class="tocnumber">6.1</span> <span class="toctext">Mode 0 – Interrupt On Terminal Count</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="Programmable_Interval_Timer#Mode_1_–_Hardware_Re-triggerable_One-shot"><span class="tocnumber">6.2</span> <span class="toctext">Mode 1 – Hardware Re-triggerable One-shot</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="Programmable_Interval_Timer#Mode_2_–_Rate_Generator"><span class="tocnumber">6.3</span> <span class="toctext">Mode 2 – Rate Generator</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="Programmable_Interval_Timer#Mode_3_–_Square_Wave_Generator"><span class="tocnumber">6.4</span> <span class="toctext">Mode 3 – Square Wave Generator</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="Programmable_Interval_Timer#Mode_4_–_Software_Triggered_Strobe"><span class="tocnumber">6.5</span> <span class="toctext">Mode 4 – Software Triggered Strobe</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="Programmable_Interval_Timer#Mode_5_–_Hardware_Triggered_Strobe"><span class="tocnumber">6.6</span> <span class="toctext">Mode 5 – Hardware Triggered Strobe</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="Programmable_Interval_Timer#Counter_Latch_Command"><span class="tocnumber">7</span> <span class="toctext">Counter Latch Command</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="Programmable_Interval_Timer#Read_Back_Command"><span class="tocnumber">8</span> <span class="toctext">Read Back Command</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="Programmable_Interval_Timer#Read_Back_Status_Byte"><span class="tocnumber">8.1</span> <span class="toctext">Read Back Status Byte</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="Programmable_Interval_Timer#Reading_The_Current_Count"><span class="tocnumber">9</span> <span class="toctext">Reading The Current Count</span></a></li>
<li class="toclevel-1 tocsection-20"><a href="Programmable_Interval_Timer#Setting_The_Reload_Value"><span class="tocnumber">10</span> <span class="toctext">Setting The Reload Value</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="Programmable_Interval_Timer#PIT_Channel_0_Example_Code"><span class="tocnumber">11</span> <span class="toctext">PIT Channel 0 Example Code</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="Programmable_Interval_Timer#Uses_for_the_Timer_IRQ"><span class="tocnumber">12</span> <span class="toctext">Uses for the Timer IRQ</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="Programmable_Interval_Timer#Using_the_IRQ_to_Implement_sleep"><span class="tocnumber">12.1</span> <span class="toctext">Using the IRQ to Implement sleep</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="Programmable_Interval_Timer#Using_the_IRQ_for_Preemptive_Multitasking"><span class="tocnumber">12.2</span> <span class="toctext">Using the IRQ for Preemptive Multitasking</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-25"><a href="Programmable_Interval_Timer#See_Also"><span class="tocnumber">13</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-26"><a href="Programmable_Interval_Timer#Articles"><span class="tocnumber">13.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="Programmable_Interval_Timer#Threads"><span class="tocnumber">13.2</span> <span class="toctext">Threads</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="Programmable_Interval_Timer#External_Links"><span class="tocnumber">13.3</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="The_Oscillator">The Oscillator</span></h2>
<p>The oscillator used by the PIT chip runs at (roughly) 1.193182 MHz. The reason for this requires a trip back into history (to the later half of the 1970's)...
</p><p>The original PC used a single "base oscillator" to generate a frequency of 14.31818 MHz because this frequency was commonly used in television circuitry at the time. This base frequency was divided by 3 to give a frequency of 4.77272666 MHz that was used by the CPU, and divided by 4 to give a frequency of 3.579545 MHz that was used by the CGA video controller. By logically ANDing these signals together a frequency equivalent to the base frequency divided by 12 was created. This frequency is 1.1931816666 MHz (where the 6666 part is recurring). At the time it was a brilliant method of reducing costs, as the 14.31818 MHz oscillator was cheap due to mass production and it was cheaper to derive the other frequencies from this than to have several oscillators. In modern computers, where the cost of electronics is much less, and the CPU and video run at much higher frequencies the PIT lives on as a reminder of "the good ole' days".
</p>
<h2><span class="mw-headline" id="Frequency_Dividers">Frequency Dividers</span></h2>
<p>The basic principle of a frequency divider is to divide one frequency to obtain a slower frequency. This is typically done by using a counter. Each "pulse" from the input frequency causes the counter to be decreased, and when that counter has reached zero a pulse is generated on the output and the counter is reset. For example, if the input signal is 200 Hz and the counter is reset to a value of ten each time, then the output frequency would be 200/10, or 20 Hz.
</p><p>The PIT has only 16 bits that are used as frequency divider, which can represent the values from 0 to 65535. Since the frequency can't be divided by 0 in a sane way, many implementations use 0 to represent the value 65536 (or 10000 when programmed in BCD mode).
</p><p>The PIT chip has three separate frequency dividers (or 3 separate channels) that are programmable, in that the value of the "reset counter" is set by software (the OS). Software also specifies an action to be taken when the counter reaches zero on each individual channel. In this way, each channel can be used in one of several "modes" – for example, as a frequency divider (where the count is automatically reset) or as a "one shot" timer (where the count isn't automatically reset).
</p><p>Each PIT channel also has a "gate input" pin which can be used to control whether the input signal (the 1.19MHz one) gets to the channel or not. For PIT channels 0 and 1, the associated gate input pin is not connected to anything. The PIT channel 2 gate is controlled by IO port 0x61, bit 0.
</p>
<h2><span class="mw-headline" id="PIT_Timer_Accuracy">PIT Timer Accuracy</span></h2>
<p>The accuracy of the PIT timer depends on the quality of the oscillator used, and is typically accurate to within +/- 1.73 seconds per day. There are many causes for this inaccuracy, however because of this there isn't much point in specifying times or frequencies to more than five or six digits.
</p>
<h2><span class="mw-headline" id="Outputs">Outputs</span></h2>
<p>Channel 0 is connected directly to IRQ0, so it is best to use it only for purposes that should generate interrupts. Channel 1 is unusable, and may not even exist. Channel 2 is connected to the PC speaker, but can be used for other purposes without producing audible speaker tones.
</p>
<h3><span class="mw-headline" id="Channel_0">Channel 0</span></h3>
<p>The output from PIT channel 0 is connected to the PIC chip, so that it generates an "IRQ 0". Typically during boot the BIOS sets channel 0 with a count of 65535 or 0 (which translates to 65536), which gives an output frequency of 18.2065 Hz (or an IRQ every 54.9254 ms). Channel 0 is probably the most useful PIT channel, as it is the only channel that is connected to an IRQ. It can be used to generate an infinte series of "timer ticks" at a frequency of your choice (as long as it is higher than 18 Hz), or to generate single CPU interrupts (in "one shot" mode) after programmable short delays (less than an 18th of a second).
</p><p>When choosing <a href="Programmable_Interval_Timer#Operating_Modes">an operating mode</a>, below, it is useful to remember that the IRQ0 is generated by the <i>rising edge</i> of the Channel 0 output voltage (ie. the transition from "low" to "high", only).
</p>
<h3><span class="mw-headline" id="Channel_1">Channel 1</span></h3>
<p>The output for PIT channel 1 was once used (in conjunction with the DMA controller's channel 0) for refreshing the DRAM (Dynamic Random Access Memory) or RAM. Typically, each bit in RAM consists of a capacitor which holds a tiny charge representing the state of that bit, however (due to leakage) these capacitors need to be "refreshed" periodically so that they don't forget their state.
</p><p>On later machines, the DRAM refresh is done with dedicated hardware and the PIT (and DMA controller) is no longer used. On modern computers where the functionality of the PIT is implemented in a large scale integrated circuit, PIT channel 1 is no longer usable and may not be implemented at all.
</p>
<h3><span class="mw-headline" id="Channel_2">Channel 2</span></h3>
<p>The output of PIT channel 2 is connected to the PC speaker, so the frequency of the output determines the frequency of the sound produced by the speaker. This is the only channel where the gate input can be controlled by software (via bit 0 of I/O port 0x61), and the only channel where its output (a high or low voltage) can be read by software (via bit 5 of I/O port 0x61). Details of how to program the PC speaker can be found <a href="PC_Speaker" title="PC Speaker">here</a>.
</p>
<h2><span id="I.2FO_Ports"></span><span class="mw-headline" id="I/O_Ports">I/O Ports</span></h2>
<p>The PIT chip uses the following I/O ports:
</p>
<pre>I/O port     Usage
0x40         Channel 0 data port (read/write)
0x41         Channel 1 data port (read/write)
0x42         Channel 2 data port (read/write)
0x43         Mode/Command register (write only, a read is ignored)
</pre>
<p>Each 8 bit data port is the same, and is used to set the counter's 16 bit reload value or read the channel's 16 bit current count (more on this later). The PIT channel's current count and reload value should not be confused. In general, when the current count reaches zero the PIT channel's output is changed and the current count is reloaded with the reload value, however this isn't always the case. How the current count and reload value are used and what they contain depends on which mode the PIT channel is configured to use.
</p><p>The Mode/Command register at I/O address 0x43 contains the following:
</p>
<pre>Bits         Usage
6 and 7      Select channel&#160;:
                0 0 = Channel 0
                0 1 = Channel 1
                1 0 = Channel 2
                1 1 = Read-back command (8254 only)
4 and 5      Access mode&#160;:
                0 0 = Latch count value command
                0 1 = Access mode: lobyte only
                1 0 = Access mode: hibyte only
                1 1 = Access mode: lobyte/hibyte
1 to 3       Operating mode&#160;:
                0 0 0 = Mode 0 (interrupt on terminal count)
                0 0 1 = Mode 1 (hardware re-triggerable one-shot)
                0 1 0 = Mode 2 (rate generator)
                0 1 1 = Mode 3 (square wave generator)
                1 0 0 = Mode 4 (software triggered strobe)
                1 0 1 = Mode 5 (hardware triggered strobe)
                1 1 0 = Mode 2 (rate generator, same as 010b)
                1 1 1 = Mode 3 (square wave generator, same as 011b)
0            BCD/Binary mode: 0 = 16-bit binary, 1 = four-digit BCD
</pre>
<p>The "Select Channel" bits select which channel is being configured, and must always be valid on every write of the mode/command register, regardless of the other bits or the type of operation being performed. The "read back" (both bits set) is not supported on the old 8253 chips but should be supported on all AT and later computers except for PS/2 (i.e. anything that isn't obsolete will support it). The "read back" command is discussed later.
</p><p>The "Access Mode" bits tell the PIT what access mode you wish to use for the selected channel, and also specify <a href="Programmable_Interval_Timer#Counter_Latch_Command">the "counter latch" command</a> to the CTC. These bits must be valid on every write to the mode/command register. For <a href="Programmable_Interval_Timer#Read_Back_Command">the "read back" command</a>, these bits have a different meaning. For the remaining combinations, these bits specify what order data will be read and written to the data port for the associated PIT channel. Because the data port is an 8 bit I/O port and the values involved are all 16 bit, the PIT chip needs to know what byte each read or write to the data port wants. For "lobyte only", only the lowest 8 bits of the counter value is read or written to/from the data port. For "hibyte only", only the highest 8 bits of the counter value is read or written. For the "lobyte/hibyte" mode, 16 bits are always transferred as a pair, with the lowest 8 bits followed by the highest 8 bits (both 8 bit transfers are to the <b>same</b> IO port, sequentially – a word transfer will not work).
</p><p>The "Operating Mode" bits specify which mode the selected PIT channel should operate in. For the "read back" command and the "counter latch" command, these bits have different meanings (see the information corresponding to these commands below). There are 6 different <a href="Programmable_Interval_Timer#Operating_Modes">operating modes</a>. Each operating mode will be discussed separately later.
</p><p>The "BCD/Binary" bit determines if the PIT channel will operate in binary mode or BCD mode (where each 4 bits of the counter represent a decimal digit, and the counter holds values from 0000 to 9999). 80x86 PCs only use binary mode (BCD mode is ugly and limits the range of counts/frequencies possible). Although it should still be possible to use BCD mode, it may not work properly on some "compatible" chips. For the "read back" command and the "counter latch" command, this bit has different meanings (see the information corresponding to these commands below).
</p>
<h2><span class="mw-headline" id="Operating_Modes">Operating Modes</span></h2>
<p>While each operating mode behaves differently, some things are common to all operating modes. This includes:
</p>
<dl><dt><b>Initial Output State</b></dt>
<dd>Every time the mode/command register is written to, all internal logic in the selected PIT channel is reset, and the output immediately goes to its initial state (which depends on the mode).</dd>
<dt><b>Changing Reload Value</b></dt>
<dd>A new reload value can be written to a PIT channel's data port at any time. The operating mode determines the exact effect that this will have.</dd>
<dt><b>Current Counter</b></dt>
<dd>The current counter value is always either decremented or reset to the reload value on the <i>falling</i> edge of the (1.193182 MHz) input signal.</dd>
<dt><b>Current Counter Reload</b></dt>
<dd>In modes where the current count is decremented when it is reloaded, the current count is not decremented on the same input clock pulse as the reload – it starts decrementing on the <i>next</i> input clock pulse.</dd></dl>
<h3><span id="Mode_0_.E2.80.93_Interrupt_On_Terminal_Count"></span><span class="mw-headline" id="Mode_0_–_Interrupt_On_Terminal_Count">Mode 0 – Interrupt On Terminal Count</span></h3>
<p>For this mode, when the mode/command register is written the output signal goes low and the PIT waits for the reload register to be set by software, to begin the countdown. After the reload register has been set, the current count will be set to the reload value on the next falling edge of the (1.193182 MHz) input signal. Subsequent falling edges of the input signal will decrement the current count (if the gate input is high on the preceding rising edge of the input signal).
</p><p>When the current count decrements from one to zero, the output goes high and remains high until another mode/command register is written or the reload register is set again. The current count will wrap around to 0xFFFF (or 0x9999 in BCD mode) and continue to decrement until the mode/command register or the reload register are set, however this will not affect the output pin state.
</p><p>The reload value can be changed at any time. In "lobyte/hibyte" access mode counting will stop when the first byte of the reload value is set. Once the full reload value is set (in any access mode), the next falling edge of the (1.193182 MHz) input signal will cause the new reload value to be copied into the current count, and the countdown will continue from the new value.
</p><p>Note: despite the misleading name of this mode, it only generates interrupts on channel 0.
</p>
<h3><span id="Mode_1_.E2.80.93_Hardware_Re-triggerable_One-shot"></span><span class="mw-headline" id="Mode_1_–_Hardware_Re-triggerable_One-shot">Mode 1 – Hardware Re-triggerable One-shot</span></h3>
<p>This mode is similar to mode 0 above, however counting doesn't start until a rising edge of the gate input is detected. For this reason it is not usable for PIT channels 0 or 1 (where the gate input can't be changed).
</p><p>When the mode/command register is written the output signal goes high and the PIT waits for the reload register to be set by software. After the reload register has been set the PIT will wait for the next rising edge of the gate input. Once this occurs, the output signal will go low and the current count will be set to the reload value on the next falling edge of the (1.193182 MHz) input signal. Subsequent falling edges of the input signal will decrement the current count.
</p><p>When the current count decrements from one to zero, the output goes high and remains high until another mode/command register is written or the reload register is set again. The current count will wrap around to 0xFFFF (or 0x9999 in BCD mode) and continue to decrement until the mode/command register or the reload register are set, however this will not affect the output pin state.
</p><p>If the gate input signal goes low during this process it will have no effect. However, if the gate input goes high again it will cause the current count to be reloaded from the reload register on the next falling edge of the input signal, and restart the count again (the same as when counting first started).
</p><p>The reload value can be changed at any time, however the new value will not affect the current count until the current count is reloaded (on the next rising edge of the gate input). So if you want to do this, clear and then reset bit 0 of IO port 0x61, after modifying the reload value.
</p>
<h3><span id="Mode_2_.E2.80.93_Rate_Generator"></span><span class="mw-headline" id="Mode_2_–_Rate_Generator">Mode 2 – Rate Generator</span></h3>
<p>This mode operates as a frequency divider.
</p><p>When the mode/command register is written the output signal goes high and the PIT waits for the reload register to be set by software. After the reload register has been set, the current count will be set to the reload value on the next falling edge of the (1.193182 MHz) input signal. Subsequent falling edges of the input signal will decrement the current count (if the gate input is high on the preceding rising edge of the input signal).
</p><p>When the current count decrements from two to one, the output goes low, and on the next falling edge of the (1.193182 MHz) input signal it will go high again and the current count will be set to the reload value and counting will continue.
</p><p>If the gate input goes low, counting stops and the output goes high immediately. Once the gate input has returned high, the next falling edge on input signal will cause the current count to be set to the reload value and operation will continue.
</p><p>The reload value can be changed at any time, however the new value will not affect the current count until the current count is reloaded (when it is decreased from two to one, or the gate input going low then high). When this occurs counting will continue using the new reload value.
</p><p>A reload value (or divisor) of one must <i>not</i> be used with this mode.
</p><p>This mode creates a high output signal that drops low for one input signal cycle (0.8381 uS), which is too fast to make a difference to the PC speaker (see mode 3). For this reason mode 2 is useless for producing sounds with PIT channel 2.
</p><p>Typically, OSes and BIOSes use mode 3 (see below) for PIT channel 0 to generate IRQ 0 timer ticks, but some use mode 2 instead, to gain frequency accuracy (frequency = 1193182 / reload_value Hz).
</p>
<h3><span id="Mode_3_.E2.80.93_Square_Wave_Generator"></span><span class="mw-headline" id="Mode_3_–_Square_Wave_Generator">Mode 3 – Square Wave Generator</span></h3>
<p>For mode 3, the PIT channel operates as a frequency divider like mode 2, however the output signal is fed into an internal "flip flop" to produce a square wave (rather than a short pulse). The flip flop changes its output state each time its input state (or the output of the PIT channel's frequency divider) changes. This causes the actual output to change state half as often, so to compensate for this the current count is decremented twice on each falling edge of the input signal (instead of once), and the current count is set to the reload value twice as often.
</p><p>When the mode/command register is written the output signal goes high and the PIT waits for the reload register to be set by software. After the reload register has been set, the current count will be set to the reload value on the next falling edge of the (1.193182 MHz) input signal. Subsequent falling edges of the input signal will decrement the current count twice (if the gate input is high on the preceding rising edge of the input signal).
</p><p>Note: under normal circumstances the output state will be low 50% of the time when the mode/command register is written. The output will then go high, which will generate an immediate (perhaps spurious) IRQ0. The other 50% of the time the output will already be high, and there will be no IRQ0 generated.
</p><p>For even reload values, when the current count decrements from two to zero the output of the flip-flop changes state; the current count will be reset to the reload value and counting will continue.
</p><p>For odd reload values, the current count is always set to one less than the reload value.
If the output of the flip flop is low when the current count decrements from two to zero it will behave the same as the equivalent even reload value. However, if the output of the flip flop is high the reload will be delayed for one input signal cycle (0.8381 uS), which causes the "high" pulse to be slightly longer and the duty cycle will not be exactly 50%. Because the reload value is rounded down to the nearest even number anyway, it is recommended that only even reload values be used (which means you should mask the value before sending it to the port).
</p><p>Note: This even value limitation on the reload value in mode 3 reduces the number of possible output frequencies in half. If you want to be able to control the frequency of IRQ0 to a somewhat higher degree, then think about using mode 2 instead for channel 0.
</p><p>On channel 2, if the gate input goes low, counting stops and the output goes high immediately. Once the gate input has returned high, the next falling edge on input signal will cause the current count to be set to the reload value and operation will continue (with the output left high).
</p><p>The reload value can be changed at any time, however the new value will not affect the current count until the current count is reloaded (when it is decreased from two to zero, or the gate input going low then high). When this occurs counting will continue using the new reload value.
</p><p>A reload value (or divisor) of one must <i>not</i> be used with this mode.
</p>
<h3><span id="Mode_4_.E2.80.93_Software_Triggered_Strobe"></span><span class="mw-headline" id="Mode_4_–_Software_Triggered_Strobe">Mode 4 – Software Triggered Strobe</span></h3>
<p>Mode four operates as a retriggerable delay, and generates a pulse when the current count reaches zero.
</p><p>When the mode/command register is written the output signal goes high and the PIT waits for the reload register to be set by software. After the reload register has been set, the current count will be set to the reload value on the next falling edge of the (1.193182 MHz) input signal. Subsequent falling edges of the input signal will decrement the current count (if the gate input is high on the preceding rising edge of the input signal).
</p><p>When the current count decrements from one to zero, the output goes low for one cycle of the input signal (0.8381 uS). The current count will wrap around to 0xFFFF (or 0x9999 in BCD mode) and continue to decrement until the mode/command register or the reload register are set, however this will not affect the output state.
</p><p>If the gate input goes low, counting stops but the output will not be affected and the current count will not be reset to the reload value.
</p><p>The reload value can be changed at any time. When the new value has been set (both bytes for "lobyte/hibyte" access mode) it will be loaded into the current count on the next falling edge of the (1.193182 MHz) input signal, and counting will continue using the new reload value.
</p>
<h3><span id="Mode_5_.E2.80.93_Hardware_Triggered_Strobe"></span><span class="mw-headline" id="Mode_5_–_Hardware_Triggered_Strobe">Mode 5 – Hardware Triggered Strobe</span></h3>
<p>Mode 5 is similar to mode 4, except that it waits for the rising edge of the gate input to trigger (or re-trigger) the delay period (like mode 1). For this reason it is not usable for PIT channels 0 or 1 (where the gate input can't be changed).
</p><p>When the mode/command register is written the output signal goes high and the PIT waits for the reload register to be set by software. After the reload register has been set the PIT will wait for the next rising edge of the gate input. Once this occurs, the current count will be set to the reload value on the next falling edge of the (1.193182 MHz) input signal. Subsequent falling edges of the input signal will decrement the current count.
</p><p>When the current count decrements from one to zero, the output goes low for one cycle of the input signal (0.8381 uS). The current count will wrap around to 0xFFFF (or 0x9999 in BCD mode) and continue to decrement until the mode/command register or the reload register are set, however this will not affect the output state.
</p><p>If the gate input signal goes low during this process it will have no effect. However, if the gate input goes high again it will cause the current count to be reloaded from the reload register on the next falling edge of the input signal, and restart the count again (the same as when counting first started).
</p><p>The reload value can be changed at any time, however the new value will not affect the current count until the current count is reloaded (on the next rising edge of the gate input). When this occurs counting will continue using the new reload value.
</p>
<h2><span class="mw-headline" id="Counter_Latch_Command">Counter Latch Command</span></h2>
<p>To prevent the current count from being updated, it is possible to "latch" a PIT channel using the latch command. To do this, send the value CC000000 (in binary) to the mode/command register (I/O port 0x43), where 'CC' corresponds to the channel number. When the latch command has been sent, the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
</p><p>The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
</p><p>While the latch command should not affect the current count, on some (old/dodgy) motherboards sending the latch command can cause a cycle of the input signal to be occasionally missed, which would cause the current count to be decremented 0.8381ms later than it should be. If you're sending the latch command often this could cause accuracy problems (but if you need to send the latch command often you may wish to consider redesigning your code anyway).
</p>
<h2><span class="mw-headline" id="Read_Back_Command">Read Back Command</span></h2>
<p>The read back command is a special command sent to the mode/command register (I/O port 0x43). The "read back" is not supported on the old 8253 chips but should be supported on all AT and later computers except for PS/2 (i.e. anything that isn't obsolete will support it).
</p><p>For the read back command, the mode/command register uses the following format:
</p>
<pre>Bits         Usage
7 and 6      Must be set for the read back command
5            Latch count flag (0 = latch count, 1 = don't latch count)
4            Latch status flag (0 = latch status, 1 = don't latch status)
3            Read back timer channel 2 (1 = yes, 0 = no)
2            Read back timer channel 1 (1 = yes, 0 = no)
1            Read back timer channel 0 (1 = yes, 0 = no)
0            Reserved (should be clear)
</pre>
<p>Note: Be careful with bits 4 and 5 – they are inverted.
</p><p>Bits 1 to 3 of the read back command select which PIT channels are affected, and allow multiple channels to be selected at the same time.
</p><p>If bit 5 is clear, then any/all PIT channels selected with bits 1 to 3 will have their current count copied into their latch register (similar to sending the latch command, except it works for multiple channels with one command).
</p><p>If bit 4 is clear, then for any/all PIT channels selected with bits 1 to 3, the next read of the corresponding data port will return a status byte (discussed below).
</p>
<h3><span class="mw-headline" id="Read_Back_Status_Byte">Read Back Status Byte</span></h3>
<p>After sending a read back command with bit 4 clear, reading the data port for each selected channel will return a status value with the following format:
</p>
<pre>Bit/s        Usage
7            Output pin state
6            Null count flags
4 and 5      Access mode&#160;:
                0 0 = Latch count value command
                0 1 = Access mode: lobyte only
                1 0 = Access mode: hibyte only
                1 1 = Access mode: lobyte/hibyte
1 to 3       Operating mode&#160;:
                0 0 0 = Mode 0 (interrupt on terminal count)
                0 0 1 = Mode 1 (hardware re-triggerable one-shot)
                0 1 0 = Mode 2 (rate generator)
                0 1 1 = Mode 3 (square wave generator)
                1 0 0 = Mode 4 (software triggered strobe)
                1 0 1 = Mode 5 (hardware triggered strobe)
                1 1 0 = Mode 2 (rate generator, same as 010b)
                1 1 1 = Mode 3 (square wave generator, same as 011b)
0            BCD/Binary mode: 0 = 16-bit binary, 1 = four-digit BCD
</pre>
<p>The bottom six bits return the values that where programmed into the mode/command register when the channel was last initialized.
</p><p>Bit 7 indicates the state of the PIT channel's output pin at the moment that the read-back command was issued.
</p><p>Bit 6 indicates whether a newly-programmed divisor value has been loaded into the current count yet (if clear) or the channel is still waiting for a trigger signal or for the current count to count down to zero before a newly programmed reload value is loaded into the current count (if set). This bit is set when the mode/command register is initialized or when a new reload value is written, and cleared when the reload value is copied into the current count.
</p>
<h2><span class="mw-headline" id="Reading_The_Current_Count">Reading The Current Count</span></h2>
<p>To read the current count using the "lobyte only" or "hibyte only" access modes, you can just do an "in al,0x40" (for PIT channel 0) without problems. For frequencies higher than 4.7 KHz it can be easiest to set the high byte of the reload value to zero, and then use the "lobyte only" access mode to minimize hassles.
</p><p>For the "lobyte/hibyte" access mode you need to send the latch command (described above) to avoid getting wrong results. If any other code could try set the PIT channel's reload value or read its current count after you've sent the latch command but before you've read the highest 8 bits, then you have to prevent it. Disabling interrupts works for single CPU computers. For example, to read the count of PIT channel 0 you could use something like:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">read_pit_count</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Disable interrupts</span>
<span class="w">	</span><span class="n">cli</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// al = channel in bits 6 and 7, remaining bits clear</span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="mh">0x43</span><span class="p">,</span><span class="mb">0b0000000</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="mh">0x40</span><span class="p">);</span><span class="w">		</span><span class="c1">// Low byte</span>
<span class="w">	</span><span class="n">count</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span><span class="w">		</span><span class="c1">// High byte</span>
<span class="w">	</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Setting_The_Reload_Value">Setting The Reload Value</span></h2>
<p>To set the reload value, just send the value/s to the corresponding data port. For the "lobyte only" or "hibyte only" access modes this only takes a single "out 0x40,al" (for PIT channel 0).
</p><p>For the "lobyte/hibyte" access mode you need to send the low 8 bits followed by the high 8 bits. You must prevent other code from setting the PIT channel's reload value or reading its current count once you've sent the lowest 8 bits. Disabling interrupts works for single CPU computers. For example:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">set_pit_count</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Disable interrupts</span>
<span class="w">	</span><span class="n">cli</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Set low byte</span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span><span class="n">count</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">);</span><span class="w">		</span><span class="c1">// Low byte</span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,(</span><span class="n">count</span><span class="o">&amp;</span><span class="mh">0xFF00</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">);</span><span class="w">	</span><span class="c1">// High byte</span>
<span class="w">	</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>It should be noted that a reload value of zero can be used to specify a divisor of 65536. This is how the BIOS gets an IRQ 0 frequency as low as 18.2065 Hz.
</p>
<h2><span class="mw-headline" id="PIT_Channel_0_Example_Code">PIT Channel 0 Example Code</span></h2>
<p>The following example code was written for NASM, but hasn't been tested.
</p><p>The idea is to provide a single routine to initialize PIT channel 0 for any (possible) frequency and use IRQ 0 to accurately keep track of real time in milliseconds since the PIT was configured.
</p><p>For the sake of accuracy, the initialization code will calculate the number of whole milliseconds to add to the "system timer tick" each IRQ, and the number of "fractions of a millisecond" to avoid drift. This may be important, for example if the PIT is set for 700 Hz it'd work out to (roughly) 1.42857 ms between IRQs, so keeping track of whole milliseconds only would lead to huge inaccuracies.
</p><p>Hopefully, everyone is familiar with fixed point mathematics. For example, with the "32.32" notation I'll be using, if the high 32-bit value is equal to 0x00000001 and the low 32-bit value is equal to 0x80000000 then the combined value would be 1.5. In a similar way, the fraction 0.75 is represented with 0xC000000, 0.125 is represented with 0x20000000 and 0.12345 would be represented with 0x1F9A6B50.
</p><p>To begin with, this following code contains all of the data used by this example. It is assumed that the ".bss" section is filled with zeros.
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">section</span><span class="w"> </span><span class="no">.bss</span><span class="w"></span>
<span class="nl">system_timer_fractions:</span><span class="w">  </span><span class="nf">resd</span><span class="w"> </span><span class="mi">1</span><span class="w">          </span><span class="c1">; Fractions of 1 ms since timer initialized</span>
<span class="nl">system_timer_ms:</span><span class="w">         </span><span class="nf">resd</span><span class="w"> </span><span class="mi">1</span><span class="w">          </span><span class="c1">; Number of whole ms since timer initialized</span>
<span class="nl">IRQ0_fractions:</span><span class="w">          </span><span class="nf">resd</span><span class="w"> </span><span class="mi">1</span><span class="w">          </span><span class="c1">; Fractions of 1 ms between IRQs</span>
<span class="nl">IRQ0_ms:</span><span class="w">                 </span><span class="nf">resd</span><span class="w"> </span><span class="mi">1</span><span class="w">          </span><span class="c1">; Number of whole ms between IRQs</span>
<span class="nl">IRQ0_frequency:</span><span class="w">          </span><span class="nf">resd</span><span class="w"> </span><span class="mi">1</span><span class="w">          </span><span class="c1">; Actual frequency of PIT</span>
<span class="nl">PIT_reload_value:</span><span class="w">        </span><span class="nf">resw</span><span class="w"> </span><span class="mi">1</span><span class="w">          </span><span class="c1">; Current PIT reload value</span>
<span class="nf">section</span><span class="w"> </span><span class="no">.text</span><span class="w"></span>
</pre></div>
<p>Next is the handler for IRQ 0. It's fairly simple (all it does it add 2 64 bit fixed point values and send an EOI to the PIC chip).
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="nl">IRQ0_handler:</span><span class="w"></span>
<span class="w">	</span><span class="nf">push</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
<span class="w">	</span><span class="nf">push</span><span class="w"> </span><span class="no">ebx</span><span class="w"></span>
<span class="w"> </span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">IRQ0_fractions</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">IRQ0_ms</span><span class="p">]</span><span class="w">                    </span><span class="c1">; eax.ebx = amount of time between IRQs</span>
<span class="w">	</span><span class="nf">add</span><span class="w"> </span><span class="p">[</span><span class="no">system_timer_fractions</span><span class="p">],</span><span class="w"> </span><span class="no">eax</span><span class="w">     </span><span class="c1">; Update system timer tick fractions</span>
<span class="w">	</span><span class="nf">adc</span><span class="w"> </span><span class="p">[</span><span class="no">system_timer_ms</span><span class="p">],</span><span class="w"> </span><span class="no">ebx</span><span class="w">            </span><span class="c1">; Update system timer tick milli-seconds</span>
<span class="w"> </span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">al</span><span class="p">,</span><span class="w"> </span><span class="mi">0x20</span><span class="w"></span>
<span class="w">	</span><span class="nf">out</span><span class="w"> </span><span class="mi">0x20</span><span class="p">,</span><span class="w"> </span><span class="no">al</span><span class="w">                          </span><span class="c1">; Send the EOI to the PIC</span>

<span class="w">	</span><span class="nf">pop</span><span class="w"> </span><span class="no">ebx</span><span class="w"></span>
<span class="w">	</span><span class="nf">pop</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
<span class="w">	</span><span class="nf">iretd</span><span class="w"></span>
</pre></div>
<p>Now for the tricky bit – the initialization routine. The PIT can't generate some frequencies. For example if you want 8000 Hz then you've got a choice of 8007.93 Hz or 7954.544 Hz. In this case the following code will find the nearest possible frequency. Once it has calculated the nearest possible frequency it will reverse the calculation to find the actual frequency selected (rounded to the nearest integer, intended for display purposes only).
</p><p>For some extra accuracy, I also use "3579545 / 3" instead of 1193182 Hz. This is mostly pointless due to inaccurate hardware (I just like being correct).
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="w"> </span><span class="c1">;Input</span>
<span class="w"> </span><span class="c1">; ebx   Desired PIT frequency in Hz</span>
<span class="w"> </span>
<span class="w"> </span><span class="nl">init_PIT:</span><span class="w"></span>
<span class="w">    </span><span class="nf">pushad</span><span class="w"></span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">; Do some checking</span>
<span class="w"> </span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="mi">0x10000</span><span class="w">                   </span><span class="c1">;eax = reload value for slowest possible frequency (65536)</span>
<span class="w">    </span><span class="nf">cmp</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="mi">18</span><span class="w">                        </span><span class="c1">;Is the requested frequency too low?</span>
<span class="w">    </span><span class="nf">jbe</span><span class="w"> </span><span class="no">.gotReloadValue</span><span class="w">               </span><span class="c1">; yes, use slowest possible frequency</span>
<span class="w"> </span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="mi">1</span><span class="w">                         </span><span class="c1">;ax = reload value for fastest possible frequency (1)</span>
<span class="w">    </span><span class="nf">cmp</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="mi">1193181</span><span class="w">                   </span><span class="c1">;Is the requested frequency too high?</span>
<span class="w">    </span><span class="nf">jae</span><span class="w"> </span><span class="no">.gotReloadValue</span><span class="w">               </span><span class="c1">; yes, use fastest possible frequency</span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">; Calculate the reload value</span>
<span class="w"> </span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="mi">3579545</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="mi">0</span><span class="w">                         </span><span class="c1">;edx:eax = 3579545</span>
<span class="w">    </span><span class="nf">div</span><span class="w"> </span><span class="no">ebx</span><span class="w">                           </span><span class="c1">;eax = 3579545 / frequency, edx = remainder</span>
<span class="w">    </span><span class="nf">cmp</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="mi">3579545</span><span class="w"> </span><span class="err">/</span><span class="w"> </span><span class="mi">2</span><span class="w">               </span><span class="c1">;Is the remainder more than half?</span>
<span class="w">    </span><span class="nf">jb</span><span class="w"> </span><span class="no">.l1</span><span class="w">                            </span><span class="c1">; no, round down</span>
<span class="w">    </span><span class="nf">inc</span><span class="w"> </span><span class="no">eax</span><span class="w">                           </span><span class="c1">; yes, round up</span>
<span class="w"> </span><span class="nl">.l1:</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="mi">3</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="mi">0</span><span class="w">                         </span><span class="c1">;edx:eax = 3579545 * 256 / frequency</span>
<span class="w">    </span><span class="nf">div</span><span class="w"> </span><span class="no">ebx</span><span class="w">                           </span><span class="c1">;eax = (3579545 * 256 / 3 * 256) / frequency</span>
<span class="w">    </span><span class="nf">cmp</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="mi">3</span><span class="w"> </span><span class="err">/</span><span class="w"> </span><span class="mi">2</span><span class="w">                     </span><span class="c1">;Is the remainder more than half?</span>
<span class="w">    </span><span class="nf">jb</span><span class="w"> </span><span class="no">.l2</span><span class="w">                            </span><span class="c1">; no, round down</span>
<span class="w">    </span><span class="nf">inc</span><span class="w"> </span><span class="no">eax</span><span class="w">                           </span><span class="c1">; yes, round up</span>
<span class="w"> </span><span class="nl">.l2:</span><span class="w"></span>
<span class="w"> </span>
<span class="w"> </span>
<span class="w"> </span><span class="c1">; Store the reload value and calculate the actual frequency</span>
<span class="w"> </span>
<span class="w"> </span><span class="nl">.gotReloadValue:</span><span class="w"></span>
<span class="w">    </span><span class="nf">push</span><span class="w"> </span><span class="no">eax</span><span class="w">                          </span><span class="c1">;Store reload_value for later</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="p">[</span><span class="no">PIT_reload_value</span><span class="p">],</span><span class="no">ax</span><span class="w">         </span><span class="c1">;Store the reload value for later</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="no">eax</span><span class="w">                       </span><span class="c1">;ebx = reload value</span>
<span class="w"> </span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="mi">3579545</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="mi">0</span><span class="w">                         </span><span class="c1">;edx:eax = 3579545</span>
<span class="w">    </span><span class="nf">div</span><span class="w"> </span><span class="no">ebx</span><span class="w">                           </span><span class="c1">;eax = 3579545 / reload_value, edx = remainder</span>
<span class="w">    </span><span class="nf">cmp</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="mi">3579545</span><span class="w"> </span><span class="err">/</span><span class="w"> </span><span class="mi">2</span><span class="w">               </span><span class="c1">;Is the remainder more than half?</span>
<span class="w">    </span><span class="nf">jb</span><span class="w"> </span><span class="no">.l3</span><span class="w">                            </span><span class="c1">; no, round down</span>
<span class="w">    </span><span class="nf">inc</span><span class="w"> </span><span class="no">eax</span><span class="w">                           </span><span class="c1">; yes, round up</span>
<span class="w"> </span><span class="nl">.l3:</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="mi">3</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="mi">0</span><span class="w">                         </span><span class="c1">;edx:eax = 3579545 / reload_value</span>
<span class="w">    </span><span class="nf">div</span><span class="w"> </span><span class="no">ebx</span><span class="w">                           </span><span class="c1">;eax = (3579545 / 3) / frequency</span>
<span class="w">    </span><span class="nf">cmp</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="mi">3</span><span class="w"> </span><span class="err">/</span><span class="w"> </span><span class="mi">2</span><span class="w">                     </span><span class="c1">;Is the remainder more than half?</span>
<span class="w">    </span><span class="nf">jb</span><span class="w"> </span><span class="no">.l4</span><span class="w">                            </span><span class="c1">; no, round down</span>
<span class="w">    </span><span class="nf">inc</span><span class="w"> </span><span class="no">eax</span><span class="w">                           </span><span class="c1">; yes, round up</span>
<span class="w"> </span><span class="nl">.l4:</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="p">[</span><span class="no">IRQ0_frequency</span><span class="p">],</span><span class="no">eax</span><span class="w">          </span><span class="c1">;Store the actual frequency for displaying later</span>
<span class="w"> </span>
<span class="w"> </span>
<span class="w"> </span><span class="c1">; Calculate the amount of time between IRQs in 32.32 fixed point</span>
<span class="w"> </span><span class="c1">;</span>
<span class="w"> </span><span class="c1">; Note: The basic formula is:</span>
<span class="w"> </span><span class="c1">;           time in ms = reload_value / (3579545 / 3) * 1000</span>
<span class="w"> </span><span class="c1">;       This can be rearranged in the following way:</span>
<span class="w"> </span><span class="c1">;           time in ms = reload_value * 3000 / 3579545</span>
<span class="w"> </span><span class="c1">;           time in ms = reload_value * 3000 / 3579545 * (2^42)/(2^42)</span>
<span class="w"> </span><span class="c1">;           time in ms = reload_value * 3000 * (2^42) / 3579545 / (2^42)</span>
<span class="w"> </span><span class="c1">;           time in ms * 2^32 = reload_value * 3000 * (2^42) / 3579545 / (2^42) * (2^32)</span>
<span class="w"> </span><span class="c1">;           time in ms * 2^32 = reload_value * 3000 * (2^42) / 3579545 / (2^10)</span>
<span class="w"> </span>
<span class="w">    </span><span class="nf">pop</span><span class="w"> </span><span class="no">ebx</span><span class="w">                           </span><span class="c1">;ebx = reload_value</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="mi">0xDBB3A062</span><span class="w">                </span><span class="c1">;eax = 3000 * (2^42) / 3579545</span>
<span class="w">    </span><span class="nf">mul</span><span class="w"> </span><span class="no">ebx</span><span class="w">                           </span><span class="c1">;edx:eax = reload_value * 3000 * (2^42) / 3579545</span>
<span class="w">    </span><span class="nf">shrd</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="no">edx</span><span class="p">,</span><span class="mi">10</span><span class="w"></span>
<span class="w">    </span><span class="nf">shr</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="mi">10</span><span class="w">                        </span><span class="c1">;edx:eax = reload_value * 3000 * (2^42) / 3579545 / (2^10)</span>
<span class="w"> </span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="p">[</span><span class="no">IRQ0_ms</span><span class="p">],</span><span class="no">edx</span><span class="w">                 </span><span class="c1">;Set whole ms between IRQs</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="p">[</span><span class="no">IRQ0_fractions</span><span class="p">],</span><span class="no">eax</span><span class="w">          </span><span class="c1">;Set fractions of 1 ms between IRQs</span>
<span class="w"> </span>
<span class="w"> </span>
<span class="w"> </span><span class="c1">; Program the PIT channel</span>
<span class="w"> </span>
<span class="w">    </span><span class="nf">pushfd</span><span class="w"></span>
<span class="w">    </span><span class="nf">cli</span><span class="w">                               </span><span class="c1">;Disabled interrupts (just in case)</span>
<span class="w"> </span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">al</span><span class="p">,</span><span class="mi">00110100</span><span class="no">b</span><span class="w">                  </span><span class="c1">;channel 0, lobyte/hibyte, rate generator</span>
<span class="w">    </span><span class="nf">out</span><span class="w"> </span><span class="mi">0x43</span><span class="p">,</span><span class="w"> </span><span class="no">al</span><span class="w"></span>
<span class="w"> </span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,[</span><span class="no">PIT_reload_value</span><span class="p">]</span><span class="w">         </span><span class="c1">;ax = 16 bit reload value</span>
<span class="w">    </span><span class="nf">out</span><span class="w"> </span><span class="mi">0x40</span><span class="p">,</span><span class="no">al</span><span class="w">                       </span><span class="c1">;Set low byte of PIT reload value</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">al</span><span class="p">,</span><span class="no">ah</span><span class="w">                         </span><span class="c1">;ax = high 8 bits of reload value</span>
<span class="w">    </span><span class="nf">out</span><span class="w"> </span><span class="mi">0x40</span><span class="p">,</span><span class="no">al</span><span class="w">                       </span><span class="c1">;Set high byte of PIT reload value</span>
<span class="w"> </span>
<span class="w">    </span><span class="nf">popfd</span><span class="w"></span>
<span class="w"> </span>
<span class="w">    </span><span class="nf">popad</span><span class="w"></span>
<span class="w">    </span><span class="nf">ret</span><span class="w"></span>
</pre></div>
<p>Note: you also need to install an IDT entry for IRQ 0, and unmask it in the PIC chip (or I/O APIC).
</p><p>Of course it's easier to configure the PIT to a fixed value, but where's the fun in that?&#160;:-)
</p>
<h2><span class="mw-headline" id="Uses_for_the_Timer_IRQ">Uses for the Timer IRQ</span></h2>
<h3><span class="mw-headline" id="Using_the_IRQ_to_Implement_sleep">Using the IRQ to Implement <tt>sleep</tt></span></h3>
<p>The PIT's generating a hardware interrupt every <i>n</i> milliseconds allows you to create a simple timer. Start with a global variable that contains the delay:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">CountDown</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Next, every time the timer interrupt is called, decrement this variable until 0 is stored.
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="w"> </span><span class="nf">section</span><span class="w"> </span><span class="no">.text</span><span class="w"></span>
<span class="w"> </span><span class="nf">global</span><span class="w"> </span><span class="no">TimerIRQ</span><span class="w"></span>
<span class="w"> </span><span class="nl">TimerIRQ:</span><span class="w"></span>
<span class="w">     </span><span class="nf">push</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
<span class="w">     </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">CountDown</span><span class="p">]</span><span class="w"></span>
<span class="w">     </span><span class="nf">test</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
<span class="w">     </span><span class="nf">jz</span><span class="w"> </span><span class="no">TimerDone</span><span class="w"></span>
<span class="w">     </span><span class="nf">dec</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
<span class="w">     </span><span class="nf">mov</span><span class="w"> </span><span class="p">[</span><span class="no">CountDown</span><span class="p">],</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
<span class="w"> </span><span class="nl">TimerDone:</span><span class="w"></span>
<span class="w">     </span><span class="nf">pop</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
<span class="w">     </span><span class="nf">iretd</span><span class="w"></span>
</pre></div>
<p>Finally, create a function <tt>sleep</tt> that waits the interval, in milliseconds.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">sleep</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">millis</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CountDown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">millis</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">CountDown</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">halt</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>In a multitasking system, consider using a linked list or array of these CountDown variables. If your multitasking system supports interprocess communication, you can also store the semaphore/exchange where two processes can talk to, have the interrupt send a message to the waiting process when the timer is done, and have the waiting process block all execution until that message comes:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define COUNTDOWN_DONE_MSG 1</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">TimerBlock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">EXCHANGE</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">CountDown</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">timerblocks</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">TimerIRQ</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="cm">/* called from Assembly */</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timerblocks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">CountDown</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">timerblocks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">CountDown</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timerblocks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">CountDown</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">SendMessage</span><span class="p">(</span><span class="n">timerblocks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">COUNTDOWN_DONE_MESSAGE</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Sleep</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">delay</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">TimerBlock</span><span class="w"> </span><span class="o">*</span><span class="n">t</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">findTimerBlock</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">CountDown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delay</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">WaitForMessageFrom</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCrntExch</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>In your documentation, note the interval of the timer. For example, if the timer interval is 10 milliseconds per tick, tell the programmer to issue
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">Sleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>to sleep for a single second.
</p>
<h3><span class="mw-headline" id="Using_the_IRQ_for_Preemptive_Multitasking">Using the IRQ for Preemptive Multitasking</span></h3>
<p>The timer IRQ can also be used to perform preemptive multitasking. To give the currently running task some time to run, set a threshold, for example of 3 ticks. Use a global variable like the one before but go up from 0, and when that variable hits 3, switch tasks. How you do so is up to you.
</p>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="Time_And_Date" title="Time And Date">Time And Date</a></li>
<li><a href="RTC" title="RTC">RTC</a></li></ul>
<h3><span class="mw-headline" id="Threads">Threads</span></h3>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a href="https://wikipedia.org/wiki/Programmable_Interval_Timer" class="extiw" title="wikipedia:Programmable Interval Timer"> Programmable Interval Timer</a> on Wikipedia</li>
<li><a rel="nofollow" class="external text" href="http://www.osdever.net/bkerndev/Docs/pit.htm">The PIT: A System Clock</a> on osdever</li></ul>
<!-- 
NewPP limit report
Cached time: 20250211122419
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.075 seconds
Real time usage: 1.392 seconds
Preprocessor visited node count: 141/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 31535/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1560-0!canonical and timestamp 20250211122418 and revision id 29325.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Programmable_Interval_Timer&amp;oldid=29325">https://wiki.osdev.org/index.php?title=Programmable_Interval_Timer&amp;oldid=29325</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Common_Devices" title="Category:Common Devices">Common Devices</a></li><li><a href="./Category:Timers" title="Category:Timers">Timers</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Programmable+Interval+Timer" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="Programmable_Interval_Timer#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Programmable_Interval_Timer" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:Programmable_Interval_Timer" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Programmable_Interval_Timer"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Programmable_Interval_Timer&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Programmable_Interval_Timer&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Programmable_Interval_Timer" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="./Special:RecentChangesLinked/Programmable_Interval_Timer" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Programmable_Interval_Timer&amp;oldid=29325" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Programmable_Interval_Timer&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/Programmable_Interval_Timer" title="Programmable Interval Timer – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 15 December 2024, at 08:25.</li>
	<li id="footer-info-0">This page has been accessed 23,935 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Programmable_Interval_Timer&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.075","walltime":"1.392","ppvisitednodes":{"value":141,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":31535,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20250211122419","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":1499});});</script>
</body>
</html>