<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>ARM Overview - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"20d21a0ccbda62f18c7da6ce","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"ARM_Overview","wgTitle":"ARM Overview","wgCurRevisionId":28710,"wgRevisionId":28710,"wgArticleId":2332,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["ARM","Instruction Set Architecture"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"ARM_Overview","wgRelevantArticleId":2332,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{"search":
false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-ARM_Overview rootpage-ARM_Overview skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">ARM Overview</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="ARM_Overview#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="ARM_Overview#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>ARM is a family of instruction set architectures based on RISC architecture developed by a single company - ARM Holdings. 
</p><p>Because ARM is a family of architectures and not a single architecture, it can be found in large scale of electronic devices (from simple small embedded systems with ARM MCUs, through smartphones, tablets and MP3 players to low-power servers).
When you look at a device with ARM processing unit (term processing unit is more accurate because ARM can be found in microcontrollers as well as in microprocessors), there are two things that matter: architecture and core. 
</p><p>So far (Q3 2014) there have been 8 ARM architectures released or announced (where some of them have their extended versions), 7 of them being 32-bit, and the last one being 64-bit, but user-space compatibile with 32-bit instruction set (therefore making it possible to run 32-bit user processes, yet not 32-bit operating systems without virtualization). Very broadly said, with every new architecture version there have been added some new features to all cores (with exceptions) which had been already tried in some cores of a previous architecture. Not all features of previous architecture must be again available in the next one, and not all new versions of technologies added in previous architectures must be compatibile with the old ones. The simplest reason for this one could think of is that designing processors isn't like writing software: when a program decides whether to process old file format or a new one, it makes its decision and then exectues only one code, but  backward compatibility of (for example instruction) formats may mean more transistors and more transistors usually (always?) result in more heat. 
</p><p>You must know you can't buy an ARM processor just like you would buy Intel abc or AMD xyz. ARM Holdings is a company that designs architecture, writes an <b>Architecture Reference Manual</b>, then designs a core and writes a <b>Technical Reference Manual</b>. Finally, it sells designed core to a chip-making-company and releases manuals to public. From there, a chip-making-company designs a processing unit - a microcontroller (MCU), a System On a Chip (SoC), an FPGA, whatever - and it may manufacture the silicon itself or order n-thousands of chips from a semiconductor manufacturer. 
All of processors you'll see in tablets or smartphones are SoCs which act as sort of motherboard with a processor. They contain logic for driving peripherals (ethernet, USB, SD/MMC cards, SPI, I2C, audio), they may contain GPU for graphics coprocessing or FPGA for custom logic.
</p><p>Many uses means either few multifunctional (and theferefore complex and power-consuming) devices, or many simple devices suited just for that kind of operation. ARM processors as RISC devices chose simplicity over complexity, and therefore they are way too many cores with different instructions used. To have just <i>one assembler to rule them all</i>, ARM defined Unified Assembly Language which can be translated for <b>any</b> of ARM cores.
</p><p>ARM cores are divided in lastest versions to three main lines:
</p>
<ul><li>Cortex-M cores, used for really small devices, usually with on-chip memory and simpler operations</li>
<li>Cortex-R cores, used for real-time devices</li>
<li>Cortex-A cores, used for applications in multifunctional devices like smartphones, TVs or maybe computers.</li></ul>
<p>Apple machines use custom ARM cores, and so do some Nvidia boards.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="ARM_Overview#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="ARM_Overview#Exceptions,_IRQs_and_Software_Interrupts_on_ARMv4_and_up"><span class="tocnumber">2</span> <span class="toctext">Exceptions, IRQs and Software Interrupts on ARMv4 and up</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="ARM_Overview#Note_regarding_the_&#39;Spectre&#39;_exploit"><span class="tocnumber">2.1</span> <span class="toctext">Note regarding the 'Spectre' exploit</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="ARM_Overview#Registers"><span class="tocnumber">3</span> <span class="toctext">Registers</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="ARM_Overview#Calling_Convention_Cheat_Sheets"><span class="tocnumber">3.1</span> <span class="toctext">Calling Convention Cheat Sheets</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="ARM_Overview#Instructions"><span class="tocnumber">4</span> <span class="toctext">Instructions</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="ARM_Overview#Memory"><span class="tocnumber">5</span> <span class="toctext">Memory</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="ARM_Overview#Paging"><span class="tocnumber">5.1</span> <span class="toctext">Paging</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="ARM_Overview#Memory_Detection"><span class="tocnumber">5.2</span> <span class="toctext">Memory Detection</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="ARM_Overview#Exceptions"><span class="tocnumber">6</span> <span class="toctext">Exceptions</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="ARM_Overview#Coding_Gotchas"><span class="tocnumber">7</span> <span class="toctext">Coding Gotchas</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="ARM_Overview#Heap_Pointers_Needs_To_Be_Aligned"><span class="tocnumber">7.1</span> <span class="toctext">Heap Pointers Needs To Be Aligned</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="ARM_Overview#Missing_Division_Functions_(_aeabi_uidivmod,_aeabi_idiv)/No_Division_Support"><span class="tocnumber">7.2</span> <span class="toctext">Missing Division Functions (__aeabi_uidivmod, __aeabi_idiv)/No Division Support</span></a>
<ul>
<li class="toclevel-3 tocsection-14"><a href="ARM_Overview#This_section_is_just_if_you_want_a_more_in_depth_explanation_and_discussion."><span class="tocnumber">7.2.1</span> <span class="toctext">This section is just if you want a more in depth explanation and discussion.</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-15"><a href="ARM_Overview#Unaligned_Memory_Access_And_Byte_Order"><span class="tocnumber">7.3</span> <span class="toctext">Unaligned Memory Access And Byte Order</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="ARM_Overview#Branch_Instruction_In_Vector_Table"><span class="tocnumber">7.4</span> <span class="toctext">Branch Instruction In Vector Table</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="ARM_Overview#Specifying_CPSR_using_AS_(Binutils/GCC)_Syntax"><span class="tocnumber">7.5</span> <span class="toctext">Specifying CPSR using AS (Binutils/GCC) Syntax</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="ARM_Overview#GCC_(Chars_Not_Signed)"><span class="tocnumber">7.6</span> <span class="toctext">GCC (Chars Not Signed)</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="ARM_Overview#Emulators"><span class="tocnumber">8</span> <span class="toctext">Emulators</span></a></li>
<li class="toclevel-1 tocsection-20"><a href="ARM_Overview#Targeting_Multiple_ARM_Based_Devices"><span class="tocnumber">9</span> <span class="toctext">Targeting Multiple ARM Based Devices</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="ARM_Overview#Tutorials_And_Starting_Points"><span class="tocnumber">10</span> <span class="toctext">Tutorials And Starting Points</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="ARM_Overview#Highly_Useful_External_Resources"><span class="tocnumber">11</span> <span class="toctext">Highly Useful External Resources</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Overview">Overview</span></h2>
<p>ARM processors operate in various modes. User, Fast Interrupt, Interrupt, Supervisor, Abort, and System. Each mode has its own stack and environment that it lives in.
</p><p>While the ARM manuals distinguish between these modes, the demarcation is made not in their associated privilege levels, but their purposes. There are essentially two privilege levels in ARM: the manuals refer to them as either 'Privileged modes' or 'Non-privileged modes'.
</p><p>Of the modes listed above, 'User' is the only non-privileged mode, while the others are collectively the privileged modes for the architecture.
</p><p>Why are there so many modes? And what's the difference between the 'Interrupt' mode and the 'Fast Interrupt' mode? Will I have to write a special sort of abstraction which splits my kernel's interrupt handling away from the rest of its operation? No.
</p><p>These modes are simply the state the processor is left in when a particular type of exception occurs, or a particular type of IRQ.
</p><p>As copied from the ARM7TDI datasheet (3.6 Operating Modes):
</p>
<table class="wikitable">
<tbody><tr>
<th>Mode
</th>
<th>Description
</th></tr>
<tr>
<td>User (usr)</td>
<td>Normal ARM execution state
</td></tr>
<tr>
<td>FIQ (fiq)</td>
<td>Designed to support data transfer or channel process
</td></tr>
<tr>
<td>IRQ (irq)</td>
<td>Used for general purpose interrupt handling
</td></tr>
<tr>
<td>Supervisor (svc)</td>
<td>Protected mode for the operating system
</td></tr>
<tr>
<td>Abort mode (abt)</td>
<td>Entered after data or instruction prefetch abort
</td></tr>
<tr>
<td>System (sys)</td>
<td>A privileged user mode for the operating system
</td></tr>
<tr>
<td>Undefined (und)</td>
<td>Entered when an undefined instruction is executed
</td></tr></tbody></table>
<h2><span id="Exceptions.2C_IRQs_and_Software_Interrupts_on_ARMv4_and_up"></span><span class="mw-headline" id="Exceptions,_IRQs_and_Software_Interrupts_on_ARMv4_and_up">Exceptions, IRQs and Software Interrupts on ARMv4 and up</span></h2>
<p>The ARMv4+ architectures define seven vectors for the architecture, contrasted with the x86's grand total of 256 vectors. Also, note well that the kernel does not have the choice of which interrupt vector to store the syscall entry to: ARM statically provides a 'SWI' instruction for software interrupts, and no 'INT N' instruction, so syscalls are statically fixed to a particular vector.
</p><p>Now we get to go into the idea of the various privileged modes of the processor: When the SWI instruction is executed, the ARM processor vectors into the kernel provided vector table, and jumps to the hardware fixed vector which is set aside for the SWI instruction. The kernel is expected to install the syscall strapping code on this vector, since there is no other logical choice.
</p><p>However, instead of, like x86, reading which privilege level or privilege settings to apply for a particular vector (I'm referring to the x86's GDT selector which is present in each IDT entry), the idea of modes are employed, such that for an SWI instruction, the ARM CPU will automatically enter the 'Supervisor' mode.
</p><p>Please remember from now that the 'Supervisor' mode is the standard mode which the kernel is expected to operate from. 'System' mode is not switched to on any public vector; It is like, based on the dodgy way the manual refers to it, and the fact that none of the defined interrupts actually switch to 'System' mode, a #SMI (System Management Interrupt, which switched to System Management Mode) on the PC.
</p><p>From 'System' mode, the kernel would process the SWI, then return to userspace.
</p><p>Abort mode switched to by the processor on encountering the equivalent of a Page fault on x86. The processor switches to privileged mode, but the specific mode 'Abort', one of those listed above. Most ARM kernels just take note of the fact that the processor was in Abort mode on kernel enter, then switch to 'Supervisor' mode and service the exception.
</p><p>Interrupt Mode and Fast Interrupt Mode are almost the same, except that FIQ mode is given its own set of registers (the registers are actually switched from those you refer to, although they still have the same names (r8, for example is still, in your assembly, referred to as r8; however, in FIQ mode, you must be aware that if you had information in r8 in usermode, you should not expect to find that same data under the register named r8 in FIQ mode), so that it can execute IRQ handlers without having to save context too much.
</p><p>Essentially, like x86, you would have a piece of hardware which could be configured by the kernel. The kernel, knowing that it has only 7 vectors, and two of them are designated for IRQs only, would give out the IRQ number of one of the 2 IRQ vectors (IRQ or FIQ vectors). For a device configured to signal an IRQ on the IRQ vector, the processor, on receiving an interrupt signal on the IRQ vector will enter privileged mode, in the IRQ mode state.
</p><p>For an interrupt received on the FIQ vector, the processor would enter privileged mode, but in the FIQ mode state.
</p><p>The 'Undefined' Mode is switched to on the encounter by the CPU of an undefined exception. However, based on the tone used in the ARMv4 manual, and the fact that they blatantly imply this, the exception mode was really meant for the kernel to emulate instructions for the usermode process, and then return.
</p>
<h3><span id="Note_regarding_the_.27Spectre.27_exploit"></span><span class="mw-headline" id="Note_regarding_the_'Spectre'_exploit">Note regarding the 'Spectre' exploit</span></h3>
<p>ARM have recently added a new CPU instruction to their specification that mitigates cache speculation side-channel exploits. You can read more about this design patch and recommended action to take regarding Spectre (<a rel="nofollow" class="external free" href="https://developer.arm.com/-/media/Files/pdf/Cache_Speculation_Side-channels.pdf?revision=8b5a5f33-c686-4b00-8186-187dd2910355">https://developer.arm.com/-/media/Files/pdf/Cache_Speculation_Side-channels.pdf?revision=8b5a5f33-c686-4b00-8186-187dd2910355</a> here).
</p>
<table class="wikitable">
<tbody><tr>
<th>Page
</th>
<th>Description
</th></tr>
<tr>
<td><a rel="nofollow" class="external free" href="https://www.embedded.com/design/prototyping-and-development/4006695/How-to-use-ARM-s-data-abort-exception">http://www.embedded.com/design/prototyping-and-development/4006695/How-to-use-ARM-s-data-abort-exception</a></td>
<td>Good article on the data and instruction ABORT exceptions
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Registers">Registers</span></h2>
<p>ARM processors have a somewhat large number of registers. The ARM7, for example, has 37 registers, 31 of those being 32-bit general registers, and 6 of those being status registers. Some are only usable by certain modes. 
</p><p>Unlike the x86, important operating registers are clearly visible through general use registers. For example, r15 is 'pc', or the 'program counter', and r13 is the 'stack pointer', or 'sp'.
</p><p>Along with the general purpose registers, there is also the CPSR register, or, the 'Current Program Status Register'. This registers keeps track of the current operating mode, whether interrupts are enabled or not, etc. The operating system can read and write to this register using the MSR\MRS instructions. (<a rel="nofollow" class="external text" href="http://www.arm.com/support/faqdev/1472.html">See Here</a>) There are several other system registers which can be used to <a href="Detecting_Raspberry_Pi_Board" title="Detecting Raspberry Pi Board">detect the ARM board</a> for example.
</p>
<table class="wikitable">

<tbody><tr>
<th>Mode
</th>
<th>R0
</th>
<th>R1
</th>
<th>R2
</th>
<th>R3
</th>
<th>R4
</th>
<th>R5
</th>
<th>R6
</th>
<th>R7
</th>
<th>R8
</th>
<th>R9
</th>
<th>R10
</th>
<th>R11
</th>
<th>R12
</th>
<th>R13 (SP)
</th>
<th>R14 (LR)
</th>
<th>R15 (PC)
</th></tr>
<tr>
<th>User32/System
</th>
<td>R0</td>
<td>R1</td>
<td>R2</td>
<td>R3</td>
<td>R4</td>
<td>R5</td>
<td>R6</td>
<td>R7</td>
<td>R8</td>
<td>R9</td>
<td>R10</td>
<td>R11</td>
<td>R12</td>
<td>R13</td>
<td>R14</td>
<td>R15
</td></tr>
<tr>
<th>FIQ32
</th>
<td>R0</td>
<td>R1</td>
<td>R2</td>
<td>R3</td>
<td>R4</td>
<td>R5</td>
<td>R6</td>
<td>R7</td>
<td>R8FIQ</td>
<td>R9FIQ</td>
<td>R10FIQ</td>
<td>R11FIQ</td>
<td>R12FIQ</td>
<td>R13FIQ</td>
<td>R14FIQ</td>
<td>R15FIQ
</td></tr>
<tr>
<th>Supervisor32
</th>
<td>R0</td>
<td>R1</td>
<td>R2</td>
<td>R3</td>
<td>R4</td>
<td>R5</td>
<td>R6</td>
<td>R7</td>
<td>R8</td>
<td>R9</td>
<td>R10</td>
<td>R11</td>
<td>R12</td>
<td>R13SVC</td>
<td>R14SVC</td>
<td>R15SVC
</td></tr>
<tr>
<th>Abort32
</th>
<td>R0</td>
<td>R1</td>
<td>R2</td>
<td>R3</td>
<td>R4</td>
<td>R5</td>
<td>R6</td>
<td>R7</td>
<td>R8</td>
<td>R9</td>
<td>R10</td>
<td>R11</td>
<td>R12</td>
<td>R13ABT</td>
<td>R14ABT</td>
<td>R15ABT
</td></tr>
<tr>
<th>IRQ32
</th>
<td>R0</td>
<td>R1</td>
<td>R2</td>
<td>R3</td>
<td>R4</td>
<td>R5</td>
<td>R6</td>
<td>R7</td>
<td>R8</td>
<td>R9</td>
<td>R10</td>
<td>R11</td>
<td>R12</td>
<td>R13IRQ</td>
<td>R14IRQ</td>
<td>R15IRQ
</td></tr>
<tr>
<th>Undefined32
</th>
<td>R0</td>
<td>R1</td>
<td>R2</td>
<td>R3</td>
<td>R4</td>
<td>R5</td>
<td>R6</td>
<td>R7</td>
<td>R8</td>
<td>R9</td>
<td>R10</td>
<td>R11</td>
<td>R12</td>
<td>R13UNDEF</td>
<td>R14UNDEF</td>
<td>R15UNDEF
</td></tr></tbody></table>
<p>Each mode shares some registers with other modes. Normally registers are specified in ARM instructions they use 4 bits. Which can represent 16 registers. As you can see there are exactly 16 registers which you can reference using instructions in each mode. The mnemonic names are specified
across the top header as R0 through R15. An alias to R13, R14, and R15 is
specified in parenthesis which is SP, LR, and PC. So using the mnemonic R15
is the same as using the mnemonic PC, but keep in mind that this is only relevant to the assembler/compiler. The ARM processor only understands the value given using 4 bits in most instructions. The exactly value represented
using these 4 bits for each mnemonic can be gained by simply removing the prefixed letter R. So that R5 is represented by 4 bits as 0101, R6 as 0110, and R7 as 0111. The denotations that postfix <i>IRQ</i>, <i>UNDEF</i>, <i>ABT</i>, <i>SVC</i>, and <i>FIQ</i> are simply for display, and are relevant only to this table, and aren't considered valid by any assembler/compiler. For example <i>R13ABT</i>, <i>R13IRQ</i>, <i>R13UNDEF</i>, <i>R13SVC</i>, and <i>R13FIQ</i> all simply show that
internally the processor maps R13 (SP) to a different address in it's register file.
</p>
<h3><span class="mw-headline" id="Calling_Convention_Cheat_Sheets">Calling Convention Cheat Sheets</span></h3>
<p>Here is a quick overview of common calling conventions. Note that the calling conventions are usually more complex than represented here (for instance, how is a large struct returned? How about a struct that fits in two registers? How about va_list's?). Look up the specifications if you want to be certain. It may be useful to write a test function and use gcc -S to see how the compiler generates code, which may give a hint of how the calling convention specification should be interpreted.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<tbody><tr>
<th>Return Value
</th>
<th>Parameter Registers
</th>
<th>Additional Parameters
</th>
<th>Stack Alignment
</th>
<th>Scratch Registers
</th>
<th>Preserved Registers
</th>
<th>Return address
</th></tr>
<tr>
<td>R0, R1</td>
<td>R0, R1, R2, R3</td>
<td>stack (R13)</td>
<td>8 byte<sup><a href="ARM_Overview#Note1">1</a></sup></td>
<td>R0, R1, R2, R3, R12</td>
<td>R4, R5, R6, R7, R8, R9, R10, R11, R13</td>
<td>R14
</td></tr></tbody></table>
<p><small id="Note1">Note 1: Stack is 8 byte aligned at all times outside of prologue/epilogue of non-leaf function. Leaf functions can have 4 byte aligned stacks. 8 byte alignment is required for ldrd/strd to function on the stack, which mostly only comes into play when using varargs with 64-bit integers. Care must be taken in interrupts and exceptions to align the stack to 8 byte before calling C code.</small>
</p><p>For details look at the <a rel="nofollow" class="external text" href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf">EABI specs</a>.
</p>
<h2><span class="mw-headline" id="Instructions">Instructions</span></h2>
<table class="wikitable">
<tbody><tr>
<th>Overview
</th></tr>
<tr>
<td>Instruction length are constant fixed size. 32-bits A32 mode. 16-bits Thumb32 mode.
</td></tr>
<tr>
<td>Strays from the RISC design by incorporating some multiple cycle instructions.
</td></tr>
<tr>
<td>Employs inline conditional fields in instructions to reduce performance loss from pipeline flushes.
</td></tr>
<tr>
<td>May produce larger code size due to RISC design compared to CISC designs, but supports Thumb32 mode which uses a 16-bit length instructions (more limited instruction set) to do 32-bit operations which produces smaller code footprint with reduced performance.
</td></tr>
<tr>
<td>Most instruction execute in few clock cycles or single cycles making development of real-time software easier.
</td></tr>
<tr>
<td>A32 and Thumb16 modes can be switched on the fly (worthy to note!)
</td></tr>
</tbody></table>
<p>Loading of large immediate values into registers can be interestingly different from x86/x64. A immediate value being a value that is literally encoded into the instruction. For example the x86/x64 compatible processors support loading a 32-bit immediate (also called a constant) into an arbitrary register. The ARM's A32 and Thumb32 instruction sets do not. Instead one must use a series instructions to gain the same effect or store the value in memory outside of the instruction stream. In essence one may consider the storage of the value outside of the instruction stream the same as storage inside but the does exist a difference in many ways and this is something to keep in mind about the ARM. But, any compiler or assembler can and may take care of this problem for you. If you are compiling C/C++ code then these problems will be transparent to you for example, but as I said this is good information to know and understand especially with system software development.
</p><p>Example, of machine code produced by GCC to load a register with a 32-bit value. As you can note the immediate value is technically outside of the instruction stream. On the x86/x64 the complete
value would have been encoded into the instruction. Also, take note how each instruction is constant in length. The instruction doing the work is LDR using the PC register and a immediate offset in order to place the value 0x12345678 into the register R3.
</p>
<pre>00000000 &lt;main&gt;:
   0:	e1a0c00d 	mov	ip, sp
   4:	e92dd800 	push	{fp, ip, lr, pc}
   8:	e24cb004 	sub	fp, ip, #4
   c:	e59f300c 	ldr	r3, [pc, #12]	; 20 &lt;main+0x20&gt;
  10:	e1a00003 	mov	r0, r3
  14:	e24bd00c 	sub	sp, fp, #12
  18:	e89d6800 	ldm	sp, {fp, sp, lr}
  1c:	e12fff1e 	bx	lr
  20:	12345678 	.word	0x12345678
</pre>
<p>An example of loading the register by storing the value in the instruction stream so to speak.
</p>
<pre>              
mov	r8, #0x78
add	r8, r8, #0x56 &lt;&lt; 8
add	r8, r8, #0x34 &lt;&lt; 16
add	r8, r8, #0x12 &lt;&lt; 24
</pre>
<p><br />
Almost all instructions support conditional execution which is directly encoded into the instruction. On a x86/x64 architecture when a series of instructions need to be conditionally executed you will likely find a branching instruction which creates a completely separate code path for the processor to follow is the branch happens. The ARM supports branching, but also almost all individual instructions support conditional execution so that instead of causing the processor to potentially flush and refill the pipeline because a branch occurred instead it will load instructions into the pipeline which have a special conditional field. There are a maximum of 16 specified conditional codes with one reserved condition making 15 usable conditions. So instead of making a branch only to execute a few instructions those few instructions can remain in the execution path and will not be executed or will be executed simply using the conditional codes.
</p><p>Here are the conditional codes for example:
</p>
<table class="wikitable">

<tbody><tr>
<th>Mnemonic
</th>
<th>Binary
</th>
<th>Description
</th></tr>
<tr>
<td>EQ</td>
<td>0000</td>
<td>Z flag set (equal)
</td></tr>
<tr>
<td>NE</td>
<td>0001</td>
<td>Z flag clear (not equal)
</td></tr>
<tr>
<td>HS</td>
<td>0010</td>
<td>C flag set (unsigned higher or same)
</td></tr>
<tr>
<td>LO</td>
<td>0011</td>
<td>C flag clear (unsigned lower)
</td></tr>
<tr>
<td>MI</td>
<td>0100</td>
<td>N flag set (negative)
</td></tr>
<tr>
<td>PL</td>
<td>0101</td>
<td>N flag clear (non-negative)
</td></tr>
<tr>
<td>VS</td>
<td>0110</td>
<td>V flag set (overflow)
</td></tr>
<tr>
<td>VC</td>
<td>0111</td>
<td>V flag clear (no overflow)
</td></tr>
<tr>
<td>HI</td>
<td>1000</td>
<td>C flag set and Z flag clear
</td></tr>
<tr>
<td>LS</td>
<td>1001</td>
<td>C flag clear or Z flag set
</td></tr>
<tr>
<td>GE</td>
<td>1010</td>
<td>N flag set and V set or N clear and V clear
</td></tr>
<tr>
<td>LT</td>
<td>1011</td>
<td>N set and V clear or N clear and V set
</td></tr>
<tr>
<td>GT</td>
<td>1100</td>
<td>Z clear with (either N or V set), or N clear and V set
</td></tr>
<tr>
<td>LE</td>
<td>1101</td>
<td>Z set or (N set and V clear), or N clear and V set
</td></tr>
<tr>
<td>AL</td>
<td>1110</td>
<td>always (no condition really)
</td></tr>
<tr>
<td>NV</td>
<td>1111</td>
<td>reserved condition
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Memory">Memory</span></h2>
<p>Many ARM processors come equipped with <a href="MMU" class="mw-redirect" title="MMU">MMUs</a>, full memory protection schemes for their 4GB address space, and <a href="TLB" title="TLB">TLB</a>. 
</p>
<h5><span class="mw-headline" id="Paging">Paging</span></h5>
<p>The paging scheme used by ARM processors uses a 2 level page table. The first level page table has 16kB size and each entry covers a region of 1MB (sections) and can be mapped directly or point to a second level page table. The second level page tables have 1kB size and each entry covers a region of 4KB (pages). The TLB also supports 16MB sections and 64kB pages. For those the right bits in the first or second level page table entries have to be set and the entry repeated 16 times. A hardware page table walk for any of the repeated entry then adds a TLB entry for the larger size. On ARMv4 and ARMv5 pages might also be divided into what the manual calls 'subpages', of, for a 4KB page, 1KB subpages, and for a 64KB page, 16KB subpages. (I assume you realize the fact that the subpages in both cases are 1/4 the size of the main page size). This is deprecated on ARMv6 and an alternate page table format can be configured that does not have subpages but has a extra access permission bits and provisions for physical address extentions (for more than 4GB physical memory) instead.
</p><p>The ARM processor supports 2 independent page tables. The first page table can be abreviated from the full 16kB down to 128 byte in powers of 2 and is used for the lower part of the virtual address space. The second page table is always 16KB in size and is used for addresses beyond the end of the first page table. If the first page table already covers all of the virtual addres space, is already full size (16kB), then the second page table is never used and can be left unset. 
</p><p>The Architecture Reference Manuals propose to use the abreviated first page table for processes individual address space and having the second level page table static for the kernel. For small processes (using 2GB or less) this results in a smaller page tables and therefore less overhead per process.
</p><p>Note: The ARMv6 Architecture Reference Manuals state clearly, multiple times, that subpages are deprecated and should not be used. Subpages have been removed in the ARMv7 Architecture Reference Manuals and are no longer available. So for maximum portability, you may decide to stick to 4KB and 64KB page sizes.
</p><p>Or you can have two sets of abstractions for your ARM Memory Manager port: One MM for ARMv4 and v5, and one for ARMv6 and up. It's all up to you.
</p>
<h5><span class="mw-headline" id="Memory_Detection">Memory Detection</span></h5>
<p>Memory detection is much different if you are coming from a background in the x86/x64 architecture. The ARM cores are used in many embedded applications and therefore the system board which the core resides on does not need to be overly complicated in order to be compatible with others boards. This is because almost any production board with an ARM core on it was likely custom designed just for that purpose. It is quite possible to use some generic board, but for lots of embedded applications there may not even be an operating system. 
</p><p>Therefore memory detection mechanisms may be non-existent and instead your operating system may opt for a value to be encoded into it at compile for a specific system (board) which is known to have a certain amount of memory, or you may have a specific driver that your operating system loads just for that board (or is compiled in) where the driver can be queried by your kernel for the amount of memory installed. There are lots of ways and these were just two ideas, but the important part is to understand that unlike the x86/x64 compatible systems you will likely find absolutely no mechanisms to <i>properly</i> poll the amount of memory.
</p><p>It may however be possible to probe memory and recover using processor exceptions. This still may not provide information about if a region of memory is FLASH, memory-mapped I/O, RAM, or ROM depending on how the system board was designed as I do suspect it could be quite possible for some ROM to be external to the core and allow writes to silently fail, and this coupled with the possibility of a region of memory to need a special unlock sequence in order to write to it will render your memory auto-detection code into a potential corner-case. 
</p><p>But, if you <i>think</i> you can do it -- then by all means try because you might figure out a way. This section is just to give you a good general feeling of what you may be getting into and I do not mean to keep any good ideas you may have from becoming something valuable.
</p>
<h2><span class="mw-headline" id="Exceptions">Exceptions</span></h2>
<p><i>Note: For some reason, the ARM people use the terms 'interrupt' and 'exception' as if they were the same.</i>
</p><p>For exceptions, ARM uses a table similar to the IVT of the real mode x86. The table consists of a number of 32-bit entries. Each entry is an instruction (ARM instructions are 4 bytes in length.) that jumps to the appropriate handler.
</p><p>Take note of that, and understand the design impact it imposes: On x86, the hardware vector table holds the addresses of handler routines. On ARM, the hardware vector table holds actual instructions. These instructions must fit into 4 bytes. This is actually not a big deal since all ARM instructions (assuming ARM mode and not Thumb, or Jazelle) are actually 4 bytes anyway. The general idea is to emulate the behaviour of something like the x86 and simply place a jump instruction into the actual vector table, so that upon indexing into the table, the ARM processor is made to act as if it jumped to an address contained in the jump instruction. From there, consistency is obtained, and portability is eased.
</p><p>Also used are various devices to <i>vector</i> interrupts. Two such are the Generic Interrupt Controller and the Vectored Interrupt Controller.
</p>
<h2><span class="mw-headline" id="Coding_Gotchas">Coding Gotchas</span></h2>
<h5><span class="mw-headline" id="Heap_Pointers_Needs_To_Be_Aligned">Heap Pointers Needs To Be Aligned</span></h5>
<p>I can not state at this time how many processors support unaligned memory access natively, but from what I know unaligned memory access is more expensive than aligned. And, a good many structures which have fields greater than one byte in size a lot of times are allocated on the heap. So from this you can see how big of a performance hit you could take. Not to mention the bug that would be introduced if running under a processor which does not even handle unaligned memory access gracefully, and by that I meant at the very least raising an exception of some sort so the code can crash and show the problem.
</p>
<h5><span id="Missing_Division_Functions_.28_aeabi_uidivmod.2C_aeabi_idiv.29.2FNo_Division_Support"></span><span class="mw-headline" id="Missing_Division_Functions_(_aeabi_uidivmod,_aeabi_idiv)/No_Division_Support">Missing Division Functions (__aeabi_uidivmod, __aeabi_idiv)/No Division Support</span></h5>
<p>This is caused by using GCC and not linking with <i>libgcc</i>. You <i>NEED TO</i> link with <i>libgcc</i> when using GCC. For information about why you should link and information about <i>libgcc</i>, read <a href="Libgcc" title="Libgcc">Libgcc</a> and <a href="GCC_Cross-Compiler" title="GCC Cross-Compiler">GCC_Cross-Compiler</a>.
</p><p>You must also make sure you use the <i>libgcc</i> that has been compiled for your target machine/architecture/platform. See <a href="Libgcc" title="Libgcc">Libgcc</a> for more information. You can produce the correct library for GCC by reading <a href="GCC_Cross-Compiler" title="GCC Cross-Compiler">GCC_Cross-Compiler</a>.
</p>
<h6><span class="mw-headline" id="This_section_is_just_if_you_want_a_more_in_depth_explanation_and_discussion.">This section is just if you want a more in depth explanation and discussion.</span></h6>
<p>This issue is actually complicated because different CPUs may not support hardware division, support it only through the floating point operations, in thumb mode, in native mode, or a combination. Also, in certain situations you may find it faster or more compact to use different methods because you may be interested in code size or performance. The <i>libgcc</i> will handle all of these situations and provide the needed symbols, however here are some various sources of information that can give you a more in-depth understanding:
</p>
<pre>The following links talk about different methods in handling this problem: 
    http://forum.osdev.org/viewtopic.php?f=1&amp;t=23857&amp;p=212244
    http://stackoverflow.com/questions/8348030/how-does-one-do-integer-signed-or-unsigned-division-on-arm
Also, some extra information that maybe useful:
    http://www.linkedin.com/groups/ARM-cores-hardware-division-85447.S.242517259
A discussion about this section, and also at the end an example of libgcc's version of the divide function:
    http://forum.osdev.org/viewtopic.php?f=8&amp;t=27767
The source for libgcc and source of the division emulation function:
    https://github.com/mirrors/gcc/blob/master/libgcc/udivmodsi4.c
    https://github.com/mirrors/gcc/blob/master/libgcc/
</pre>
<h5><span class="mw-headline" id="Unaligned_Memory_Access_And_Byte_Order">Unaligned Memory Access And Byte Order</span></h5>
<table border="1px">
<tbody><tr>
<td style="background-color: #eeeeee;">Various newer ARM cores supposedly support unaligned memory access, but a specific bit or two have to be set and unset in the program control registers. I have not checked if QEMU's emulation of the ARMv7 supports this. So keep this in mind.
</td></tr></tbody></table>
<p>Also, it is recommended to have a look at this article on <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Endianess#Atomic_element_size_16-bit">Endianness</a> which will help clarify and potentially gives a second source of information.
</p><p>Let us imagine we have a board with 8 bytes of RAM, as depicted below:
</p>
<table class="wikitable">
<tbody><tr>
<th>Value
</th>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H
</td></tr>
<tr>
<th>Address
</th>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7
</td></tr></tbody></table>
<p>A <i>little endian</i> machine reads the least significant byte (LSB) first. So, if we made a 32-bit (word sized) read at address <i>0</i> on the memory above, that would yield "DCBA". On a <i>big endian</i> machine, which reads the most significant byte (MSB) first, you would get "ABCD". It all depends on how you visualize memory addresses - whether they flow to the right (big endian), or towards the left (little endian).
</p><p>Some CPU platforms even support either mode. For example, the ARM7TDMI-S has a pin BIGEND to switch from little to big endian. (Although I could not find the QEMU option to enable this feature.)
</p><p>ARM cores have two other differences from x86/x64:
</p>
<ul><li>They do not handle unaligned memory accesses in any defined manner. It is specified on <i>4-32 ARM7TDMI-S Data Sheet</i> that if bit <i>0</i> for the memory address on a half-word access is <i>high</i> then the results are <b>undefined</b>.</li>
<li>Accessing half-words in little endian mode will swap the half-words in the word.</li></ul>
<p>An example for the latter:
</p>
<pre>uint32        *a;
uint16        *b;

a = (uint32*)0;
b = (uint16*)0;

a[0] = 0x12345678;
printf("%#04x --&gt;&#160;%#04x\n", b[0], b[1]);
</pre>
<p>This gives <i>0x5678 --&gt; 0x1234</i>, while in big endian mode you would get <i>0x1234 --&gt; 0x5678</i>.
</p>
<table class="wikitable">
<tbody><tr>
<th colspan="8">Little Endian Word Size (32-bit)
</th></tr>
<tr>
<td>ED</td>
<td>CB</td>
<td>A9</td>
<td>87</td>
<td>78</td>
<td>9A</td>
<td>BC</td>
<td>DE
</td></tr>
<tr>
<th colspan="4">Offset
</th>
<th colspan="2">Register(LittleEndian)
</th>
<th colspan="2">Register(BigEndian)
</th></tr>
<tr>
<th colspan="4">00
</th>
<td colspan="2">0x87A9CBED
</td>
<td colspan="2">0xEDCBA987
</td></tr>
<tr>
<th colspan="4">01
</th>
<td colspan="4">UNALIGNED - UNDEFINED
</td></tr>
<tr>
<th colspan="4">10
</th>
<td colspan="4">UNALIGNED - UNDEFINED
</td></tr>
<tr>
<th colspan="4">11
</th>
<td colspan="4">UNALIGNED - UNDEFINED
</td></tr></tbody></table>
<table class="wikitable">
<tbody><tr>
<th colspan="8">Little Endian Half-Word Size (16-bit)
</th></tr>
<tr>
<td>ED</td>
<td>CB</td>
<td>A9</td>
<td>87</td>
<td>78</td>
<td>9A</td>
<td>BC</td>
<td>DE
</td></tr>
<tr>
<th colspan="4">Offset
</th>
<th colspan="2">Register(LittleEndian)
</th>
<th colspan="2">Register(BigEndian)
</th></tr>
<tr>
<th colspan="4">00
</th>
<td colspan="2">0xA987
</td>
<td colspan="2">0xEDCB
</td></tr>
<tr>
<th colspan="4">01
</th>
<td colspan="4">UNALIGNED - UNDEFINED
</td></tr>
<tr>
<th colspan="4">10
</th>
<td colspan="2">0xEDCB
</td>
<td colspan="2">0xA987
</td></tr>
<tr>
<th colspan="4">11
</th>
<td colspan="4">UNALIGNED - UNDEFINED
</td></tr></tbody></table>
<table class="wikitable">
<tbody><tr>
<th colspan="8">Byte Size (8-bit)
</th></tr>
<tr>
<td>ED</td>
<td>CB</td>
<td>A9</td>
<td>87</td>
<td>78</td>
<td>9A</td>
<td>BC</td>
<td>DE
</td></tr>
<tr>
<th colspan="4">Offset
</th>
<th colspan="2">Register(LittleEndian)
</th>
<th colspan="2">Register(BigEndian)
</th></tr>
<tr>
<th colspan="4">00
</th>
<td colspan="2">0xED
</td>
<td colspan="2">0xED
</td></tr>
<tr>
<th colspan="4">01
</th>
<td colspan="2">0xCB
</td>
<td colspan="2">0xCB
</td></tr>
<tr>
<th colspan="4">10
</th>
<td colspan="2">0xA9
</td>
<td colspan="2">0xA9
</td></tr>
<tr>
<th colspan="4">11
</th>
<td colspan="2">0x87
</td>
<td colspan="2">0x87
</td></tr></tbody></table>
<p><i>From reading the data sheet it appears that if operating in big endian mode the half-word access would be reversed to be more natural as you would expect on the x86/x64 architecture. But, since I can not actually test it at the moment I am hoping I got it right.</i>
</p><p><i>The word access with offset of </i>10b (0x2)<i> may be defined, but I am not sure because it does not really state. However, it may employ some of the mechanisms for loading half-words. (Need someone to come through and correct this if it is wrong)</i>
</p><p>The reason memory access has to be aligned is because unaligned access requires additional access cycles, due to the way memory modules work (see DDR datasheet below), and would increase the complexity of load / store operations (and the processor core).
</p><p>You could simulate an unaligned memory access on the ARM7TDMI-S, but you would have to make separate loads from two memory locations. A compiler could probably emit code to do this automatically, but the checks whether an access is unaligned or not would slow down <i>all</i> memory accesses. Some code is provided in the <i>ARM7TDMI-S Data Sheet</i> on page <i>4-35</i> for such "checked" memory access,  when you do not know if the address will be aligned or non-aligned.
</p>
<ul><li><a rel="nofollow" class="external free" href="http://lists.gnu.org/archive/html/qemu-devel/2004-12/msg00206.html">http://lists.gnu.org/archive/html/qemu-devel/2004-12/msg00206.html</a> - patch for QEMU to support big-endian ARM</li>
<li><a rel="nofollow" class="external free" href="http://download.micron.com/pdf/datasheets/dram/ddr/256MBDDRx4x8x16.pdf">http://download.micron.com/pdf/datasheets/dram/ddr/256MBDDRx4x8x16.pdf</a> Datasheet for DDR memory</li></ul>
<h5><span class="mw-headline" id="Branch_Instruction_In_Vector_Table">Branch Instruction In Vector Table</span></h5>
<p>Keep in mind when working with the ARMv4 and compatible cores that in the vector table each entry is 32-bits -- and that the value in each slot is <i>not</i> the address of where the CPU should jump too.
</p><p>Instead it is an instruction. This can be a little confusing when you first start out because it seems like it makes sense for it to be an address, but instead it is an actual 32-bit instruction. It can be any instruction, but common usage is a <i>LDR</i> (data load) instruction which loads an immediate into PC from with-in 4K bytes of the instruction, or a <i>B</i> (branch) which uses a 26-bit signed offset.
</p><p>Also, if you use a <i>B</i> instruction. Remember, its relative to the instruction pointer. So for each <i>index</i> in the table subtract <i>index*4</i> from it. Then subtract an extra <i>8</i> from that so you have <i>index*4+8</i> subtracted. This <i>8</i> is from the prefetch (pipeline having been filled). 
</p><p>Failure to realize this can lead to some service routines that work long enough for you to think they are working then bug out days down the road and leave you looking through a lot of added code.
</p>
<pre>#define ARM4_XRQ_RESET   0x00
#define ARM4_XRQ_UNDEF   0x01
#define ARM4_XRQ_SWINT   0x02
#define ARM4_XRQ_ABRTP   0x03
#define ARM4_XRQ_ABRTD   0x04
#define ARM4_XRQ_RESV1   0x05
#define ARM4_XRQ_IRQ     0x06
#define ARM4_XRQ_FIQ     0x07

/*
    Will install a branch instruction for the 
    interrupt vector for the ARM platform.
*/
void arm4_xrqinstall(uint32 ndx, void *addr)
{
    uint32      *v;
    
    v = (uint32*)0x0;
    v[ndx] = 0xEA000000 | (((uintptr)addr - 8 - (4 * ndx)) &gt;&gt; 2);
}
</pre>
<p><i>It can be a wise idea to populate all entries of the table. If the table is populated with zeros each vector will hold the instruction "andeq r0, r0, r0" which does nothing. Meaning if the CPU jumps to an unpopulated vector it will effectively execute a NOP and move to the next vector which can cause a confusing bug in your code. At least point any unused vectors to a dummy function that will notify you an unhandled exception has occured!</i>
</p>
<h5><span id="Specifying_CPSR_using_AS_.28Binutils.2FGCC.29_Syntax"></span><span class="mw-headline" id="Specifying_CPSR_using_AS_(Binutils/GCC)_Syntax">Specifying CPSR using AS (Binutils/GCC) Syntax</span></h5>
<p>You have to use <i>cpsr</i> not <i>%%cpsr</i> or any other form.
</p>
<pre>uint32 arm4_cpsrget()
{
    uint32      r;
    
    asm("mrs&#160;%[ps], cpsr"&#160;: [ps]"=r" (r));
    return r;
}

void arm4_cpsrset(uint32 r)
{
    asm("msr cpsr,&#160;%[ps]"&#160;:&#160;: [ps]"r" (r));
}

/* Bit 7 and 6 have to be logic-low/unset/zero/cleared to enable the interrupt type. */
void arm4_xrqenable_fiq()
{
    arm4_cpsrset(arm4_cpsrget() &amp; ~(1 &lt;&lt; 6));
}

void arm4_xrqenable_irq()
{
    arm4_cpsrset(arm4_cpsrget() &amp; ~(1 &lt;&lt; 7));
}
</pre>
<h5><span id="GCC_.28Chars_Not_Signed.29"></span><span class="mw-headline" id="GCC_(Chars_Not_Signed)">GCC (Chars Not Signed)</span></h5>
<p>In some cases GCC when targeting ARM architecture may not handle signed values as you may expected.
</p><p>Consider the case:
</p>
<pre>void foo(char *a)
{
    *a = -1;
}

void bar()
{
    char      z;
    short     x;

    x = 0;
    foo(&amp;z);

    x = x + z;
}
</pre>
<p>The expected value for <i>x</i> would be <i>-1</i> or <i>0xFFFF</i> in a twos complement system, but instead you may 
end up surprised and spend quite a many hours when you get <i>255</i> or <i>0xFF</i> as the result. And, here is
the explanation.
</p>
<pre>  4c:	ebfffffe 	bl	0 &lt;foo&gt;
  50:	e55b300f 	ldrb	r3, [fp, #-15]
  54:	e1a02003 	mov	r2, r3
  58:	e15b30be 	ldrh	r3, [fp, #-14]
  5c:	e0823003 	add	r3, r2, r3
</pre>
<p>The x86/x64 target architecture will cause GCC to treat <i>char</i> as <i>signed char</i> [expected behavior by most], but when targeting the
ARM you may be surprised to find that <i>char</i> is treated as <i>unsigned char</i>. You must specify <i>signed</i>
before <i>char</i>, and then the compiler will generate code to correct perform the addition.
</p><p>This link explains better. Also, in case you decide to skip the reading. Essentially, code which assumes <i>char</i> should be
<i>signed char</i> could be considered essentially incorrect and buggy which was stated by one poster. So, good idea to keep
a check on this for portability.
</p>
<dl><dd><a rel="nofollow" class="external text" href="http://comments.gmane.org/gmane.linux.ports.arm.kernel/3930">Mailing List Post</a></dd></dl>
<h2><span class="mw-headline" id="Emulators">Emulators</span></h2>
<ul><li><a rel="nofollow" class="external text" href="http://bellard.org/qemu/qemu-doc.html#SEC63">QEMU</a></li>
<li><a rel="nofollow" class="external text" href="http://softgun.sourceforge.net/">Softgun</a></li>
<li><a rel="nofollow" class="external text" href="http://skyeye.sourceforge.net/index.shtml">Skyeye</a></li></ul>
<h2><span class="mw-headline" id="Targeting_Multiple_ARM_Based_Devices">Targeting Multiple ARM Based Devices</span></h2>
<p>For information about targeting multiple ARM based devices see, <a href="ARM_TargetingMultipleDevices" title="ARM TargetingMultipleDevices">here</a>.
</p>
<h2><span class="mw-headline" id="Tutorials_And_Starting_Points">Tutorials And Starting Points</span></h2>
<table class="wikitable">

<tbody><tr>
<th>Page
</th>
<th>Brief Description
</th></tr>
<tr>
<td><a href="ARM_Beagleboard" title="ARM Beagleboard">BeagleBoard</a>
</td>
<td>Tutorial on bare-metal [OS] development on the Texas Instruments BeagleBoard. Written specifically for the BeagleBoard-xM Rev C.
</td></tr>
<tr>
<td><a href="ARM_Integrator-CP_Bare_Bones" title="ARM Integrator-CP Bare Bones">Integrator Barebones</a>
</td>
<td>This is a tutorial. Read Getting Started and Beginner Mistakes. Should have reasonable knowledge of ARM assembly, but may be able to get by on less.
</td></tr>
<tr>
<td><a href="ARM_Integrator-CP_PL110_Dirty" title="ARM Integrator-CP PL110 Dirty">Integrator-CP QEMU PL110 16-Bit Color Example</a>
</td>
<td>Quick, dirty, and to the point on getting the QEMU PL110 16-Bit Color frame buffer working. Will likely not work on the real hardware, but will be very close. This is just to get someone started. Formed as a tutorial, but very short one.
</td></tr>
<tr>
<td><a href="PL050_PS/2_Controller" title="PL050 PS/2 Controller">PL050 PS/2 Controller</a>
</td>
<td>Information about interfacing a PS/2 device specifically the mouse, and starts with using the PL050. See links at bottom if PL050 is not of interest.
</td></tr>
<tr>
<td><a href="ARM_Integrator-CP_IRQTimerAndPIC" title="ARM Integrator-CP IRQTimerAndPIC">IRQ, Timer, And PIC</a>
</td>
<td>This demonstrates using exceptions (specifically the IRQ exception), Timer, And PIC. It also provides a decent base for hacking with the ARM and/or QEMU.
</td></tr>
<tr>
<td><a href="ARM_Integrator-CP_ITPTMME_Main" title="ARM Integrator-CP ITPTMME Main">ELK Pages (Thin ARM)</a>
</td>
<td>The experimental learning kernel pages aimed to take someone gradually through the process of building a functional kernel using possibly (in later part of series) experimental designs and implementations that differ from the standard and conventional design in certain areas.
</td></tr>
<tr>
<td><a href="ARM_RaspberryPi" class="mw-redirect" title="ARM RaspberryPi">ARM_RaspberryPi</a>
</td>
<td>Description and details on the commonly used Raspberry Pi boards
</td></tr>
<tr>
<td><a href="./User:Pancakes/ARM_QEMU_REALVIEW-PB-A" class="mw-redirect" title="User:Pancakes/ARM QEMU REALVIEW-PB-A">QEMU realview-pb-a board</a>
</td>
<td>This page gives you some information about programming for the realview-pb-a board under QEMU. Actual hardware <i>could</i>be different. It also contains a link to the datasheet (which might be hard to find).
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Highly_Useful_External_Resources">Highly Useful External Resources</span></h2>
<ul><li><a rel="nofollow" class="external text" href="http://infocenter.arm.com/help/index.jsp">ARM Infocenter</a></li>
<li><a rel="nofollow" class="external text" href="http://www.arm.com/documentation/Software_Development_Tools/">More ARM Documentation</a></li>
<li><a rel="nofollow" class="external text" href="http://www.coranac.com/tonc/text/asm.htm">Whirlwind Tour of ARM Assembly</a></li>
<li><a rel="nofollow" class="external text" href="http://re-eject.gbadev.org/files/GasARMRef.pdf">GAS ARM Reference</a></li>
<li><a rel="nofollow" class="external text" href="http://re-eject.gbadev.org/files/armref.pdf">ARM Instruction Reference</a></li>
<li><a rel="nofollow" class="external text" href="http://www.arm.com/miscPDFs/9658.pdf">ARM Assembly Language Programming</a></li>
<li><a rel="nofollow" class="external text" href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0159b/DUI0159B_integratorcp_1_0_ug.pdf">Integrator/CP Reference Manual</a></li>
<li><a rel="nofollow" class="external text" href="https://www.amazon.com/ARM-System-Developers-Guide-Architecture/dp/1558608745">Amazon: ARM System Developer's Guide: Designing and Optimizing System Software</a></li>
<li><a rel="nofollow" class="external text" href="http://www.embedded-bits.co.uk/2011/mmucode/">Turning on an ARM MMU and Living to tell the tale: The code</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250211122107
Cache expiry: 86400
Reduced expiry: false
Complications: [showtoc]
CPU time usage: 0.029 seconds
Real time usage: 0.030 seconds
Preprocessor visited node count: 129/1000000
Postexpand include size: 162/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 2629/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.619      1 Template:Wikitable
100.00%    0.619      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2332-0!canonical and timestamp 20250211122107 and revision id 28710.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=ARM_Overview&amp;oldid=28710">https://wiki.osdev.org/index.php?title=ARM_Overview&amp;oldid=28710</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="./Category:ARM" title="Category:ARM">ARM</a></li><li><a href="./Category:Instruction_Set_Architecture" title="Category:Instruction Set Architecture">Instruction Set Architecture</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=ARM+Overview" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="ARM_Overview#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="ARM_Overview" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:ARM_Overview" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="ARM_Overview"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=ARM_Overview&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=ARM_Overview&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/ARM_Overview" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/ARM_Overview" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=ARM_Overview&amp;oldid=28710" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=ARM_Overview&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/ARM" title="ARM  Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 27 March 2024, at 11:33.</li>
	<li id="footer-info-0">This page has been accessed 19,290 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=ARM_Overview&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.029","walltime":"0.030","ppvisitednodes":{"value":129,"limit":1000000},"postexpandincludesize":{"value":162,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":2629,"limit":5000000},"timingprofile":["100.00%    0.619      1 Template:Wikitable","100.00%    0.619      1 -total"]},"cachereport":{"timestamp":"20250211122107","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":98});});</script>
</body>
</html>