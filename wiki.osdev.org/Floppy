<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Floppy Disk Controller - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"bab829d75ed4e17f95581b36","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Floppy_Disk_Controller","wgTitle":"Floppy Disk Controller","wgCurRevisionId":28697,"wgRevisionId":28697,"wgArticleId":1458,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Storage","Common Devices"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Floppy_Disk_Controller","wgRelevantArticleId":1458,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],
"wgRestrictionMove":[],"wgRedirectedFrom":"Floppy","wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgInternalRedirectTargetUrl":"/Floppy_Disk_Controller","wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="Floppy_Disk_Controller"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Floppy_Disk_Controller rootpage-Floppy_Disk_Controller skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Floppy Disk Controller</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"><span class="mw-redirectedfrom">(Redirected from <a href="https://wiki.osdev.org/index.php?title=Floppy&amp;redirect=no" class="mw-redirect" title="Floppy">Floppy</a>)</span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="Floppy#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="Floppy#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Floppy#Overview_and_Documentation"><span class="tocnumber">1</span> <span class="toctext">Overview and Documentation</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="Floppy#Accessing_Floppies_in_Real_Mode"><span class="tocnumber">1.1</span> <span class="toctext">Accessing Floppies in Real Mode</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="Floppy#Accessing_USB_Floppy_Drives"><span class="tocnumber">1.2</span> <span class="toctext">Accessing USB Floppy Drives</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="Floppy#The_Floppy_Subsystem_is_Ugly"><span class="tocnumber">1.3</span> <span class="toctext">The Floppy Subsystem is Ugly</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="Floppy#How_Many_Controllers?_One!_Usually."><span class="tocnumber">1.4</span> <span class="toctext">How Many Controllers? One! Usually.</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="Floppy#How_Many_Drives?"><span class="tocnumber">1.5</span> <span class="toctext">How Many Drives?</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="Floppy#The_Actual_Drive"><span class="tocnumber">1.6</span> <span class="toctext">The Actual Drive</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="Floppy#CHS"><span class="tocnumber">1.7</span> <span class="toctext">CHS</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="Floppy#DMA_Data_Transfers"><span class="tocnumber">1.8</span> <span class="toctext">DMA Data Transfers</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="Floppy#PIO_Data_Transfers"><span class="tocnumber">1.9</span> <span class="toctext">PIO Data Transfers</span></a>
<ul>
<li class="toclevel-3 tocsection-11"><a href="Floppy#Bochs_Can&#39;t_Handle_Polling_PIO"><span class="tocnumber">1.9.1</span> <span class="toctext">Bochs Can't Handle Polling PIO</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="Floppy#There_are_3_&quot;Modes&quot;"><span class="tocnumber">1.10</span> <span class="toctext">There are 3 "Modes"</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="Floppy#Most_Commands_Run_&quot;Silently&quot;"><span class="tocnumber">1.11</span> <span class="toctext">Most Commands Run "Silently"</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="Floppy#Timing_Issues"><span class="tocnumber">1.12</span> <span class="toctext">Timing Issues</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="Floppy#Reliability"><span class="tocnumber">1.13</span> <span class="toctext">Reliability</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="Floppy#Registers"><span class="tocnumber">2</span> <span class="toctext">Registers</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="Floppy#FIFO"><span class="tocnumber">2.1</span> <span class="toctext">FIFO</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="Floppy#Tape_Drive_Register"><span class="tocnumber">2.2</span> <span class="toctext">Tape Drive Register</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="Floppy#DOR_bitflag_definitions"><span class="tocnumber">2.3</span> <span class="toctext">DOR bitflag definitions</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="Floppy#MSR_bitflag_definitions"><span class="tocnumber">2.4</span> <span class="toctext">MSR bitflag definitions</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="Floppy#CCR_and_DSR"><span class="tocnumber">2.5</span> <span class="toctext">CCR and DSR</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="Floppy#DIR_register,_Disk_Change_bit"><span class="tocnumber">2.6</span> <span class="toctext">DIR register, Disk Change bit</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-23"><a href="Floppy#Programming_Details"><span class="tocnumber">3</span> <span class="toctext">Programming Details</span></a>
<ul>
<li class="toclevel-2 tocsection-24"><a href="Floppy#Motor_Delays"><span class="tocnumber">3.1</span> <span class="toctext">Motor Delays</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="Floppy#Gap_Lengths"><span class="tocnumber">3.2</span> <span class="toctext">Gap Lengths</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="Floppy#Hardware_Control_of_Bad_Cylinders"><span class="tocnumber">3.3</span> <span class="toctext">Hardware Control of Bad Cylinders</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="Floppy#Procedures"><span class="tocnumber">3.4</span> <span class="toctext">Procedures</span></a>
<ul>
<li class="toclevel-3 tocsection-28"><a href="Floppy#Reinitialization"><span class="tocnumber">3.4.1</span> <span class="toctext">Reinitialization</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="Floppy#Controller_Reset"><span class="tocnumber">3.4.2</span> <span class="toctext">Controller Reset</span></a></li>
<li class="toclevel-3 tocsection-30"><a href="Floppy#Drive_Selection"><span class="tocnumber">3.4.3</span> <span class="toctext">Drive Selection</span></a></li>
<li class="toclevel-3 tocsection-31"><a href="Floppy#Detecting_Media"><span class="tocnumber">3.4.4</span> <span class="toctext">Detecting Media</span></a></li>
<li class="toclevel-3 tocsection-32"><a href="Floppy#Waiting"><span class="tocnumber">3.4.5</span> <span class="toctext">Waiting</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="Floppy#The_Proper_Way_to_issue_a_command"><span class="tocnumber">3.4.6</span> <span class="toctext">The Proper Way to issue a command</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-34"><a href="Floppy#Commands"><span class="tocnumber">3.5</span> <span class="toctext">Commands</span></a>
<ul>
<li class="toclevel-3 tocsection-35"><a href="Floppy#&quot;Deleted_sectors&quot;"><span class="tocnumber">3.5.1</span> <span class="toctext">"Deleted sectors"</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="Floppy#Option_bits"><span class="tocnumber">3.5.2</span> <span class="toctext">Option bits</span></a>
<ul>
<li class="toclevel-4 tocsection-37"><a href="Floppy#Bit_MT"><span class="tocnumber">3.5.2.1</span> <span class="toctext">Bit MT</span></a></li>
<li class="toclevel-4 tocsection-38"><a href="Floppy#Bit_MF"><span class="tocnumber">3.5.2.2</span> <span class="toctext">Bit MF</span></a></li>
<li class="toclevel-4 tocsection-39"><a href="Floppy#Bit_SK"><span class="tocnumber">3.5.2.3</span> <span class="toctext">Bit SK</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-40"><a href="Floppy#Status_Registers"><span class="tocnumber">3.5.3</span> <span class="toctext">Status Registers</span></a>
<ul>
<li class="toclevel-4 tocsection-41"><a href="Floppy#st0"><span class="tocnumber">3.5.3.1</span> <span class="toctext">st0</span></a></li>
<li class="toclevel-4 tocsection-42"><a href="Floppy#st1"><span class="tocnumber">3.5.3.2</span> <span class="toctext">st1</span></a></li>
<li class="toclevel-4 tocsection-43"><a href="Floppy#st2"><span class="tocnumber">3.5.3.3</span> <span class="toctext">st2</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-44"><a href="Floppy#Configure"><span class="tocnumber">3.5.4</span> <span class="toctext">Configure</span></a></li>
<li class="toclevel-3 tocsection-45"><a href="Floppy#Version"><span class="tocnumber">3.5.5</span> <span class="toctext">Version</span></a></li>
<li class="toclevel-3 tocsection-46"><a href="Floppy#Lock"><span class="tocnumber">3.5.6</span> <span class="toctext">Lock</span></a></li>
<li class="toclevel-3 tocsection-47"><a href="Floppy#Specify"><span class="tocnumber">3.5.7</span> <span class="toctext">Specify</span></a>
<ul>
<li class="toclevel-4 tocsection-48"><a href="Floppy#SRT,_HLT_and_HUT"><span class="tocnumber">3.5.7.1</span> <span class="toctext">SRT, HLT and HUT</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-49"><a href="Floppy#Sense_Interrupt"><span class="tocnumber">3.5.8</span> <span class="toctext">Sense Interrupt</span></a></li>
<li class="toclevel-3 tocsection-50"><a href="Floppy#Recalibrate"><span class="tocnumber">3.5.9</span> <span class="toctext">Recalibrate</span></a></li>
<li class="toclevel-3 tocsection-51"><a href="Floppy#Seek"><span class="tocnumber">3.5.10</span> <span class="toctext">Seek</span></a>
<ul>
<li class="toclevel-4 tocsection-52"><a href="Floppy#Relative_seek"><span class="tocnumber">3.5.10.1</span> <span class="toctext">Relative seek</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-53"><a href="Floppy#Read/Write"><span class="tocnumber">3.5.11</span> <span class="toctext">Read/Write</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-54"><a href="Floppy#Perpendicular_Mode_and_2.88M_floppies"><span class="tocnumber">3.6</span> <span class="toctext">Perpendicular Mode and 2.88M floppies</span></a></li>
<li class="toclevel-2 tocsection-55"><a href="Floppy#Additional_Programming_Notes"><span class="tocnumber">3.7</span> <span class="toctext">Additional Programming Notes</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-56"><a href="Floppy#Code_Examples"><span class="tocnumber">4</span> <span class="toctext">Code Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-57"><a href="Floppy#A_common_coding_error_example"><span class="tocnumber">4.1</span> <span class="toctext">A common coding error example</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-58"><a href="Floppy#Related_Links"><span class="tocnumber">5</span> <span class="toctext">Related Links</span></a>
<ul>
<li class="toclevel-2 tocsection-59"><a href="Floppy#Articles"><span class="tocnumber">5.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-60"><a href="Floppy#Reference_Documents"><span class="tocnumber">5.2</span> <span class="toctext">Reference Documents</span></a></li>
<li class="toclevel-2 tocsection-61"><a href="Floppy#Forum_Posts"><span class="tocnumber">5.3</span> <span class="toctext">Forum Posts</span></a></li>
<li class="toclevel-2 tocsection-62"><a href="Floppy#Implementations"><span class="tocnumber">5.4</span> <span class="toctext">Implementations</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Overview_and_Documentation">Overview and Documentation</span></h2>
<p>The Floppy Disk Controller (FDC) is a (legacy) device that controls <b>internal</b> 3.5/5.25 inch floppy disk drive devices on desktop x86 systems.
There are a range of chips that have been produced for this function which include: 8272A, 82078, 82077SL &amp; 82077AA. The 82077AA is the most
advanced, and has been produced since 1991. For more recent systems, a model of that chip has been embedded in the motherboard chipset.
(So pay close attention to that datasheet, below.)
</p>
<h3><span class="mw-headline" id="Accessing_Floppies_in_Real_Mode">Accessing Floppies in Real Mode</span></h3>
<p>For bootloaders or OSes that run with the CPU remaining in <a href="Real_Mode" title="Real Mode">Real Mode</a>, use <a href="BIOS#BIOS_functions" title="BIOS">BIOS Function</a>
INT13h AH=2 (read) or AH=3 (write) to access floppy drives. You need to know the "drive number" (typically 0 or 1), and put that value in DL.
More detailed info can be found in the <a href="ATA_in_x86_RealMode_(BIOS)" class="mw-redirect" title="ATA in x86 RealMode (BIOS)">ATA in x86 RealMode (BIOS)</a> article, because accessing a floppy is identical to accessing a hard disk
(using CHS) in Real Mode. The rest of this article deals with creating Protected Mode drivers for the floppy subsystem.
</p><p>Note: the Extended BIOS Int13h functions do not work with floppies.
</p><p>Note2: the BIOS IRQ0 handler remembers a timeout for turning the motor off, from the last BIOS floppy access. The last access may have been
attempting to load your bootloader. So, in the distant future, if the BIOS ever receives 36 more IRQ0 ticks (if you ever return to Real Mode)
it may turn off your floppy motors for you, once.
</p>
<h3><span class="mw-headline" id="Accessing_USB_Floppy_Drives">Accessing USB Floppy Drives</span></h3>
<p>All <a href="USB" class="mw-redirect" title="USB">USB</a> devices, including USB floppy drives, are accessed indirectly (using SCSI-style commands encoded in USB datapackets) over the USB bus.
USB floppy drives do not use any of the IO ports or FDC commands described in this article.
</p>
<h3><span class="mw-headline" id="The_Floppy_Subsystem_is_Ugly">The Floppy Subsystem is Ugly</span></h3>
<p>Many of the devices that an OS controls in an x86 system have had functional patches added to them over the years. This makes them all
rather unpleasant when coding drivers. The floppy subsystem is probably the worst. As the functionality evolved, some
of the bit definitions were actually <b>reversed</b> in meaning, not merely made obsolete. Several commands require duplicating the
same information in two different locations -- and if the duplicated info doesn't match, the command fails. There were never definitive
flags added to identify which "mode" the controller is operating in. Also, the floppy
subsystem is the primary remaining one that accesses the obsolete and terrible ISA DMA system for its data transfers.
</p>
<h3><span id="How_Many_Controllers.3F_One.21_Usually."></span><span class="mw-headline" id="How_Many_Controllers?_One!_Usually.">How Many Controllers? One! Usually.</span></h3>
<p>Each ribbon cable for floppy drives can support 2 drives. One floppy controller chip can control 2 floppy cables, for a total
of 4 drives. It is possible for a system to have more than one controller chip, but you will not find many existing systems with
more than one. If a system has more than one floppy controller, the second controller will be found at a base IO port address of 0x370.
</p><p>Some systems also have a third floppy controller, but these are exceedingly rare. Most of these will have originally been disk
duplication systems. The third floppy controller can be found at a base IO port address of 0x360.
</p>
<h3><span id="How_Many_Drives.3F"></span><span class="mw-headline" id="How_Many_Drives?">How Many Drives?</span></h3>
<p>It is probably wisest to always get the drive count and types from <a href="CMOS" title="CMOS">CMOS</a>, register 0x10.
</p>
<h3><span class="mw-headline" id="The_Actual_Drive">The Actual Drive</span></h3>
<p>In the olden days, there used to be 5.25 inch low-density, high-density, and single-sided drives. There used to be media
for each of these drive types. There also used to be 3.5 inch low density media. None of this really exists anymore. The only
actual hardware you will typically run into now is 3.5 inch, 1.44MB drives.
</p><p>A 1.44MB floppy disk is usually formatted with 80 cylinders, 2 sides, and 18 sectors per track. The drive records the two sides
with two "heads" that are bolted together. They cannot seek independently. The "track" on one side of a disk is always exactly
opposite the track on the other side of the disk. (There is a misconception about this in many floppy driver code examples.)
You only need to seek one head to find a particular cylinder, so that both heads may read/write that cylinder.
</p>
<h3><span class="mw-headline" id="CHS">CHS</span></h3>
<p>Floppy drives use CHS addressing exclusively. There are always 2 heads (sides), but the driver (and controller) must also know how many cylinders and
sectors per track the media expects. Typically, as said above, it is 80 cylinders and 18 sectors per track. In usual CHS fashion,
the cylinders and heads are counted starting with a 0 base, but the sector numbers start counting from 1. That is, legal cylinder
numbers are typically 0 to 79 inclusive, heads are 0 or 1, and sector numbers are 1 to 18 inclusive. Asking for sector number 0
is always highly illegal and this is a major source of errors in prototype driver code.
</p><p>It is, however, much  more logical to address things in LBA (Logical Block Addressing), as the first sector is at 0 (like an array).
Conversion between the two is rather simple. The equations are as follows:
</p><p><i>CYL = LBA / (HPC * SPT)</i>
</p><p><i>HEAD = (LBA&#160;% (HPC * SPT)) / SPT</i>
</p><p><i>SECT = (LBA&#160;% (HPC * SPT))&#160;% SPT + 1</i>
</p><p><i>LBA = ( ( CYL * HPC + HEAD ) * SPT ) + SECT - 1</i>
</p><p>This can be described in C with the following code:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">lba_2_chs</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="o">*</span><span class="w"> </span><span class="n">cyl</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="o">*</span><span class="w"> </span><span class="n">sector</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">cyl</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">lba</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FLOPPY_144_SECTORS_PER_TRACK</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">head</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">lba</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FLOPPY_144_SECTORS_PER_TRACK</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">FLOPPY_144_SECTORS_PER_TRACK</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">sector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">lba</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FLOPPY_144_SECTORS_PER_TRACK</span><span class="p">))</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">FLOPPY_144_SECTORS_PER_TRACK</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>You would then send this data to the floppy controller.
</p>
<h3><span class="mw-headline" id="DMA_Data_Transfers">DMA Data Transfers</span></h3>
<p>The floppy typically uses ISA DMA (which is <b>not</b> the same thing as PCI BusMastering DMA) to do data transfers. The floppy
is hardwired to DMA channel 2. The only other way of doing data transfers is called "PIO Mode" (see below).
</p><p>To do DMA data transfers:
Set up DMA channel 2 (as in the <a href="DMA" class="mw-redirect" title="DMA">DMA</a> article) -- by setting the total transfer bytecount - 1, the target buffer physical address,
and the transfer direction.
</p><p>init/reset the controller if needed (see below), select the drive if needed (see below),
set up the floppy controller for DMA using the "specify" command,
seek to the correct cylinder, issue a sense interrupt command, then issue the standard read/write commands. The data transfer happens invisibly.
The controller will send an IRQ6 when the transfer is complete. Then read the "result" bytes to see if there were any errors.
See below for more detail.
</p>
<h3><span class="mw-headline" id="PIO_Data_Transfers">PIO Data Transfers</span></h3>
<p>PIO data transfers can either be done using polling or interrupts. Using PIO mode can transfer data 10 percent faster than a DMA
transfer, but there is an immense cost in CPU cycle requirements. However, if your OS or application is single-tasking, then there
is nothing else that the CPU cycles can be used for anyway, so you may as well use PIO mode.
</p><p>In general, the controller has a 16 byte buffer, and wants to send an IRQ6 whenever the buffer count reaches a "threshold" value that
is set by your driver. If you are using PIO mode floppy transfers in a multitasking environment (bad idea), then the IRQ6 events should
be used to fill or drain the floppy controller's buffer via some system buffer, in the interrupt handler code.
</p><p>If you are using PIO mode in a singletasking environment then the IRQ6s just waste CPU cycles, and you should be using polling instead.
You can usually shut the IRQs off by setting bit 3 (value = 8) of the Digital Output Register (see below). If you want, you can even
toggle that bit on and off for specific commands, so that you receive some types of interrupts but not others.
</p><p>To do PIO data transfers: init/reset the controller if needed (see below), select the drive if needed (see below),
seek to the correct cylinder, issue a sense interrupt command, then issue the standard read/write commands.
After you send the command, either poll the RQM bit in the Main Status Register to determine when the controller wants to have data moved
in/out of the FIFO buffer -- or wait for an IRQ6 to do the same thing. When the transfer is complete, read the "result" bytes to see
if there were any errors. See below for more detail.
</p>
<h4><span id="Bochs_Can.27t_Handle_Polling_PIO"></span><span class="mw-headline" id="Bochs_Can't_Handle_Polling_PIO">Bochs Can't Handle Polling PIO</span></h4>
<p>If you try to turn off the IRQs in Bochs (to use pure polling PIO mode), Bochs will panic. It may also not be able to handle
non-DMA data transfers properly, even if IRQs are turned on. It is currently mainly designed to model the floppy using DMA.
</p>
<h3><span id="There_are_3_.22Modes.22"></span><span class="mw-headline" id="There_are_3_&quot;Modes&quot;">There are 3 "Modes"</span></h3>
<p>There were several generations of floppy controller chips on several generations of 80286 (and prior) computers, before
the 82077AA chip existed. The 82077AA was built to emulate all of them, by setting various pins on the chip to 5 volts.
The three modes are: PC-AT mode, PS/2 mode, and Model 30 mode. The most likely mode you will see on any hardware that
still runs is Model 30 mode. You may find some pre-1996 Pentium machines using PS/2 mode. Sadly, most emulator programs run in PS/2 mode!
In the documentation, you can ignore PC-AT mode. Or you can try to handle all three, by only using registers and commands that are identical
in all 3 modes.
</p>
<h3><span id="Most_Commands_Run_.22Silently.22"></span><span class="mw-headline" id="Most_Commands_Run_&quot;Silently&quot;">Most Commands Run "Silently"</span></h3>
<p>There are only a few commands/conditions that produce interrupts: a reset (in polling mode only), Seek, Recalibrate, or one of the
read/write/verify/format commands. Several commands do not produce any result bytes, either. If you want to verify that a silent
command actually worked, just about the only thing you can do is use the Dumpreg command to check the current state of the
controller.
</p>
<h3><span class="mw-headline" id="Timing_Issues">Timing Issues</span></h3>
<p>On real hardware, there are definite timing issues. Seek delays and motor delays are just what any programmer would expect. It
would be nice if the drive would send an IRQ when the motor was up to speed, but it does not. Two things that you may not
expect are that quite new hardware probably still needs artificial delays between outputting "command/parameter" bytes, and that you
probably also need artificial delays between inputting "result" bytes. There is a bit in the MSR to test in order to know when the
next byte can be sent/retrieved. It is not a good idea to simply hardcode specific delays between output/input bytes.
Looping 20 times, and testing the value of the RQM bit in the MSR each time, should always be a sufficient "timeout".
</p><p>However, using IO Port reads to generate delays (or polling MSR) leads to poor performance in a multitasking environment, and
you may want to put the driver to sleep for the shortest possible period (microsleep), instead.
</p>
<h3><span class="mw-headline" id="Reliability">Reliability</span></h3>
<p>In real hardware, floppy drives are extremely unreliable. On emulators, it doesn't matter -- but for code that is intended for
real hardware, make sure to retry every command at least twice more after any error.
</p>
<h2><span class="mw-headline" id="Registers">Registers</span></h2>
<p>The floppy controller is programmed through 9 registers, which can be accessed through IO ports 0x3F0 through 0x3F7 (excluding 0x3F6). As usual on the
PC architecture, some of those IO ports access different controller registers depending on whether you read from or write to them.
Note that code snippets and datasheets name these registers based on their trigrams (e.g. SRA, MSR, DIR, CCR, etc.).
Use standard "outb" and "inb" commands to access the registers.
</p><p>The basic set of floppy registers can be found in the following enumeration:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">FloppyRegisters</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">STATUS_REGISTER_A</span><span class="w">                </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3F0</span><span class="p">,</span><span class="w"> </span><span class="c1">// read-only</span>
<span class="w">   </span><span class="n">STATUS_REGISTER_B</span><span class="w">                </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3F1</span><span class="p">,</span><span class="w"> </span><span class="c1">// read-only</span>
<span class="w">   </span><span class="n">DIGITAL_OUTPUT_REGISTER</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3F2</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">TAPE_DRIVE_REGISTER</span><span class="w">              </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3F3</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">MAIN_STATUS_REGISTER</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3F4</span><span class="p">,</span><span class="w"> </span><span class="c1">// read-only</span>
<span class="w">   </span><span class="n">DATARATE_SELECT_REGISTER</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3F4</span><span class="p">,</span><span class="w"> </span><span class="c1">// write-only</span>
<span class="w">   </span><span class="n">DATA_FIFO</span><span class="w">                        </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3F5</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">DIGITAL_INPUT_REGISTER</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3F7</span><span class="p">,</span><span class="w"> </span><span class="c1">// read-only</span>
<span class="w">   </span><span class="n">CONFIGURATION_CONTROL_REGISTER</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3F7</span><span class="w">  </span><span class="c1">// write-only</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>All commands, parameter information, result codes, and disk data transfers go through the FIFO port.
MSR contains the "busy" bitflags, that must be checked before reading/writing each byte through the FIFO.
DOR controls the floppy drive motors, floppy drive "selection", and resets.
The other registers contain very little information, and are typically accessed very little, if at all.
</p><p>Note: IO port 0x3F6 is the ATA (hard disk) Alternate Status register, and is not used by any floppy controller.
</p><p>Note2: some people prefer to give the registers values based on their offset from the base address, and then add the
FDC's base address (0x3F0 or 0x370). So STATUS_REGISTER_A would have value 0, STATUS_REGISTER_B value 1, etc., and to
access STATUS_REGISTER_B on FDC 1, you would use FDC1_BASE_ADDRESS + STATUS_REGISTER_B = 0x370 + 1 = 0x371.
</p><p>As said above, the most common controller chip has 3 modes, and many bitflags in the registers are different (or opposite!) depending on
the mode. However, all of the important registers and bitflags remain the same between modes.
They are the following:
</p>
<h3><span class="mw-headline" id="FIFO">FIFO</span></h3>
<p>FIFO: The FIFO register may not have a 16byte buffer in all modes, but this is a minor difference that does not really affect its operation.
</p>
<h3><span class="mw-headline" id="Tape_Drive_Register">Tape Drive Register</span></h3>
<p>TDR: The Tape Drive Register is a R/W register which is identical in all modes. According to the documentation for the Intel 82077AA, the two least significant bits form a number between 1 and 3 (0 is an invalid value, drive 0 may not be selected) that assigns tape support to one particular drive out of four total drives. It is probably irrelevant for modern uses, is not supported by any emulator and is probably not worth implementing support for unless you have all the real hardware to test this functionality on.
</p>
<h3><span class="mw-headline" id="DOR_bitflag_definitions">DOR bitflag definitions</span></h3>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Mnemonic
</th>
<th>bit number
</th>
<th>value
</th>
<th>meaning/usage
</th></tr>
<tr>
<td>MOTD
</td>
<td>7
</td>
<td>0x80
</td>
<td>Set to turn drive 3's motor ON
</td></tr>
<tr>
<td>MOTC
</td>
<td>6
</td>
<td>0x40
</td>
<td>Set to turn drive 2's motor ON
</td></tr>
<tr>
<td>MOTB
</td>
<td>5
</td>
<td>0x20
</td>
<td>Set to turn drive 1's motor ON
</td></tr>
<tr>
<td>MOTA
</td>
<td>4
</td>
<td>0x10
</td>
<td>Set to turn drive 0's motor ON
</td></tr>
<tr>
<td>IRQ
</td>
<td>3
</td>
<td>8
</td>
<td>Set to enable IRQs and DMA
</td></tr>
<tr>
<td>RESET
</td>
<td>2
</td>
<td>4
</td>
<td>Clear = enter reset mode, Set = normal operation
</td></tr>
<tr>
<td>DSEL1 and 0
</td>
<td>0, 1
</td>
<td>3
</td>
<td>"Select" drive number for next access
</td></tr></tbody></table>
<p>Note: the IRQ/DMA enable bit (bit 3, value = 8) cannot be cleared in "PS/2 mode", so for PIO transfers you should make sure to have a stubbed IRQ6 handler
in place, just in case the IRQs happen anyway. The bit <b>must</b> be set for DMA to function.
</p><p>Note2: if you want to execute a command that accesses a disk (see the command list below), then that respective disk must have its
motor spinning (and up to speed), <b>and</b> its "select" bits must be set in the DOR, <b>first</b>.
</p><p>Note3: toggling DOR reset state requires a 4 microsecond delay. It may be smarter to use DSR reset mode, because
the hardware "untoggles" reset mode automatically after the proper delay.
</p>
<h3><span class="mw-headline" id="MSR_bitflag_definitions">MSR bitflag definitions</span></h3>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Mnemonic
</th>
<th>bit number
</th>
<th>value
</th>
<th>meaning/usage
</th></tr>
<tr>
<td>RQM
</td>
<td>7
</td>
<td>0x80
</td>
<td>Set if it's OK (or mandatory) to exchange bytes with the FIFO IO port
</td></tr>
<tr>
<td>DIO
</td>
<td>6
</td>
<td>0x40
</td>
<td>Set if FIFO IO port expects an IN opcode
</td></tr>
<tr>
<td>NDMA
</td>
<td>5
</td>
<td>0x20
</td>
<td>Set in Execution phase of PIO mode read/write commands only.
</td></tr>
<tr>
<td>CB
</td>
<td>4
</td>
<td>0x10
</td>
<td>Command Busy: set when command byte received, cleared at end of Result phase
</td></tr>
<tr>
<td>ACTD
</td>
<td>3
</td>
<td>8
</td>
<td>Drive 3 is seeking
</td></tr>
<tr>
<td>ACTC
</td>
<td>2
</td>
<td>4
</td>
<td>Drive 2 is seeking
</td></tr>
<tr>
<td>ACTB
</td>
<td>1
</td>
<td>2
</td>
<td>Drive 1 is seeking
</td></tr>
<tr>
<td>ACTA
</td>
<td>0
</td>
<td>1
</td>
<td>Drive 0 is seeking
</td></tr></tbody></table>
<p>The two important bits are RQM and DIO. NDMA and BUSY are also useful in polling PIO mode.
Most important is RQM, which is set when it is OK (or necessary!) to read/write data from/to the FIFO port.
NDMA signals the end of the "execution phase" of a command, and the beginning of "result phase".
DIO and BUSY should be checked to verify proper command termination (the end of "result phase" and beginning of "command phase").
</p>
<h3><span class="mw-headline" id="CCR_and_DSR">CCR and DSR</span></h3>
<p>The bottom 2 bits of DSR match CCR, and setting one of them sets the other. The upper 6 bits on both DSR and CCR default to 0, and
can always be set to zero safely. So, even though they have different bit definitions, you always set them with identical values, and
one or the other of DSR and CCR can be ignored in any modern system.
Alternately, you can always set both of them, for maximum compatibility with ancient chipsets.
</p><p>The bottom 2 bits specify the data transfer rate to/from the drive. You want both bits set to zero for a 1.44MB or 1.2MB floppy drive.
So generally, you want to set CCR to zero just once, after bootup (because the BIOS may not have done it, unless it booted a floppy disk).
</p><p>Note: a reset procedure does not affect this register. However, if you have drives of different types on the bus which
use different datarates, then you need to switch the datarate when you select the other drive. It also seems to be possible
to modify this register while the FDC is in "reset state".
</p><p>Note2: some tutorials seem to claim that changing/setting the datarate causes an IRQ6. This is false.
</p><p>Datarates used for setting either DSR or CCR:
</p>
<pre>Datarate   value   Drive Type
1Mbps        3       2.88M
500Kbps      0       1.44M, 1.2M
</pre>
<p>Note: There is also a 300Kbps (value = 1), and a 250Kbps setting (value = 2) but they are only for utterly obsolete drives/media.
</p>
<h3><span id="DIR_register.2C_Disk_Change_bit"></span><span class="mw-headline" id="DIR_register,_Disk_Change_bit">DIR register, Disk Change bit</span></h3>
<p>This bit (bit 7, value = 0x80) is fairly useful. It gets set if the floppy door was opened/closed. Sadly, almost all the emulator
programs set and clear this bit completely inappropriately (especially after a reset).
Do not trust your handling of this bit until you have tested the functionality on real hardware.
</p><p>Note: The datasheet is very confusing about the value of the bit, because Model 30 mode shows the bit as being inverted. But
in Model 30 mode, the <b>signal</b> is also inverted, so it comes out the same. "False" always means the bit is cleared, and
"true" always means the bit is set.
</p><p>Note2: You must turn on the drive motor bit before you access the DIR register for a selected drive (you do not have to wait
for the motor to spin up, though). It may also be necessary to read the register five times (discard the first 4 values) when
<b>changing</b> the selected drive -- because "selecting" sometimes takes a little time.
</p><p>Basically, you want to keep a flag for whether there is media in each drive. If Disk Change is set and there was media,
the OS should get a signal that the previous media was ejected.
</p><p>Once the Disk Change bit signals "true" (and you have processed that "event"), you need to try to clear the bit. The main way to
clear the bit is with a <b>successful</b> Seek/Recalibrate to a <b>new</b> cylinder on the media. (A reset does not work. If the
controller thinks the heads are already on the correct cylinder, it will eat a Seek command without clearing the Disk
Change bit. If the heads are already on cylinder 0, a Recalibrate is also a no-op.) If the seek <b>fails</b>, you can be fairly
certain that there is no media in the drive anymore. It is important to note that
this means you should check the value of Disk Change just prior to every Seek command that you do, because otherwise you
will lose any Disk Change information. This is also true for implied seeks, and relative seeks.
</p><p>Apparently a small number of floppy drives also support one additional way to clear the bit -- something that
Linux calls a "twaddle". Simply toggle the drive motor bit on, off, and then on again. When your driver tries to clear the
Disk Change bit the first time, it can try a twaddle, and see if it works, and keep a flag if it does.
</p><p><br />
</p>
<h2><span class="mw-headline" id="Programming_Details">Programming Details</span></h2>
<p>Overall, the controller needs to be initialized and reset once (see below for the steps involved). Then drives can be
accessed. To access drives:
</p>
<ol><li>Turn on the drive's motor and select the drive, using an "outb" command to the DOR IO port.</li>
<li>Wait for awhile for the motor to get up to speed, using some waiting scheme.</li>
<li>Issue your command byte plus some parameter bytes (the "command phase") to the FIFO IO port.</li>
<li>Exchange data with the drive / "seek" the drive heads (the "execution phase"), on the FIFO IO port.</li>
<li>Get an IRQ6 at the end of the execution phase, but <b>only if the command HAS an execution phase</b>.</li>
<li>Read any "result bytes" produced by the command (the "result phase"), on the FIFO IO port.</li>
<li>The commands "Recalibrate", "Seek", and "Seek Relative" do not have a result phase, and require an additional "Sense Interrupt" command to be sent.</li></ol>
<p>And then you are ready for the next command. See below for more detail on how to issue a command.
</p>
<h3><span class="mw-headline" id="Motor_Delays">Motor Delays</span></h3>
<p>Note: the Linux floppy driver sourcecode has a comment that claims that turning on the MOTC or MOTD bits in the DOR
can completely lock up some systems. This claim seems unlikely?
</p><p>When you turn a floppy drive motor on, it takes quite a few milliseconds to "spin up" -- to reach the (stabilized) speed
needed for data transfer. The controller has electronics to handle a large variation in rotation speed, but it has its limits.
If you start reading/writing immediately after the motor is turned on, "the PLL will fail to lock on to the data signal" and you will get an error.
</p><p>After you are done reading (or writing), you should typically wait an additional two seconds to turn the motor off. (It may also be smart
to seek the heads back to cylinder 0 just before turning the motor off.) You could leave the motor on longer,
but it might give the user the idea that the floppy is still transferring data and that it's taking an awfully long time.
The reason to leave the motor on is that your driver may not know if there is a queue of sector reads or writes
that are going to be executed next. If there are going to be more drive accesses immediately, they won't need to wait
for the motor to spin up.
</p><p>The suggested delays when turning the motor on are:
</p>
<ul><li>300 milliseconds (for a 3.5" floppy).</li>
<li>500 milliseconds (for a 5.25" floppy).</li></ul>
<p>These values should be more than enough for any floppy drive to spin up correctly. 50ms should be sufficient, in fact.
</p><p>Another functional method is not delaying or waiting at all, but just enter a loop and keep retrying any command until it works.
A 3.5 inch disk rotates once every 200ms, so each retry is effectively a delay.
</p>
<h3><span class="mw-headline" id="Gap_Lengths">Gap Lengths</span></h3>
<p>There are two different gap lengths that are controlled by software for specifying the amount of blank space between sectors.
The gap lengths are used by the floppy hardware to help find the "start of sector" markers, and to avoid problems caused by speed variations
in different floppy drives (for e.g. writing a sector on a slower drive would cause the sector to take up more physical space on the disk,
potentially overwriting the next sector). The first gap length (typically called "GPL1") is used when reading or writing data, and sets the
length of the gap between sectors that the floppy should expect (but doesn't change this gap). The second (typically called "GPL2")
is the gap length for the "format track" command, which specifies the amount of space between sectors to use. The actual gap lengths depend on many factors,
but GPL1 is always a bit less than GPL2 so that the floppy hardware starts expecting the next sector near the end of the blank space.
</p><p>Standard values for these gap lengths can be found in the floppy controller datasheets. However, it is possible to squeeze more sectors
on each track by reducing the gap length. For example, by using a gap length of 0x1C when formatting (and 0x0C when reading/writing)
instead of 0x54 (and 0x1B when reading/writing) it's possible to format a normal 1440 KB floppy disk with 21 sectors per track to create
a 1680Kb floppy disk. These disks may be unreliable on very old computers (where accuracy and speed variation may be worse),
but were considered reliable enough for Microsoft to distribute a version of Windows on 1680Kb floppies (Windows 95 on a set of 12 floppies).
It is also possible to format 3 extra cylinders on each disk, for a total of 83.
</p>
<h3><span class="mw-headline" id="Hardware_Control_of_Bad_Cylinders">Hardware Control of Bad Cylinders</span></h3>
<p>The FDC subsystem has a built-in method for handling unreliable media. However, it is probably not a good idea to use it.
It involves finding a bad sector on the media, and then marking the entire track or cylinder as being bad, during the formatting process.
</p><p>If you try to do this, then you cannot simply seek to a cylinder. All of the cylinders get "remapped" with new "TrackID"s. Whenever
you seek to a cylinder, then you need to use the ReadID command to verify that the cylinder you seeked to contains the data that you
actually want. So this eliminates any possibility of using implied seeks, and adds an extra step to most read/write operations.
</p>
<h3><span class="mw-headline" id="Procedures">Procedures</span></h3>
<h4><span class="mw-headline" id="Reinitialization">Reinitialization</span></h4>
<p>The BIOS probably leaves the controller in its default state. "Drive polling mode" on, FIFO off, threshold = 1, implied seek off,
lock off. This is a lousy state for the controller to be in, and your OS will need to fix it. The BIOS probably also does not have
any better guess as to the proper values for the "Specify" command than your OS does (the values are specific to the particular
drive). There is certainly no reason why you should trust the BIOS to have done any of it <b>correctly.</b>
</p><p>So, when your OS is initializing:
</p>
<ol><li>Send a Version command to the controller.</li>
<li>Verify that the result byte is 0x90 -- if it is not, it might be a good idea to abort and not support the floppy subsystem. Almost all of the code based on this article will work, even on the oldest chipsets -- but there are a few commands that will not.</li>
<li>If you don't want to bother having to send another Configure command after every Reset procedure, then:
<ol><li>Send a better Configure command to the controller. A suggestion would be: drive polling mode off, FIFO on, threshold = 8, implied seek on, precompensation 0.</li>
<li>send a Lock command.</li></ol></li>
<li>Do a Controller Reset procedure.</li>
<li>Send a Recalibrate command to each of the drives.</li></ol>
<h4><span class="mw-headline" id="Controller_Reset">Controller Reset</span></h4>
<p>The second most common failure mode for any floppy command is for the floppy controller to lock up forever. This
condition is detected with a timeout, and needs to be fixed with a Reset. You also need one Reset during initialization. Hopefully, it is
the only one you will ever need to do.
</p>
<ol><li>Either use:
<ol><li>Bit 2 (value = 4) in the DOR: Save the current/"original" value of the DOR, write a 0 to the DOR, wait 4 microseconds, then write the original value (bit 2 is always set) back to the DOR.</li>
<li><b>or</b> Bit 7 (value = 0x80) in the DSR: Precalculate a good value for the DSR (generally 0), and OR it with 0x80. Write that value to the DSR.</li></ol></li>
<li>Wait for the resulting IRQ6 (unless you have IRQs turned off in the DOR)</li>
<li>If (and only if) <a href="Floppy#Configure">drive polling mode</a> is turned on, send 4 Sense Interrupt commands (required).</li>
<li>If your OS/driver never sent a Lock command, then you probably need to send a new Configure command (the fifo settings were lost in the reset).</li>
<li>Do a Drive Select procedure for the next drive to be accessed.</li></ol>
<p>Note: A reset clears all the Specify information, so the next Select procedure must send a new Specify command (use some sort of flag to tell the
driver to do this).
</p><p>Note2: Emulators will often set the Disk Change flag to "true" after a reset, <b>but this does not happen on real hardware</b> -- it is
a shared bug in all the emulators that do it. Another shared bug is that most emulators do not fire an IRQ6 if disk polling mode is off.
</p><p>Note3: A reset does not change the <a href="Floppy#Configure">drive polling mode or implied seek</a> settings.
</p>
<h4><span class="mw-headline" id="Drive_Selection">Drive Selection</span></h4>
<p>Each floppy drive on the system may be a different type. When switching between accessing different types of drives, you need
to fix the Specify and Datarate settings in the controller. The controller does <b>not</b> remember the settings on a per-drive
basis. The only per-drive number that it remembers is the current cylinder.
</p>
<ol><li>Send the correct Datarate setting to CCR. Usually this is a 0 (1.44MB floppy drive).</li>
<li>If the newly selected drive is a different type than the previously selected drive (or changing from PIO to DMA mode), send a new Specify command.</li>
<li>Set the "drive select" bits (and the other bitflags) in DOR properly, including possibly turning on the Motor bit for the drive (if it will be accessed soon).</li></ol>
<h4><span class="mw-headline" id="Detecting_Media">Detecting Media</span></h4>
<p>The user can swap media out of a floppy drive at any moment. If your driver sends a command to the drive, and the
command fails -- this may be the reason why.
</p>
<ol><li>Turn the drive motor bit on.</li>
<li>Read DIR. If the "Disk Change" bitflag is set to "true", then the floppy drive door was opened, so the OS needs to test if a new disk is in the drive.</li></ol>
<h4><span class="mw-headline" id="Waiting">Waiting</span></h4>
<p>Waiting for the drive can be done in many ways, and it is an OS-specific design decision. You can poll the value of
the PIT, waiting for it to count down to a certain value. You can poll a memory location that contains "the current time"
in some format, waiting for it to reach a certain value. Your OS can implement a realtime callback, where a particular function
in the driver will be called at a particular time. Or you can implement some form of multitasking "blocking", where the driver
process is put in a "sleep" state, and is not assigned any timeslices for a certain length of time.
</p>
<h4><span class="mw-headline" id="The_Proper_Way_to_issue_a_command">The Proper Way to issue a command</span></h4>
<ol><li>Read MSR (port 0x3F4).</li>
<li>Verify that RQM = 1 and DIO = 0 ((Value &amp; 0xc0) == 0x80) -- if not, reset the controller and start all over.</li>
<li>Send your chosen command byte to the FIFO port (port 0x3F5).</li>
<li>In a loop: loop on reading MSR until RQM = 1. Verify DIO = 0, then send the next parameter byte for the command to the FIFO port.</li>
<li>Either Execution or Result Phase begins when all parameter bytes have been sent, depending on whether you are in PIO mode, and the command has an Execution phase. If using DMA, or the command does not perform read/write/head movement operations, skip to the Result Phase.</li>
<li>(In PIO Mode Execution phase) read MSR, verify NDMA = 1 ((Value &amp; 0x20) == 0x20) -- if it's not set, the command has no Execution phase, so skip to Result phase.</li>
<li>begin a loop:</li>
<li>Either poll MSR until RQM = 1, or wait for an IRQ6, using some waiting method.</li>
<li>In an inner loop: transfer a byte in or out of the FIFO port via a system buffer, then read MSR. Repeat while RQM = 1 and NDMA = 1 ((Value &amp; 0xa0) == 0xa0).</li>
<li>if NDMA = 1, loop back to the beginning of the outer loop, unless your data buffer ran out (detect underflow/overflow).</li>
<li>Result Phase begins. If the command does not have a Result phase, it silently exits to waiting for the next command.</li>
<li>If using DMA on a read/write command, wait for a terminal IRQ6.
<ol><li>Loop on reading MSR until RQM = 1, verify that DIO = 1.</li>
<li>In a loop: read the next result byte from the FIFO, loop on reading MSR until RQM = 1, verify CMD BSY = 1 and DIO = 1 ((Value &amp; 0x50) == 0x50).</li></ol></li>
<li>After reading all the expected result bytes: check them for error conditions, verify that RQM = 1, CMD BSY = 0, and DIO = 0. <b>If not</b> retry the entire command again, several times, starting from step 2!</li></ol>
<p>Note: implementing a failure timeout for each loop and the IRQ is pretty much required -- it is the only way to detect many command errors.
</p>
<h3><span class="mw-headline" id="Commands">Commands</span></h3>
<p>Each command is a single byte with a value less than 32, which is written to the DATA_FIFO port. There are three "option bits"
that can be OR'ed onto some command bytes, typically called MF, MT, and SK. Each command must be followed by a specific set of
"parameter bytes", and returns a specific set of "result bytes". See the discussion of each command for its list of parameter bytes,
and result bytes.
</p><p>A command byte may only be sent to the FIFO port if the RQM bit is 1 and the DIO bit is 0, in the MSR. If these
bits are not correct, then the previous command encountered a fatal error, and you must issue a <a href="Floppy#Controller_Reset">reset</a>.
</p><p>The following is an enumeration of the values of the command bytes. The ones that you actually will <b>use</b> are marked
with a * and a comment.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">FloppyCommands</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">READ_TRACK</span><span class="w"> </span><span class="o">=</span><span class="w">                 </span><span class="mi">2</span><span class="p">,</span><span class="w">	</span><span class="c1">// generates IRQ6</span>
<span class="w">   </span><span class="n">SPECIFY</span><span class="w"> </span><span class="o">=</span><span class="w">                    </span><span class="mi">3</span><span class="p">,</span><span class="w">      </span><span class="c1">// * set drive parameters</span>
<span class="w">   </span><span class="n">SENSE_DRIVE_STATUS</span><span class="w"> </span><span class="o">=</span><span class="w">         </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">WRITE_DATA</span><span class="w"> </span><span class="o">=</span><span class="w">                 </span><span class="mi">5</span><span class="p">,</span><span class="w">      </span><span class="c1">// * write to the disk</span>
<span class="w">   </span><span class="n">READ_DATA</span><span class="w"> </span><span class="o">=</span><span class="w">                  </span><span class="mi">6</span><span class="p">,</span><span class="w">      </span><span class="c1">// * read from the disk</span>
<span class="w">   </span><span class="n">RECALIBRATE</span><span class="w"> </span><span class="o">=</span><span class="w">                </span><span class="mi">7</span><span class="p">,</span><span class="w">      </span><span class="c1">// * seek to cylinder 0</span>
<span class="w">   </span><span class="n">SENSE_INTERRUPT</span><span class="w"> </span><span class="o">=</span><span class="w">            </span><span class="mi">8</span><span class="p">,</span><span class="w">      </span><span class="c1">// * ack IRQ6, get status of last command</span>
<span class="w">   </span><span class="n">WRITE_DELETED_DATA</span><span class="w"> </span><span class="o">=</span><span class="w">         </span><span class="mi">9</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">READ_ID</span><span class="w"> </span><span class="o">=</span><span class="w">                    </span><span class="mi">10</span><span class="p">,</span><span class="w">	</span><span class="c1">// generates IRQ6</span>
<span class="w">   </span><span class="n">READ_DELETED_DATA</span><span class="w"> </span><span class="o">=</span><span class="w">          </span><span class="mi">12</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">FORMAT_TRACK</span><span class="w"> </span><span class="o">=</span><span class="w">               </span><span class="mi">13</span><span class="p">,</span><span class="w">     </span><span class="c1">// *</span>
<span class="w">   </span><span class="n">DUMPREG</span><span class="w"> </span><span class="o">=</span><span class="w">                    </span><span class="mi">14</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">SEEK</span><span class="w"> </span><span class="o">=</span><span class="w">                       </span><span class="mi">15</span><span class="p">,</span><span class="w">     </span><span class="c1">// * seek both heads to cylinder X</span>
<span class="w">   </span><span class="n">VERSION</span><span class="w"> </span><span class="o">=</span><span class="w">                    </span><span class="mi">16</span><span class="p">,</span><span class="w">	</span><span class="c1">// * used during initialization, once</span>
<span class="w">   </span><span class="n">SCAN_EQUAL</span><span class="w"> </span><span class="o">=</span><span class="w">                 </span><span class="mi">17</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">PERPENDICULAR_MODE</span><span class="w"> </span><span class="o">=</span><span class="w">         </span><span class="mi">18</span><span class="p">,</span><span class="w">	</span><span class="c1">// * used during initialization, once, maybe</span>
<span class="w">   </span><span class="n">CONFIGURE</span><span class="w"> </span><span class="o">=</span><span class="w">                  </span><span class="mi">19</span><span class="p">,</span><span class="w">     </span><span class="c1">// * set controller parameters</span>
<span class="w">   </span><span class="n">LOCK</span><span class="w"> </span><span class="o">=</span><span class="w">                       </span><span class="mi">20</span><span class="p">,</span><span class="w">     </span><span class="c1">// * protect controller params from a reset</span>
<span class="w">   </span><span class="n">VERIFY</span><span class="w"> </span><span class="o">=</span><span class="w">                     </span><span class="mi">22</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">SCAN_LOW_OR_EQUAL</span><span class="w"> </span><span class="o">=</span><span class="w">          </span><span class="mi">25</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">SCAN_HIGH_OR_EQUAL</span><span class="w"> </span><span class="o">=</span><span class="w">         </span><span class="mi">29</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<h4><span id=".22Deleted_sectors.22"></span><span class="mw-headline" id="&quot;Deleted_sectors&quot;">"Deleted sectors"</span></h4>
<p>Deleted sectors is a legacy feature, dating back to the 1970s, when IBM data entry terminals stored a single database record in each (128 byte) floppy sector, and a record could be marked as deleted by writing a different address mark before the sector. This feature was almost never used with IBM PC and compatibles  exceptions were occasional abuse by copy protection schemes, and (possibly) hiding bad sectors. Few (if any) emulators emulate this functionality, and many late model FDCs didn't implement it.
</p><p>The "WRITE_DELETED_DATA" command can be used to create a deleted sector, and the "READ_DELETED_DATA" command can be used to read one back.
</p>
<h4><span class="mw-headline" id="Option_bits">Option bits</span></h4>
<p>OR these bits onto the above read/write/format/verify commands.
</p>
<h5><span class="mw-headline" id="Bit_MT">Bit MT</span></h5>
<p>Value = 0x80. Multitrack mode. The controller will switch automatically from Head 0 to Head 1
at the end of the track. This allows you to read/write twice as much data with a single command.
</p>
<h5><span class="mw-headline" id="Bit_MF">Bit MF</span></h5>
<p>Value = 0x40. "MFM" magnetic encoding mode. Always set it for read/write/format/verify operations.
</p><p>A zero value represents the old "single density" FM format, which (on IBM PCs) was only used by 8-inch floppies (which were extremely rare). Few people ever used FM format, except for data interchange with non-PC systems (such as CP/M or minicomputers). Later model FDCs (e.g. Intel 82078) dropped support for it.
</p>
<h5><span class="mw-headline" id="Bit_SK">Bit SK</span></h5>
<p>Value = 0x20. Skip mode. This skips "deleted sectors" (see explanation in section above).
</p><p>Ignore this bit and leave it cleared, unless you have a really good reason not to.
</p>
<h4><span class="mw-headline" id="Status_Registers">Status Registers</span></h4>
<p>There are 3 registers that hold information about the last error encountered. The st0 register information
is passed back with the result bytes of most commands. The st1 and st2 information is returned in the result
bytes of read/write commands. They can also be retrieved with a Dumpreg command.
</p>
<h5><span class="mw-headline" id="st0">st0</span></h5>
<p>The top 2 bits (value = 0xC0) are set after a reset procedure, with polling on. Either bit being set at any other
time is an error indication.
Bit 5 (value = 0x20) is set after every Recalibrate, Seek, or an implied seek. The other bits are not useful.
</p>
<h5><span class="mw-headline" id="st1">st1</span></h5>
<p>The st1 register provides more detail about errors during read/write operations.
</p><p>Bit 7 (value = 0x80) is set if the floppy had too few sectors on it to complete a read/write. This is often
caused by <b>not subtracting 1</b> when setting the DMA byte count.
Bit 4 (value = 0x10) is set if your driver is too slow to get bytes in or out of the FIFO port in time.
Bit 1 (value = 2) is set if the media is write protected.
The rest of the bits are for various types of data errors; indicating bad media, or a bad drive.
</p>
<h5><span class="mw-headline" id="st2">st2</span></h5>
<p>The st2 register provides more (useless) detail about errors during read/write operations.
</p><p>The bits all indicate various types of data errors for either bad media, or a bad drive.
</p><p><br />
</p>
<h4><span class="mw-headline" id="Configure">Configure</span></h4>
<p>This command initializes controller-specific values: the data buffer "threshold" value, implied seek enable, FIFO disable, polling enable.
(And "Write Precompensation".) A good setting is: implied seek on, FIFO on, drive polling mode off, threshold = 8, precompensation 0.
</p><p>If you enable implied seeks, then you don't have to send Seek commands (or Sense Interrupt commands for the Seek commands).
</p><p>If you leave the FIFO disabled, then it cannot buffer data -- you will get an IRQ6 or DMA request for every single byte (which needs
to be serviced quickly, because the very next byte will automatically cause an overflow/underflow and error out your
transfer!).
</p><p>Drive polling mode is just an annoyance that is there for backwards software compatibility. It makes you need Sense Interrupts
after every reset. Always turn it off, if you send a Configure command.
</p><p>A big "threshold" such as 15 will wait 15 bytes between interrupts. So there won't be many interrupts, but you only
have one byte left in the FIFO before it overflows/underflows and kills the r/w operation. thresh_val = threshold - 1.
</p><p>Write precompensation is a technical thing having to do with drive head magnetics. A precomp_val of 0 tells the controller/drive
to use the manufacturer default value. Use that unless you have a very good reason for setting another value.
</p>
<ul><li>Configure command = 0x13</li>
<li>First parameter byte = 0</li>
<li>Second parameter byte = (implied seek ENable &lt;&lt; 6) | (fifo <b>DIS</b>able &lt;&lt; 5) | (drive polling mode <b>DIS</b>able &lt;&lt; 4) | thresh_val (= threshold - 1)</li>
<li>Third parameter byte = precomp_val = 0</li>
<li>No result bytes.</li>
<li>No interrupt.</li></ul>
<h4><span class="mw-headline" id="Version">Version</span></h4>
<p>Returns one byte. If the value is 0x90, the floppy controller is a 82077AA.
</p>
<ul><li>Version command = 0x10</li>
<li>No parameter bytes.</li>
<li>No interrupt.</li>
<li>First result byte = 0x90</li></ul>
<h4><span class="mw-headline" id="Lock">Lock</span></h4>
<p>Under default circumstances, every Controller Reset will disable the fifo, and set the fifo threshold to 1 (thresh_val = 0).
If you change these settings with the Configure command and don't want to have to fix them after every Controller Reset,
then you can send a Lock command with the lock bit turned on. You can "unset" the lock, by sending another Lock command
with the lock bit turned off. Use the MT option bit as the lock bit.
</p>
<ul><li>Lock command = 0x94</li>
<li><b>or</b> Unlock command = 0x14</li>
<li>No parameter bytes.</li>
<li>No interrupt.</li>
<li>First result byte = lock bit &lt;&lt; 4</li></ul>
<h4><span class="mw-headline" id="Specify">Specify</span></h4>
<p>This command puts information in the controller about the next disk drive to be accessed.
</p><p><b>Important Note:</b> The controller only has one set of registers for this information. It does not <b>store</b> the information
between multiple drives. So if you are switching control between two different types of drives (with different specify values)
then you need to send a new Specify command every single time you select the other drive.
</p><p>If your driver will be using DMA to transfer data, set the NDMA bit to 0. If using PIO mode instead, set it to 1.
</p>
<ul><li>Specify command = 0x3</li>
<li>First parameter byte = SRT_value &lt;&lt; 4 | HUT_value</li>
<li>Second parameter byte = HLT_value &lt;&lt; 1 | NDMA</li>
<li>No result bytes.</li>
<li>No interrupt.</li></ul>
<h5><span id="SRT.2C_HLT_and_HUT"></span><span class="mw-headline" id="SRT,_HLT_and_HUT">SRT, HLT and HUT</span></h5>
<p>These parameters sent with the Specify command to the controller are meant to optimize drive performance, and head lifetime.
</p><p>The values are specific to the exact model, condition, and age of floppy drive installed on the system. The values sent by the driver to the
controller were always meant
to be <b>adaptive</b>. That is, your driver is theoretically supposed to keep statistics of how often Seek commands fail with the current
setting of SRT. If they always work, and your driver wants to optimize performance, then it can send a new Specify command, with the SRT
value reduced by 1. Then begin keeping new statistics. Similarly for HLT regarding Read/Write operations. As drives age and collect
dirt, the driver would automatically compensate by seeing higher statistical error rates, and increase the values of SRT and HLT.
</p><p>Keeping statistics in that way only works when the drive in question is used often. Now that internal floppy drives are nearly obsolete,
it is worthless. So the current recommendation is just to use very safe values, and forget about performance.
</p><p>If you look up spec sheets for individual floppy drives, they usually show a worst-case "track to track seek time" = SRT, but not the other two.
</p>
<ul><li>SRT = "Step Rate Time" = time the controller should wait for the head assembly to move between successive cylinders. A reasonable amount of time</li></ul>
<p>to allow for this is 3ms for modern 3.5 inch floppy drives. A very safe amount would be 6 to 8ms. To calculate the value for the SRT setting
from the given time, use "SRT_value = 16 - (milliseconds * data_rate / 500000)". For a 1.44 MB floppy and 8ms delay this gives "SRT_value =
16 - (8 * 500000 / 500000)" or a parameter value of 8.
</p>
<ul><li>HLT = "Head Load Time" = time the controller should wait between activating a head and actually performing a read/write.</li></ul>
<p>A reasonable value for this is around 10ms. A very safe amount would be 30ms. To calculate the value for the HLT setting
from the given time, use "HLT_value = milliseconds * data_rate / 1000000".
For a 1.44 MB floppy and a 10ms delay this gives "HLT_value = 10 * 500000 / 1000000" or 5.
</p>
<ul><li>HUT = "Head Unload Time" = time the controller should wait before deactivating the head. To calculate the value for the HUT setting</li></ul>
<p>from a given time, use "HUT_value = milliseconds * data_rate / 8000000".
For a 1.44 MB floppy and a 240 mS delay this gives "HUT_value = 24 * 500000 / 8000000" or 15. However, it seems likely that the smartest
thing to do is just to set the value to 0 (which is the maximum in any mode).
</p>
<h4><span class="mw-headline" id="Sense_Interrupt">Sense Interrupt</span></h4>
<p>This command's main function is to return any error code from a Seek or Recalibrate command to your driver. It also clears an internal
bitflag in the controller. It is required in three circumstances that produce interrupts.
</p>
<ol><li>After doing a Controller Reset procedure with <a href="Floppy#Configure">drive polling mode</a> turned on.</li>
<li>After the completion of a Seek command (or Relative Seek).</li>
<li>After the completion of a Recalibrate command.</li></ol>
<p>These are the only times when you should send a Sense Interrupt. You should still send them even if you have IRQs turned off in
the DOR and you are using PIO polling instead. If you send Sense Interrupt commands at other times: the command will complete, return
a 0x80, and then lock up the controller until you do a Reset.
</p>
<ul><li>Sense Interrupt command = 0x8</li>
<li>No parameter bytes.</li>
<li>No interrupt.</li>
<li>First result byte = <a href="Floppy#st0">st0</a></li>
<li>Second result byte = controller's idea of the current cylinder</li></ul>
<p>Note: if you try to read the result bytes without waiting for RQM to set, then you are likely to always get an incorrect result value
of 0. This is also likely to get your driver out of sync with the FDC for input/output. The correct value of st0 after a reset should
be 0xC0 | drive number (drive number = 0 to 3). After a Recalibrate/Seek it should be 0x20 | drive number.
</p>
<h4><span class="mw-headline" id="Recalibrate">Recalibrate</span></h4>
<p>Note: There is an error in the FDC datasheet regarding this command. Some statements say the command will try a maximum of 80 head
assembly steps. In other places it says 79 steps. The value 79 is correct.
</p><p>The motor needs to be on, and the drive needs to be selected. For this particular command, you do not have to wait for the command to
complete before selecting a different drive, and sending another Recalibrate command to it (but the Step Rates have to match, for this
to work).
</p><p>It is possible for a normal 1.44M floppy to be formatted with 83 cylinders. So, theoretically, it may take two (or more) Recalibrates
to move the head back to cylinder 0. It is a good idea to test bit 5 (value = 0x20) in <a href="Floppy#st0">st0</a> after the Sense Interrupt, and
retry the Recalibrate command if that bit is clear.
</p>
<ul><li>Recalibrate command = 0x7</li>
<li>First parameter byte = drive number = 0 to 3.</li>
<li>No result bytes.</li>
<li>The interrupt may take up to 3 seconds to arrive, so use a long timeout.</li></ul>
<p>It is possible to poll the "disk active" bits in the MSR to find out when the head movement is finished.
A Sense Interrupt command is required after this command completes, to clear it from being BUSY. (Multiple Sense Interrupts,
if you ran multiple simultaneous Recalibrates.)
</p>
<h4><span class="mw-headline" id="Seek">Seek</span></h4>
<p>The motor needs to be on, and the drive needs to be selected.
For this particular command, you do not have to wait for the command to complete before selecting a different drive, and sending another
Seek command to it. Maximum cylinder number is 255; if the disk has more, you must use the Relative Seek command, instead. There is
really no reason to ever use head 1 when seeking.
</p>
<ul><li>Seek command = 0xf</li>
<li>First parameter byte = (head number &lt;&lt; 2) | drive number (the drive number must match the currently selected drive!)</li>
<li>Second parameter byte = requested cylinder number</li>
<li>No result bytes.</li>
<li>The interrupt may take up to 3 seconds to arrive, so use a long timeout.</li></ul>
<p>It is possible to poll the "disk active" bits in the MSR to find out when the head movement is finished.
</p><p>A Sense Interrupt command is required after this command completes, to clear it from being BUSY. (Multiple Sense Interrupts,
if you ran multiple Seeks.)
</p><p>Note: the controller tries to remember what cylinder each drive's heads are currently on. If you try to seek to that same
cylinder, then the controller will silently ignore the command (and return a "success" value). One of the things this means
is that you can get a "success" return value on a seek <b>even if there is no media in the drive</b>, if you happen to seek
to the wrong cylinder number.
</p>
<h5><span class="mw-headline" id="Relative_seek">Relative seek</span></h5>
<p>The normal Seek command allows you to select an absolute cylinder number from 0 to 255. It is also possible to use a "relative"
seek command in all situations, and especially for drives that have more than 255 cylinders (there are none, currently).
</p><p>To use a relative seek, set the MT bit to 1. To seek to higher cylinder numbers set the MFM bit -- clear MFM to seek
backwards to lower cylinder numbers. If you seek past cylinder 255, there are a lot of extra complications.
Otherwise, the command behaves identically to regular Seek.
</p>
<h4><span id="Read.2FWrite"></span><span class="mw-headline" id="Read/Write">Read/Write</span></h4>
<p>Note: Remember that this is in CHS format, so the sector number starts at 1.
</p>
<ul><li>Read command = MT bit | MFM bit | 0x6</li>
<li>or Write command = MT bit | MFM bit | 0x5</li>
<li>First parameter byte = (head number &lt;&lt; 2) | drive number (the drive number must match the currently selected drive!)</li>
<li>Second parameter byte = cylinder number</li>
<li>Third parameter byte = head number (yes, this is a repeat of the above value)</li>
<li>Fourth parameter byte = starting sector number</li>
<li>Fifth parameter byte = 2 (all floppy drives use 512bytes per sector)</li>
<li>Sixth parameter byte = EOT (end of track, the last sector number on the track)</li>
<li>Seventh parameter byte = 0x1b (GAP1 default size)</li>
<li>Eighth parameter byte = 0xff (all floppy drives use 512bytes per sector)</li></ul>
<ul><li>First result byte = <a href="Floppy#st0">st0</a> status register</li>
<li>Second result byte = <a href="Floppy#st1">st1</a> status register</li>
<li>Third result byte = <a href="Floppy#st2">st2</a> status register</li>
<li>Fourth result byte = cylinder number</li>
<li>Fifth result byte = ending head number</li>
<li>Sixth result byte = ending sector number</li>
<li>Seventh result byte = 2</li></ul>
<p>Note: if you try to read the result bytes without waiting for RQM to set, then you are likely to always get an incorrect result
value of 0. This is also likely to get your driver out of sync with the FDC for input/output.
</p><p>Note2: You'll see that there's no sector count parameter. Instead, the FDC figures out when to stop by the DMA signaling to the FDC
that it's done, or in PIO mode, by the FDC experiencing a FIFO overrun or underrun.
</p><p>Note3: Floppy media and electronics are well known for being unreliable. Any read or write command that fails should be retried
at least twice, unless it was a write and failed on "write protect".
</p>
<h3><span class="mw-headline" id="Perpendicular_Mode_and_2.88M_floppies">Perpendicular Mode and 2.88M floppies</span></h3>
<p>If you are using an emulator and you need a floppy disk image that is bigger than 1440Kb, there is a 2880Kb image available.
In order to access it in Pmode, you need to modify your driver to handle Perpendicular Mode. Basically, it is an extra configuration
command where you enable any of the four drives for perpendicular mode.
</p><p>Note: If the parameter byte is 0 (except for the "perpendicular enable" bits), then a reset will not affect the settings.
</p>
<ul><li>Perpendicular Mode command = 0x12</li>
<li>First parameter byte = (Drive 3 enable &lt;&lt; 5) | (Drive 2 enable &lt;&lt; 4) | (Drive 1 enable &lt;&lt; 3) | (Drive 0 enable &lt;&lt; 2)</li>
<li>No result bytes.</li>
<li>No interrupt.</li></ul>
<p>You also need to set CCR/DSR for the 1M datarate (value = 3) to access a 2.88M drive.
</p>
<h3><span class="mw-headline" id="Additional_Programming_Notes">Additional Programming Notes</span></h3>
<p>If you are doing a transfer between 2 floppy drives (so that both motors are on), and you are toggling "selection" between the two,
there may be a short delay required.
</p>
<h2><span class="mw-headline" id="Code_Examples">Code Examples</span></h2>
<h3><span class="mw-headline" id="A_common_coding_error_example">A common coding error example</span></h3>
<p>The following code intentionally contains a common bug that causes an infinite loop (waiting for IRQ6) on most emulators.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">volatile</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">ReceivedIRQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="c1">// This function gets called when an IRQ6 is generated.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">FloppyHandler</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">ReceivedIRQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Waits for an IRQ to be issued.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">WaitForIRQ</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">ReceivedIRQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">ReceivedIRQ</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// buggy example Controller Reset function</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">ResetFloppy</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">DisableController</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">EnableController</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">WaitForIRQ</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Sure this code <i>looks</i> OK, but some emulators or floppy drives might manage to be faster than your code. What if you've just returned from
<i>EnableController()</i> and the floppy already issued the IRQ6? Then <i>ReceivedIRQ</i> will be set to true, your driver will enter <i>WaitForIRQ()</i>,
set it to false again and then infinitely loop, waiting for an IRQ that has already been received. It's usually better to do something like:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">volatile</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">ReceivedIRQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="c1">// This function gets called when an IRQ6 is generated.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">FloppyHandler</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">ReceivedIRQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// pretty good Controller Reset function (it should do more checking of MSR)</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">ResetFloppy</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ReceivedIRQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> 	</span><span class="c1">// This will prevent the FDC from being faster than us!</span>

<span class="w">    </span><span class="c1">// Enter, then exit reset mode.</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="n">Controller</span><span class="p">.</span><span class="n">DOR</span><span class="p">,</span><span class="mh">0x00</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="n">Controller</span><span class="p">.</span><span class="n">DOR</span><span class="p">,</span><span class="mh">0x0C</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">ReceivedIRQ</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">	</span><span class="c1">// Wait for the IRQ handler to run</span>

<span class="w">    </span><span class="c1">// sense interrupt -- 4 of them typically required after a reset</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="o">--</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">send_command</span><span class="p">(</span><span class="n">SENSE_INTERRUPT</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="n">read_data_byte</span><span class="p">();</span><span class="w"></span>
<span class="w">       </span><span class="n">read_data_byte</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="n">controller</span><span class="p">.</span><span class="n">CCR</span><span class="p">,</span><span class="mh">0x00</span><span class="p">);</span><span class="w">	</span><span class="c1">// 500Kbps -- for 1.44M floppy</span>

<span class="w">    </span><span class="c1">// configure the drive</span>
<span class="w">    </span><span class="n">send_command</span><span class="p">(</span><span class="n">SPECIFY</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="n">Controller</span><span class="p">.</span><span class="n">FIFO</span><span class="p">,</span><span class="w"> </span><span class="n">steprate_headunload</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="n">Controller</span><span class="p">.</span><span class="n">FIFO</span><span class="p">,</span><span class="w"> </span><span class="n">headload_ndma</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Related_Links">Related Links</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="DMA" class="mw-redirect" title="DMA">DMA</a></li></ul>
<h3><span class="mw-headline" id="Reference_Documents">Reference Documents</span></h3>
<ul><li><a rel="nofollow" class="external free" href="http://www.osdever.net/documents/82077AA_FloppyControllerDatasheet.pdf?the_id=41">http://www.osdever.net/documents/82077AA_FloppyControllerDatasheet.pdf?the_id=41</a></li>
<li><a rel="nofollow" class="external free" href="http://bos.asmhackers.net/docs/floppy/">http://bos.asmhackers.net/docs/floppy/</a></li>
<li><a rel="nofollow" class="external free" href="http://bos.asmhackers.net/docs/floppy/docs/floppy_tutorial.txt">http://bos.asmhackers.net/docs/floppy/docs/floppy_tutorial.txt</a></li>
<li><a rel="nofollow" class="external text" href="http://www.intel.com/design/archives/periphrl/docs/29046803.htm">Intel 82078 CHMOS SINGLE-CHIP FLOPPY DISK CONTROLLER datasheet (useless)</a></li>
<li><a rel="nofollow" class="external free" href="http://www.brokenthorn.com/Resources/OSDev20.html">http://www.brokenthorn.com/Resources/OSDev20.html</a></li></ul>
<h3><span class="mw-headline" id="Forum_Posts">Forum Posts</span></h3>
<ul><li><a href="http://forum.osdev.org/viewtopic.php?t=13538" class="extiw" title="topic:13538">TUTORIAL, with DMA, by Mystran (highly recommended, but has a few tiny errors)</a></li>
<li><a href="http://forum.osdev.org/viewtopic.php?t=310" class="extiw" title="topic:310">Floppy in pmode</a></li>
<li><a href="http://forum.osdev.org/viewtopic.php?t=12279" class="extiw" title="topic:12279">Floppy Disk Driver</a></li>
<li><a href="http://forum.osdev.org/viewtopic.php?t=8405" class="extiw" title="topic:8405">Floppy programming tutorial (floppy_tutorial.txt) companion thread</a></li>
<li><a href="http://forum.osdev.org/viewtopic.php?t=11181" class="extiw" title="topic:11181">Multitask Floppy Driver</a></li>
<li><a href="http://forum.osdev.org/viewtopic.php?t=17274" class="extiw" title="topic:17274">PIO mode information</a></li></ul>
<h3><span class="mw-headline" id="Implementations">Implementations</span></h3>
<ul><li><a rel="nofollow" class="external text" href="https://github.com/FDOS/kernel/blob/master/drivers/floppy.asm">FreeDOS</a> (C, GPL)</li>
<li><a rel="nofollow" class="external text" href="http://bos.asmhackers.net/docs/floppy/snippet_9/fdc.c">GazOS</a> (C, GPL)</li>
<li><a rel="nofollow" class="external text" href="http://bos.asmhackers.net/docs/floppy/snippet_5/FLOPPY.ASM">RDOS</a> (Assembly, GPL)</li>
<li><a rel="nofollow" class="external text" href="https://github.com/torvalds/linux/blob/master/drivers/block/floppy.c">Linux</a> (C, GPL)</li></ul>
<!-- 
NewPP limit report
Cached time: 20250211125014
Cache expiry: 86400
Reduced expiry: false
Complications: [showtoc]
CPU time usage: 0.067 seconds
Real time usage: 0.721 seconds
Preprocessor visited node count: 245/1000000
Postexpand include size: 324/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 18473/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.990      1 -total
 89.09%    0.882      2 Template:Wikitable
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1458-0!canonical and timestamp 20250211125014 and revision id 28697.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Floppy_Disk_Controller&amp;oldid=28697">https://wiki.osdev.org/index.php?title=Floppy_Disk_Controller&amp;oldid=28697</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Storage" title="Category:Storage">Storage</a></li><li><a href="./Category:Common_Devices" title="Category:Common Devices">Common Devices</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Floppy+Disk+Controller" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="Floppy#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Floppy_Disk_Controller" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:Floppy_Disk_Controller" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Floppy_Disk_Controller"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Floppy_Disk_Controller&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Floppy_Disk_Controller&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Floppy_Disk_Controller" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/Floppy_Disk_Controller" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Floppy_Disk_Controller&amp;oldid=28697" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Floppy_Disk_Controller&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/Floppy_Disk_Controller" title="Floppy Disk Controller  Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 12 March 2024, at 03:43.</li>
	<li id="footer-info-0">This page has been accessed 19,768 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Floppy_Disk_Controller&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.067","walltime":"0.721","ppvisitednodes":{"value":245,"limit":1000000},"postexpandincludesize":{"value":324,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":18473,"limit":5000000},"timingprofile":["100.00%    0.990      1 -total"," 89.09%    0.882      2 Template:Wikitable"]},"cachereport":{"timestamp":"20250211125014","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":833});});</script>
</body>
</html>