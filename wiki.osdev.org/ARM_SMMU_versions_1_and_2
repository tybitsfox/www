<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>ARM SMMU versions 1 and 2 - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"b7c7c9de9120fcbfbb2c4d19","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"ARM_SMMU_versions_1_and_2","wgTitle":"ARM SMMU versions 1 and 2","wgCurRevisionId":23789,"wgRevisionId":23789,"wgArticleId":4366,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["ARM"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"ARM_SMMU_versions_1_and_2","wgRelevantArticleId":4366,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{
"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head","mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-ARM_SMMU_versions_1_and_2 rootpage-ARM_SMMU_versions_1_and_2 skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">ARM SMMU versions 1 and 2</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="ARM_SMMU_versions_1_and_2#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="ARM_SMMU_versions_1_and_2#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>The ARM SMMU specification outlines an IOMMU architecture for ARM processors, similar to Intel's VT-d. The SMMU mediates accesses to RAM by devices, and can translate addresses generated by DMA engines so as to correct them as the OS requires.
</p><p>This page is current with versions 1 and 2 of the SMMU specification. This page does not serve as an exhaustive description of the SMMU. It is meant to serve as a refresher to jog the memory of people who have already read the SMMU specification.
</p><p>A common 's' in a register name, as in SMMU_sCR0 implies that versions of this register exist for both secure and non-secure mode and that both versions are being talked about in that instance.
</p><p>The SMMU supports processing transactions from multiple streams at once, and translation of multiple contexts at once.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="ARM_SMMU_versions_1_and_2#Terminology:"><span class="tocnumber">1</span> <span class="toctext">Terminology:</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="ARM_SMMU_versions_1_and_2#Usage_model"><span class="tocnumber">2</span> <span class="toctext">Usage model</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="ARM_SMMU_versions_1_and_2#Contrast_against_Intel_VT-d"><span class="tocnumber">2.1</span> <span class="toctext">Contrast against Intel VT-d</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="ARM_SMMU_versions_1_and_2#Secure/Non-secure_mode_split_and_SSD"><span class="tocnumber">2.2</span> <span class="toctext">Secure/Non-secure mode split and SSD</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="ARM_SMMU_versions_1_and_2#Splitting_the_Stream_Mapping_table_between_secure_and_non-secure_mode"><span class="tocnumber">2.2.1</span> <span class="toctext">Splitting the Stream Mapping table between secure and non-secure mode</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="ARM_SMMU_versions_1_and_2#Splitting_the_Context_banks_between_secure_and_non-secure_mode"><span class="tocnumber">2.2.2</span> <span class="toctext">Splitting the Context banks between secure and non-secure mode</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-7"><a href="ARM_SMMU_versions_1_and_2#Translation,_bypass_and_faulting"><span class="tocnumber">2.3</span> <span class="toctext">Translation, bypass and faulting</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="ARM_SMMU_versions_1_and_2#Setup/Initialization_related_information"><span class="tocnumber">3</span> <span class="toctext">Setup/Initialization related information</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="ARM_SMMU_versions_1_and_2#SSD_knowledge"><span class="tocnumber">3.1</span> <span class="toctext">SSD knowledge</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="ARM_SMMU_versions_1_and_2#StreamIDs"><span class="tocnumber">3.2</span> <span class="toctext">StreamIDs</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="ARM_SMMU_versions_1_and_2#Stream_Matching_Registers"><span class="tocnumber">3.3</span> <span class="toctext">Stream Matching Registers</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="ARM_SMMU_versions_1_and_2#Context_Banks_and_number_of_supported_Contexts"><span class="tocnumber">3.4</span> <span class="toctext">Context Banks and number of supported Contexts</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="ARM_SMMU_versions_1_and_2#Support_for_stage1_and_stage2"><span class="tocnumber">3.5</span> <span class="toctext">Support for stage1 and stage2</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="ARM_SMMU_versions_1_and_2#Stream_Mapping_Table"><span class="tocnumber">3.6</span> <span class="toctext">Stream Mapping Table</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="ARM_SMMU_versions_1_and_2#TLBs"><span class="tocnumber">3.7</span> <span class="toctext">TLBs</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="ARM_SMMU_versions_1_and_2#Client_transaction_flowchart"><span class="tocnumber">4</span> <span class="toctext">Client transaction flowchart</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="ARM_SMMU_versions_1_and_2#Image"><span class="tocnumber">4.1</span> <span class="toctext">Image</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="ARM_SMMU_versions_1_and_2#Synopsis:"><span class="tocnumber">4.2</span> <span class="toctext">Synopsis:</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="ARM_SMMU_versions_1_and_2#Flow_for_Translation-type_scenarios"><span class="tocnumber">4.3</span> <span class="toctext">Flow for Translation-type scenarios</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-20"><a href="ARM_SMMU_versions_1_and_2#Stream_Mapping"><span class="tocnumber">5</span> <span class="toctext">Stream Mapping</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="ARM_SMMU_versions_1_and_2#Transaction_attribute_combinations"><span class="tocnumber">6</span> <span class="toctext">Transaction attribute combinations</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="ARM_SMMU_versions_1_and_2#TLB_Management"><span class="tocnumber">7</span> <span class="toctext">TLB Management</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="ARM_SMMU_versions_1_and_2#TLB_tagging"><span class="tocnumber">7.1</span> <span class="toctext">TLB tagging</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="ARM_SMMU_versions_1_and_2#TLB_Prefetching_behaviour"><span class="tocnumber">7.2</span> <span class="toctext">TLB Prefetching behaviour</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="ARM_SMMU_versions_1_and_2#TLB_Maintenance"><span class="tocnumber">7.3</span> <span class="toctext">TLB Maintenance</span></a>
<ul>
<li class="toclevel-3 tocsection-26"><a href="ARM_SMMU_versions_1_and_2#HYPC_contexts"><span class="tocnumber">7.3.1</span> <span class="toctext">HYPC contexts</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="ARM_SMMU_versions_1_and_2#MONC_contexts_(Section_2.9.2)"><span class="tocnumber">7.3.2</span> <span class="toctext">MONC contexts (Section 2.9.2)</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="ARM_SMMU_versions_1_and_2#E2HC_contexts_(Section_2.10)"><span class="tocnumber">7.3.3</span> <span class="toctext">E2HC contexts (Section 2.10)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-29"><a href="ARM_SMMU_versions_1_and_2#Context_banks"><span class="tocnumber">8</span> <span class="toctext">Context banks</span></a>
<ul>
<li class="toclevel-2 tocsection-30"><a href="ARM_SMMU_versions_1_and_2#Hypervisor_Contexts_(HYPC)_(section_2.8)"><span class="tocnumber">8.1</span> <span class="toctext">Hypervisor Contexts (HYPC) (section 2.8)</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="ARM_SMMU_versions_1_and_2#Monitor_Contexts_(MONC)_(Section_2.9)"><span class="tocnumber">8.2</span> <span class="toctext">Monitor Contexts (MONC) (Section 2.9)</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="ARM_SMMU_versions_1_and_2#VHE_EL2_Contexts_(E2HC)_(Section_2.10)"><span class="tocnumber">8.3</span> <span class="toctext">VHE EL2 Contexts (E2HC) (Section 2.10)</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-33"><a href="ARM_SMMU_versions_1_and_2#IRQs_/_SMMU_Faults"><span class="tocnumber">9</span> <span class="toctext">IRQs / SMMU Faults</span></a>
<ul>
<li class="toclevel-2 tocsection-34"><a href="ARM_SMMU_versions_1_and_2#Context_bank_faults"><span class="tocnumber">9.1</span> <span class="toctext">Context bank faults</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Terminology:">Terminology:</span></h2>
<ul><li>Just in general, the SMMU spec refers to DMA engines and MCUs on the chipset as being "upstream" from the SMMU and it refers to RAM as being "downstream" from the SMMU.</li>
<li>The "Stream mapping table" is a term used to refer to the combined working of the SMMU_SMRn + SMMU_S2CRn registers. Do not confuse the SMMU_SMRn ("Stream <i>match</i>ing registers") with the umbrella term "Stream <i>mapp</i>ing registers". ARM defines Stream mapping as (Section 2.3.2) "<i>the process of mapping a StreamID to the associated Stream-to-Context register, SMMU_S2CRn</i>".</li>
<li>"Contexts" are synonymous with Intel's "domain" terminology used in the VT-d specification; they refer to a set of IO-page tables for translating IO-Addresses into output addresses on the bus/memory controller.</li>
<li>Transactions: Any write to or read from the SMMU by any agent is an SMMU transaction.
<ul><li>Client transactions: Client transactions are requests sent through the SMMU which can be potentially translated. These are generally bus messages.</li>
<li>Configuration transactions: Configuration transactions are accesses to the SMMU register interface to program the SMMU's behaviour (using the SMMU_* registers).</li></ul></li>
<li>StreamIDs: These are used to identify the source of a transaction. They identify a device uniquely, or otherwise a set of devices working together deliberately to appear to be the same device.
<ul><li>A single device may also pretend to be multiple devices by using multiple StreamIDs.</li>
<li>An example of a StreamID might be a PCI Bus+Slot+Function combination.</li></ul></li></ul>
<h2><span class="mw-headline" id="Usage_model">Usage model</span></h2>
<h3><span class="mw-headline" id="Contrast_against_Intel_VT-d">Contrast against Intel VT-d</span></h3>
<p>Both SMMU and VT-d support 1st-stage translation. 1st-stage translation can be used:
</p>
<ul><li>To isolate devices and ensure that they don't access memory beyond what they are expected to (i.e, beyond the scatter gather list that has currently been programmed into the device).</li></ul>
<p>VT-d 1st-stage translation can be used:
</p>
<ul><li>To isolate guest VMs and ensure that they don't touch memory outside of what they have been allocated as their guest physical address space (IPA addrspace).</li></ul>
<p>Only SMMU supports 2nd-stage translation. 2nd stage translation can be used:
</p>
<ul><li>When passing a device through to a guest VM, to translate the IPA addresses that the guest will program into the device, into their correct PAs.</li></ul>
<p>Only VT-d supports PASID 2nd-stage translation. PASID translation can be used:
</p>
<ul><li>To enable a device to directly walk the page tables of userspace processes, and translate virtual addresses into physical addresses.
<ul><li>For example, the virtual address of a graphics texture buffer can be sent to the GFX card directly, and the VT-d DHRU will be able to walk the page tables of the sending process and translate the virtual address on its own.</li></ul></li>
<li>PASID translation is then chained into the standard translation flow to isolate the device's address accesses in the standard way that an IOMMU is normally used.</li></ul>
<p>VT-d only supports PCI devices in its current form (at the time of writing) while SMMU supports multiple buses but leaves it up to the OEM implementation to determine how to map a bus technology's device IDs onto the identifier nomenclature ("StreamIDs") employed by the SMMU specification. For example, for the SMMU, an OEM is likely to map the 16-bit PCI Bus+Slot+Function onto the 15/16-bit StreamID space provided by the SMMU.
</p>
<h3><span id="Secure.2FNon-secure_mode_split_and_SSD"></span><span class="mw-headline" id="Secure/Non-secure_mode_split_and_SSD">Secure/Non-secure mode split and SSD</span></h3>
<p>The SMMU splits its registers for use between secure and non-secure mode; both modes can use the SMMU at the same time and there is register banking for some of the registers to facilitate this. Because both modes can use the SMMU at the same time, the SMMU also needs to know which devices have been partitioned into secure-mode devices and which are left for non-secure mode. In particular, secure mode devices can generate client transactions which access both secure memory and non-secure memory whereas non-secure mode devices can only access non-secure memory.
</p><p>There is a distinction to be kept in mind about the difference between the SMMU's SSD feature (Security-State Determination) and the marking of a transaction by an upstream bus technology/device as either secure or non-secure. A non-secure device may maliciously mark its transactions as being secure, so the SSD feature which sits within the SMMU is meant to thwart that. When an upstream device is determined to be SSD-non-secure, the SMMU will never generate a downstream transaction which is marked secure. When an upstream device is determined to be SSD-secure, the SMMU may generate a downstream transaction which is either secure or non-secure.
</p>
<ul><li>The SMMU may not have a programmable SSD register space, in which case the SSD determination is done via some [implementation defined] mechanism attached to the SMMU.</li>
<li>The SMMU SSD register space is present if SMMU_IDR1.SSDTP == 0b01 or 0b11.</li>
<li>When this field has either of those values, the SSD space is present in the SMMU.
<ul><li>When the SSD space is present in the SMMU, the SMMU_SSDRn registers are present.</li>
<li>These SMMU_SSDRn registers are bitfields, 32 bits each. If bit&lt;N&gt; is 1 then device&lt;N&gt; is non-secure, else it is secure.</li></ul></li></ul>
<h4><span class="mw-headline" id="Splitting_the_Stream_Mapping_table_between_secure_and_non-secure_mode">Splitting the Stream Mapping table between secure and non-secure mode</span></h4>
<p>The Stream Mapping table is global and shared between Secure and non-secure mode. Secure mode must decide how many Stream Mapping register groups it will expose for non-secure mode's use. ARM recommends that secure mode software leaves at least one Stream mapping register group for use by non-secure software.
</p><p>Having an SMMU_S2CR which has been allocated to secure be configured to mode point to a context bank which is non-secure is UNPREDICTABLE. Having an SMMU_S2CR which has been allocated to non-secure mode be configured to point to a context bank which is secure will trigger an Unimplemented Context Bank SMMU Fault.
</p>
<h4><span class="mw-headline" id="Splitting_the_Context_banks_between_secure_and_non-secure_mode">Splitting the Context banks between secure and non-secure mode</span></h4>
<p>Some number of context banks can be reserved for use by secure mode using SMMU_SCR1.NSNUMCBO. The allocation begins from the top of the available context bank space. The SMMU will intelligently present the correct number of context banks to non-secure mode through non-secure accesses to SMMU_IDR1.NUMCB. <i> SMMU_SCR1.NSNUMCBO actually reserves a number of context banks for <b>non-secure</b> mode. The leftover context banks that come <b>after</b> those reserved by SMMU_SCR1.NSNUMCBO are what are actually reserved for <b>secure</b> mode. </i>.
</p>
<h3><span id="Translation.2C_bypass_and_faulting"></span><span class="mw-headline" id="Translation,_bypass_and_faulting">Translation, bypass and faulting</span></h3>
<p>The SMMU will do one of 3 things with any client transaction that is sent to it:
</p>
<ul><li>Translate the transaction using translation tables.</li>
<li>Allow the transaction to bypass translation, and just modify the attributes of the transaction (read/write, shareability, caching, etc).</li>
<li>Generate an SMMU fault.</li></ul>
<h2><span id="Setup.2FInitialization_related_information"></span><span class="mw-headline" id="Setup/Initialization_related_information">Setup/Initialization related information</span></h2>
<h3><span class="mw-headline" id="SSD_knowledge">SSD knowledge</span></h3>
<p>The SSD register space, if available, tells the OS which devices are secure vs non-secure. For a secure-mode OS, it allows the OS to set which StreamIDs are secure/non-secure. A Secure-mode OS should set these registers up. A non-secure mode OS may choose to read these registers to determine which devices are under its purvue.
</p><p>Also, secure mode software may need to prevent access by non-secure software to the global register file of the SMMU. This can be done by setting SMMU_SCR1.GASRAE==1 (Section 2.10.1).
</p>
<h3><span class="mw-headline" id="StreamIDs">StreamIDs</span></h3>
<p>The number of supported streamID <b>bits</b> is determined by reading SMMU_IDR0.NUMSIDB[3:0].
</p>
<ul><li>Ranges from 0-15.</li>
<li>Can be 0 in the case of an SMMU which is dedicated to handling transactions from a single upstream StreamID.</li></ul>
<p>For SMMUv2:
</p>
<ul><li>Support for 16-bit streamIDs exists if SMMU_IDR0.EXIDS==1 AND SMMU_IDR0.NUMSIDB==15.</li>
<li>16-bit Stream IDs are enabled by setting SMMU_sCR0.EXIDENABLE==1.</li></ul>
<p>Furthermore, if the OS intends to use Stream Indexing instead of Stream Matching, then the number of StreamIDs is further constrained by the number of SMMU_S2CRn registers available. The number of SMMU_S2CRn registers is directly determined by the number of SMMU_SMRn registers (Section 2.3.2, "Stream indexing": <i>This means the maximum StreamID is determined by the number of implemented SMMU_S2CRns</i>). See <a href="ARM_SMMU_versions_1_and_2#Stream_Matching_Registers">#Stream Matching Registers</a> for how to determine the number of SMMU_S2CRn registers by inferring it from the number of SMMU_SMRn regs.
</p><p>The OS should determine the max number of StreamIDs based on the Stream Mapping technique it intends to use, and set up metadata accordingly.
</p>
<h3><span class="mw-headline" id="Stream_Matching_Registers">Stream Matching Registers</span></h3>
<p>SMMUv1 supports <i>up to</i> 128 SMMU_SMRs.
SMMUv2 may optionally support the Extended Stream Matching Extension which provides  <i>up to</i> 1024 SMMU_SMRs.
</p><p>The number of SMMU_SMRn regs determines the number of SMMU_S2CRn regs (Section 2.3.2, "Stream matching": <i>the optional Extended Stream Matching Extension, that provides up to 1024 Stream Match Registers and associated Stream-to-Context registers</i>).
</p>
<ul><li>Support for Stream Matching is indicated via SMMU_IDR0.SMS == 1.</li>
<li>Support for Extended Stream Matching is indicated via SMMU_IDR0.EXSMRGS == 1.</li>
<li>Enable Extended Stream Matching using SMMU_sCR2.EXSMRGENABLE==1.
<ul><li>Setting SMMU_SCR2.EXNSSMRGDISABLE==1 with a secure write to SMMU_SCR2 disables the use of Extended Stream Matching by non-secure mode.</li></ul></li>
<li>Support for compressed Indexing (which is a subfeature under Stream Matching) is indicated via a secure read of SMMU_IDR2.COMPINDEXS == 1. A non-secure read of this bit only states whether or not compressed indexing is available for use by non-secure software.</li>
<li>The number of Stream Mapping Register Groups is determined by reading SMMU_IDR0.NUMSMRG.</li>
<li>It is possible for an implementation not to support Stream <b>Matching</b>, but still allow software to reference the Stream <b>Mapping</b> Table (which is the <b>combination</b> of the SMMU_SMRn and SMMU_S2CRn register sets).
<ul><li>In such a case, the SMMU_SMRn register group will be RES0.</li></ul></li></ul>
<p><i>ARM found it important to mention that if the SMMU support Extended Stream Matching and the extension is not enabled, the (up to) 128 SMMU_SMRs that are exposed, map onto the final 128 SMMU_SMRs provided by the extension. Since it's apparently important, I'll mention it too.</i>
</p>
<h3><span class="mw-headline" id="Context_Banks_and_number_of_supported_Contexts">Context Banks and number of supported Contexts</span></h3>
<p>The max number of supported contexts is implied by the max number of SMMU_CBARn registers (Section 2.3.4: "The number of SMMU_CBARn regs matches the number of entries in the translation context bank table, and is IMPLEMENTATION DEFINED. SMMU_IDR1.NUMCB specifies the number of implemented SMMU_CBARn regs."). That said, NUMCB is an 8-bit field, and section 2.6.1 says: "The SMMU architecture provides space for up to 128 translation context banks".
</p>
<ul><li>Multiple SMMU_SMRn regs may cause multiple StreamIDs to map to the same Context when Stream Matching is used.</li>
<li>Each incoming StreamID maps directly to a specific Context when Stream Indexing is used.</li></ul>
<p>Section 2.6.1: <i> On reset no translation context bank table entry initializatoin is required. Typically, the SMMU implementation [sic] initializes the required values before use. </i>
</p>
<h3><span class="mw-headline" id="Support_for_stage1_and_stage2">Support for stage1 and stage2</span></h3>
<ul><li>Support for stage1 translation is indicated via SMMU_IDR0.S1TS.</li>
<li>Support for stage2 translation is indicated via SMMU_IDR0.S2TS.</li>
<li>Support for stage1 followed by stage2 translation is indicated via SMMU_IDR0.NTS.
<ul><li>If SMMU_IDR0.NTS is set, then both SMMU_IDR0.S1TS and SMMU_IDR0.S2TS must be set.</li></ul></li></ul>
<p>If both stage1 and stage2 are supported, then all contexts except the first X can support either stage1 or stage2 translation. The first X context banks <b>may</b> be restricted such that they only support stage2. To detect the number X which can only be used for stage2 translation, see SMMU_IDR1.NUMS2CB. The SMMU_CBARn.TYPE field governs the stage of translation for a context bank which supports both stages.
</p>
<h3><span class="mw-headline" id="Stream_Mapping_Table">Stream Mapping Table</span></h3>
<p>Section 2.3.10: "On reset, no initialization is performed on the Stream mapping table entries.". Ergo the OS must explicitly initialize all the stream mapping reg groups "before the SMMU is enabled" [sic].
</p>
<h3><span class="mw-headline" id="TLBs">TLBs</span></h3>
<p>Section 2.5.2: "In SMMUv2, All TLBs are disabled from reset. All MMUs are disabled from reset and the contexnts of the TLBs have no effect on address translation."
</p><p>However, an implementation may require an IMPLEMENTATION DEFINED TLB invalidation routine to be called before enabling TLBs/MMU after #RESET. Such a routine must be doucmented clearly by the device. If TLBs which have not been invalidated since #RESET are used their behaviour is UNPREDICTABLE.
</p>
<h2><span class="mw-headline" id="Client_transaction_flowchart">Client transaction flowchart</span></h2>
<h3><span class="mw-headline" id="Image">Image</span></h3>
<p><a href="./File:Smmu-transaction-flowchart.png" class="image"><img alt="Smmu-transaction-flowchart.png" src="images/e/e9/Smmu-transaction-flowchart.png" decoding="async" width="821" height="1062" data-file-width="821" data-file-height="1062" /></a>
</p>
<h3><span class="mw-headline" id="Synopsis:">Synopsis:</span></h3>
<p>Do not allow a single StreamID to map to multiple contexts. Multiple stream IDs can however, map to a single context.
</p>
<ul><li>Client transactions are enabled with the "Client Port Disable" bit: SMMU_sCR0.CLIENTPD==0.</li>
<li>If SMMU_sCR0.CLIENTPD==1, then bypass is assumed for all incoming transactions.
<ul><li>Bypass attribute transformation is done based on the values in SMMU_sCR0.</li></ul></li>
<li>If SMMU_sCR0.CLIENTPD==0, client transaction processing is enabled, and:
<ul><li>Stream Mapping table is searched.
<ul><li>Stream Mapping table search is done using either Stream Matching, Compressed Stream Indexing or Stream Indexing.</li></ul></li>
<li>If Stream Mapping search yields <i>no results</i> then <i>either</i>:
<ul><li>[if SMMU_sCR0.USFCFG==1 -- USFCFG means "Unidentified Stream Fault Config"] An Unidentified Stream SMMU fault is generated.</li>
<li>[if SMMU_sCR0.USFCFG==0] The unidentifiable stream ID is handled by bypassing it and applying the attribute transformation specified in SMMU_sCR0.</li></ul></li>
<li>If Stream mapping table search yields multiple results:
<ul><li>[if SMMU_sCR0.SMCFCFG==1 -- SMCFCFG means "Stream Match Conflict Fault Config"] A Stream Match Conflict SMMU Fault is generated.</li>
<li>[if SMMU_sCR0.SMCFCFG==0 ] The conflict is handled via bypass and applying the attribute transformation specified in SMMU_sCR0 (just like the Unidentified Stream case).</li></ul></li>
<li>If Stream Mapping table search yields a single result ('This is the desired normal case').
<ul><li>The Stream Mapping table lookup will identify one of the 128 SMMU_S2CRn Stream to Context Registers.</li>
<li>The S2C register will determine which of the 3 handling mechanisms will be used to deal with the incoming client transaction (translation, bypass or fault).
<ul><li>[if SMMU_S2CRn.Type == Fault] An Invalid Context SMMU fault is generated.</li>
<li>[if SMMU_S2CRn.Type == bypass] The client transaction is handled via bypass and the attributes specified in SMMU_S2CRn are applied to the transaction.</li>
<li>[if SMMU_S2CRn.Type == Translation] The client transaction is handled by translation and:
<ul><li>The attributes in SMMU_CBARn (stage 1 Context Bank Attribute Reg) and SMMU_SBA2Rn (stage 2 Context Bank Attribute Reg) are 'optionally' applied to the output transaction which is generated downstream.</li>
<li>[if SMMU_CBn_SCTLR.M==1 <i>for the particular stage in question</i>] then translation is done for that stage using the configuration in SMMU_CBARn.</li></ul></li></ul></li></ul></li></ul></li></ul>
<h3><span class="mw-headline" id="Flow_for_Translation-type_scenarios">Flow for Translation-type scenarios</span></h3>
<p><a href="./File:Smmu-stage1-into-stage2-flowchart.png" class="image"><img alt="Smmu-stage1-into-stage2-flowchart.png" src="images/4/4f/Smmu-stage1-into-stage2-flowchart.png" decoding="async" width="744" height="703" data-file-width="744" data-file-height="703" /></a>
</p>
<h2><span class="mw-headline" id="Stream_Mapping">Stream Mapping</span></h2>
<p>As stated before on this page, Stream Mapping is defined by ARM as "'the process of mapping a StreamID to the associated Stream-to-Context register'".
</p><p>When a client transaction comes in from upstream, if client transaction processing is enabled (SMMU_sCR0.CLIENTPD==0), the SMMU must decide what SMMU context to use to translate the transaction into the output transaction which will eventually be emitted downstream by the SMMU. The process of determining which Context bank should be used to handle client transactions sent by a particular upstream StreamID is an "associative search" [sic] which uses one of 3 methods: Stream Matching, Compressed Stream Indexing or Stream Indexing.
</p><p>The Stream Mapping table is global and shared between Secure and non-secure mode. Secure mode must decide how many Stream Mapping register groups it will expose for non-secure mode's use. ARM recommends that secure mode software leaves at least one Stream mapping register group for use by non-secure software. To set the number of Stream mapping regs exposed to non-secure mode, use SMMU_SCR1.NSNUMSMRGO. The SMMU will intelligently deduce the number of SMR regs to tell non-secure mode about, and will report the appropriate number to a non-secure reader through SMMU_IDR0.NUMSMRG.
</p>
<h2><span class="mw-headline" id="Transaction_attribute_combinations">Transaction attribute combinations</span></h2>
<p>See tables 2-2 and 2-3 for information on how cacheability, shareability, INSTCFG (instruction fetch), etc combine to form the final output attributes of the client transaction.
</p>
<h2><span class="mw-headline" id="TLB_Management">TLB Management</span></h2>
<p>The SMMU maintains its own TLB of translations to speed up client transactions. The topology of the TLBs is IMPLEMENTATION DEFINED. TLB implementations may cache entries for any level or stage (or combination thereof) of translation. TLB maintenance can be done via either: (1) Broadcast TLB operations or (2) TLB maintenance register accesses.
</p>
<h3><span class="mw-headline" id="TLB_tagging">TLB tagging</span></h3>
<p>Section 2.5: "Software must treat all TLB entries as being tagged with the input address. For other attributes [sic] TLB enteries are categorized so that the tagging applied to an entry depends on the translation regime. For a particular translation regime, a TLB entry must specify 'appropriate information' [sic], and certain conditions [sic] must be satisfied. For example, a non-secure stage 1 TLB entry must specify an ASID."
</p><p><a href="./File:Smmu-tlb-tagging.png" class="image"><img alt="Smmu-tlb-tagging.png" src="images/4/43/Smmu-tlb-tagging.png" decoding="async" width="866" height="585" data-file-width="866" data-file-height="585" /></a>
</p>
<h3><span class="mw-headline" id="TLB_Prefetching_behaviour">TLB Prefetching behaviour</span></h3>
<p>The SMMU is allowed to prefetch the translation tables pointed to by a context bank if that context bank is pointed to by an entry in the Stream Mapping table. This is permitted even if there is no client transaction which is using/ has used that translation (section 2.5.1).
</p>
<h3><span class="mw-headline" id="TLB_Maintenance">TLB Maintenance</span></h3>
<h4><span class="mw-headline" id="HYPC_contexts">HYPC contexts</span></h4>
<p>Section 2.8.2: <i>TLB entries that are allocated as a result of HYPC accesses are Hyp tagged. All HYP tagged TLB entries are considered to belong to the same software entity and have no associated ASID or VMID.</i>
</p><p>Ergo the SMMU assumes that there is only one piece of software that is acting as a hypervisor.
</p>
<h4><span id="MONC_contexts_.28Section_2.9.2.29"></span><span class="mw-headline" id="MONC_contexts_(Section_2.9.2)">MONC contexts (Section 2.9.2)</span></h4>
<p>SMMUv2 provides the following TLB maintenance operations for maintaining MONC TLB tagged entries:
</p>
<ul><li>SMMU_TLBIALLM: Invalidate all EL3 Monitor entries.</li>
<li>SMMU_TLBIVAM: Invalidates all EL3 Monitor entries which are associated with a 64-bit VA.</li>
<li>SMMU_TLBIVALM: Same as TLBIVAM, but invalidates only the last level table entries.</li></ul>
<p>ARM found it necessary to warn that: <i>These operations are not required to invalidate non-MONC Secure TLB entries</i>.
</p>
<h4><span id="E2HC_contexts_.28Section_2.10.29"></span><span class="mw-headline" id="E2HC_contexts_(Section_2.10)">E2HC contexts (Section 2.10)</span></h4>
<p>E2HC context TLB entries are tagged by the TLB as E2H, but have no security state tagging. They are coupled with an ASID if they are non-global.
</p><p>TLB entries for E2HC contexts matching combinations of (E2H identification) or (E2H identification+ASID tagging) are required to be invalidated by:
</p>
<ul><li>SMMU_TLBIALLH</li>
<li>SMMU_TLBIVAH</li>
<li>SMMU_TLBIVAH64</li>
<li>SMMU_TLBIVALH64</li>
<li>SMMU_TLBIALLNSNH</li></ul>
<p>E2H identified TLB entries are not required to be invalidated by:
</p>
<ul><li>Secure TLBI operations.</li>
<li>SMMU_TLBIVMID.</li>
<li>SMMU_TLBIVMIDS1</li></ul>
<p>Additionally, the standard SMMU_CBn_TLBI* operations work on E2HC context TLB entries, except that instead of matching based on VMID, they match based on (E2H identification) or (E2H identification + ASID tagging).
</p><p>In particular <b>other than the specific TLB invalidate operations bulleted above, E2HC contexts are not considered to be hypervisor contexts by the SMMU</b>.
</p><p>Operation of the TLB is UNPREDICTABLE if there exist TLB entries allocated in the cache identified as HYPC and E2HC concurrently. Software must invalidate the HYPC/E2HC TLBs when switching between operating the SMMU with E2HC vs HYPC support enabled. Please see Section 2.10, example 2-1 for a full listing of the procedure for enabling E2HC operation.
</p>
<h2><span class="mw-headline" id="Context_banks">Context banks</span></h2>
<p>Each context bank is one page large, where "one page" is defined as PAGESIZE which may be either 4KiB or 64KiB. The intention is that a hypervisor can
Accessing an unimplemented context bank's register space will either result in an IMPLEMENTATION DEFINED result of either RAZ/WI or a Configuration Access SMMU Fault.
</p><p>The SMMU_CBA2Rn.MONC, SMMU_CBARn.HYPC and SMMU_CBA2Rn.VA64 bits work together to define the security context and page table format (long vs short) for translation of a particular context bank.
</p>
<h3><span id="Hypervisor_Contexts_.28HYPC.29_.28section_2.8.29"></span><span class="mw-headline" id="Hypervisor_Contexts_(HYPC)_(section_2.8)">Hypervisor Contexts (HYPC) (section 2.8)</span></h3>
<p>Hypervisor mode contexts (HYPC) are the page tables of an OS running in HYP mode and not the 2nd stage page tables for a guest IPA. The SMMU is able to walk HYPC page tables. For that reason a HYPC bank cannot be a stage1 followed by stage2 context. I couldn't think of a good reason for a normal hypervisor to prefer to use HYPC tables when it can just use normal IO page tables. <b>I could also be misinterpreting the purpose of this feature</b>, as it appears to be linked to VHE extensions, and it may pertain to a special page table format used by VHE guests.
</p><p>Support for HYPC is mututally exclusive with support for E2HC. HYPC is supported:
</p>
<ul><li>For both SMMUv1 and SMMUv2, if VHE is not supported, then HYPC is supported.</li>
<li>In an SMMUv2 implementation that has VHE, if SMMU_CR0.HYPMODE==0, HYPC is available, else E2HC is available.</li></ul>
<p>VHE is supported by the SMMU if:
</p>
<ul><li>SMMU_IDR2.E2HS==1</li></ul>
<p>To set a context bank to be a HYPC bank, set SMMU_CBARn.HYPC==1.
</p><p>Caveats:
</p>
<ul><li>Do not set the HYPC bit on <b>secure</b> context banks -- that's illogical. See section 2.8.3 for details.</li>
<li>The SMMU_CBn_TCR2.SEP field is ignored for HYPC contexts.</li></ul>
<h3><span id="Monitor_Contexts_.28MONC.29_.28Section_2.9.29"></span><span class="mw-headline" id="Monitor_Contexts_(MONC)_(Section_2.9)">Monitor Contexts (MONC) (Section 2.9)</span></h3>
<p>I couldn't determine whether MONC contexts are meant for use by devices claimed specifically by Monitor Mode (EL3) or whether this bit is meant to be set by all secure mode software. The specific wording of the manual is:
Section 2.9: <i>In SMMUv2, <b>for a secure bank</b>, when the value of the corresponding SMMU_CBA2Rn.MONC bit is 1, the bank is a MONC (Secure Monitor) context bank. MONC Translation context banks are intended to be used by the Secure EL3 translation regime.</i>
</p><p>The phrasing seems to support the latter of the two interpretations.
</p><p>Caveats:
</p>
<ul><li>Do not set both HYPC and MONC on any bank because that is UNPREDICTABLE.</li>
<li>MONC only pertains to contexts reserved for secure mode use. Non-secure contexts ignore and treat the MONC bit as 0. Set it to 0.</li>
<li>Sign extension via SMMU_CBn_TCR2.SEP is ignored for MONC banks.</li></ul>
<h3><span id="VHE_EL2_Contexts_.28E2HC.29_.28Section_2.10.29"></span><span class="mw-headline" id="VHE_EL2_Contexts_(E2HC)_(Section_2.10)">VHE EL2 Contexts (E2HC) (Section 2.10)</span></h3>
<p>E2HC contexts are meant to be used by hypervisor guests running in pseudo-EL2 (ARM's VHE feature) on top of another hypervisor which is running in real-EL2. The SMMU can only be programmed to use either E2HC or HYPC, but not both at the same time. This is a decision which must be made globally and it affects all software using the SMMU whether secure or nonsecure, whether EL3, EL2 or EL1. In fact, the HYPC and E2HC bits are polymorphically at the same position in the register.
</p><p>E2HC contexts must be programmed to be of SMMU_CBARn.TYPE of 0b01 (stage1 followed by stage2 bypass). Unlike HYPC however, the E2HC translation regime is split between two TTBR registers. See the TLB management section to understand how the TLB entries for E2HC are handled by the TLB.
</p>
<h2><span id="IRQs_.2F_SMMU_Faults"></span><span class="mw-headline" id="IRQs_/_SMMU_Faults">IRQs / SMMU Faults</span></h2>
<h3><span class="mw-headline" id="Context_bank_faults">Context bank faults</span></h3>
<p>The SMMU may raise faults for a context bank when processing a stage of translation for a particular context bank.
</p>
<ul><li>For SMMUv1, the SMMU_CBAR register states which interrupt is raised to signal faults while processing that context.</li>
<li>For SMMUv2, each context bank has its own IRQ pin.</li></ul>
<!-- 
NewPP limit report
Cached time: 20250211135643
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.026 seconds
Real time usage: 0.027 seconds
Preprocessor visited node count: 106/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:4366-0!canonical and timestamp 20250211135642 and revision id 23789.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=ARM_SMMU_versions_1_and_2&amp;oldid=23789">https://wiki.osdev.org/index.php?title=ARM_SMMU_versions_1_and_2&amp;oldid=23789</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="./Category:ARM" title="Category:ARM">ARM</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=ARM+SMMU+versions+1+and+2" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="ARM_SMMU_versions_1_and_2#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="ARM_SMMU_versions_1_and_2" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Talk:ARM_SMMU_versions_1_and_2&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="ARM_SMMU_versions_1_and_2"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=ARM_SMMU_versions_1_and_2&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=ARM_SMMU_versions_1_and_2&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/ARM_SMMU_versions_1_and_2" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/ARM_SMMU_versions_1_and_2" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=ARM_SMMU_versions_1_and_2&amp;oldid=23789" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=ARM_SMMU_versions_1_and_2&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 8 August 2019, at 03:50.</li>
	<li id="footer-info-0">This page has been accessed 4,702 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=ARM_SMMU_versions_1_and_2&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.026","walltime":"0.027","ppvisitednodes":{"value":106,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20250211135643","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":128});});</script>
</body>
</html>