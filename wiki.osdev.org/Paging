<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Paging - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"b9db3c75369ebdccab923224","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Paging","wgTitle":"Paging","wgCurRevisionId":29363,"wgRevisionId":29363,"wgArticleId":2122,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Disputed Pages","Memory management","Paging","Virtual Memory","Security"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Paging","wgRelevantArticleId":2122,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],
"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head","mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Paging rootpage-Paging skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Paging</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="Paging#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="Paging#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><center>
<table style="border: 1px solid #cfcfbf; padding: .0em .25em .0em; background-color: #f0f0ff; text-align: center;">
<tbody><tr>
<td>
<p><font color="black">The factual accuracy of this article or section is <a href="./Category:Disputed_Pages" title="Category:Disputed Pages">disputed</a>.</font><br /><small><font color="red">Please see the relevant discussion on the <a href="./Talk:Paging" title="Talk:Paging">talk page</a>.</font></small>
</p>
</td>
<td>
</td></tr></tbody></table>
</center>
<div class="thumb tright"><div class="thumbinner" style="width:469px;"><a href="./File:Paging_Structure.gif" class="image"><img alt="" src="images/thumb/7/77/Paging_Structure.gif/467px-Paging_Structure.gif" decoding="async" width="467" height="350" class="thumbimage" srcset="images/thumb/7/77/Paging_Structure.gif/700px-Paging_Structure.gif 1.5x, images/7/77/Paging_Structure.gif 2x" data-file-width="801" data-file-height="601" /></a>  <div class="thumbcaption"><div class="magnify"><a href="./File:Paging_Structure.gif" class="internal" title="Enlarge"></a></div>x86 Paging Structure</div></div></div>
<p>Paging is a system which allows each process to see a full virtual address space, without actually requiring the full amount of physical memory to be available or present. 32-bit x86 processors support 32-bit virtual addresses and 4-GiB virtual address spaces, and current 64-bit processors support 48-bit virtual addressing and 256-TiB virtual address spaces. Intel has released <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Intel_5-level_paging">documentation</a> for a extension to 57-bit virtual addressing and 128-PiB virtual address spaces. Currently, implementations of x86-64 have a limit of between 4 GiB and 256 TiB of physical address space (and an architectural limit of 4 PiB of physical address space).
</p><p>In addition to this, paging introduces the benefit of page-level protection. In this system, user processes can only see and modify data which is paged in on their own address space, providing hardware-based isolation. System pages are also protected from user processes. On the x86-64 architecture, page-level protection now completely supersedes <a href="Segmentation" title="Segmentation">Segmentation</a> as the memory protection mechanism. On the IA-32 architecture, both paging and segmentation exist, but segmentation is now considered 'legacy'.
</p><p>Once an Operating System has paging, it can also make use of other benefits and workarounds, such as linear framebuffer simulation for memory-mapped IO and paging out to disk, where disk storage space is used to free up physical RAM.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Paging#32-bit_Paging_(Protected_Mode)"><span class="tocnumber">1</span> <span class="toctext">32-bit Paging (Protected Mode)</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="Paging#MMU"><span class="tocnumber">1.1</span> <span class="toctext">MMU</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="Paging#Page_Directory"><span class="tocnumber">1.2</span> <span class="toctext">Page Directory</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="Paging#Page_Table"><span class="tocnumber">1.3</span> <span class="toctext">Page Table</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="Paging#Example"><span class="tocnumber">1.4</span> <span class="toctext">Example</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="Paging#64-Bit_Paging"><span class="tocnumber">2</span> <span class="toctext">64-Bit Paging</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="Paging#Page_Map_Table_Entries"><span class="tocnumber">2.1</span> <span class="toctext">Page Map Table Entries</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="Paging#Process_Context_Identifiers"><span class="tocnumber">2.2</span> <span class="toctext">Process Context Identifiers</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="Paging#Enabling"><span class="tocnumber">3</span> <span class="toctext">Enabling</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="Paging#32-bit_Paging"><span class="tocnumber">3.1</span> <span class="toctext">32-bit Paging</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="Paging#64-bit_Paging_2"><span class="tocnumber">3.2</span> <span class="toctext">64-bit Paging</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-12"><a href="Paging#Physical_Address_Extension"><span class="tocnumber">4</span> <span class="toctext">Physical Address Extension</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="Paging#Usage"><span class="tocnumber">5</span> <span class="toctext">Usage</span></a>
<ul>
<li class="toclevel-2 tocsection-14"><a href="Paging#Virtual_Address_Spaces"><span class="tocnumber">5.1</span> <span class="toctext">Virtual Address Spaces</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="Paging#Virtual_Memory"><span class="tocnumber">5.2</span> <span class="toctext">Virtual Memory</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="Paging#Manipulation"><span class="tocnumber">6</span> <span class="toctext">Manipulation</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="Paging#Page_Faults"><span class="tocnumber">7</span> <span class="toctext">Page Faults</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="Paging#Handling"><span class="tocnumber">7.1</span> <span class="toctext">Handling</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="Paging#INVLPG"><span class="tocnumber">8</span> <span class="toctext">INVLPG</span></a></li>
<li class="toclevel-1 tocsection-20"><a href="Paging#Paging_Tricks"><span class="tocnumber">9</span> <span class="toctext">Paging Tricks</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="Paging#PAT"><span class="tocnumber">10</span> <span class="toctext">PAT</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="Paging#See_Also"><span class="tocnumber">11</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="Paging#Articles"><span class="tocnumber">11.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="Paging#External_Links"><span class="tocnumber">11.2</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span id="32-bit_Paging_.28Protected_Mode.29"></span><span class="mw-headline" id="32-bit_Paging_(Protected_Mode)">32-bit Paging (Protected Mode)</span></h2>
<h3><span class="mw-headline" id="MMU">MMU</span></h3>
<p>Paging is achieved through the use of the <a href="Memory_Management_Unit" title="Memory Management Unit">Memory Management Unit</a> (MMU). On the x86, the MMU maps memory through a series of <a href="Page_Tables" title="Page Tables">tables</a>, two to be exact. They are the paging directory (PD), and the paging table (PT).
</p><p>Both <a href="Page_Tables" title="Page Tables"> tables</a> contain 1024 4-byte entries, making them 4 KiB each. In the page directory, each entry points to a page table. In the page table, each entry points to a 4 KiB physical page frame. Additionally, each entry has bits controlling access protection and caching features of the structure to which it points. The entire system consisting of a page directory and page tables represents a linear 4-GiB virtual memory map.
</p><p>Translation of a virtual address into a physical address first involves dividing the virtual address into three parts: the most significant 10 bits (bits 22-31) specify the index of the page directory entry, the next 10 bits (bits 12-21) specify the index of the page table entry, and the least significant 12 bits (bits 0-11) specify the page offset. The then MMU walks through the paging structures, starting with the page directory, and uses the page directory entry to locate the page table. The page table entry is used to locate the base address of the physical page frame, and the page offset is added to the physical base address to produce the physical address. If translation fails for some reason (entry is marked as not present, for example), then the processor issues a page fault.
</p>
<h3><span class="mw-headline" id="Page_Directory">Page Directory</span></h3>
<p>The topmost paging structure is the page directory. It is essentially an array of page directory entries that take the following form.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:432px;"><a href="./File:Page_directory_entry.png" class="image"><img alt="" src="images/1/1e/Page_directory_entry.png" decoding="async" width="430" height="427" class="thumbimage" data-file-width="430" data-file-height="427" /></a>  <div class="thumbcaption">A Page Directory Entry</div></div></div>
<p>When PS=0, the page table address field represents the physical address of the page table that manages the four megabytes at that point. Please note that it is very important that this address be 4-KiB aligned. This is needed, due to the fact that the last 12 bits of the 32-bit value are overwritten by access bits and such. Similarly, when PS=1, the address must be 4-MiB aligned.
</p>
<ul><li>PAT, or '<b>P</b>age <b>A</b>ttribute <b>T</b>able'. If <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Page_attribute_table">PAT</a> is supported, then PAT along with PCD and PWT shall indicate the memory caching type.  Otherwise, it is reserved and must be set to 0.</li>
<li>G, or '<b>G</b>lobal' tells the processor not to invalidate the TLB entry corresponding to the page upon a MOV to CR3 instruction. Bit 7 (PGE) in CR4 must be set to enable global pages.</li>
<li>PS, or '<b>P</b>age <b>S</b>ize' stores the page size for that specific entry. If the bit is set, then the PDE maps to a page that is 4 MiB in size. Otherwise, it maps to a 4 KiB page table. Please note that 4-MiB pages require PSE to be enabled.</li>
<li>D, or '<b>D</b>irty' is used to determine whether a page has been written to.</li>
<li>A, or '<b>A</b>ccessed' is used to discover whether a PDE or PTE was read during virtual address translation. If it has, then the bit is set, otherwise, it is not. Note that, this bit will not be cleared by the CPU, so that burden falls on the OS (if it needs this bit at all).</li>
<li>PCD, is the 'Cache Disable' bit. If the bit is set, the page will not be cached. Otherwise, it will be.</li>
<li>PWT, controls Write-Through' abilities of the page. If the bit is set, write-through caching is enabled. If not, then write-back is enabled instead.</li>
<li>U/S, the '<b>U</b>ser/Supervisor' bit, controls access to the page based on privilege level. If the bit is set, then the page may be accessed by all; if the bit is not set, however, only the supervisor can access it. For a page directory entry, the user bit controls access to all the pages referenced by the page directory entry. Therefore if you wish to make a page a user page, you must set the user bit in the relevant page directory entry as well as the page table entry.</li>
<li>R/W, the '<b>R</b>ead/<b>W</b>rite' permissions flag. If the bit is set, the page is read/write. Otherwise when it is not set, the page is read-only. The WP bit in CR0 determines if this is only applied to userland, always giving the kernel write access (the default) or both userland and the kernel (see Intel Manuals 3A 2-20).</li>
<li>P, or '<b>P</b>resent'. If the bit is set, the page is actually in physical memory at the moment. For example, when a page is swapped out, it is not in physical memory and therefore not 'Present'. If a page is called, but not present, a page fault will occur, and the OS should handle it. (See below.)</li></ul>
<p>The remaining bits 9 through 11 (if PS=0, also bits 6 &amp; 8) are not used by the processor, and are free for the OS to store some of its own accounting information. In addition, when P is not set, the processor ignores the rest of the entry and you can use all remaining 31 bits for extra information, like recording where the page has ended up in swap space. When changing the accessed or dirty bits from 1 to 0 while an entry is marked as present, it's recommended to invalidate the associated page. Otherwise, the processor may not set those bits upon subsequent read/writes due to TLB caching. 
</p>
<div class="thumb tright"><div class="thumbinner" style="width:432px;"><a href="./File:Page_table_entry.png" class="image"><img alt="" src="images/6/60/Page_table_entry.png" decoding="async" width="430" height="251" class="thumbimage" data-file-width="430" data-file-height="251" /></a>  <div class="thumbcaption">A Page Table Entry</div></div></div>
<p>Setting the PS bit makes the page directory entry point directly to a 4-MiB page. There is no paging table involved in the address translation.
Note: With 4-MiB pages, whether or not bits 20 through 13 are reserved depends on PSE being enabled and how many PSE bits are supported by the processor (PSE, PSE-36, PSE-40). <a href="CPUID" title="CPUID">CPUID</a> should be used to determine this. Thus, the physical address must also be 4-MiB-aligned. Physical addresses above 4 GiB can only be mapped using 4 MiB PDEs.
</p>
<h3><span class="mw-headline" id="Page_Table">Page Table</span></h3>
<p>In each page table, as it is, there are also 1024 entries. These are called page table entries, and are <b>very</b> similar to page directory entries.
</p><p>The first item, is once again, a 4-KiB aligned physical address. Unlike previously, however, the address is not that of a page table, but instead a 4 KiB block of physical memory that is then mapped to that location in the page table and directory. Note that the PAT bit is bit 7 instead of bit 12 as in the 4 MiB PDE.
</p>
<h3><span class="mw-headline" id="Example">Example</span></h3>
<p>Say the kernel is loaded to 0x100000. However, it needed to be remapped to 0xC0000000. After loading the kernel, it'll initiate paging, and set up the appropriate tables. (See <a href="Higher_Half_Kernel" title="Higher Half Kernel">Higher Half Kernel</a>) After <a href="Identity_Paging" title="Identity Paging">Identity Paging</a> the first megabyte, it'll need to create a second table (ie. at entry #768 in the paging directory.) to map 0x100000 to 0xC0000000. The code may be like:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="w"> </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x0</span><span class="w"></span>
<span class="w"> </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="mi">0x100000</span><span class="w"></span>
<span class="w"> </span><span class="nl">.fill_table:</span><span class="w"></span>
<span class="w">      </span><span class="nf">mov</span><span class="w"> </span><span class="no">ecx</span><span class="p">,</span><span class="w"> </span><span class="no">ebx</span><span class="w"></span>
<span class="w">      </span><span class="nf">or</span><span class="w"> </span><span class="no">ecx</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="w">      </span><span class="nf">mov</span><span class="w"> </span><span class="p">[</span><span class="no">table_768</span><span class="err">+</span><span class="no">eax</span><span class="p">*</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="no">ecx</span><span class="w"></span>
<span class="w">      </span><span class="nf">add</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="w"></span>
<span class="w">      </span><span class="nf">inc</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
<span class="w">      </span><span class="nf">cmp</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"></span>
<span class="w">      </span><span class="nf">jne</span><span class="w"> </span><span class="no">.fill_table</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="64-Bit_Paging">64-Bit Paging</span></h2>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="./File:64-bit_page_tables1.png" class="image"><img alt="" src="images/thumb/4/41/64-bit_page_tables1.png/300px-64-bit_page_tables1.png" decoding="async" width="300" height="272" class="thumbimage" srcset="images/thumb/4/41/64-bit_page_tables1.png/450px-64-bit_page_tables1.png 1.5x, images/thumb/4/41/64-bit_page_tables1.png/600px-64-bit_page_tables1.png 2x" data-file-width="689" data-file-height="624" /></a>  <div class="thumbcaption"><div class="magnify"><a href="./File:64-bit_page_tables1.png" class="internal" title="Enlarge"></a></div>Page map table entry structure (non-page-sized)</div></div></div>
<p>Paging in <a href="X86-64" title="X86-64">long mode</a> is similar to that of 32-bit paging, except <a href="PAE" class="mw-redirect" title="PAE">Physical Address Extension</a> (PAE) is required. Registers CR2 and CR3 are extended to 64 bits. Instead of just having to utilize 3 levels of page maps: page directory pointer table, page directory, and page table, a fourth page-map table is used: the level-4 page map table (PML4). This allows a processor to map 48-bit virtual addresses to 52-bit physical addresses. If level-5 page maps are supported and enabled, then a fifth page-map table, the level-5 page map table (PML5), allows the processor to map 57-bit virtual addresses to 52-bit physical addresses. Both the PML4 and PML5 contain 512 64-bit entries of which each may point to a lower-level page map table. Do note that with each additional level of paging, virtual addressing becomes slower, especially in the case of TLB cache misses.
</p><p>Virtual addresses in 64-bit mode must be <b>canonical</b>, that is, the upper bits of the address must either be all 0s or all 1s. For systems supporting 48-bit virtual address spaces, the upper 16 bits must be the same, and for systems supporting 57-bit virtual addresses, the upper 7 bits must match. Although 32-bit code running in <a href="X86-64" title="X86-64">long mode</a> (compatibility mode) is still limited to 32-bit virtual addresses, they can still map to a 52-bit physical addresses.
</p>
<h3><span class="mw-headline" id="Page_Map_Table_Entries">Page Map Table Entries</span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="./File:64-bit_page_tables2.png" class="image"><img alt="" src="images/thumb/6/6b/64-bit_page_tables2.png/300px-64-bit_page_tables2.png" decoding="async" width="300" height="437" class="thumbimage" srcset="images/6/6b/64-bit_page_tables2.png 1.5x" data-file-width="430" data-file-height="626" /></a>  <div class="thumbcaption"><div class="magnify"><a href="./File:64-bit_page_tables2.png" class="internal" title="Enlarge"></a></div>Page map table entry structure (page-sized)</div></div></div>
<p>New bits have been added to page map table entries for long-mode paging:
</p>
<ul><li>XD, or '<b>E</b>xecute <b>D</b>isable'. If the NXE bit (bit 11) is set in the <a href="CPU_Registers_x86-64#IA32_EFER" title="CPU Registers x86-64">EFER register</a>, then instructions are not allowed to be executed at addresses within the page whenever XD is set. If EFER.NXE bit is 0, then the XD bit is reserved and should be set to 0.</li></ul>
<ul><li>PK, or '<b>P</b>rotection <b>K</b>ey'. The protection key is a 4-bit corresponding to each virtual address that is used to control user-mode and supervisor-mode memory accesses. If the PKE bit (bit 22) in CR4 is set, then the PKRU register is used for determining access rights for user-mode based on the protection key. If the PKS bit (bit 24) is set in CR4, then the PKRS register is used for determining access rights for supervisor-mode based on the protection key. A protection key allows the system to enable/disable access rights for multiple page entries across different address spaces at once.</li></ul>
<p>M signifies the physical address width supported by a processor using PAE. Currently, up to 52 bits are supported, but the actual supported width may be less.
</p><p>Bits marked as reserved must all be set to 0, otherwise, a page fault will occur with a reserved error code.
</p><p>Support for 1 GiB pages, (NX) execute disable, (PKS/PKU) protection keys for supervisor-mode and user-mode pages, shadow stack pages, (M) physical address width, virtual address width, (PAT) page attribute table, (PCID) process context identifiers, and (LA57) 5-level paging can be determined with the <a href="CPUID" title="CPUID">CPUID</a> instruction (EAX:0x01; EAX:0x07, ECX=0x00; EAX:0x80000001; EAX:0x80000008).
</p>
<h3><span class="mw-headline" id="Process_Context_Identifiers">Process Context Identifiers</span></h3>
<p>If process context ids (PCID) are supported, then bits 0-11 of CR3 specify the process context id. Otherwise, bit 3 is PWT for PML4, and bit 4 is PCD for PML4. PCIDs are used to control TLB caching across multiple address spaces. The INVPCID instruction uses PCIDs to allow more control over page invalidation.
</p>
<h2><span class="mw-headline" id="Enabling">Enabling</span></h2>
<h3><span class="mw-headline" id="32-bit_Paging">32-bit Paging</span></h3>
<p>Enabling paging is actually very simple. All that is needed is to load CR3 with the address of the page directory and to set the paging (PG) and protection (PE) bits of CR0.
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="w"> </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">page_directory</span><span class="w"></span>
<span class="w"> </span><span class="nf">mov</span><span class="w"> </span><span class="no">cr3</span><span class="p">,</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
<span class="w"> </span>
<span class="w"> </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">cr0</span><span class="w"></span>
<span class="w"> </span><span class="nf">or</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x80000001</span><span class="w"></span>
<span class="w"> </span><span class="nf">mov</span><span class="w"> </span><span class="no">cr0</span><span class="p">,</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
</pre></div>
<p>Note: setting the paging flag when the protection flag is clear causes a <a href="Exceptions#General_Protection_Fault" title="Exceptions">general protection exception</a>. Also, once paging has been enabled, any attempt to enable long mode by setting LME (bit 8) of the <a href="CPU_Registers_x86-64#IA32_EFER" title="CPU Registers x86-64">EFER register</a> will trigger a <a href="Exceptions#General_Protection_Fault" title="Exceptions">GPF</a>. The CR0.PG must first be cleared before EFER.LME can be set.
</p><p>If you want to set pages as read-only for both userspace and supervisor, replace 0x80000001 above with 0x80010001, which also sets the WP bit.
</p><p>To enable PSE (4 MiB pages) the following code is required.
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="w"> </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">cr4</span><span class="w"></span>
<span class="w"> </span><span class="nf">or</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x00000010</span><span class="w"></span>
<span class="w"> </span><span class="nf">mov</span><span class="w"> </span><span class="no">cr4</span><span class="p">,</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="64-bit_Paging_2">64-bit Paging</span></h3>
<p>Enabling paging in long mode requires a few more additional steps. Since it is not possible to enter long mode without paging with PAE active, the order in which one enables the bits are important. Firstly, paging must not be active (i.e. CR0.PG must be cleared.) Then, CR4.PAE (bit 5) and EFER.LME (bit 8 of MSR 0xC0000080) are set. If 57-bit virtual addresses are to be enabled, then CR4.LA57 (bit 12) is set. Finally, CR0.PG is set to enable paging.
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="w">  </span><span class="c1">; Skip these 3 lines if paging is already disabled</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="no">cr0</span><span class="w"></span>
<span class="w">  </span><span class="nf">and</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="err">~</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="err">&lt;&lt;</span><span class="w"> </span><span class="mi">31</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">cr0</span><span class="p">,</span><span class="w"> </span><span class="no">ebx</span><span class="w"></span>

<span class="w">  </span><span class="c1">; Enable PAE</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="w"> </span><span class="no">cr4</span><span class="w"></span>
<span class="w">  </span><span class="nf">or</span><span class="w">  </span><span class="no">edx</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="err">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">cr4</span><span class="p">,</span><span class="w"> </span><span class="no">edx</span><span class="w"></span>

<span class="w">  </span><span class="c1">; Set LME (long mode enable)</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">ecx</span><span class="p">,</span><span class="w"> </span><span class="mi">0xC0000080</span><span class="w"></span>
<span class="w">  </span><span class="nf">rdmsr</span><span class="w"></span>
<span class="w">  </span><span class="nf">or</span><span class="w">  </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="err">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nf">wrmsr</span><span class="w"></span>

<span class="w">  </span><span class="c1">; Replace &#39;pml4_table&#39; with the appropriate physical address (and flags, if applicable)</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">pml4_table</span><span class="w"></span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">cr3</span><span class="p">,</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>

<span class="w">  </span><span class="c1">; Enable paging (and protected mode, if it isn&#39;t already active)</span>
<span class="w">  </span><span class="nf">or</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="err">&lt;&lt;</span><span class="w"> </span><span class="mi">31</span><span class="p">)</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="err">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">cr0</span><span class="p">,</span><span class="w"> </span><span class="no">ebx</span><span class="w"></span>

<span class="w">  </span><span class="c1">; Now reload the segment registers (CS, DS, SS, etc.) with the appropriate segment selectors...</span>

<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="no">DATA_SEL</span><span class="w"></span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">ds</span><span class="p">,</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">es</span><span class="p">,</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">fs</span><span class="p">,</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">gs</span><span class="p">,</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">; Reload CS with a 64-bit code selector by performing a long jmp</span>

<span class="w">  </span><span class="nf">jmp</span><span class="w"> </span><span class="no">CODE_SEL</span><span class="p">:</span><span class="no">reloadCS</span><span class="w"></span>

<span class="err">[</span><span class="nf">BITS</span><span class="w"> </span><span class="mi">64</span><span class="p">]</span><span class="w"></span>
<span class="nl">reloadCS:</span><span class="w"></span>
<span class="w">  </span><span class="nf">hlt</span><span class="w">   </span><span class="c1">; Done. Replace these lines with your own code</span>
<span class="w">  </span><span class="nf">jmp</span><span class="w"> </span><span class="no">reloadCS</span><span class="w"></span>
</pre></div>
<p>Once paging has been enabled, you cannot switch from 4-level paging to 5-level paging (and vice-versa) directly. The same is true for switching to legacy 32-bit paging. You must first disable paging by clearing CR0.PG before making changes. Failure to do so will result in a <a href="Exceptions#General_Protection_Fault" title="Exceptions">general protection fault</a>.
</p>
<h2><span class="mw-headline" id="Physical_Address_Extension">Physical Address Extension</span></h2>
<p>All Intel processors since Pentium Pro (with exception of the Pentium M at 400 Mhz) and all AMD since the Athlon series implement the <a href="PAE" class="mw-redirect" title="PAE">Physical Address Extension</a> (PAE). This feature allows you to access up to 4 PiB (2<sup>52</sup>) of RAM. You can check for this feature using <a href="CPUID" title="CPUID">CPUID</a>. Once checked, you can activate this feature by setting bit 5 in CR4.
</p><p>For legacy 32-bit PAE, the CR3 register points to a page directory pointer table (PDPT) of 4 64-bit entries, each one pointing to a page directory made of 4096 bytes (like in normal paging), divided into 512 64-bit entries, each pointing to a 4096-byte page table, divided into 512 64bit page entries. Keep in mind that virtual addresses are still limited to 4 GiB (2<sup>32</sup> bytes).
</p><p>For 4-level and 5-level PAE, as used in compatibility mode and <a href="X86-64" title="X86-64">long mode</a>, the CR3 register points to the top-level page map table: the PML4 table and PML5 table, respectively. Each of the page map tables: PML5 table, PML4 table, page directory pointer table, page directory, page table, contain 512 64-bit entries.
</p><p>If paging is enabled then PAE must also be enabled before entering long mode. Attempting to enter long mode with CR0.PG set and CR4.PAE cleared will trigger a general protection fault.
</p>
<h2><span class="mw-headline" id="Usage">Usage</span></h2>
<p>Due to the simplicity in the design of paging, it has many uses.
</p>
<h3><span class="mw-headline" id="Virtual_Address_Spaces">Virtual Address Spaces</span></h3>
<p>In a paged system, each process may execute in its own area of memory, without any chance of affecting any other process's memory, or the kernel's. Two or more processes may opt to share memory by mapping the same physical page(s) to addresses in their own address spaces. The virtual address of each mapping do not need to be the same. Consequently, a virtual address in one address space won't point to the same data in other address spaces, in general. 
</p>
<div class="thumb tnone"><div class="thumbinner" style="width:552px;"><a href="./File:Virtual_memory.png" class="image"><img alt="" src="images/a/a7/Virtual_memory.png" decoding="async" width="550" height="175" class="thumbimage" data-file-width="550" data-file-height="175" /></a>  <div class="thumbcaption">paging illustrated: two process with different views of the same physical memory</div></div></div>
<h3><span class="mw-headline" id="Virtual_Memory">Virtual Memory</span></h3>
<p>Because paging allows for the dynamic handling of unallocated page tables, an OS can swap entire pages, not in current use, to the hard drive where they can wait until they are called. In the mean time, however, the  physical memory that they were using can be used elsewhere. In this way, the OS can manipulate the system so that programs actually seem to have more RAM than there actually is. 
</p><p><i>More...</i>
</p>
<h2><span class="mw-headline" id="Manipulation">Manipulation</span></h2>
<p>The CR3 value, that is, the value containing the address of the page directory, is in physical form. Once, then, the computer is in paging mode, only recognizing those virtual addresses mapped into the paging tables, how can the tables be edited and dynamically changed?
</p><p>Many prefer to map the last PDE to itself. The page directory will look like a page table to the system. To get the physical address of any virtual address in the range 0x00000000-0xFFFFF000 is then just a matter of:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">get_physaddr</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">virtualaddr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">pdindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">virtualaddr</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">22</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ptindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">virtualaddr</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x03FF</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">pd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mh">0xFFFFF000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Here you need to check whether the PD entry is present.</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mh">0xFFC00000</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mh">0x400</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pdindex</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Here you need to check whether the PT entry is present.</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)((</span><span class="n">pt</span><span class="p">[</span><span class="n">ptindex</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mh">0xFFF</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">virtualaddr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFF</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>To map a virtual address to a physical address can be done as follows:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">map_page</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">physaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">virtualaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Make sure that both addresses are page-aligned.</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">pdindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">virtualaddr</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">22</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ptindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">virtualaddr</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x03FF</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">pd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mh">0xFFFFF000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Here you need to check whether the PD entry is present.</span>
<span class="w">    </span><span class="c1">// When it is not present, you need to create a new empty PT and</span>
<span class="w">    </span><span class="c1">// adjust the PDE accordingly.</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mh">0xFFC00000</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mh">0x400</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pdindex</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Here you need to check whether the PT entry is present.</span>
<span class="w">    </span><span class="c1">// When it is, then there is already a mapping present. What do you do now?</span>

<span class="w">    </span><span class="n">pt</span><span class="p">[</span><span class="n">ptindex</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">physaddr</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFF</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w"> </span><span class="c1">// Present</span>

<span class="w">    </span><span class="c1">// Now you need to flush the entry in the TLB</span>
<span class="w">    </span><span class="c1">// or you might not notice the change.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Unmapping an entry is essentially the same as above, but instead of assigning the <code>pt[ptindex]</code> a value, you set it to 0x00000000 (i.e. not present). When the entire page table is empty, you may want to remove it and mark the page directory entry 'not present'. Of course you don't need the 'flags' or 'physaddr' for unmapping.
</p>
<h2><span class="mw-headline" id="Page_Faults">Page Faults</span></h2>
<p>A <a href="Exceptions#Page_Fault" title="Exceptions">page fault</a> exception is caused when a process is seeking to access an area of virtual memory that is not mapped to any physical memory, when a write is attempted on a read-only page, when accessing a PTE or PDE with the reserved bit or when permissions are inadequate. A <a href="Exceptions#Page_Fault" title="Exceptions">page fault</a> can either be pure, which occurs when the faulting process has permission to access the page, or invalid, which is due to a protection violation. Pure <a href="Exceptions#Page_Fault" title="Exceptions">page faults</a> aren't errors, but are resolved through the page fault handler by performing the appropriate map operation and/or page swap.
</p>
<h3><span class="mw-headline" id="Handling">Handling</span></h3>
<p>The CPU pushes an error code on the stack before firing a <a href="Exceptions#Page_Fault" title="Exceptions">page fault exception</a>.  The error code must be analyzed by the exception handler to determine how to handle the exception.  The following bits are the only ones used, all others are reserved.
</p>
<pre>Bit 0 (P) is the Present flag.
Bit 1 (R/W) is the Read/Write flag.
Bit 2 (U/S) is the User/Supervisor flag.
Bit 3 (RSVD) indicates whether a reserved bit was set in some page-structure entry
Bit 4 (I/D) is the Instruction/Data flag (1=instruction fetch, 0=data access)
Bit 5 (PK) indicates a protection-key violation
Bit 6 (SS) indicates a shadow-stack access fault
Bit 15 (SGX) indicates an <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Software_Guard_Extensions">SGX violaton</a>
</pre>
<p>The combination of these flags specify the details of the page fault and indicate what action to take:
</p>
<pre>US RW  P - Description
0  0  0 - Supervisory process tried to read a non-present page entry
0  0  1 - Supervisory process tried to read a page and caused a protection fault
0  1  0 - Supervisory process tried to write to a non-present page entry
0  1  1 - Supervisory process tried to write a page and caused a protection fault
1  0  0 - User process tried to read a non-present page entry
1  0  1 - User process tried to read a page and caused a protection fault
1  1  0 - User process tried to write to a non-present page entry
1  1  1 - User process tried to write a page and caused a protection fault
</pre>
<p>When the CPU fires a page-not-present exception the CR2 register is populated with the linear address that caused the exception.  The upper 10 bits specify the page directory entry (PDE) and the middle 10 bits specify the page table entry (PTE).  First check the PDE and see if it's present bit is set, if not setup a page table and point  the PDE to the base address of the page table, set the present bit and iretd.  If the PDE is present then the present bit of the PTE will be cleared.  You'll need to map some physical memory to the page table, set the present bit and then iretd to continue processing.
</p>
<h2><span class="mw-headline" id="INVLPG">INVLPG</span></h2>
<p>INVLPG is an instruction available since the i486 that invalidates a single page in the TLB. Intel notes that this instruction may be implemented differently on future processors, but that this alternate behavior must be explicitly enabled. INVLPG modifies no flags.
</p><p>NASM example:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="w"> </span><span class="nf">invlpg</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
</pre></div>
<p>Inline assembly for GCC (from Linux kernel source):
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__native_flush_tlb_single</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;invlpg (%0)&quot;</span><span class="w"> </span><span class="o">::</span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;memory&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This only invalidates the page on the current processor. If you're using SMP, you'll need to send an IPI to the other processors so that they can also invalidate the page (this is called a TLB shootdown; it's very slow), making sure to avoid any nasty race conditions. You may only want to do this when removing a mapping, and just make your page fault handler invalidate a page if it you didn't invalidate a mapping addition on that processor by looking through the page directory, again avoiding race conditions.
</p><p>When you modify an entry in the page directory, rather than just a page table, you'll need to invalidate each page in the table. Alternatively, you could  reload CR3 which will invalidates the whole directory, but this may be slower. (TODO time this)
</p>
<h2><span class="mw-headline" id="Paging_Tricks">Paging Tricks</span></h2>
<p>The processor always fires a page fault exception when the present bit is cleared in the PDE or PTE regardless of the address.  This means the contents of the PTE or PDE can be used to indicate a location of the page saved on mass storage and to quickly load it.  When a page gets swapped to disk, use these entries to identify the location in the paging file where they can be quickly loaded from then set the present bit to 0. Similarly, blocks from disk can be mapped to memory this way. When a process accesses the memory-mapped region, a page fault occurs. The fault handler reads the appropriate tables, loads the disk block(s) into a page, and maps it. The process can then read/write to memory as if it were accessing the device directly. The contents of the page would then be written back to disk to save the changes.
</p><p>For memory efficiency, two or more processes can share pages as read-only. If one process were to write to its page, then a page fault would occur and the system could duplicate the page and then mark it as read-write. This is known as copy-on-write (COW). Copy-on-write allows the system to delay memory allocation until a process actually requires it, preventing unnecessary copying.
</p>
<h2><span class="mw-headline" id="PAT">PAT</span></h2>
<p>The Page Attribute Table determines caching attributes on a page granularity. This is similar to <a href="MTRR" title="MTRR">MTRRs</a>, but those apply to physical addresses and are more limited.
</p><p>The PAT is set via the IA32_PAT_MSR <a href="MSR" class="mw-redirect" title="MSR">MSR</a> (0x277). It has 8 entries, taking the low order 3 bits of each byte, in standard little endian order. So the high byte is PAT7, low byte is PAT0.
</p><p>The following are the different caching types.
</p>
<table class="wikitable" border="1">

<tbody><tr>
<th>Number
</th>
<th>Name
</th>
<th>Description
</th></tr>
<tr>
<td>0
</td>
<td>UC — Uncacheable
</td>
<td>All accesses are uncacheable. Write combining is not allowed. Speculative accesses are not allowed.
</td></tr>
<tr>
<td>1
</td>
<td>WC — Write-Combining
</td>
<td>All accesses are uncacheable. Write combining is allowed. Speculative reads are allowed.
</td></tr>
<tr>
<td>4
</td>
<td>WT — Writethrough
</td>
<td>Reads allocate cache lines on a cache miss. Cache lines are not allocated on a write miss.
<p>Write hits update the cache and main memory.
</p>
</td></tr>
<tr>
<td>5
</td>
<td>WP — Write-Protect
</td>
<td>Reads allocate cache lines on a cache miss. All writes update main memory.
<p>Cache lines are not allocated on a write miss. Write hits invalidate the cache
line and update main memory.
</p>
</td></tr>
<tr>
<td>6
</td>
<td>WB — Writeback
</td>
<td>Reads allocate cache lines on a cache miss, and can allocate to either the shared,
<p>exclusive, or modified state. Writes allocate to the modified state on a cache miss.
</p>
</td></tr>
<tr>
<td>7
</td>
<td>UC- — Uncached
</td>
<td>Same as uncacheable, <i>except</i> that this can be overriden by Write-Combining MTRRs.
</td></tr></tbody></table>
<p>The PAT has a reset value of 0x0007040600070406. This ensures compatibility with non-PAT usage. This corresponds to the following:
</p>
<table class="wikitable" border="1">

<tbody><tr>
<td>UC
</td>
<td>UC-
</td>
<td>WT
</td>
<td>WB
</td>
<td>UC
</td>
<td>UC-
</td>
<td>WT
</td>
<td>WB
</td></tr></tbody></table>
<p>The PAT is indexed by the three page table bits:
</p>
<table class="wikitable" border="1">

<tbody><tr>
<td>PAT
</td>
<td>PCD
</td>
<td>PWT
</td></tr></tbody></table>
<p>The PAT bit is reserved when there isn't a PAT, and the default value of the MSR ensures backwards comaptibility with the PCD and PWT bit.
</p><p>You will need to modify the PAT if you want Write-Combining cache, which is very useful for framebuffers.
</p>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="Identity_Paging" title="Identity Paging">Identity Paging</a></li>
<li><a href="Page_Frame_Allocation" title="Page Frame Allocation">Page Frame Allocation</a></li>
<li><a href="Setting_Up_Paging" title="Setting Up Paging">Setting Up Paging</a></li>
<li><a href="Page_Tables" title="Page Tables">Page Tables</a></li>
<li><a href="Memory_Management" class="mw-redirect" title="Memory Management">Memory Management</a></li>
<li><a href="Memory_Management_Unit" title="Memory Management Unit">Memory Management Unit</a></li>
<li><a rel="nofollow" class="external text" href="https://forum.osdev.org/viewtopic.php?p=282061">Page Coloring</a></li></ul>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="https://forum.osdev.org/viewtopic.php?f=1&amp;t=18222">INVLPG thread</a></li>
<li><a rel="nofollow" class="external text" href="http://www.dumaisnet.ca/index.php?article=ff3b7adb128cb438ac1e306b3fbe37e7">Process Context ID</a></li>
<li><a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Intel_5-level_paging">5-Level Paging</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250212010442
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.076 seconds
Real time usage: 1.130 seconds
Preprocessor visited node count: 160/1000000
Post‐expand include size: 425/2097152 bytes
Template argument size: 9/2097152 bytes
Highest expansion depth: 4/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 20800/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    1.160      1 -total
100.00%    1.160      1 Template:Disputed
 37.41%    0.434      1 Template:DiscussThis
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2122-0!canonical and timestamp 20250212010441 and revision id 29363.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Paging&amp;oldid=29363">https://wiki.osdev.org/index.php?title=Paging&amp;oldid=29363</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Disputed_Pages" title="Category:Disputed Pages">Disputed Pages</a></li><li><a href="./Category:Memory_management" title="Category:Memory management">Memory management</a></li><li><a href="./Category:Paging" title="Category:Paging">Paging</a></li><li><a href="./Category:Virtual_Memory" title="Category:Virtual Memory">Virtual Memory</a></li><li><a href="./Category:Security" title="Category:Security">Security</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Paging" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="Paging#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Paging" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:Paging" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Paging"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Paging&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Paging&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Paging" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/Paging" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Paging&amp;oldid=29363" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Paging&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/Paging" title="Paging – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 1 February 2025, at 19:05.</li>
	<li id="footer-info-0">This page has been accessed 55,174 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Paging&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.076","walltime":"1.130","ppvisitednodes":{"value":160,"limit":1000000},"postexpandincludesize":{"value":425,"limit":2097152},"templateargumentsize":{"value":9,"limit":2097152},"expansiondepth":{"value":4,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":20800,"limit":5000000},"timingprofile":["100.00%    1.160      1 -total","100.00%    1.160      1 Template:Disputed"," 37.41%    0.434      1 Template:DiscussThis"]},"cachereport":{"timestamp":"20250212010442","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":1225});});</script>
</body>
</html>