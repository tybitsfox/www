<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Kernel Debugging - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"c6f40dc5116d80268d744e5e","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Kernel_Debugging","wgTitle":"Kernel Debugging","wgCurRevisionId":28799,"wgRevisionId":28799,"wgArticleId":1947,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Kernel","Debugging","Troubleshooting"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Kernel_Debugging","wgRelevantArticleId":1947,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],
"wgRestrictionMove":[],"wgRedirectedFrom":"How_Do_I_Use_A_Debugger_With_My_OS","wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgInternalRedirectTargetUrl":"/Kernel_Debugging","wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook",
"ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="Kernel_Debugging"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Kernel_Debugging rootpage-Kernel_Debugging skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Kernel Debugging</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"><span class="mw-redirectedfrom">(Redirected from <a href="https://wiki.osdev.org/index.php?title=How_Do_I_Use_A_Debugger_With_My_OS&amp;redirect=no" class="mw-redirect" title="How Do I Use A Debugger With My OS">How Do I Use A Debugger With My OS</a>)</span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="How_Do_I_Use_A_Debugger_With_My_OS#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="How_Do_I_Use_A_Debugger_With_My_OS#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>Humans make mistakes. Some of these mistakes may end up being part of your OS. Since bugs are more difficult to find than to fix, this page provides a list of common techniques that can be used to isolate bugs in your OS.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Debug_statements_and_log_files"><span class="tocnumber">1</span> <span class="toctext">Debug statements and log files</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Pseudo-Breakpoints"><span class="tocnumber">2</span> <span class="toctext">Pseudo-Breakpoints</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Use_a_virtual_machine"><span class="tocnumber">3</span> <span class="toctext">Use a virtual machine</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Using_the_serial_port"><span class="tocnumber">4</span> <span class="toctext">Using the serial port</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Writing_logfiles_with_QEMU"><span class="tocnumber">4.1</span> <span class="toctext">Writing logfiles with QEMU</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="How_Do_I_Use_A_Debugger_With_My_OS#On_real_hardware"><span class="tocnumber">4.2</span> <span class="toctext">On real hardware</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="How_Do_I_Use_A_Debugger_With_My_OS#With_remote_debugger_/_GDB"><span class="tocnumber">4.2.1</span> <span class="toctext">With remote debugger / GDB</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Using_mini_debugger"><span class="tocnumber">4.2.2</span> <span class="toctext">Using mini debugger</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Using_Debuggers_with_VMs"><span class="tocnumber">5</span> <span class="toctext">Using Debuggers with VMs</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Use_GDB_with_QEMU"><span class="tocnumber">5.1</span> <span class="toctext">Use GDB with QEMU</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Use_LLDB_with_QEMU"><span class="tocnumber">5.2</span> <span class="toctext">Use LLDB with QEMU</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Use_bochs_debugger"><span class="tocnumber">5.3</span> <span class="toctext">Use bochs debugger</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Use_VirtualBox_debugger"><span class="tocnumber">5.4</span> <span class="toctext">Use VirtualBox debugger</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="How_Do_I_Use_A_Debugger_With_My_OS#GUI_frontends"><span class="tocnumber">6</span> <span class="toctext">GUI frontends</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Develop_in_hosted_environment"><span class="tocnumber">7</span> <span class="toctext">Develop in hosted environment</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Using_an_IDE"><span class="tocnumber">8</span> <span class="toctext">Using an IDE</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="How_Do_I_Use_A_Debugger_With_My_OS#VirtualBox"><span class="tocnumber">9</span> <span class="toctext">VirtualBox</span></a></li>
<li class="toclevel-1 tocsection-18"><a href="How_Do_I_Use_A_Debugger_With_My_OS#See_Also"><span class="tocnumber">10</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-19"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Articles"><span class="tocnumber">10.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="How_Do_I_Use_A_Debugger_With_My_OS#Forum_Threads"><span class="tocnumber">10.2</span> <span class="toctext">Forum Threads</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Debug_statements_and_log_files">Debug statements and log files</span></h2>
<p>The first solution is probably the easiest, and depends on what kind of information you
want to get back from your debugger.
</p><p>The problem with using a debugger such as DDD or GDB is that they require an OS to run... kinda
useless when it's the OS itself that you want to debug.
</p><p>Debugging is essentially being able to probe the contents of a variable at a specific breakpoint.
When your program hits the breakpoint, you can probe the variable.
</p><p>This can also be achieved without using a debugger, by instead inserting a line of code to
write to the screen or to a log of some kind. This gives you the contents of the variable
that you are interested in - but it means knowing in advance what variable to check, and when,
and implies recompiling the kernel every time you want to check a different set of variables...
but it is the simplest solution.
</p>
<h2><span class="mw-headline" id="Pseudo-Breakpoints">Pseudo-Breakpoints</span></h2>
<p>In places where a full print or logging function is not feasible (such as when trying to isolate a single erroneous assembly language instruction), you can create a kind of 'pseudo-breakpoint' by inserting an "1: jmp 1b" instruction into the code. These can be used to perform a binary space isolation (often referred to as a 'binary chop') through the code. The idea is to place the endless loop at a point roughly halfway through the part of the code suspected to be at fault; if the CPU halts before the error occurs, then you know that the error is after the breakpoint, otherwise, it must be in the code before breakpoint. Repeat this procedure until the error is isolated. Unfortunately, this only works if the result of the error can be differentiated from the halt instruction itself, and it does little in the case of a problem occurring more than one repetition into loop, such as an array overrun. But you could use a virtual machine debugger to do single stepping with pseudo-breakpoints (see below "Using Debuggers with VMs").
</p><p>IMPORTANT NOTE #1: the HLT instruction is a privileged instruction, and as such it will only work in your kernel. The pseudo-breakpoint "1: jmp 1b" is unprivileged, and works from user mode too.
</p><p>IMPORTANT NOTE #2: gcc thinks it is smarter than the programmer, so if you use "while(1);", then it will falsely assume that everything after that loop is not needed, and it will REMOVE all those code from the binary. You MUST use inline assembly so that gcc will keep your code as-is.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;1: jmp 1b&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Use_a_virtual_machine">Use a virtual machine</span></h2>
<p>A virtual machine is a program that simulates another computer (Java coders should be familiar with
the concept).
</p><p>There are a number of virtual machines that can simulate x86 machines, my favorite is Bochs
(<a rel="nofollow" class="external free" href="http://bochs.sourceforge.net">http://bochs.sourceforge.net</a>). Bochs is capable of setting breakpoints in any kind of software
(even if it is compiled without debugging info!), and provides an additional "debugging <tt>out</tt>
port" you can easily access from within your kernel code to print debug messages.
</p><p>The main downside to using a virtual machine like this is that all the code is displayed in
assembler (or binary depending on what machine you choose) - instead of the C/C++ source you
originally wrote. Also, simulating a virtual machine is slower than an actual machine, and the
VM might not even behave exactly like the "real" hardware.
</p><p>That being said, there are also a lot of other advantages to using a VM.
For example, you don't have to reboot to test your new OS, you just start the VM.
</p>
<h2><span class="mw-headline" id="Using_the_serial_port">Using the serial port</span></h2>
<h3><span class="mw-headline" id="Writing_logfiles_with_QEMU">Writing logfiles with QEMU</span></h3>
<p>QEMU allows you to redirect everything that you send to COM1 port to a file on your host computer. To enable this feature, you have to add the following flag when launching QEMU:
</p>
<pre>-serial file:serial.log
</pre>
<p>... while "serial.log" is the path to the output file. Once you have this feature enabled, you can write log entries by simply <a href="Serial_Ports" title="Serial Ports">writing characters to the COM1 port</a> (reading from the file over the serial port is not supported).
</p>
<h3><span class="mw-headline" id="On_real_hardware">On real hardware</span></h3>
<p>When your real computer resets due to a programming error, anything you might have put on the screen will instantly vanish. If you're tampering with the video card, you will often find yourself with no visual debugging method at all. If you have a pair of computers connected with a null-modem cable, you can instead send all debug statments over the serial port instead and record them on your development machine that is more stable. Using an actual serial terminal works just as well. It requires a bit of additional cabling, but it works fairly simple and can prove to be a very good replacement for a VM log.
</p>
<h4><span id="With_remote_debugger_.2F_GDB"></span><span class="mw-headline" id="With_remote_debugger_/_GDB">With remote debugger / GDB</span></h4>
<p>Since serial works two ways, you can also control your kernel remotely in case of problems. This can be a simple interface, but you can also attach GDB onto the serial port and potentially get a full blown debugger running.
</p><p>This is however rather tricky, since it requires additional hardware, and special support coded into your kernel. You might want to read the <a rel="nofollow" class="external text" href="http://web.archive.org/web/20070415113206/http://www.kernelhacking.org/docs/kernelhacking-HOWTO/indexs09.html">kernel hacking how-to</a> and (at minimum) <a rel="nofollow" class="external text" href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Remote-Debugging.html#Remote-Debugging">chapter 20 of the GDB manual</a>, and chances are likely that your debugger will introduce even more bugs at first.
</p>
<h4><span class="mw-headline" id="Using_mini_debugger">Using mini debugger</span></h4>
<p>Because integrating gdb is quite a task, you could use the <a rel="nofollow" class="external text" href="https://gitlab.com/bztsrc/minidbg">mini debugger</a> library instead, which is small and simple, written in ANSI C (and a little Assembly). That is a minimal interactive debugger (dumps registers and memory, disassembles instructions) which works on serial terminals (such as VT100, VT220 or emulators like PuTTY and minicom). Available for <a href="AArch64" title="AArch64">AArch64</a> and <a href="X86-64" title="X86-64">x86-64</a> kernels. You can use that library as a skeleton to implement your own, fully featured kernel debugger if you want.
</p>
<h2><span class="mw-headline" id="Using_Debuggers_with_VMs">Using Debuggers with VMs</span></h2>
<h3><span class="mw-headline" id="Use_GDB_with_QEMU">Use GDB with QEMU</span></h3>
<p>You can run QEMU to listen for a "GDB connection" before it starts executing any code to debug it.
</p>
<pre>qemu -s -S &lt;harddrive.img&gt;
</pre>
<p>...will setup QEMU to listen on port 1234 and wait for a GDB connection to it. Then, from a remote or local shell:
</p>
<pre>gdb 
(gdb) target remote localhost:1234 
</pre>
<p>(Replace localhost with remote IP / URL if necessary.) Then start execution:
</p><p>But that's not all, you can compile your source code under GCC with debugging symbols using "-g". This will add all the debugging symbols in the kernel image itself (Thus making it bigger). There is also a way to put all of the debugging information in a separate file using the "objcopy" tool, which is part of the GNU Binutils package.
</p>
<pre>objcopy --only-keep-debug kernel.elf kernel.sym
</pre>
<p>This will put the debugging information into a file called "kernel.sym". After that to strip your executable of debugging information you can do
</p>
<pre>objcopy --strip-debug kernel.elf
</pre>
<p>Or alternatively, if you are using a flat binary as your kernel image, you can do
</p>
<pre>objcopy -O binary kernel.elf kernel.bin
</pre>
<p>To produce a flat binary which can be debugged using the previously extracted debug information
</p><p>You can import the symbols in GDB by pointing GDB to the file containing debug information
</p>
<pre>(gdb) symbol-file kernel.elf             ;kernel.elf is the actual unstripped kernel image in this case
</pre>
<p>From there, you can see the actual C source code as it runs line per line! (Use the stepi instruction in GDB to execute the code line per line.)
</p><p>Example&#160;:
</p>
<pre>$ qemu -s -S c.img
warning: could not open /dev/net/tun: no virtual network emulation
Waiting gdb connection on port 1234 

(gdb) target remote localhost:1234
Remote debugging using localhost:1234
0x0000fff0 in&#160;?? ()
(gdb) symbol-file kernel.b
Reading symbols from kernel.b...done.

(gdb) break kmain                       &#160;; This will add a break point to any function in your kernel code.
Breakpoint 1 at 0x101800: file kernel/kernel.c, line 12.

(gdb) continue

Breakpoint 1, kmain (mdb=0x341e0, magic=0) at kernel/kernel.c:12
12      {
</pre>
<p>The above started code execution, and will stop at kmain specified in the "break kmain" above.
You can view registers at anytime with this command
</p>
<pre>(gdb) info registers
</pre>
<p>I won't start explaining all the nice things about GDB, but as you can see, it is a very powerful tool for debugging OSes.
</p><p>Alternatively you can force a breakpoint in your code without knowing the name of the function or the address. Place an endless loop pseudo-breakpoint somewhere in your code
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;1: jmp 1b&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Then on the terminal that's running gdb, when your VM hangs press Ctrl^C to stop execution and drop you at the debugger prompt. There
</p>
<pre>(gdb) set $pc += 2
</pre>
<p>Will step over the endless loop, and you can start single stepping, executing one instruction at a time with
</p>
<pre>(gdb) si
</pre>
<h3><span class="mw-headline" id="Use_LLDB_with_QEMU">Use LLDB with QEMU</span></h3>
<p>LLDB supports GDB server that QEMU uses, so you can do the same thing with the previous section, but with some command modification as LLDB has some commands that are different than GDB
</p><p>You can run QEMU to listen for a "GDB connection" before it starts executing any code to debug it.
</p>
<pre>qemu -s -S &lt;harddrive.img&gt;
</pre>
<p>...will setup QEMU to listen on port 1234 and wait for a GDB connection to it. Then, from a remote or local shell:
</p>
<pre>lldb kernel.elf
(lldb) target create "kernel.elf"
Current executable set to '/home/user/osdev/kernel.elf' (x86_64).
(lldb) gdb-remote localhost:1234
Process 1 stopped
* thread #1, stop reason = signal SIGTRAP
    frame #0: 0x000000000000fff0
-&gt;  0xfff0: addb   %al, (%rax)
    0xfff2: addb   %al, (%rax)
    0xfff4: addb   %al, (%rax)
    0xfff6: addb   %al, (%rax)
</pre>
<p>(Replace localhost with remote IP / URL if necessary.) Then start execution:
</p>
<pre>(lldb) c
Process 1 resuming
</pre>
<p>To set a breakpoint:
</p>
<pre>(lldb) breakpoint set --name kmain
Breakpoint 1: where = kernel.elf`kmain, address = 0xffffffff802025d0
</pre>
<h3><span class="mw-headline" id="Use_bochs_debugger">Use bochs debugger</span></h3>
<p>The easiest way to trigger a breakpoint in bochs is to place "xchg bx, bx" into your code. For example
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;xchg %bx, %bx&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Then when you run the virtual machine, it will stop execution and drop you at debugger prompt. To single step from there, use
</p>
<pre>bochs:1&gt; s
</pre>
<h3><span class="mw-headline" id="Use_VirtualBox_debugger">Use VirtualBox debugger</span></h3>
<p>Unfortunately VirtualBox developers have removed the "--start-dbg" command line option, so there's no way to set up breakpoints before your VM starts execution.
But you can do a similar trick as with GDB, which is to place an endless loop pseudo-breakpoint in your code somewhere:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;1: jmp 1b&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Then when the execution hangs, access "Command line..." under "Debug" menu (if you don't have a Debug menu in the Machine window, you'll have to enable the debugger see below). In the debugger command line, the first thing to do is that you MUST stop the VM from running:
</p>
<pre>VBoxDbg&gt; stop
</pre>
<p>This should dump the registers. But if not, then get the current RIP value with:
</p>
<pre>VBoxDbg&gt; r
</pre>
<p>Once you get the current RIP, add 2 to it, and set a new RIP (I couldn't find any way to reference RIP from command line, you have to use constants), for example:
</p>
<pre>VBoxDbg&gt; r rip = 0xfffffffff1000102
</pre>
<p>Check if the current RIP correctly points to the instruction after the endless loop:
</p>
<pre>VBoxDbg&gt; r
</pre>
<p>And you can start single stepping with
</p>
<pre>VBoxDbg&gt; p
</pre>
<h2><span class="mw-headline" id="GUI_frontends">GUI frontends</span></h2>
<p>While GDB provides a text-based user interface (available via the `-tui` command line option or by entering `wh` at the GDB prompt), you might want to use one of the available GUI frontents to GDB. These include but are not limited to:
</p>
<pre>* <a rel="nofollow" class="external text" href="http://www.kdbg.org/">KDbg</a>
* <a rel="nofollow" class="external text" href="http://sources.redhat.com/insight/">Insight</a>
* <a rel="nofollow" class="external text" href="http://www.gnu.org/s/ddd/">DDD</a>
* <a rel="nofollow" class="external text" href="http://visualkernel.com/">VisualKernel</a>
</pre>
<p>Attaching to a QEMU session works similar to the command line GDB described above.
</p>
<h2><span class="mw-headline" id="Develop_in_hosted_environment">Develop in hosted environment</span></h2>
<p>Another possibility, which is also a great architectural exercise, is to code every software module in a hosted environment like Linux, and then port it to your OS. You can do this for kernel code too, not just usermode programs.
</p><p>Suppose you want to develop your VFS interface implementation. Your already created the interface for block devices (doesn't matter if you already implemented it in your kernel). In this case, you can implement your block device interface as a set of wrappers that <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Adapter_pattern">adapts</a> your interface to POSIX calls. You will then implement your VFS interface (i.e., the code that will manage the filesystem drivers in your kernel) on top of those wrappers. You will then test&amp;debug your implementation all in the hosted environment, and when it is mature, you link it into your real kernel instead of into your hosted implementations. You will finally test your newly introduced code, now in the freestanding environment to ensure it works there as well.
</p><p>Now, the Pros. First of all, you can use your favourite debugger. You can also use unit testing, for example, which is far better than testing software by hand, if you use the right method.
</p><p>There are some Cons on this approach. For example, you are far from your target environment when you code like this. This is further aggravated by the fact that so-called <i>freestanding</i> environments are dramatically more sensitive to undefined behaviour, specially uninitialized variables. You can work around this limitation by asking the compiler to perform aggressive optimization while testing hosted, which make software more sensible to undefined behaviour, too. However, as the best debug environment is the final target environment, you will still want to test your code when you introduce in into your real kernel.
</p><p>Another Con that will probably scare most people is that this approach requires you to consistently plan your interfaces beforehand. Depending on your specific requirements, you may still be able to avoid a too long planning phase. For example, if you want to throw away the hosted implementations once you get the modules working properly, then you don't have to bother maintaining the same interfaces forever.
</p>
<h2><span class="mw-headline" id="Using_an_IDE">Using an IDE</span></h2>
<p>You can debug Linux kernel modules with Visual Studio if you use the VisualKernel plugin. Here's a tutorial showing a normal debugging session: <a rel="nofollow" class="external free" href="http://visualkernel.com/tutorials/kgdb/">http://visualkernel.com/tutorials/kgdb/</a>
</p><p>If you have an i686-elf toolchain that includes GDB, you can use <a rel="nofollow" class="external text" href="https://visualgdb.com/">VisualGDB</a> to both compile and debug your kernel. For more information on configuring VisualGDB for kernel development in Visual Studio, see <a href="Visual_Studio" title="Visual Studio">Visual Studio</a>.
</p>
<h2><span class="mw-headline" id="VirtualBox">VirtualBox</span></h2>
<p>Start your virtual machine with the command <tt>VBoxManage startvm --putenv VBOX_GUI_DBG_ENABLED=true &lt;Name&gt;</tt> and then a "Debug" menu will appear on the window. You can choose "Command Line" to open a debugging prompt.
</p><p>Useful commands:
</p>
<ul><li>cpu x - switch CPU</li>
<li>r - views registers</li>
<li>dq &lt;Address&gt; - dump 48 bytes of memory at the given virtual address as quadwords</li>
<li>.pgmphystofile "File Path" - dump physical memory to file</li>
<li>info help/&lt;Name&gt; - View device information</li></ul>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="GDB" title="GDB">GDB</a></li></ul>
<h3><span class="mw-headline" id="Forum_Threads">Forum Threads</span></h3>
<ul><li><a href="http://forum.osdev.org/viewtopic.php?t=9514" class="extiw" title="topic:9514">Benchmarking and Debugging</a></li>
<li><a href="http://forum.osdev.org/viewtopic.php?t=10140" class="extiw" title="topic:10140">Implementation of kassert()</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250212010427
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.026 seconds
Real time usage: 0.288 seconds
Preprocessor visited node count: 85/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 1488/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1947-0!canonical and timestamp 20250212010426 and revision id 28799.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Kernel_Debugging&amp;oldid=28799">https://wiki.osdev.org/index.php?title=Kernel_Debugging&amp;oldid=28799</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Kernel" title="Category:Kernel">Kernel</a></li><li><a href="./Category:Debugging" title="Category:Debugging">Debugging</a></li><li><a href="./Category:Troubleshooting" title="Category:Troubleshooting">Troubleshooting</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Kernel+Debugging" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="How_Do_I_Use_A_Debugger_With_My_OS#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Kernel_Debugging" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:Kernel_Debugging" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Kernel_Debugging"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Kernel_Debugging&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Kernel_Debugging&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Kernel_Debugging" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/Kernel_Debugging" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Kernel_Debugging&amp;oldid=28799" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Kernel_Debugging&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 5 May 2024, at 23:19.</li>
	<li id="footer-info-0">This page has been accessed 21,223 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Kernel_Debugging&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.026","walltime":"0.288","ppvisitednodes":{"value":85,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":1488,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20250212010427","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":395});});</script>
</body>
</html>