<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>C++ - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"fc66e7631a4121d22e694bda","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"C++","wgTitle":"C++","wgCurRevisionId":24639,"wgRevisionId":24639,"wgArticleId":1528,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","In Progress","Languages","C++"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"C++","wgRelevantArticleId":1528,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":"C_PlusPlus",
"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgInternalRedirectTargetUrl":"/C%2B%2B","wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head","mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="C++"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-C rootpage-C skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">C++</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"><span class="mw-redirectedfrom">(Redirected from <a href="https://wiki.osdev.org/index.php?title=C_PlusPlus&amp;redirect=no" class="mw-redirect" title="C PlusPlus">C PlusPlus</a>)</span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="C_PlusPlus#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="C_PlusPlus#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><dl><dd><i>For a quick tutorial on getting a bare bones C++ kernel running see <a href="Bare_Bones" title="Bare Bones">Bare Bones</a></i></dd></dl>
<p>A kernel can be programmed in C++, it is very similar to making a kernel in C, except that there are a few pitfalls you must take into account (runtime support, constructors, ...). This page will not list any (dis)advantages of this approach, but rather what you need to do to get things fired up.
</p><p>A lot of features C++ offers can be used on-the-fly; they require no additional support or code to use them properly (e.g. templates, classes, inheritance, virtual functions). There are however other parts of C++ that do require runtime support, which will be discussed in this article.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="C_PlusPlus#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="C_PlusPlus#Pure_virtual_functions"><span class="tocnumber">2</span> <span class="toctext">Pure virtual functions</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="C_PlusPlus#Global_objects"><span class="tocnumber">3</span> <span class="toctext">Global objects</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="C_PlusPlus#GCC"><span class="tocnumber">3.1</span> <span class="toctext">GCC</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="C_PlusPlus#Visual_C++"><span class="tocnumber">3.2</span> <span class="toctext">Visual C++</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="C_PlusPlus#Local_Static_Variables_(GCC_Only)"><span class="tocnumber">4</span> <span class="toctext">Local Static Variables (GCC Only)</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="C_PlusPlus#The_Operators_&#39;new&#39;_and_&#39;delete&#39;"><span class="tocnumber">5</span> <span class="toctext">The Operators 'new' and 'delete'</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="C_PlusPlus#Placement_New"><span class="tocnumber">5.1</span> <span class="toctext">Placement New</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="C_PlusPlus#RTTI_(Run-Time_Type_Information)"><span class="tocnumber">6</span> <span class="toctext">RTTI (Run-Time Type Information)</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="C_PlusPlus#Exceptions"><span class="tocnumber">7</span> <span class="toctext">Exceptions</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="C_PlusPlus#Standard_Library"><span class="tocnumber">8</span> <span class="toctext">Standard Library</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="C_PlusPlus#Full_C++_Runtime_Support_Using_libgcc_And_libsupc++"><span class="tocnumber">9</span> <span class="toctext">Full C++ Runtime Support Using libgcc And libsupc++</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="C_PlusPlus#Optimizations"><span class="tocnumber">10</span> <span class="toctext">Optimizations</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="C_PlusPlus#Links"><span class="tocnumber">11</span> <span class="toctext">Links</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="C_PlusPlus#Wiki"><span class="tocnumber">11.1</span> <span class="toctext">Wiki</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Introduction">Introduction</span></h2>
<p>If you have created a C++ kernel as documented in the <a href="Bare_Bones" title="Bare Bones">Bare Bones</a> article, then many C++ features are already available and work out the box. However, your kernel does not yet satisfy the ABI and you cannot be confident that the compiler will not emit problematic code, even if you stick to the intersection of C and C++. In particular, you may need to initialize further CPU state to enable the floating-point registers and instructions, as the compiler has every reason to think floating point registers and instructions are available by default.
</p><p>However, the compiler will assume that all the C++ runtime support is available by default, however you are not linking in libsupc++ into your C++ kernel, which implements the necessary run-time support. This is why you are passing -fno-rtti and -fno-exceptions to your cross-compiler to let these runtime features are unavailable. Going further, you should link in libsupc++ into your kernel, but at the moment it's known to not be readily accessible to those starting out with operating systems development and the GCC build process doesn't cross-compile it properly for the bare -elf platforms by default.
</p><p>You also need to call the global constructors as documented in <a href="Calling_Global_Constructors" title="Calling Global Constructors">Calling Global Constructors</a> to satisfy the ABI requirement that the program initialization tasks are properly called.
</p>
<h2><span class="mw-headline" id="Pure_virtual_functions">Pure virtual functions</span></h2>
<p>If you want to use pure virtual functions, your compiler needs a single support function. It is only called in case a pure virtual function call cannot be made (e.g. if you have overridden the virtual function table of an object). But nonetheless your linker will complain about unresolved symbols, if you use pure virtual functions and don't provide this support routine.
</p><p>Enabling pure virtual functions in GCC is fairly straightforward. All you need to do is add the function below to one of your C++ source files (and make sure it is linked in). It is not necessary to declare this function first, the definition alone is good enough for GCC. The function itself doesn't even need to do anything (and it doesn't in most implementations), it just needs to be "there" just in case.
</p><p>Below you will find an example of an implementation in respectively GCC.
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__cxa_pure_virtual</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Do nothing or print an error message.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Or, if you happen to use Visual Studio:
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="kr">__cdecl</span><span class="w"> </span><span class="n">_purecall</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Do nothing or print an error message.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>If, during runtime, your kernel detects that a call to a pure virtual function couldn't be made, it calls the above functions. These functions should actually never be called, because without hacks, or through undefined behaviour of your kernel, it is not possible to instantiate a class that doesn't define all pure virtual functions.
</p>
<h2><span class="mw-headline" id="Global_objects">Global objects</span></h2>
<center>
<table style="border: 1px solid #cfcfbf; margin-top: 25px; margin-bottom: 25px; background-color: #f0f0ff; text-align: center;">
<tbody><tr>
<td>
<p><a href="./File:Under_Construction.png" class="image" title="This page is under construction!"><img alt="This page is under construction!" src="images/1/14/Under_Construction.png" decoding="async" width="50" height="50" data-file-width="50" data-file-height="50" /></a>
This page or section is a work in progress and may thus be incomplete. Its content may be changed in the near future.
</p>
</td>
<td>
</td></tr></tbody></table>
</center>
<p>TODO: Please unify this information with the newer <a href="Calling_Global_Constructors" title="Calling Global Constructors">Calling_Global_Constructors</a> article.
</p><p>Global objects must have their constructors called before they are used. Usually, they are called by the start-up code (which you just disabled). So, in order to be able to use them, you have to write your own start-up code for them. All objects have a constructor and a destructor. When an executable is loaded into memory and the program jumps straight to the entry point, the constructors of global objects will not have been called. One solution is to do this manually. You could put this code first when your C++ entry point is called:
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="n">object1</span><span class="p">.</span><span class="n">object1</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">object2</span><span class="p">.</span><span class="n">object2</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">object3</span><span class="p">.</span><span class="n">object3</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="c1">// ...</span>
</pre></div>
<p>Global or static objects have to be constructed by the environment before they are available to C++. Care should be taken if global/static objects need <b>new</b> and <b>delete</b> in their constructors. In this case it is best to construct these objects only after your kernel heap is ready for use (and you have access to dynamic memory allocation). Not doing so can cause an object to attempt to allocate memory via the non-working <b>new</b> operator. This also simplifies the storing of the destructor functions in <b>__cxa_atexit</b>, because you don't have to use a static and fixed-size structure.
</p>
<h3><span class="mw-headline" id="GCC">GCC</span></h3>
<p>Note: This appears to be specific to the Itanium platform. For IA-32/x86/i386 and amd64/x86_64, please check out <a href="Calling_Global_Constructors" title="Calling Global Constructors">Calling_Global_Constructors</a> instead.
</p><p>According to the <a rel="nofollow" class="external text" href="http://refspecs.freestandards.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/baselib---cxa-atexit.html">Itanium C++ Application Binary Interface</a> (which <b>g++</b> follows and VC++ does not) the function <b>__cxa_atexit</b> is used to register a destructor that should be called when a shared library needs to be unloaded. It should insert a function pointer with maximum 1 accompanying argument and the handle of the object or shared resource to be destroyed into a table.
</p><p>In the example implementation of <b>__cxa_atexit</b>, the <b>__atexit_funcs[ATEXIT_MAX_FUNCS]</b> array acts as the table. This is why the <b>__cxa_atexit</b> function is defined as:
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">__cxa_atexit</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__dso_handle</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>So that the <b>destructor</b> function pointer is the handle for a destructor function and <b>arg</b> is the single argument it may take. Finally, <b>__dso_handle</b> is a handle for the DSO (Dynamic Shared Object).
</p><p>So summarized, you are required to define two functions and one symbol in order to use global objects in your C++ files:
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__dso_handle</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">__cxa_atexit</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dso</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__cxa_finalize</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>After you have called the objects constructor GCC automatically calls the function
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">__cxa_atexit</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dso</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>This function should save all three parameters and if successful return zero, on failure non-zero. When your kernel exits you should call <b>__cxa_finalize(0)</b>. According to the ABI specification, calling this with 0 as the parameter instead of the address of a function (to be called and removed from the list) causes <i>all</i> destructors in the list to be called and removed from the list.
</p><p>Since you will be calling this function from your Assembly source right after your kernel exits, you could use the following code:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">; This is NASM source, mind you.</span>
<span class="nf">sub</span><span class="w"> </span><span class="no">esp</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="nf">mov</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="p">],</span><span class="w"> </span><span class="no">dword</span><span class="w"> </span><span class="mi">0x0</span><span class="w"></span>

<span class="nf">call</span><span class="w"> </span><span class="no">__cxa_finalize</span><span class="w"></span>

<span class="nf">add</span><span class="w"> </span><span class="no">esp</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
</pre></div>
<p>The following is tested, working, fully commented source that gives a more detailed explanation than the source previously found here. It also highlights what improvements can be implemented and where they can be inserted. To use it, just include <b>icxxabi.h</b> in any <b>one</b> file of your C++ kernel source (preferably the file where your kernel's main statements begin). 
</p><p><b>File: icxxabi.h</b>
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#ifndef _ICXXABI_H</span>
<span class="w">	</span><span class="cp">#define _ICXXABI_H</span>

<span class="w">	</span><span class="cp">#define ATEXIT_MAX_FUNCS	128</span>
<span class="w">	</span>
<span class="w">	</span><span class="cp">#ifdef __cplusplus</span>
<span class="w">	</span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="cp">#endif</span>
<span class="w">	</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">uarch_t</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">atexit_func_entry_t</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="cm">/*</span>
<span class="cm">	* Each member is at least 4 bytes large. Such that each entry is 12bytes.</span>
<span class="cm">	* 128 * 12 = 1.5KB exact.</span>
<span class="cm">	**/</span><span class="w"></span>
<span class="w">	</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">destructor_func</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">obj_ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dso_handle</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">__cxa_atexit</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">objptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dso</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__cxa_finalize</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cp">#ifdef __cplusplus</span>
<span class="w">	</span><span class="p">};</span><span class="w"></span>
<span class="w">	</span><span class="cp">#endif</span>

<span class="cp">#endif</span>
</pre></div>
<p><br />
<b>File: icxxabi.cpp</b>
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;./icxxabi.h&quot;</span><span class="cp"></span>

<span class="w">	</span><span class="cp">#ifdef __cplusplus</span>
<span class="w">	</span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="cp">#endif</span>

<span class="n">atexit_func_entry_t</span><span class="w"> </span><span class="n">__atexit_funcs</span><span class="p">[</span><span class="n">ATEXIT_MAX_FUNCS</span><span class="p">];</span><span class="w"></span>
<span class="n">uarch_t</span><span class="w"> </span><span class="n">__atexit_func_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__dso_handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//Attention! Optimally, you should remove the &#39;= 0&#39; part and define this in your asm script.</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">__cxa_atexit</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">objptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dso</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__atexit_func_count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">ATEXIT_MAX_FUNCS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;};</span><span class="w"></span>
<span class="w">	</span><span class="n">__atexit_funcs</span><span class="p">[</span><span class="n">__atexit_func_count</span><span class="p">].</span><span class="n">destructor_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">__atexit_funcs</span><span class="p">[</span><span class="n">__atexit_func_count</span><span class="p">].</span><span class="n">obj_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">objptr</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">__atexit_funcs</span><span class="p">[</span><span class="n">__atexit_func_count</span><span class="p">].</span><span class="n">dso_handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dso</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">__atexit_func_count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="cm">/*I would prefer if functions returned 1 on success, but the ABI says...*/</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">__cxa_finalize</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uarch_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__atexit_func_count</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/*</span>
<span class="cm">		* According to the Itanium C++ ABI, if __cxa_finalize is called without a</span>
<span class="cm">		* function ptr, then it means that we should destroy EVERYTHING MUAHAHAHA!!</span>
<span class="cm">		*</span>
<span class="cm">		* TODO:</span>
<span class="cm">		* Note well, however, that deleting a function from here that contains a __dso_handle</span>
<span class="cm">		* means that one link to a shared object file has been terminated. In other words,</span>
<span class="cm">		* We should monitor this list (optional, of course), since it tells us how many links to </span>
<span class="cm">		* an object file exist at runtime in a particular application. This can be used to tell </span>
<span class="cm">		* when a shared object is no longer in use. It is one of many methods, however.</span>
<span class="cm">		**/</span><span class="w"></span>
<span class="w">		</span><span class="c1">//You may insert a prinf() here to tell you whether or not the function gets called. Testing</span>
<span class="w">		</span><span class="c1">//is CRITICAL!</span>
<span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__atexit_funcs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">destructor_func</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="cm">/* ^^^ That if statement is a safeguard...</span>
<span class="cm">				* To make sure we don&#39;t call any entries that have already been called and unset at runtime.</span>
<span class="cm">				* Those will contain a value of 0, and calling a function with value 0</span>
<span class="cm">				* will cause undefined behaviour. Remember that linear address 0, </span>
<span class="cm">				* in a non-virtual address space (physical) contains the IVT and BDA.</span>
<span class="cm">				*</span>
<span class="cm">				* In a virtual environment, the kernel will receive a page fault, and then probably</span>
<span class="cm">				* map in some trash, or a blank page, or something stupid like that.</span>
<span class="cm">				* This will result in the processor executing trash, and...we don&#39;t want that.</span>
<span class="cm">				**/</span><span class="w"></span>
<span class="w">				</span><span class="p">(</span><span class="o">*</span><span class="n">__atexit_funcs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">destructor_func</span><span class="p">)(</span><span class="n">__atexit_funcs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">obj_ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="p">};</span><span class="w"></span>
<span class="w">		</span><span class="p">};</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">};</span><span class="w"></span>

<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/*</span>
<span class="cm">		* The ABI states that multiple calls to the __cxa_finalize(destructor_func_ptr) function</span>
<span class="cm">		* should not destroy objects multiple times. Only one call is needed to eliminate multiple</span>
<span class="cm">		* entries with the same address.</span>
<span class="cm">		*</span>
<span class="cm">		* FIXME:</span>
<span class="cm">		* This presents the obvious problem: all destructors must be stored in the order they</span>
<span class="cm">		* were placed in the list. I.e: the last initialized object&#39;s destructor must be first</span>
<span class="cm">		* in the list of destructors to be called. But removing a destructor from the list at runtime</span>
<span class="cm">		* creates holes in the table with unfilled entries.</span>
<span class="cm">		* Remember that the insertion algorithm in __cxa_atexit simply inserts the next destructor</span>
<span class="cm">		* at the end of the table. So, we have holes with our current algorithm</span>
<span class="cm">		* This function should be modified to move all the destructors above the one currently</span>
<span class="cm">		* being called and removed one place down in the list, so as to cover up the hole.</span>
<span class="cm">		* Otherwise, whenever a destructor is called and removed, an entire space in the table is wasted.</span>
<span class="cm">		**/</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__atexit_funcs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">destructor_func</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* </span>
<span class="cm">			* Note that in the next line, not every destructor function is a class destructor.</span>
<span class="cm">			* It is perfectly legal to register a non class destructor function as a simple cleanup</span>
<span class="cm">			* function to be called on program termination, in which case, it would not NEED an</span>
<span class="cm">			* object This pointer. A smart programmer may even take advantage of this and register</span>
<span class="cm">			* a C function in the table with the address of some structure containing data about</span>
<span class="cm">			* what to clean up on exit.</span>
<span class="cm">			* In the case of a function that takes no arguments, it will simply be ignore within the</span>
<span class="cm">			* function itself. No worries.</span>
<span class="cm">			**/</span><span class="w"></span>
<span class="w">			</span><span class="p">(</span><span class="o">*</span><span class="n">__atexit_funcs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">destructor_func</span><span class="p">)(</span><span class="n">__atexit_funcs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">obj_ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">__atexit_funcs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">destructor_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="cm">/*</span>
<span class="cm">			* Notice that we didn&#39;t decrement __atexit_func_count: this is because this algorithm</span>
<span class="cm">			* requires patching to deal with the FIXME outlined above.</span>
<span class="cm">			**/</span><span class="w"></span>
<span class="w">		</span><span class="p">};</span><span class="w"></span>
<span class="w">	</span><span class="p">};</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="w">	</span><span class="cp">#ifdef __cplusplus</span>
<span class="w">	</span><span class="p">};</span><span class="w"></span>
<span class="w">	</span><span class="cp">#endif</span>
</pre></div>
<h3><span id="Visual_C.2B.2B"></span><span class="mw-headline" id="Visual_C++">Visual C++</span></h3>
<dl><dd><i>Main article:</i> <a href="Visual_Studio" title="Visual Studio">Visual Studio</a></dd></dl>
<p>Running constructors and destructors is covered in MSDN help and in the C runtime library sources. See <b>#pragma init_seg</b> on MSDN for more information.
</p><p>Basically what happens is that pointers to functions are placed in <b>.CRT$XIC, $XIL, $XIU</b> based on the value of <b>init_seg</b>. The linker then merges everything together in the <b>.CRT</b> section, in the order of the letters after the <b>$</b>. The pointers between the XIA (<b>xi_a</b>) and XIZ (<b>xi_z</b>) are then called if non-zero. The <b>.CRT</b> section is merged with the <b>.data</b> section to avoid a completely separated section.
</p><p>One problem with C++ support is the horrible name-mangling that is impossible to read in the map file. A build script should be set up that runs the map file through the <b>undname.exe</b> tool, so that names like <b>??2@YAPAXI@Z</b> (operator new - I think...) and others are readable.
</p><p>Below you will find some example code. Simply call <b>runInit()</b> if you want to initialize any static objects and then call <b>runTerm()</b> if static object destructors are to be run.
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">_PVFV</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">_PIFV</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">_PVFI</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="cp">#pragma data_seg(&quot;.CRT$XIA&quot;)</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">allocate</span><span class="p">(</span><span class="s">&quot;.CRT$XIA&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">_PIFV</span><span class="w"> </span><span class="n">__xi_a</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="cp">#pragma data_seg(&quot;.CRT$XIZ&quot;)</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">allocate</span><span class="p">(</span><span class="s">&quot;.CRT$XIZ&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">_PIFV</span><span class="w"> </span><span class="n">__xi_z</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="cp">#pragma data_seg(&quot;.CRT$XCA&quot;)</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">allocate</span><span class="p">(</span><span class="s">&quot;.CRT$XCA&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">_PVFV</span><span class="w"> </span><span class="n">__xc_a</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="cp">#pragma data_seg(&quot;.CRT$XCZ&quot;)</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">allocate</span><span class="p">(</span><span class="s">&quot;.CRT$XCZ&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">_PVFV</span><span class="w"> </span><span class="n">__xc_z</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="cp">#pragma data_seg(&quot;.CRT$XPA&quot;)</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">allocate</span><span class="p">(</span><span class="s">&quot;.CRT$XPA&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">_PVFV</span><span class="w"> </span><span class="n">__xp_a</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="cp">#pragma data_seg(&quot;.CRT$XPZ&quot;)</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">allocate</span><span class="p">(</span><span class="s">&quot;.CRT$XPZ&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">_PVFV</span><span class="w"> </span><span class="n">__xp_z</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="cp">#pragma data_seg(&quot;.CRT$XTA&quot;)</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">allocate</span><span class="p">(</span><span class="s">&quot;.CRT$XTA&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">_PVFV</span><span class="w"> </span><span class="n">__xt_a</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="cp">#pragma data_seg(&quot;.CRT$XTZ&quot;)</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">allocate</span><span class="p">(</span><span class="s">&quot;.CRT$XTZ&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">_PVFV</span><span class="w"> </span><span class="n">__xt_z</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="cp">#pragma data_seg()</span>
<span class="cp">#pragma comment(linker, &quot;/merge:.CRT=.data&quot;)</span>

<span class="k">static</span><span class="w"> </span><span class="n">_PVFV</span><span class="w"> </span><span class="n">onexitarray</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="n">_PVFV</span><span class="w"> </span><span class="o">*</span><span class="n">onexitbegin</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">onexitend</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="kr">__cdecl</span><span class="w"> </span><span class="n">_purecall</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// print error message</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="kr">__cdecl</span><span class="w"> </span><span class="n">atexit</span><span class="p">(</span><span class="n">_PVFV</span><span class="w"> </span><span class="n">fn</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">onexitend</span><span class="o">-</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">onexitbegin</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">                </span><span class="o">*</span><span class="p">(</span><span class="n">onexitend</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">EXTERN</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">runInit</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// init the __xi_a to __xi_z:  __initex(__xi_a, __xi_z);</span>
<span class="w">        </span><span class="c1">// init __xc_a to __xc_z</span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="p">(</span><span class="n">_PVFV</span><span class="w"> </span><span class="o">*</span><span class="n">pfbegin</span><span class="p">,</span><span class="w"> </span><span class="n">_PVFV</span><span class="w"> </span><span class="o">*</span><span class="n">pfend</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">pfbegin</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pfend</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pfbegin</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="o">**</span><span class="n">pfbegin</span><span class="p">)();</span><span class="w"></span>
<span class="w">        </span><span class="o">++</span><span class="n">pfbegin</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__initex</span><span class="p">(</span><span class="n">_PIFV</span><span class="w"> </span><span class="o">*</span><span class="n">pfbegin</span><span class="p">,</span><span class="w"> </span><span class="n">_PIFV</span><span class="w"> </span><span class="o">*</span><span class="n">pfend</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">pfbegin</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pfend</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pfbegin</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">**</span><span class="n">pfbegin</span><span class="p">)();</span><span class="w"></span>
<span class="w">            </span><span class="o">++</span><span class="n">pfbegin</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">EXTERN</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">runUninit</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">onexitbegin</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">--</span><span class="n">onexitend</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">onexitbegin</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">onexitend</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">                                </span><span class="p">(</span><span class="o">**</span><span class="n">onexitend</span><span class="p">)();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">__init</span><span class="p">(</span><span class="n">__xp_a</span><span class="p">,</span><span class="w"> </span><span class="n">__xp_z</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">__init</span><span class="p">(</span><span class="n">__xt_a</span><span class="p">,</span><span class="w"> </span><span class="n">__xt_z</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">EXTERN</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">onexitinit</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">onexitend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">onexitbegin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">onexitarray</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">onexitbegin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#pragma data_seg(&quot;.CRT$XIB&quot;)      </span><span class="c1">// run onexitinit automatically</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">allocate</span><span class="p">(</span><span class="s">&quot;.CRT$XIB&quot;</span><span class="p">))</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">_PIFV</span><span class="w"> </span><span class="n">pinit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">onexitinit</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma data_seg()</span>
</pre></div>
<h2><span id="Local_Static_Variables_.28GCC_Only.29"></span><span class="mw-headline" id="Local_Static_Variables_(GCC_Only)">Local Static Variables (GCC Only)</span></h2>
<p>When you declare a local static variable, GCC puts a guard around the variable's constructor call. This ensures that only one thread can call the constructor at the same time to initialize it.
</p><p><i>Note that these are only stubs to get the code compiled, and you should implement them yourself. Simply add a mutex-like guard with a test-and-set primitive.</i>
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">__cxxabiv1</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* guard variables */</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* The ABI requires a 64-bit type.  */</span><span class="w"></span>
<span class="w">	</span><span class="n">__extension__</span><span class="w"> </span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__guard</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">mode</span><span class="p">(</span><span class="n">__DI__</span><span class="p">)));</span><span class="w"></span>

<span class="w">	</span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__cxa_guard_acquire</span><span class="w"> </span><span class="p">(</span><span class="n">__guard</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__cxa_guard_release</span><span class="w"> </span><span class="p">(</span><span class="n">__guard</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__cxa_guard_abort</span><span class="w"> </span><span class="p">(</span><span class="n">__guard</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__cxa_guard_acquire</span><span class="w"> </span><span class="p">(</span><span class="n">__guard</span><span class="w"> </span><span class="o">*</span><span class="n">g</span><span class="p">)</span><span class="w"> </span>
<span class="w">	</span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="o">!*</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">g</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__cxa_guard_release</span><span class="w"> </span><span class="p">(</span><span class="n">__guard</span><span class="w"> </span><span class="o">*</span><span class="n">g</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="o">*</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__cxa_guard_abort</span><span class="w"> </span><span class="p">(</span><span class="n">__guard</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">{</span><span class="w"></span>

<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The actual code emitted by GCC to call a local static variable's constructor looks something like this:
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">guard</span><span class="p">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">guard</span><span class="p">.</span><span class="n">first_byte</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__cxa_guard_acquire</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">guard</span><span class="p">))</span><span class="w"></span>
<span class="w">	</span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">		</span><span class="k">try</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="c1">// Do initialization.</span>
<span class="w">			</span><span class="n">__cxa_guard_release</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">guard</span><span class="p">);</span><span class="w"></span>

<span class="w">			</span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="c1">// Register variable for destruction at end of program.</span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="k">catch</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">__cxa_guard_abort</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">guard</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span id="The_Operators_.27new.27_and_.27delete.27"></span><span class="mw-headline" id="The_Operators_'new'_and_'delete'">The Operators 'new' and 'delete'</span></h2>
<p>Before you can properly use <b>new</b> and <b>delete</b>, you have to implement some sort of memory management. You also have to implement both operators (including their array counterparts). <b>new</b> and <b>delete</b> respectively allocate and delete memory (much like <b>malloc</b> and <b>free</b> in C). Take a look at the <a href="Memory_Management" class="mw-redirect" title="Memory Management">Memory Management</a> article if you would like to know more about this subject.
</p><p>Every time you call one of the operators <b>new</b>, <b>new[]</b>, <b>delete</b>, or <b>delete[]</b>, the compiler inserts a call to them. The most simple implementation would be to map them to your kernel's <b>malloc</b> and <b>free</b>. For example:
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stddef.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="k">operator</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="k">operator</span><span class="w"> </span><span class="k">new</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="k">delete</span><span class="p">[](</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>You could also let <b>new</b> use <b>calloc</b> (allocate and zero). This way, newly allocated memory will always be zeroed (thus, not contain garbage). The standard <b>new</b> implementations do however not clear the returned memory.
</p><p>An easy malloc implementation you can port to your OS is <a rel="nofollow" class="external text" href="https://github.com/blanham/liballoc/">liballoc</a>. It only requires basic <a href="Paging" title="Paging">Paging</a> (that is, store a list of used and free pages, and have a function to find the next free page) to work.
</p>
<h3><span class="mw-headline" id="Placement_New">Placement New</span></h3>
<p>In C++ (especially in OS code where structures can be found at fixed addresses) it can be useful to construct an object in memory obtained elsewhere. This is accomplished through a technique known as 'placement new'. For example, say you wanted to create an APIC object at address <b>0x09FFF0000</b>, then this snippet of code will use placement new to do the trick:
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">apic_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="mh">0x09FFF0000</span><span class="p">);</span><span class="w"></span>
<span class="n">APIC</span><span class="w"> </span><span class="o">*</span><span class="n">apic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="p">(</span><span class="n">apic_address</span><span class="p">)</span><span class="w"> </span><span class="n">APIC</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>In order to use placement new, you need special overloads of the new and delete operators defined in scope. Fortunately, the required definitions are simple and can be inlined in a header file (the C++ standard puts them in a header called <b>new</b>).
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="k">operator</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w">     </span><span class="k">throw</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="k">operator</span><span class="w"> </span><span class="k">new</span><span class="p">[](</span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w">   </span><span class="k">throw</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="k">delete</span><span class="w">  </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="k">delete</span><span class="p">[](</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
<p>The above implementation can potentially be unsafe for allocating memory since your kernel does not mark the memory that was allocated as being used. Placement new is hardly ever used, and if you wish to read an object from a specified address in memory, it is usually easier to create a pointer to that address.
</p><p>You never call placement delete explicitly (it's only required for certain implementation detail reasons). Instead, you simply invoke your object's destructor explicitly.
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="n">apic</span><span class="o">-&gt;~</span><span class="n">APIC</span><span class="p">();</span><span class="w"></span>
</pre></div>
<h2><span id="RTTI_.28Run-Time_Type_Information.29"></span><span class="mw-headline" id="RTTI_(Run-Time_Type_Information)">RTTI (Run-Time Type Information)</span></h2>
<p>RTTI is used for <b>typeid</b> and <b>dynamic_cast</b>. It requires runtime support as well. Disable it with <b>-fno-rtti</b>. A kernel has no access to run-time features, which are most likely operating system-dependent. Note that virtual functions work without RTTI.
</p>
<h2><span class="mw-headline" id="Exceptions">Exceptions</span></h2>
<p>Another feature that requires run-time support. Disable it with <b>-fno-exceptions</b>. Exceptions require code to unwind the stack while looking for an appropriate exception handler to handle the exception. Usually, this code is linked in with your C++ application, but in a freestanding kernel the code must be provided manually.
</p><p>See <a href="C++_Exception_Support" title="C++ Exception Support">C++ Exception Support</a>.
</p>
<h2><span class="mw-headline" id="Standard_Library">Standard Library</span></h2>
<p>Note that the C++ Standard Library (stdlib) is not the same as the C++ Standard Template Library (STL). The STL was designed in 1994 and largely influenced the C++ Standard Library, but it's not a part of the ISO C++ standard. The C++ Standard Library is part of the C++ ISO specification, however, and is what you're using when you use <i>std::vector</i>, <i>std::string</i>, etc. Be wary of misusing the term STL and, ideally, avoid it completely. Anyone using it almost certainly means the C++ stdlib.
</p><p>You cannot use stdlib functions or classes without porting a stdlib implementation. A lot of existing code depending on the stdlib is OS-dependent, so you must port an stdlib implementation to your OS if you want to use them.
</p><p>To gain access to the stdlib in your OS you can do either of the following:
</p>
<ul><li>Write your own implementation of a few of the required class templates (std::string, std::list, std::cout, ...).</li>
<li>Port a stdlib implementation to your OS (e.g. <a href="https://wiki.osdev.org/index.php?title=STLport&amp;action=edit&amp;redlink=1" class="new" title="STLport (page does not exist)">STLport</a>).</li></ul>
<p>A lot of the stdlib classes require <b>new</b> and <b>delete</b> to be implemented in your OS. File access requires your OS to support reading and wrapping. Console functions require your OS to already have working console I/O.
</p><p>Porting the C++ stdlib (like porting the <a href="C_Library" title="C Library">C Standard Library</a>) does not automatically make your OS able to read from and write to the disk or get data straight from the keyboard. These are simply wrappers around your OS' functions, and must be implemented by in your kernel.
</p><p>Note that it is generally not a good idea to port the entire stdlib to your kernel, although it is reasonable to port a few class templates, such as <tt>std::vector</tt> and <tt>std::string</tt> if you wish to. As for your user applications: the more the merrier!&#160;:)
</p><p>Here is a list of a the most commonly used stdlib implementations:
</p>
<ul><li><a rel="nofollow" class="external text" href="http://incubator.apache.org/stdcxx/">STDCXX</a> (a.k.a Apache C++ Standard Library, formally Rogue Wave C++ Standard Library)</li>
<li><a rel="nofollow" class="external text" href="https://www.dinkumware.com/">Dinkumware C++ Standard Library</a></li>
<li><a rel="nofollow" class="external text" href="http://msdn2.microsoft.com/en-us/library/cscc687y%28VS.80%29.aspx">Microsoft C++ Standard Library</a> (closed source)</li>
<li><a rel="nofollow" class="external text" href="http://gcc.gnu.org/libstdc++/">libstdc++</a> (a.k.a. GNU Standard C++ Library)</li>
<li><a rel="nofollow" class="external text" href="http://www.stlport.org/">STLport</a></li>
<li><a rel="nofollow" class="external text" href="http://ustl.sourceforge.net/">uSTL</a></li>
<li><a rel="nofollow" class="external text" href="http://libcxx.llvm.org/">libc++</a> (LLVM C++ Standard library)</li></ul>
<h2><span id="Full_C.2B.2B_Runtime_Support_Using_libgcc_And_libsupc.2B.2B"></span><span class="mw-headline" id="Full_C++_Runtime_Support_Using_libgcc_And_libsupc++">Full C++ Runtime Support Using libgcc And libsupc++</span></h2>
<dl><dd><i>Main article:</i> <a href="Libsupcxx#Full_C++_Runtime_Support_Using_libgcc_And_libsupc++" title="Libsupcxx">Libsupcxx#Full C++ Runtime Support Using libgcc And libsupc++</a></dd></dl>
<p>If you want Exceptions, RTTI, new and delete altogether, you should use <a href="Libgcc" title="Libgcc">libgcc</a> and libsupc++. libgcc contains the unwinder (for exceptions), while libsupc++ contains the C++ support.
</p><p>You may run into problems with libsupc++, but there are <a href="GCC_and_Libc++" title="GCC and Libc++">alternative libraries</a>.
</p>
<h2><span class="mw-headline" id="Optimizations">Optimizations</span></h2>
<p>There are <a href="C#Things_you_should_know_about_optimizations" title="C">things you should know about optimizations</a> that also affect C++ because it is an extension of the <a href="C" title="C">C</a> language. You should know about them even if you don't plan to to use the optimizer of your C++ compiler in the near future.
</p>
<h2><span class="mw-headline" id="Links">Links</span></h2>
<h3><span class="mw-headline" id="Wiki">Wiki</span></h3>
<ul><li><a href="Bare_Bones" title="Bare Bones">Bare Bones</a></li>
<li><a href="Volatile_(keyword)" title="Volatile (keyword)">Use of the volatile keyword</a></li>
<li><a href="C++_to_ASM_linkage_in_GCC" title="C++ to ASM linkage in GCC">Linking C++ and Assembly (GCC-specific)</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250211172205
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.111 seconds
Real time usage: 2.211 seconds
Preprocessor visited node count: 155/1000000
Post‐expand include size: 478/2097152 bytes
Template argument size: 74/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 52541/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00% 1891.258      1 -total
  0.08%    1.464      1 Template:In_Progress
  0.04%    0.682      2 Template:Main
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1528-0!canonical and timestamp 20250211172203 and revision id 24639.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=C%2B%2B&amp;oldid=24639">https://wiki.osdev.org/index.php?title=C%2B%2B&amp;oldid=24639</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:In_Progress" title="Category:In Progress">In Progress</a></li><li><a href="./Category:Languages" title="Category:Languages">Languages</a></li><li><a href="./Category:C++" title="Category:C++">C++</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=C%2B%2B" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="C_PlusPlus#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="C++" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Talk:C%2B%2B&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="C++"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=C%2B%2B&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=C%2B%2B&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/C++" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/C%2B%2B" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=C%2B%2B&amp;oldid=24639" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=C%2B%2B&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/C%2B%2B" title="C++ – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 28 April 2020, at 17:38.</li>
	<li id="footer-info-0">This page has been accessed 15,031 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=C%2B%2B&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.111","walltime":"2.211","ppvisitednodes":{"value":155,"limit":1000000},"postexpandincludesize":{"value":478,"limit":2097152},"templateargumentsize":{"value":74,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":52541,"limit":5000000},"timingprofile":["100.00% 1891.258      1 -total","  0.08%    1.464      1 Template:In_Progress","  0.04%    0.682      2 Template:Main"]},"cachereport":{"timestamp":"20250211172205","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":2311});});</script>
</body>
</html>