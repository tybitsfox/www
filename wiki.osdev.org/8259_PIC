<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>8259 PIC - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"03cf03f78d0f9f6610294ad4","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"8259_PIC","wgTitle":"8259 PIC","wgCurRevisionId":29386,"wgRevisionId":29386,"wgArticleId":1478,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Interrupts","X86"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"8259_PIC","wgRelevantArticleId":1478,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{
"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-8259_PIC rootpage-8259_PIC skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">8259 PIC</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="8259_PIC#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="8259_PIC#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>The 8259 <i>Programmable Interrupt Controller</i> (PIC) is one of the most important chips making up the x86 architecture. Without it, the x86 architecture would not be an interrupt driven architecture. The function of the 8259A is to manage hardware interrupts and send them to the appropriate system <a href="Interrupts" title="Interrupts">interrupt</a>. This allows the system to respond to devices needs without loss of time (from polling the device, for instance).
</p><p>It is important to note that <a href="APIC" title="APIC">APIC</a> has replaced the 8259 PIC in more modern systems, especially those with multiple cores/processors.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="8259_PIC#What_does_the_8259_PIC_do?"><span class="tocnumber">1</span> <span class="toctext">What does the 8259 PIC do?</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="8259_PIC#The_IBM_PC_8259_PIC_Architecture"><span class="tocnumber">1.1</span> <span class="toctext">The IBM PC 8259 PIC Architecture</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="8259_PIC#The_IBM_PC/AT_8259_PIC_Architecture"><span class="tocnumber">1.2</span> <span class="toctext">The IBM PC/AT 8259 PIC Architecture</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="8259_PIC#How_does_the_8259_PIC_chip_work?"><span class="tocnumber">2</span> <span class="toctext">How does the 8259 PIC chip work?</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="8259_PIC#Programming_with_the_8259_PIC"><span class="tocnumber">3</span> <span class="toctext">Programming with the 8259 PIC</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="8259_PIC#Real_Mode"><span class="tocnumber">3.1</span> <span class="toctext">Real Mode</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="8259_PIC#Protected_Mode"><span class="tocnumber">3.2</span> <span class="toctext">Protected Mode</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="8259_PIC#Code_Examples"><span class="tocnumber">4</span> <span class="toctext">Code Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="8259_PIC#Common_Definitions"><span class="tocnumber">4.1</span> <span class="toctext">Common Definitions</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="8259_PIC#End_of_Interrupt"><span class="tocnumber">4.2</span> <span class="toctext">End of Interrupt</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="8259_PIC#Initialisation"><span class="tocnumber">4.3</span> <span class="toctext">Initialisation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-12"><a href="8259_PIC#Disabling"><span class="tocnumber">5</span> <span class="toctext">Disabling</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="8259_PIC#Masking"><span class="tocnumber">6</span> <span class="toctext">Masking</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="8259_PIC#ISR_and_IRR"><span class="tocnumber">7</span> <span class="toctext">ISR and IRR</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="8259_PIC#Spurious_IRQs"><span class="tocnumber">8</span> <span class="toctext">Spurious IRQs</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="8259_PIC#Handling_Spurious_IRQs"><span class="tocnumber">8.1</span> <span class="toctext">Handling Spurious IRQs</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-17"><a href="8259_PIC#See_Also"><span class="tocnumber">9</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="8259_PIC#Articles"><span class="tocnumber">9.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="8259_PIC#Threads"><span class="tocnumber">9.2</span> <span class="toctext">Threads</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="8259_PIC#External_Links"><span class="tocnumber">9.3</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span id="What_does_the_8259_PIC_do.3F"></span><span class="mw-headline" id="What_does_the_8259_PIC_do?">What does the 8259 PIC do?</span></h2>
<p>The 8259 PIC controls the CPU's interrupt mechanism, by accepting several interrupt requests and feeding them to the processor in order. For instance, when a keyboard registers a keyhit, it sends a pulse along its interrupt line (<a href="IRQ" class="mw-redirect" title="IRQ">IRQ</a> 1) to the PIC chip, which then translates the IRQ into a system interrupt, and sends a message to interrupt the CPU from whatever it is doing. Part of the kernel's job is to either handle these IRQs and perform the necessary procedures (poll the keyboard for the scancode) or alert a userspace program to the interrupt (send a message to the keyboard driver).
</p><p>Without a PIC, you would have to poll all the devices in the system to see if they want to do anything (signal an event), but with a PIC, your system can run along nicely until such time that a device wants to signal an event, which means you don't waste time going to the devices, you let the devices come to you when they are ready.
</p>
<h3><span class="mw-headline" id="The_IBM_PC_8259_PIC_Architecture">The IBM PC 8259 PIC Architecture</span></h3>
<p>In the beginning (IBM PC and XT), only a single 8259 PIC chip was used, which provided 8 IRQs to the system. These were traditionally mapped by the BIOS to interrupts 8 to 15 (0x08 to 0x0F). It is unlikely that any of these single-PIC machines will be encountered these days.
</p>
<h3><span id="The_IBM_PC.2FAT_8259_PIC_Architecture"></span><span class="mw-headline" id="The_IBM_PC/AT_8259_PIC_Architecture">The IBM PC/AT 8259 PIC Architecture</span></h3>
<p>The IBM PC/AT extended the PC architecture by adding a second 8259 PIC chip. This was possible due to the 8259A's ability to cascade interrupts, that is, have them flow through one chip and into another. This gives a total of 15 interrupts. Why 15 and not 16? That's because when you cascade chips, the PIC needs to use one of the interrupt lines to signal the other chip.
</p><p>Thus, in an AT, IRQ line 2 is used to signal the second chip. Because of this, IRQ 2 is not available for use by hardware devices, which got wired to IRQ 9 on the slave PIC instead. The real mode BIOS used to set up an interrupt handler for IRQ 9 that redirects to the IRQ 2 handler. This way DOS drivers who used IRQ 2 continued to work. This two-chip architecture is still used and available in modern systems, and hasn't changed (except for the advent of the above-mentioned APIC architecture).
</p>
<h2><span id="How_does_the_8259_PIC_chip_work.3F"></span><span class="mw-headline" id="How_does_the_8259_PIC_chip_work?">How does the 8259 PIC chip work?</span></h2>
<p>Each of the two 8259 PICs in modern systems have 8 inputs. When any of the inputs is raised, the PIC sets a bit internally telling one of the inputs needs servicing. It then checks whether that channel is masked or not, and whether there's an interrupt already pending.
If the channel is unmasked and there's no interrupt pending, the PIC will raise the interrupt line. On the slave, this feeds IRQ 2 to the master, and the master is connected to the processor interrupt line.
</p><p>When the processor accepts the interrupt, the master checks which of the two PICs is responsible for answering, then either supplies the interrupt number to the processor, or asks the slave to do so. The PIC that answers looks up the "vector offset" variable stored internally and adds the input line to form the requested interrupt number. After that the processor will look up the interrupt address and act accordingly (see <a href="Interrupts" title="Interrupts">Interrupts</a> for more details).
</p>
<h2><span class="mw-headline" id="Programming_with_the_8259_PIC">Programming with the 8259 PIC</span></h2>
<p>Each chip (master and slave) has a command port and a data port (given in the table below). When no command is issued, the data port allows us to access the interrupt mask of the 8259 PIC.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Chip - Purpose
</th>
<th><a href="I/O_ports" class="mw-redirect" title="I/O ports">I/O port</a>
</th></tr>
<tr>
<td>Master PIC - Command
</td>
<td>0x0020
</td></tr>
<tr>
<td>Master PIC - Data
</td>
<td>0x0021
</td></tr>
<tr>
<td>Slave PIC - Command
</td>
<td>0x00A0
</td></tr>
<tr>
<td>Slave PIC - Data
</td>
<td>0x00A1
</td></tr></tbody></table>
<ul><li>Each PIC vector offset must be divisible by 8, as the 8259A uses the lower 3 bits for the interrupt number of a particular interrupt (0..7).</li>
<li>The only way to change the vector offsets used by the 8259 PIC is to re-initialize it, which explains why the code is "so long" and plenty of things that have apparently no reasons to be here.</li>
<li>If you plan to return to real mode from protected mode (for any purpose), you really must restore the PIC to its former configuration.</li></ul>
<h3><span class="mw-headline" id="Real_Mode">Real Mode</span></h3>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Chip
</th>
<th>Interrupt numbers (IRQ)
</th>
<th>Vector offset
</th>
<th>Interrupt Numbers
</th></tr>
<tr>
<td>Master PIC
</td>
<td>0 to 7
</td>
<td>0x08
</td>
<td>0x08 to 0x0F
</td></tr>
<tr>
<td>Slave PIC
</td>
<td>8 to 15
</td>
<td>0x70
</td>
<td>0x70 to 0x77
</td></tr></tbody></table>
<p>These default BIOS values suit real mode programming quite well; they do not conflict with any CPU exceptions like they do in protected mode.
</p>
<h3><span class="mw-headline" id="Protected_Mode">Protected Mode</span></h3>
<p>In protected mode, the IRQs 0 to 7 conflict with the CPU exception which are reserved by Intel up until 0x1F. (It was an IBM design mistake.) Consequently it is difficult to tell the difference between an IRQ or an software error. It is thus recommended to change the PIC's offsets (also known as remapping the PIC) so that IRQs use non-reserved vectors. A common choice is to move them to the beginning of the available range (IRQs 0..0xF -&gt; INT 0x20..0x2F). For that, we need to set the master PIC's offset to 0x20 and the slave's to 0x28. For code examples, see below.
</p>
<h2><span class="mw-headline" id="Code_Examples">Code Examples</span></h2>
<h3><span class="mw-headline" id="Common_Definitions">Common Definitions</span></h3>
<p>This is just a set of definitions common to the rest of this section. For the outb(), inb() and io_wait() functions, see <a href="Inline_Assembly/Examples#I/O_access" title="Inline Assembly/Examples">this page</a>.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define PIC1		0x20		</span><span class="cm">/* IO base address for master PIC */</span><span class="cp"></span>
<span class="cp">#define PIC2		0xA0		</span><span class="cm">/* IO base address for slave PIC */</span><span class="cp"></span>
<span class="cp">#define PIC1_COMMAND	PIC1</span>
<span class="cp">#define PIC1_DATA	(PIC1+1)</span>
<span class="cp">#define PIC2_COMMAND	PIC2</span>
<span class="cp">#define PIC2_DATA	(PIC2+1)</span>
</pre></div>
<h3><span class="mw-headline" id="End_of_Interrupt">End of Interrupt</span></h3>
<p>Perhaps the most common command issued to the PIC chips is the <i>end of interrupt</i> (EOI) command (code 0x20). This is issued to the PIC chips at the end of an IRQ-based interrupt routine. If the IRQ came from the Master PIC, it is sufficient to issue this command only to the Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command to both PIC chips.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define PIC_EOI		0x20		</span><span class="cm">/* End-of-interrupt command code */</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">PIC_sendEOI</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">irq</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="p">(</span><span class="n">irq</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC2_COMMAND</span><span class="p">,</span><span class="n">PIC_EOI</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC1_COMMAND</span><span class="p">,</span><span class="n">PIC_EOI</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Initialisation">Initialisation</span></h3>
<p>When you enter protected mode (or even before hand, if you're not using <a href="GRUB" title="GRUB">GRUB</a>) the first command you will need to give the two PICs is the initialise command (code 0x11). This command makes the PIC wait for 3 extra "initialisation words" on the data port. These bytes give the PIC:
</p>
<ul><li>Its vector offset. (ICW2)</li>
<li>Tell it how it is wired to master/slaves. (ICW3)</li>
<li>Gives additional information about the environment. (ICW4)</li></ul>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* reinitialize the PIC controllers, giving them specified vector offsets</span>
<span class="cm">   rather than 8h and 70h, as configured by default */</span><span class="w"></span>

<span class="cp">#define ICW1_ICW4	0x01		</span><span class="cm">/* Indicates that ICW4 will be present */</span><span class="cp"></span>
<span class="cp">#define ICW1_SINGLE	0x02		</span><span class="cm">/* Single (cascade) mode */</span><span class="cp"></span>
<span class="cp">#define ICW1_INTERVAL4	0x04		</span><span class="cm">/* Call address interval 4 (8) */</span><span class="cp"></span>
<span class="cp">#define ICW1_LEVEL	0x08		</span><span class="cm">/* Level triggered (edge) mode */</span><span class="cp"></span>
<span class="cp">#define ICW1_INIT	0x10		</span><span class="cm">/* Initialization - required! */</span><span class="cp"></span>

<span class="cp">#define ICW4_8086	0x01		</span><span class="cm">/* 8086/88 (MCS-80/85) mode */</span><span class="cp"></span>
<span class="cp">#define ICW4_AUTO	0x02		</span><span class="cm">/* Auto (normal) EOI */</span><span class="cp"></span>
<span class="cp">#define ICW4_BUF_SLAVE	0x08		</span><span class="cm">/* Buffered mode/slave */</span><span class="cp"></span>
<span class="cp">#define ICW4_BUF_MASTER	0x0C		</span><span class="cm">/* Buffered mode/master */</span><span class="cp"></span>
<span class="cp">#define ICW4_SFNM	0x10		</span><span class="cm">/* Special fully nested (not) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">arguments:</span>
<span class="cm">	offset1 - vector offset for master PIC</span>
<span class="cm">		vectors on the master become offset1..offset1+7</span>
<span class="cm">	offset2 - same for slave PIC: offset2..offset2+7</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">PIC_remap</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">offset1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">offset2</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC1_COMMAND</span><span class="p">,</span><span class="w"> </span><span class="n">ICW1_INIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ICW1_ICW4</span><span class="p">);</span><span class="w">  </span><span class="c1">// starts the initialization sequence (in cascade mode)</span>
<span class="w">	</span><span class="n">io_wait</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC2_COMMAND</span><span class="p">,</span><span class="w"> </span><span class="n">ICW1_INIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ICW1_ICW4</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">io_wait</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span><span class="w"> </span><span class="n">offset1</span><span class="p">);</span><span class="w">                 </span><span class="c1">// ICW2: Master PIC vector offset</span>
<span class="w">	</span><span class="n">io_wait</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span><span class="w"> </span><span class="n">offset2</span><span class="p">);</span><span class="w">                 </span><span class="c1">// ICW2: Slave PIC vector offset</span>
<span class="w">	</span><span class="n">io_wait</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w">                       </span><span class="c1">// ICW3: tell Master PIC that there is a slave PIC at IRQ2 (0000 0100)</span>
<span class="w">	</span><span class="n">io_wait</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">                       </span><span class="c1">// ICW3: tell Slave PIC its cascade identity (0000 0010)</span>
<span class="w">	</span><span class="n">io_wait</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span><span class="w"> </span><span class="n">ICW4_8086</span><span class="p">);</span><span class="w">               </span><span class="c1">// ICW4: have the PICs use 8086 mode (and not 8080 mode)</span>
<span class="w">	</span><span class="n">io_wait</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span><span class="w"> </span><span class="n">ICW4_8086</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">io_wait</span><span class="p">();</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Unmask both PICs.</span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><i>Note the presence of io_wait() calls, on older machines its necessary to give the PIC some time to react to commands as they might not be processed quickly.</i>
</p>
<h2><span class="mw-headline" id="Disabling">Disabling</span></h2>
<p>If you are going to use the processor local APIC and the IOAPIC, you must first disable the PIC. This is done by masking every single interrupt.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">pic_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Masking">Masking</span></h2>
<p>The PIC has an internal register called the IMR, or the Interrupt Mask Register. It is 8 bits wide. This register is a bitmap of the request lines going into the PIC. When a bit is set, the PIC ignores the request and continues normal operation. Note that setting the mask on a higher request line will not affect a lower line. Masking IRQ2 will cause the Slave PIC to stop raising IRQs.
</p><p>Here is an example of how to mask an IRQ:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">IRQ_set_mask</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">IRQline</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">port</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">IRQline</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIC1_DATA</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIC2_DATA</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">IRQline</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="n">port</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">IRQline</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w">        </span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">IRQ_clear_mask</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">IRQline</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">port</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">IRQline</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIC1_DATA</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIC2_DATA</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">IRQline</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="n">port</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">IRQline</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w">        </span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="ISR_and_IRR">ISR and IRR</span></h2>
<p>The PIC chip has two interrupt status registers: the In-Service Register (ISR) and the Interrupt Request Register (IRR).  The ISR tells us which interrupts are being serviced, meaning IRQs sent to the CPU.  The IRR tells us which interrupts have been raised.  Based on the interrupt mask (IMR), the PIC will send interrupts from the IRR to the CPU, at which point they are marked in the ISR.
</p><p>The ISR and IRR can be read via the OCW3 command word.  This is a command sent to one of the command ports (0x20 or 0xa0) with bit 3 set.  To read the ISR or IRR, write the appropriate command to the command port, and then read the command port (not the data port).  To read the IRR, write 0x0a.  To read the ISR, write 0x0b.  
</p><p>The ISR and IRR are each 8 bits.  Here is an example of how to read 16 bits worth of ISR and IRR data from two cascaded PICs:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define PIC_READ_IRR                0x0a    </span><span class="cm">/* OCW3 irq ready next CMD read */</span><span class="cp"></span>
<span class="cp">#define PIC_READ_ISR                0x0b    </span><span class="cm">/* OCW3 irq service next CMD read */</span><span class="cp"></span>

<span class="cm">/* Helper func */</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">__pic_get_irq_reg</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ocw3</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* OCW3 to PIC CMD to get the register values.  PIC2 is chained, and</span>
<span class="cm">     * represents IRQs 8-15.  PIC1 is IRQs 0-7, with 2 being the chain */</span><span class="w"></span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="n">PIC1_COMMAND</span><span class="p">,</span><span class="w"> </span><span class="n">ocw3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="n">PIC2_COMMAND</span><span class="p">,</span><span class="w"> </span><span class="n">ocw3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">PIC2_COMMAND</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="n">PIC1_COMMAND</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Returns the combined value of the cascaded PICs irq request register */</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="nf">pic_get_irr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__pic_get_irq_reg</span><span class="p">(</span><span class="n">PIC_READ_IRR</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Returns the combined value of the cascaded PICs in-service register */</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="nf">pic_get_isr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__pic_get_irq_reg</span><span class="p">(</span><span class="n">PIC_READ_ISR</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Note that these functions will show bit 2 (0x0004) as on whenever any of the PIC2 bits are set, due to the chained nature of the PICs.  Also note that it is not necessary to reset the OCW3 command every time you want to read.  Once you set it for either the IRR or the ISR, future reads of the CMD port will return the appropriate register.  The chip remembers what OCW3 setting you used.  (Disclaimer: I have not tested this last part, but that's what the spec says.)
</p>
<h2><span class="mw-headline" id="Spurious_IRQs">Spurious IRQs</span></h2>
<p>When an IRQ occurs, the PIC chip tells the CPU (via. the PIC's INTR line) that there's an interrupt, and the CPU acknowledges this and waits for the PIC to send the interrupt vector. This creates a race condition: if the IRQ disappears after the PIC has told the CPU there's an interrupt but before the PIC has sent the interrupt vector to the CPU, then the CPU will be waiting for the PIC to tell it which interrupt vector but the PIC won't have a valid interrupt vector to tell the CPU.
</p><p>To get around this, the PIC tells the CPU a fake interrupt number. This is a spurious IRQ. The fake interrupt number is the lowest priority interrupt number for the corresponding PIC chip (IRQ 7 for the master PIC, and IRQ 15 for the slave PIC).
</p><p>There are several reasons for the interrupt to disappear. In my experience the most common reason is software sending an EOI at the wrong time. Other reasons include noise on IRQ lines (or the INTR line).
</p>
<h3><span class="mw-headline" id="Handling_Spurious_IRQs">Handling Spurious IRQs</span></h3>
<p>For a spurious IRQ, there is no real IRQ and the PIC chip's ISR (In Service Register) flag for the corresponding IRQ will not be set. This means that the interrupt handler must not send an EOI back to the PIC to reset the ISR flag.
</p><p>The correct way to handle an IRQ 7 is to first check the master PIC chip's ISR to see if the IRQ is a spurious IRQ or a real IRQ. If it is a real IRQ then it is treated the same as any other real IRQ. If it is a spurious IRQ then you ignore it (and do not send the EOI).
</p><p>The correct way to handle an IRQ 15 is similar, but a little trickier due to the interaction between the slave PIC and the master PIC. First check the slave PIC chip's ISR to see if the IRQ is a spurious IRQ or a real IRQ. If it is a real IRQ then it is treated the same as any other real IRQ. If it's a spurious IRQ then don't send the EOI to the slave PIC; however you will still need to send the EOI to the master PIC because the master PIC itself won't know that it was a spurious IRQ from the slave.
</p><p>Also note that some kernels (e.g. Linux) keep track of the number of spurious IRQs that have occurred (e.g. by incrementing a counter when a spurious IRQ occurs). This can be useful for detecting problems in software (e.g. sending EOIs at the wrong time) and detecting problems in hardware (e.g. line noise).
</p><p><br />
</p>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="APIC" title="APIC">APIC</a></li>
<li><a href="IOAPIC" title="IOAPIC">IOAPIC</a></li></ul>
<h3><span class="mw-headline" id="Threads">Threads</span></h3>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="http://pdos.csail.mit.edu/6.828/2005/readings/hardware/8259A.pdf">Intel Datasheet</a></li>
<li><a rel="nofollow" class="external free" href="http://www.brokenthorn.com/Resources/OSDevPic.html">http://www.brokenthorn.com/Resources/OSDevPic.html</a></li>
<li><a rel="nofollow" class="external free" href="http://helppc.netcore2k.net/hardware/8259">http://helppc.netcore2k.net/hardware/8259</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250212011327
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.054 seconds
Real time usage: 0.829 seconds
Preprocessor visited node count: 107/1000000
Post‐expand include size: 324/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 18063/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.655      1 -total
 86.57%    0.567      2 Template:Wikitable
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1478-0!canonical and timestamp 20250212011326 and revision id 29386.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=8259_PIC&amp;oldid=29386">https://wiki.osdev.org/index.php?title=8259_PIC&amp;oldid=29386</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Interrupts" title="Category:Interrupts">Interrupts</a></li><li><a href="./Category:X86" title="Category:X86">X86</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=8259+PIC" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="8259_PIC#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="8259_PIC" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:8259_PIC" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="8259_PIC"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=8259_PIC&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=8259_PIC&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/8259_PIC" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/8259_PIC" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=8259_PIC&amp;oldid=29386" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=8259_PIC&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/Programmable_Interrupt_Controller" title="Programmable Interrupt Controller – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 8 February 2025, at 13:30.</li>
	<li id="footer-info-0">This page has been accessed 29,600 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=8259_PIC&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.054","walltime":"0.829","ppvisitednodes":{"value":107,"limit":1000000},"postexpandincludesize":{"value":324,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":18063,"limit":5000000},"timingprofile":["100.00%    0.655      1 -total"," 86.57%    0.567      2 Template:Wikitable"]},"cachereport":{"timestamp":"20250212011327","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":930});});</script>
</body>
</html>