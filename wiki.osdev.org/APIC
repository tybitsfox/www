<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>APIC - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"2c13dee5f7ac170b3498f4d4","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"APIC","wgTitle":"APIC","wgCurRevisionId":28317,"wgRevisionId":28317,"wgArticleId":1882,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Interrupts","Multiprocessing"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"APIC","wgRelevantArticleId":1882,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{
"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-APIC rootpage-APIC skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">APIC</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="APIC#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="APIC#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>APIC ("Advanced Programmable Interrupt Controller") is the updated Intel standard for the older <a href="PIC" class="mw-redirect" title="PIC">PIC</a>. It is used in multiprocessor systems and is an integral part of all recent Intel (and compatible) processors. The APIC is used for sophisticated interrupt redirection, and for sending interrupts between processors. These things weren't possible using the older PIC specification.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="APIC#Detection"><span class="tocnumber">1</span> <span class="toctext">Detection</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="APIC#Local_APIC_and_IO-APIC"><span class="tocnumber">2</span> <span class="toctext">Local APIC and IO-APIC</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="APIC#Inter-Processor_Interrupts"><span class="tocnumber">3</span> <span class="toctext">Inter-Processor Interrupts</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="APIC#Local_APIC_configuration"><span class="tocnumber">4</span> <span class="toctext">Local APIC configuration</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="APIC#Local_APIC_and_x86_SMM_Attacks"><span class="tocnumber">5</span> <span class="toctext">Local APIC and x86 SMM Attacks</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="APIC#Local_APIC_registers"><span class="tocnumber">6</span> <span class="toctext">Local APIC registers</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="APIC#EOI_Register"><span class="tocnumber">6.1</span> <span class="toctext">EOI Register</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="APIC#Local_Vector_Table_Registers"><span class="tocnumber">6.2</span> <span class="toctext">Local Vector Table Registers</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="APIC#Spurious_Interrupt_Vector_Register"><span class="tocnumber">6.3</span> <span class="toctext">Spurious Interrupt Vector Register</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="APIC#Interrupt_Command_Register"><span class="tocnumber">6.4</span> <span class="toctext">Interrupt Command Register</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="APIC#IO_APIC_Configuration"><span class="tocnumber">7</span> <span class="toctext">IO APIC Configuration</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="APIC#IO_APIC_Registers"><span class="tocnumber">8</span> <span class="toctext">IO APIC Registers</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="APIC#Logical_Destination_Mode"><span class="tocnumber">9</span> <span class="toctext">Logical Destination Mode</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="APIC#See_Also"><span class="tocnumber">10</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="APIC#Articles"><span class="tocnumber">10.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="APIC#Threads"><span class="tocnumber">10.2</span> <span class="toctext">Threads</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="APIC#External_Links"><span class="tocnumber">10.3</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Detection">Detection</span></h2>
<p>The <a href="CPUID" title="CPUID">CPUID</a>.01h:EDX[bit 9] flag specifies whether a CPU has a built-in local APIC. You can find all of the APICs on a system (both local and IO APICs) by parsing the <a href="MADT" title="MADT">MADT</a>.
</p>
<h2><span class="mw-headline" id="Local_APIC_and_IO-APIC">Local APIC and IO-APIC</span></h2>
<p>In an APIC-based system, each CPU is made of a "core" and a "local APIC". The local APIC is responsible for handling cpu-specific interrupt configuration. Among other things, it contains the <i>Local Vector Table (LVT)</i> that translates events such as "internal clock" and other "local" interrupt sources into a interrupt vector (e.g. LocalINT1 pin could be raising an NMI exception by storing "2" in the corresponding entry of the LVT).
</p><p>More information about the local APIC can be found in Chapter 10 of the <a rel="nofollow" class="external text" href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf">Intel System Programming Guide, Vol 3A Part 1</a>.
</p><p>In addition, there is an I/O APIC (e.g. intel 82093AA) that is part of the chipset and provides multi-processor interrupt management, incorporating both static and dynamic symmetric interrupt distribution across all processors. In systems with multiple I/O subsystems, each subsystem can have its own set of interrupts.
</p><p>Each interrupt pin is individually programmable as either edge or level triggered. The interrupt vector and interrupt steering information can be specified per interrupt. An indirect register accessing scheme optimizes the memory space needed to access the I/O APIC's internal registers. To increase system flexibility when assigning memory space usage, the I/O APIC's two-register memory space is relocatable, but defaults to 0xFEC00000.
</p><p>The Intel standards for the APIC can be found on the Intel site under the category "Multiprocessor Specification", or simply <a rel="nofollow" class="external text" href="http://web.archive.org/web/20070112195752/http://developer.intel.com/design/pentium/datashts/24201606.pdf">this PDF file</a>.
</p>
<h2><span class="mw-headline" id="Inter-Processor_Interrupts">Inter-Processor Interrupts</span></h2>
<p>Inter-Processor Interrupts (IPIs) are generated by a local APIC and can be used as basic signaling for scheduling coordination, multi-processor bootstrapping, etc.
Detailed information on issuing them are available in the Chapter 11.6 of Volume 3 of the Intel Software Developer's Manual, available at the bottom of the page.
</p>
<h2><span class="mw-headline" id="Local_APIC_configuration">Local APIC configuration</span></h2>
<p>The local APIC is enabled at boot-time and can be disabled by clearing bit 11 of the IA32_APIC_BASE <a href="Model_Specific_Registers" title="Model Specific Registers"> Model Specific Register</a> (MSR) (see example below, this only works on CPUs with family &gt;5, as the Pentium does not have such MSR). The CPU then receives its interrupts directly from a 8259-compatible PIC. The Intel Software Developer's Manual, however states that, once you have disabled the local APIC through IA32_APIC_BASE you can't enable it anymore until a complete reset. The I/O APIC can also be configured to run in legacy mode so that it emulates an 8259 device.
</p><p>The local APIC's registers are memory-mapped in physical page FEE00xxx (as seen in table 8-1 of Intel P4 SPG). This address is the same for each local APIC that exists in a configuration, meaning you are only able to directly access the registers of the local APIC of the core that your code is currently executing on. Note that there is a MSR that specifies the actual APIC base (only available on CPUs with family &gt;5). The <a href="MADT" title="MADT">MADT</a> contains the local APIC base and on 64-bit systems it may also contain a field specifying a 64-bit base address override which you ought to use instead. You can choose to leave the Local APIC base just where you find it, or to move it at your pleasure. <b>Note:</b> I don't think you can move it any further than the 4th Gb.
</p><p>To enable the Local APIC to receive interrupts it is necessary to configure the "Spurious Interrupt Vector Register". The correct value for this field is the IRQ number that you want to map the spurious interrupts to within the lowest 8 bits, and the 8th bit set to 1 to actually enable the APIC (see the specification for more details). You should choose an interrupt number that has its lowest 4 bits set and is above 32 (as you might guess); easiest is to use 0xFF. This is important on some older processors because the lowest 4 bits for this value must be set to 1 on these.
</p><p><b>Disable the <a href="PIC" class="mw-redirect" title="PIC">8259 PIC</a></b> properly. This is nearly as important as setting up the APIC. You do this in two steps: masking all interrupts and remapping the IRQs. Masking all interrupts disables them in the PIC. Remapping is what you probably already did when you used the PIC: you want interrupt requests to start at 32 instead of 0 to avoid conflicts with the exceptions. You should then avoid using these interrupt vectors for other purposes. This is necessary because even though you masked all interrupts on the PIC, it could still give out spurious interrupts which will then be misinterpreted from your kernel as exceptions.
</p><p><br />
Here are some code examples on setting up the APIC:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define IA32_APIC_BASE_MSR 0x1B</span>
<span class="cp">#define IA32_APIC_BASE_MSR_BSP 0x100 </span><span class="c1">// Processor is a BSP</span>
<span class="cp">#define IA32_APIC_BASE_MSR_ENABLE 0x800</span>

<span class="cm">/** returns a &#39;true&#39; value if the CPU supports APIC</span>
<span class="cm"> *  and if the local APIC hasn&#39;t been disabled in MSRs</span>
<span class="cm"> *  note that this requires CPUID to be supported.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">check_apic</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="n">edx</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">cpuid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">edx</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CPUID_FEAT_EDX_APIC</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Set the physical address for local APIC registers */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">cpu_set_apic_base</span><span class="p">(</span><span class="kt">uintptr_t</span><span class="w"> </span><span class="n">apic</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">edx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">apic</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xfffff0000</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">IA32_APIC_BASE_MSR_ENABLE</span><span class="p">;</span><span class="w"></span>

<span class="cp">#ifdef __PHYSICAL_MEMORY_EXTENSION__</span>
<span class="w">   </span><span class="n">edx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">apic</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0f</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">   </span><span class="n">cpuSetMSR</span><span class="p">(</span><span class="n">IA32_APIC_BASE_MSR</span><span class="p">,</span><span class="w"> </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="n">edx</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * Get the physical address of the APIC registers page</span>
<span class="cm"> * make sure you map it to virtual memory&#160;;)</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">uintptr_t</span><span class="w"> </span><span class="nf">cpu_get_apic_base</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="n">edx</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">cpuGetMSR</span><span class="p">(</span><span class="n">IA32_APIC_BASE_MSR</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef __PHYSICAL_MEMORY_EXTENSION__</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">eax</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xfffff000</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">((</span><span class="n">edx</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0f</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">eax</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xfffff000</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">enable_apic</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* Section 11.4.1 of 3rd volume of Intel SDM recommends mapping the base address page as strong uncacheable for correct APIC operation. */</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* Hardware enable the Local APIC if it wasn&#39;t enabled */</span><span class="w"></span>
<span class="w">    </span><span class="n">cpu_set_apic_base</span><span class="p">(</span><span class="n">cpu_get_apic_base</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* Set the Spurious Interrupt Vector Register bit 8 to start receiving interrupts */</span><span class="w"></span>
<span class="w">    </span><span class="n">write_reg</span><span class="p">(</span><span class="mh">0xF0</span><span class="p">,</span><span class="w"> </span><span class="n">ReadRegister</span><span class="p">(</span><span class="mh">0xF0</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x100</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Local_APIC_and_x86_SMM_Attacks">Local APIC and x86 SMM Attacks</span></h2>
<p>The APIC was introduced to the core Intel processor architecture skeleton in <a rel="nofollow" class="external text" href="https://4donline.ihs.com/images/VipMasterIC/IC/INTL/INTLD047/INTLD047-2-1259.pdf?hkey=EF798316E3902B6ED9A73243A3159BB0">Intel's 82489DX discrete chip</a> in a similar time period as <a href="System_Management_Mode" title="System Management Mode">System Management Mode</a> was introduced to operating systems. In original architecture, the APIC could not be mapped to memory, and it wasn't until later changes that it became mappable.
</p><p>As System Management Mode's memory (SMRAM) is given a protected range of memory (which can vary from system to system), it is possible to map the APIC memory location into the SMRAM. The result of this is that SMM memory is pushed outside its protected range and exposed to lesser-privileged permission rings. Using this method, attackers can leverage their permissions using System Management Mode, which is protected from all rings above -2.
</p><p>In newer generation Intel processors (starting with the <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Intel_Atom">Intel Atom</a> in 2013), this has been taken into account. An undocumented check is performed against the <a href="https://wiki.osdev.org/index.php?title=System_Management_Range_Registers&amp;action=edit&amp;redlink=1" class="new" title="System Management Range Registers (page does not exist)">System Management Range Registers</a> when the APIC is relocated to memory. This check ensures that the APIC does not overlap with the SMRAM. <b>However</b>, this relies on the SMRR to be configured correctly. Otherwise, this mitigation will not work properly and attackers will still be able to use the attack.
</p>
<h2><span class="mw-headline" id="Local_APIC_registers">Local APIC registers</span></h2>
<p>The local APIC registers are memory mapped to an address that can be found in the MP/MADT tables. Make sure you map these to virtual memory if you are using paging. Each register is 32 bits long, and expects to be written and read as a 32 bit integer. Although each register is 4 bytes, they are all aligned on a 16 byte boundary. 
</p><p>List of local APIC registers (TODO: Add descriptions for all registers):
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<td>Offset
</td>
<td>Register name
</td>
<td>Read/Write permissions
</td></tr>

<tr>
<td>000h - 010h
</td>
<td>Reserved
</td>
<td>
</td></tr>

<tr>
<td>020h
</td>
<td>LAPIC ID Register
</td>
<td>Read/Write
</td></tr>

<tr>
<td>030h
</td>
<td>LAPIC Version Register
</td>
<td>Read only
</td></tr>

<tr>
<td>040h - 070h
</td>
<td>Reserved
</td>
<td>
</td></tr>

<tr>
<td>080h
</td>
<td>Task Priority Register (TPR)
</td>
<td>Read/Write
</td></tr>

<tr>
<td>090h
</td>
<td>Arbitration Priority Register (APR)
</td>
<td>Read only
</td></tr>

<tr>
<td>0A0h
</td>
<td>Processor Priority Register (PPR)
</td>
<td>Read only
</td></tr>

<tr>
<td>0B0h
</td>
<td>EOI register
</td>
<td>Write only
</td></tr>

<tr>
<td>0C0h
</td>
<td>Remote Read Register (RRD)
</td>
<td>Read only
</td></tr>

<tr>
<td>0D0h
</td>
<td>Logical Destination Register
</td>
<td>Read/Write
</td></tr>

<tr>
<td>0E0h
</td>
<td>Destination Format Register
</td>
<td>Read/Write
</td></tr>

<tr>
<td>0F0h
</td>
<td>Spurious Interrupt Vector Register
</td>
<td>Read/Write
</td></tr>

<tr>
<td>100h - 170h
</td>
<td>In-Service Register (ISR)
</td>
<td>Read only
</td></tr>

<tr>
<td>180h - 1F0h
</td>
<td>Trigger Mode Register (TMR)
</td>
<td>Read only
</td></tr>

<tr>
<td>200h - 270h
</td>
<td>Interrupt Request Register (IRR)
</td>
<td>Read only
</td></tr>

<tr>
<td>280h
</td>
<td>Error Status Register
</td>
<td>Read only
</td></tr>

<tr>
<td>290h - 2E0h
</td>
<td>Reserved
</td>
<td>
</td></tr>

<tr>
<td>2F0h
</td>
<td>LVT Corrected Machine Check Interrupt (CMCI) Register
</td>
<td>Read/Write
</td></tr>

<tr>
<td>300h - 310h
</td>
<td>Interrupt Command Register (ICR)
</td>
<td>Read/Write
</td></tr>

<tr>
<td>320h
</td>
<td>LVT Timer Register
</td>
<td>Read/Write
</td></tr>

<tr>
<td>330h
</td>
<td>LVT Thermal Sensor Register
</td>
<td>Read/Write
</td></tr>

<tr>
<td>340h
</td>
<td>LVT Performance Monitoring Counters Register
</td>
<td>Read/Write
</td></tr>

<tr>
<td>350h
</td>
<td>LVT LINT0 Register
</td>
<td>Read/Write
</td></tr>

<tr>
<td>360h
</td>
<td>LVT LINT1 Register
</td>
<td>Read/Write
</td></tr>

<tr>
<td>370h
</td>
<td>LVT Error Register
</td>
<td>Read/Write
</td></tr>

<tr>
<td>380h
</td>
<td>Initial Count Register (for Timer)
</td>
<td>Read/Write
</td></tr>

<tr>
<td>390h
</td>
<td>Current Count Register (for Timer)
</td>
<td>Read only
</td></tr>

<tr>
<td>3A0h - 3D0h
</td>
<td>Reserved
</td>
<td>
</td></tr>

<tr>
<td>3E0h
</td>
<td>Divide Configuration Register (for Timer)
</td>
<td>Read/Write
</td></tr>

<tr>
<td>3F0h
</td>
<td>Reserved
</td>
<td>
</td></tr>
</tbody></table>
<h3><span class="mw-headline" id="EOI_Register">EOI Register</span></h3>
<p>Write to the register with offset 0xB0 using the value 0 to signal an end of interrupt. A non-zero value may cause a general protection fault.
</p>
<h3><span class="mw-headline" id="Local_Vector_Table_Registers">Local Vector Table Registers</span></h3>
<p>There are some special interrupts that the processor and LAPIC can generate themselves. While external interrupts are configured in the I/O APIC, these interrupts must be configured using registers in the LAPIC. The most interesting registers are: 0x320 = lapic timer, 0x350 = lint0, 0x360 = lint1. See the Intel SDM vol 3 for more info. 
</p><p>Register format:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<td>Bits 0-7
</td>
<td>The vector number
</td></tr>
<tr>
<td>Bits 8-10 (reserved for timer)
</td>
<td>100b if NMI
</td></tr>
<tr>
<td>Bit 11
</td>
<td>Reserved
</td></tr>
<tr>
<td>Bit 12
</td>
<td>Set if interrupt pending.
</td></tr>
<tr>
<td>Bit 13 (reserved for timer)
</td>
<td>Polarity, set is low triggered
</td></tr>
<tr>
<td>Bit 14 (reserved for timer)
</td>
<td>Remote IRR
</td></tr>
<tr>
<td>Bit 15 (reserved for timer)
</td>
<td>trigger mode, set is level triggered
</td></tr>
<tr>
<td>Bit 16
</td>
<td>Set to mask
</td></tr>
<tr>
<td>Bits 17-31
</td>
<td>Reserved
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Spurious_Interrupt_Vector_Register">Spurious Interrupt Vector Register</span></h3>
<p>The offset is 0xF0. The low byte contains the number of the spurious interrupt. As noted above, you should probably set this to 0xFF. To enable the APIC, set bit 8 (or 0x100) of this register. If bit 12 is set then EOI messages will not be broadcast. All the other bits are currently reserved.
</p>
<h3><span class="mw-headline" id="Interrupt_Command_Register">Interrupt Command Register</span></h3>
<p>The interrupt command register is made of two 32-bit registers; one at 0x300 and the other at 0x310. It is used for sending interrupts to different processors. The interrupt is issued when 0x300 is written to, but not when 0x310 is written to. Thus, to send an interrupt command one should first write to 0x310, then to 0x300. At 0x310 there is one field at bits 24-27, which is local APIC ID of the target processor (for a physical destination mode). Here is how 0x300 is structured:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<td>Bits 0-7
</td>
<td>The vector number, or starting page number for SIPIs
</td></tr>
<tr>
<td>Bits 8-10
</td>
<td>The delivery mode. 0 is normal, 1 is lowest priority, 2 is SMI, 4 is NMI, 5 can be INIT or INIT level de-assert, 6 is a SIPI.
</td></tr>
<tr>
<td>Bit 11
</td>
<td>The destination mode. Clear for a physical destination, or set for a logical destination. If the bit is clear, then the destination field in 0x310 is treated normally.
</td></tr>
<tr>
<td>Bit 12
</td>
<td>Delivery status. Cleared when the interrupt has been accepted by the target. You should usually wait until this bit clears after sending an interrupt.
</td></tr>
<tr>
<td>Bit 13
</td>
<td>Reserved
</td></tr>
<tr>
<td>Bit 14
</td>
<td>Clear for INIT level de-assert, otherwise set.
</td></tr>
<tr>
<td>Bit 15
</td>
<td>Set for INIT level de-assert, otherwise clear.
</td></tr>
<tr>
<td>Bits 18-19
</td>
<td>Destination type. If this is &gt; 0 then the destination field in 0x310 is ignored. 1 will always send the interrupt to itself, 2 will send it to all processors, and 3 will send it to all processors aside from the current one. It is best to avoid using modes 1, 2 and 3, and stick with 0.
</td></tr>
<tr>
<td>Bits 20-31
</td>
<td>Reserved
</td></tr></tbody></table>
<h2><span class="mw-headline" id="IO_APIC_Configuration">IO APIC Configuration</span></h2>
<p>The IO APIC uses two registers for most of its operation - an address register at IOAPICBASE+0 and a data register at 
IOAPICBASE+0x10.  All accesses must be done on 4 byte boundaries.  The address register uses the bottom 8 bits for register select.  Here is some example code that illustrates this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">cpuReadIoApic</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ioapicaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">reg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="o">*</span><span class="n">ioapic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">ioapicaddr</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">ioapic</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">ioapic</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">cpuWriteIoApic</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ioapicaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="o">*</span><span class="n">ioapic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">ioapicaddr</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">ioapic</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">ioapic</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Note the use of the <a href="Volatile_(keyword)" title="Volatile (keyword)">volatile</a> keyword. This prevents a compiler like <a href="Visual_C" class="mw-redirect" title="Visual C">Visual C</a> from reordering or optimizing away the memory accesses, which would be a Bad Thing&#8482;. The volatile keyword is put before the '*' sign. It means that the <i>value pointed to</i> is volatile, not the pointer itself.
</p>
<h2><span class="mw-headline" id="IO_APIC_Registers">IO APIC Registers</span></h2>
<p>Using the methods described above, the following registers are accessible.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<td>0x00
</td>
<td>Get/set the IO APIC's id in bits 24-27. All other bits are reserved.
</td></tr>
<tr>
<td>0x01
</td>
<td>Get the version in bits 0-7. Get the maximum amount of redirection entries in bits 16-23. All other bits are reserved. Read only.
</td></tr>
<tr>
<td>0x02
</td>
<td>Get the arbitration priority in bits 24-27. All other bits are reserved. Read only.
</td></tr>
<tr>
<td>0x10 to 0x3F
</td>
<td>Contains a list of redirection entries. They can be read from and written to. Each entries uses two addresses, e.g. 0x12 and 0x13.
</td></tr></tbody></table>
<p>Here is what a redirection entry looks like.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<td>Bits 0-7
</td>
<td>Interrupt vector. Allowed values are from 0x10 to 0xFE.
</td></tr>
<tr>
<td>Bits 8-10
</td>
<td>Type of delivery mode. 0 = Normal, 1 = Low priority, 2 = System management interrupt, 4 = Non maskable interrupt, 5 = INIT, 7 = External. All others are reserved.
</td></tr>
<tr>
<td>Bit 11
</td>
<td>Destination mode. Affects how the destination field is read, 0 is physical mode, 1 is logical. If the Destination Mode of this entry is Physical Mode, bits 56-59 contain an APIC ID.
</td></tr>
<tr>
<td>Bit 12
</td>
<td>Set if this interrupt is going to be sent, but the APIC is busy. Read only.
</td></tr>
<tr>
<td>Bit 13
</td>
<td>Polarity of the interrupt. 0 = High is active, 1 = Low is active.
</td></tr>
<tr>
<td>Bit 14
</td>
<td>Used for level triggered interrupts only to show if a local APIC has received the interrupt (= 1), or has sent an EOI (= 0). Read only.
</td></tr>
<tr>
<td>Bit 15
</td>
<td>Trigger mode. 0 = Edge sensitive, 1 = Level sensitive.
</td></tr>
<tr>
<td>Bit 16
</td>
<td>Interrupt mask. Stops the interrupt from reaching the processor if set.
</td></tr>
<tr>
<td>Bits 17-55
</td>
<td>Reserved.
</td></tr>
<tr>
<td>Bits 56-63
</td>
<td>Destination field. If the destination mode bit was clear, then the lower 4 bits contain the bit APIC ID to sent the interrupt to. If the bit was set, the upper 4 bits also contain a set of processors. (See below)
</td></tr></tbody></table>
<p>For more information, check out chapter 3 of <a rel="nofollow" class="external text" href="http://web.archive.org/web/20161130153145/http://download.intel.com/design/chipsets/datashts/29056601.pdf">the I/O APIC datasheet</a>.
</p><p>The redirection table allows you to choose which external interrupts are sent to which processors and with which interrupt vectors. When choosing the processors you should consider: spreading out the workload between the processors, avoiding processors in a low-power state, and avoiding throttled processors. When choosing the interrupt vectors you should remember that interrupts 0x00 to 0x1F are reserved for internal processor exceptions, the interrupts you remapped the PIC to may receive spurious interrupts, that 0xFF is probably where you put the APIC spurious interrupt, and that the upper 4 bits of an interrupt vector indicate its priority.
</p>
<h2><span class="mw-headline" id="Logical_Destination_Mode">Logical Destination Mode</span></h2>
<p>Logical destination mode uses an 8-bit logical APIC ID, contained in the LDR (logical destination register, unique to each APIC). All APICs compare their local ID to the destination code sent with the interrupt. This allows to target a group of processors by programming them with the same logical APIC ID.
</p><p>The LDR is formatted as follows
</p>
<table class="wikitable">

<tbody><tr>
<td>Bits 0-23
</td>
<td>Reserved.
</td></tr>
<tr>
<td rowspan="3">Bits 24-31
</td>
<td>Flat model
</td>
<td>Bitmap of target processors (each bit identifies single processor; supports a maximum of 8 local APIC units)
</td></tr>
<tr>
<td rowspan="2">Cluster model
</td>
<td>Bits 24-27
</td>
<td>Local APIC address (identifies the specific processor in a group)
</td></tr>
<tr>
<td>Bits 28-31
</td>
<td>Cluster address (identifies a group of processors)
</td></tr></tbody></table>
<p>The DFR (destination format register) specifies Flat or Cluster model and is structured as follows
</p>
<table class="wikitable">

<tbody><tr>
<td>Bits 0-27
</td>
<td>Reserved.
</td></tr>
<tr>
<td>Bits 28-31
</td>
<td>Model (1111b = Flat model, 0000b = Cluster model)
</td></tr></tbody></table>
<p>The cluster addressing scheme has some limitations on the Pentium era systems. It may require special hardware to route the APIC bus messages between different CPU clusters or that it is sometimes limited to 15 agents (CPUs) in total. More info can be found in <a rel="nofollow" class="external text" href="https://books.google.com/books?id=TVzjEZg1--YC&amp;printsec=frontcover">"Pentium Processor System Architecture. Chapter 15: The APIC"</a>
</p><p>Operating systems running on 64-bit processors typically use "Flat model" when the system has up to 8 CPUs. If more than 8 CPUs is used some OSes use cluster model which allow to address in total 60 CPUs (cluster 0xf is a broadcast and there is 15 clusters with 4 CPUs in each).
</p><p>The logical delivery mode is handy to address multiple CPUs when doing IPIs or it might be used in conjunction with lowest priority delivery mode to deliver IRQs from MSI/IO-APICs to a certain CPU in the group specified in the destination field.
</p>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="8259_PIC" title="8259 PIC">8259 PIC</a></li>
<li><a href="IOAPIC" title="IOAPIC">IOAPIC</a></li>
<li><a href="APIC_timer" class="mw-redirect" title="APIC timer">APIC timer</a></li></ul>
<h3><span class="mw-headline" id="Threads">Threads</span></h3>
<ul><li><a rel="nofollow" class="external text" href="https://forum.osdev.org/viewtopic.php?t=10686">APIC timer</a></li>
<li><a rel="nofollow" class="external text" href="https://forum.osdev.org/viewtopic.php?t=11529">Mapping the I/O APIC</a></li>
<li><a rel="nofollow" class="external text" href="https://forum.osdev.org/viewtopic.php?p=107868#107868">Brendan gives some general info on the APIC and implementing it</a></li></ul>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20161128201003/http://www.intel.com/design/chipsets/datashts/290566.htm">Original I/O APIC specification/datasheet</a></li>
<li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20170430050751/http://www.intel.com/design/chipsets/specupdt/290710.htm">Updated I/O APIC specification/datasheet</a></li>
<li><a rel="nofollow" class="external text" href="https://www.intel.com/products/processor/manuals/">Volume 3A:System Programming Guide, Part 1,manuals has a chapter on the APIC</a></li>
<li><a rel="nofollow" class="external text" href="https://www.intel.com/products/processor/manuals/">Volume 3A:System Programming Guide, Chapter 10.4 for further reading about the LAPIC</a></li>
<li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20140308064246/http://www.osdever.net/tutorials/pdf/apic.pdf">Advanced Programmable Interrupt Controller by Mike Rieker</a></li>
<li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20121026064337/http://msdn.microsoft.com/en-us/windows/hardware/gg462964.aspx">"The Importance of Implementing APIC-Based Interrupt Subsystems on Uniprocessor PCs". Microsoft. 7 January 2003</a></li>
<li><a rel="nofollow" class="external text" href="https://books.google.com/books?id=TVzjEZg1--YC">Pentium Processor System Architecture</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250212010623
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.037 seconds
Real time usage: 0.295 seconds
Preprocessor visited node count: 91/1000000
Post‐expand include size: 810/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 10984/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  132.730      1 -total
  0.62%    0.822      5 Template:Wikitable
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1882-0!canonical and timestamp 20250212010623 and revision id 28317.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=APIC&amp;oldid=28317">https://wiki.osdev.org/index.php?title=APIC&amp;oldid=28317</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Interrupts" title="Category:Interrupts">Interrupts</a></li><li><a href="./Category:Multiprocessing" title="Category:Multiprocessing">Multiprocessing</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=APIC" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="APIC#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="APIC" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:APIC" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="APIC"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=APIC&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=APIC&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/APIC" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="./Special:RecentChangesLinked/APIC" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=APIC&amp;oldid=28317" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=APIC&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/Advanced_Programmable_Interrupt_Controller" title="Advanced Programmable Interrupt Controller – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 24 September 2023, at 20:01.</li>
	<li id="footer-info-0">This page has been accessed 29,816 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=APIC&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.037","walltime":"0.295","ppvisitednodes":{"value":91,"limit":1000000},"postexpandincludesize":{"value":810,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":10984,"limit":5000000},"timingprofile":["100.00%  132.730      1 -total","  0.62%    0.822      5 Template:Wikitable"]},"cachereport":{"timestamp":"20250212010623","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":391});});</script>
</body>
</html>