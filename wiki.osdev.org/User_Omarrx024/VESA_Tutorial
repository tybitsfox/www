<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>User:Omarrx024/VESA Tutorial - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"d8a9567dddef0a94f5a8f779","wgCSPNonce":false,"wgCanonicalNamespace":"User","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":2,"wgPageName":"User:Omarrx024/VESA_Tutorial","wgTitle":"Omarrx024/VESA Tutorial","wgCurRevisionId":27508,"wgRevisionId":27508,"wgArticleId":3938,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"User:Omarrx024/VESA_Tutorial","wgRelevantArticleId":3938,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]
,"wgRelevantUserName":"Omarrx024","wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="../favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="../opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="../api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-2 ns-subject page-User_Omarrx024_VESA_Tutorial rootpage-User_Omarrx024 skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-namespace">User</span><span class="mw-page-title-separator">:</span><span class="mw-page-title-main">Omarrx024/VESA Tutorial</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="VESA_Tutorial#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="VESA_Tutorial#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p><b>VESA Tutorial</b>
</p><p>Hello. Today, I'm posting specifically to teach people who want graphics all about VESA. That means that in less than 30 minutes, you'll be able to have a high-color graphics world in your OS!
So anyway, VESA is the Video Electronics Standard Association. They are the people who made the VBE, or the VESA BIOS Extensions Standard. Like the name implies, it is an optional BIOS extension. But I think it's safe to say that 99% of PCs built since the late 1990's have VESA support. Note that UEFI GOP has succeeded VESA BIOS Extensions, but UEFI implementations also have a legacy VESA-compaitble BIOS for backwards-compatibility.
</p><p>Anyway let's have a little history lesson...
In 1991, VESA released VBE version 1.2, which was mostly compatible with the previous 1.0 and 1.1 but had more popularity. Here, VESA defined some "video mode numbers" which are mostly the same idea as VGA mode numbers (e.g 0x03 is text 80x25, 0x13 is graphics 320x200x8bpp, ...) and they also defined "bank switching." The idea worked like this: you call the VESA BIOS and it sets a video mode for you. Then, because 1991 was still considered "DOS days," you write to 0xA000:0x0000 (linear 0xA0000) to draw to the screen. But that buffer only had a maximum of 64 KB because it is a 16-bit segment... So they invented bank switching; in which the BIOS divided the video memory into smaller chunks called banks, and you'll switch banks as you need to while drawing. For example, in a 640x480x8bpp VESA mode, we need 300 KB of video memory. But unfortunately, we can only access the video memory as 64 KB segments... So if we want to draw to the entire screen, first we switch to bank 0, which is the first 64 KB of the screen, then we draw; then we switch to bank 1, which is the second 64 KB of the screen, then we draw to the same address; then we switch to bank 2, and so on...
This had a severe performance penalty, and bank switching is deprecated today, and has been succeeded by linear framebuffers, which are discussed later in this tutorial.
</p><p>Here are some modes the VESA defined with VBE 1.x:
</p>
<pre>MODE    RESOLUTION  BITS PER PIXEL  MAXIMUM COLORS
0x0100  640x400     8               256
0x0101  640x480     8               256
0x0102  800x600     4               16
0x0103  800x600     8               256
0x010D  320x200     15              32k
0x010E  320x200     16              64k
0x010F  320x200     24/32*          16m
0x0110  640x480     15              32k
0x0111  640x480     16              64k
0x0112  640x480     24/32*          16m
0x0113  800x600     15              32k
0x0114  800x600     16              64k
0x0115  800x600     24/32*          16m
0x0116  1024x768    15              32k
0x0117  1024x768    16              64k
0x0118  1024x768    24/32*          16m</pre>
<p>Notes:
</p>
<ul><li>Some BIOSes support 24-bit color, in which each color is an RGB value, in which each color component is 8 bits; giving a total of 16 million available colors. Other BIOSes support 32-bit color, in which color is also an RGB value and each color component is still 8 bits, but there is an empty 8 bits at the top, which are known as the alpha channel; so 32-bit color is often called RGBA color while 24-bit color is often called RGB color. This is done for two reasons: as a stub for software implementing alpha blending, as to speed up memory operations by 32-bit alignment. Note that the values are in little endian.</li></ul>
<p>Then in 1994, VESA defined VBE 2.0 and this was a major improvement, although "most" VBE 2.0+ BIOSes are compatible with VBE 1.x. Anyway, in VBE 2.0, VESA defined the "linear framebuffer" which was a place in high memory (3 to 4 GB) that had a totally contiguous framebuffer; bank switching was deprecated although is still supported in the BIOS for backwards-compatibility. VESA also stated that all the modes that they defined in VBE 1.x are also deprecated, and that hardware manufacturers didn't need to support them, and that anyone can make up any modes they feel like. Most hardware vendors still support the standard VBE 1.x modes for backward-compatibility, but you should NEVER depend on that, because one day you'll find a PC on which your code just won't work.
But wait a minute... How can we set VESA modes without knowing the mode numbers? Well, VESA gave us two things: a function that returns an array of all available mode numbers, and another function that gets the details of a specified mode number (width, height, bpp, linear framebuffer address, etc...) The basic idea is that we query the BIOS for the information of every available mode, and when we find a mode that fits our needs, we can use it. Since mode numbers are not standard, you should NEVER assume mode numbers, width of a mode, height of a mode, or bpp of the mode. For example, my laptop has VESA mode 0x0118 as 1024x768x32 while older software assumed it to be a 24-bit mode. Newer software may assume it to be a 32-bit mode; while Bochs and QEMU emulate it as a 24-bit mode. Anyway, you should NEVER assume VESA modes and should always query the BIOS for what it supports.
</p><p>That's enough theory for today, I guess. Let's take a look on how to actually use the VESA BIOS Extensions!
VESA put its VBE functions at function 0x4F of BIOS interrupt 0x10. You put the function number 0x4F in AH register, the subfunction number in AL register, parameters in other registers, and call INT 0x10.
All VESA calls return 0x004F in AX on success. Any other return code should be taken as an error.
</p><p>Here are some useful functions that can be used with VBE 2.0+:
</p><p><b> FUNCTION: Get VESA BIOS information </b>
</p><p>Function code: 0x4F00
</p><p>Description: Returns the VESA BIOS information, including manufacturer, supported modes, available video memory, etc...
<b>Input:</b> AX = 0x4F00
</p><p><b>Input:</b> ES:DI = Segment:Offset pointer to where to store VESA BIOS information structure.
</p><p><b>Output:</b> AX = 0x004F on success, other values indicate that VESA BIOS is not supported.
</p><p>Anyway, the above function returns the following structure and stores it in ES:DI as they were on entry. On entry, ES:DI should contain a pointer to the following structure:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="nl">vbe_info_structure:</span><span class="w"></span>
<span class="w">	</span><span class="na">.signature</span><span class="w">		</span><span class="no">db</span><span class="w"> </span><span class="s">&quot;VBE2&quot;</span><span class="w">	</span><span class="c1">; indicate support for VBE 2.0+</span>
<span class="w">	</span><span class="nl">.table_data:</span><span class="w">		</span><span class="nf">resb</span><span class="w"> </span><span class="mi">512-4</span><span class="w">	</span><span class="c1">; reserve space for the table below</span>
</pre></div>
<p>After the BIOS call, if it succeeded (AX is 0x004F), then the same structure above now contains the following:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">vbe_info_structure</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">char</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="n">signature</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;VESA&quot;</span><span class="p">;</span><span class="w">	</span><span class="c1">// must be &quot;VESA&quot; to indicate valid VBE support</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">version</span><span class="p">;</span><span class="w">			</span><span class="c1">// VBE version; high byte is major version, low byte is minor version</span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">oem</span><span class="p">;</span><span class="w">			</span><span class="c1">// segment:offset pointer to OEM</span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">capabilities</span><span class="p">;</span><span class="w">		</span><span class="c1">// bitfield that describes card capabilities</span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">video_modes</span><span class="p">;</span><span class="w">		</span><span class="c1">// segment:offset pointer to list of supported video modes</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">video_memory</span><span class="p">;</span><span class="w">		</span><span class="c1">// amount of video memory in 64KB blocks</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">software_rev</span><span class="p">;</span><span class="w">		</span><span class="c1">// software revision</span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">vendor</span><span class="p">;</span><span class="w">			</span><span class="c1">// segment:offset to card vendor string</span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">product_name</span><span class="p">;</span><span class="w">		</span><span class="c1">// segment:offset to card model name</span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">product_rev</span><span class="p">;</span><span class="w">		</span><span class="c1">// segment:offset pointer to product revision</span>
<span class="w">	</span><span class="kt">char</span><span class="w"> </span><span class="n">reserved</span><span class="p">[</span><span class="mi">222</span><span class="p">];</span><span class="w">		</span><span class="c1">// reserved for future expansion</span>
<span class="w">	</span><span class="kt">char</span><span class="w"> </span><span class="n">oem_data</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span><span class="w">		</span><span class="c1">// OEM BIOSes store their strings in this area</span>
<span class="p">}</span><span class="w"> </span><span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">packed</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>Notice that all segment:offset fields are in little-endian, which means the low word is the offset, and the high word is the segment.
Things that might be of interest to you from the above structure: "signature" will be changed from "VBE2" to "VESA". It must be "VBE2" on entry to indicate software support for VBE 2.0. If it contains "VBE2", the BIOS will return the 512 bytes of data for VBE 2.0+. If it contains "VESA", the BIOS will return 256 bytes of data for VBE 1.x. If it is not "VESA" after the call, you should assume that VESA BIOS Extensions are not available. "version" tells you the version of VBE; 0x100 is 1.0, 0x101 is 1.1, 0x102 is 1.2, 0x200 is 2.0, and 0x300 is 3.0 (the latest version). VBE 1.x returns 256 bytes of data in the above structure, VBE 2.0 and 3.0 return 512 bytes of data if the "signature" field contained "VBE2" on entry. "video_modes" is a segment:offset pointer to the list of supported video modes. Each entry in the array is a 16-bit word, and is terminated by a 0xFFFF. If while searching for your mode, you find a 0xFFFF, then the mode is not supported. "video_memory" contains how much VGA RAM the PC has in 64 KB chunks. So, to have it in KB, multiply the value in "video_memory" by 64.
Anyway, about the supported modes array, if the PC supports modes 0x0103, 0x0115, and 0x0118, the array would look like this in a hexdump:
</p>
<pre>03 01 15 01 18 01 FF FF</pre>
<p>Notice how it is terminated by a 0xFFFF and all values are in little-endian.
</p><p><b> FUNCTION: Get VESA mode information </b>
</p><p>Function code: 0x4F01
</p><p>Description: This function returns the mode information structure for a specified mode. The mode number should be gotten from the supported modes array.
</p><p><b>Input:</b> AX = 0x4F01
</p><p><b>Input:</b> CX = VESA mode number from the video modes array
</p><p><b>Input:</b> ES:DI = Segment:Offset pointer of where to store the VESA Mode Information Structure shown below.
</p><p><b>Output:</b> AX = 0x004F on success, other values indicate a BIOS error or a mode-not-supported error.
</p><p>Here's the structure returned by this function in ES:DI:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">vbe_mode_info_structure</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">attributes</span><span class="p">;</span><span class="w">		</span><span class="c1">// deprecated, only bit 7 should be of interest to you, and it indicates the mode supports a linear frame buffer.</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">window_a</span><span class="p">;</span><span class="w">			</span><span class="c1">// deprecated</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">window_b</span><span class="p">;</span><span class="w">			</span><span class="c1">// deprecated</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">granularity</span><span class="p">;</span><span class="w">		</span><span class="c1">// deprecated; used while calculating bank numbers</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">window_size</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">segment_a</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">segment_b</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">win_func_ptr</span><span class="p">;</span><span class="w">		</span><span class="c1">// deprecated; used to switch banks from protected mode without returning to real mode</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">pitch</span><span class="p">;</span><span class="w">			</span><span class="c1">// number of bytes per horizontal line</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w">			</span><span class="c1">// width in pixels</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w">			</span><span class="c1">// height in pixels</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">w_char</span><span class="p">;</span><span class="w">			</span><span class="c1">// unused...</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">y_char</span><span class="p">;</span><span class="w">			</span><span class="c1">// ...</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">planes</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bpp</span><span class="p">;</span><span class="w">			</span><span class="c1">// bits per pixel in this mode</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">banks</span><span class="p">;</span><span class="w">			</span><span class="c1">// deprecated; total number of banks in this mode</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">memory_model</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bank_size</span><span class="p">;</span><span class="w">		</span><span class="c1">// deprecated; size of a bank, almost always 64 KB but may be 16 KB...</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">image_pages</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">reserved0</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">red_mask</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">red_position</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">green_mask</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">green_position</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">blue_mask</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">blue_position</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">reserved_mask</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">reserved_position</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">direct_color_attributes</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">;</span><span class="w">		</span><span class="c1">// physical address of the linear frame buffer; write here to draw to the screen</span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">off_screen_mem_off</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">off_screen_mem_size</span><span class="p">;</span><span class="w">	</span><span class="c1">// size of memory in the framebuffer but not being displayed on the screen</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">reserved1</span><span class="p">[</span><span class="mi">206</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">packed</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>Lots of useless sh*t, I know. The only things that interest us: "attributes" bit 7 (value 0x80) indicates the mode supports a linear frame buffer. "width", "height" are "bpp" are used while searching for the mode we want to use. "framebuffer" is the 32-bit physical pointer to the linear framebuffer. The linear framebuffer must be enabled while setting the VBE mode, which is discussed in the next function. If you are using paging, be sure to map the framebuffer somewhere known in the virtual address space!
</p><p><b> FUNCTION: Set VBE mode </b>
</p><p>Function code: 0x4F02
</p><p>Description: This function sets a VBE mode.
</p><p><b>Input:</b> AX = 0x4F02
</p><p><b>Input:</b> BX = Bits 0-13 mode number; bit 14 is the LFB bit: when set, it enables the linear framebuffer, when clear, software must use bank switching. Bit 15 is the DM bit: when set, the BIOS doesn't clear the screen. Bit 15 is usually ignored and should always be cleared.
</p><p><b>Output:</b> AX = 0x004F on success, other values indicate errors; such as BIOS error, too little video memory, unsupported VBE mode, mode doesn't support linear frame buffer, or any other error.
</p><p>So that means, if VBE mode 0x0118 is 1024x768x32bpp, and we wanted to set this mode and ask the BIOS to clear the screen for us, we can do this:
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x4F02</span><span class="w">	</span><span class="c1">; set VBE mode</span>
<span class="nf">mov</span><span class="w"> </span><span class="no">bx</span><span class="p">,</span><span class="w"> </span><span class="mi">0x4118</span><span class="w">	</span><span class="c1">; VBE mode number; notice that bits 0-13 contain the mode number and bit 14 (LFB) is set and bit 15 (DM) is clear.</span>
<span class="nf">int</span><span class="w"> </span><span class="mi">0x10</span><span class="w">			</span><span class="c1">; call VBE BIOS</span>
<span class="nf">cmp</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x004F</span><span class="w">	</span><span class="c1">; test for error</span>
<span class="nf">jne</span><span class="w"> </span><span class="no">error</span><span class="w"></span>

<span class="nl">after:</span><span class="w"></span>
<span class="w">	</span><span class="c1">; ...</span>
</pre></div>
<p>Anyway, like I mentioned at least a hundred times, you should first get the mode number from the video modes array. Those mode numbers only have the plain mode numbers (0x0118, 0x0103, etc...) and you should set bit 14 when you set the VBE mode.
</p><p><b> FUNCTION: Get current VBE mode </b>
</p><p>Function code: 0x4F03
</p><p>Description: This function returns the current VBE mode.
</p><p><b>Input:</b> AX = 0x4F03
</p><p><b>Output:</b> AX = 0x004F on success, other values indicate errors; maybe the system is not in a VBE mode?
</p><p><b>Output:</b> BX = Bits 0-13 mode number; bit 14 is the LFB bit: when set, the system is using the linear framebuffer, when clear, the system is using bank switching. Bit 15 is the DM bit: when clear, video memory was cleared when the VBE mode was set.
</p><p><b> FUNCTION: Display Window Control (deprecated) </b>
</p><p>Function code: 0x4F05
</p><p>Description: Sets/Gets the current bank (deprecated)
</p><p><b>Input:</b> AX = 0x4F05
</p><p><b>Input:</b> BH = 0x00 to set bank, 0x01 to get bank
</p><p><b>Input:</b> BL = 0x00 for window A, 0x01 for window B
</p><p><b>Input:</b> DX = Bank number in window granularity units
</p><p><b>Output:</b> AX = 0x004F on success, other values indicate errors; such as BIOS errors, unusable bank, unpresent bank, not using banked mode...
</p><p>Because bank switching is deprecated, I will not go into how to calculate bank numbers.
</p><p><b> FUNCTION: Return protected mode interface </b>
</p><p>Function code: 0x4F0A
</p><p>Description: Returns the VBE 2.0 protected mode interface
</p><p><b>Input:</b> AX = 0x4F0A
</p><p><b>Input:</b> BL = 0x00
</p><p><b>Output:</b> AX = 0x004F on success, other values indicate errors; such as BIOS errors, protected mode interface not supported, or VBE version is less than 2.0
</p><p><b>Output:</b> ES:DI = Segment:Offset pointer to protected mode table
</p><p><b>Output:</b> CX = Length of table including code in bytes for copying purposes
</p><p>This function allows software to switch banks (function 0x4F05), set display start (function 0x4F07) and set primary pallette data  (function 0x4F09) from protected mode, without needing to return to real mode. This increases performance somewhat, but is overall deprecated and may not be supported in some BIOSes.
Anyway, the table returned by ES:DI looks like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">vbe2_pmi_table</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">set_window</span><span class="p">;</span><span class="w">		</span><span class="c1">// offset in table for protected mode code for function 0x4F05</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">set_display_start</span><span class="p">;</span><span class="w">	</span><span class="c1">// offset in table for protected mode code for function 0x4F07</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">set_pallette</span><span class="p">;</span><span class="w">		</span><span class="c1">// offset in table for protected mode code for function 0x4F09</span>
<span class="p">}</span><span class="w"> </span><span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">packed</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>That means, to set the bank from protected mode, one should first find the linear address of the set_window function, by doing ES * 0x10 + DI + [ES:DI] and then doing a near CALL, because all protected mode functions end with a near RET. Useless, I know, but perhaps some people want to use bank switching as a fallback when VBE 2.0 is not available, or when the specific mode doesn't support a linear frame buffer.
</p><p>By now, your understanding of VESA should be quite clear and your implementation of VESA shouldn't be that difficult. Note, that if you use v8086 to call VESA BIOS, many video cards have memory-mapped register in high memory (3-4 GB) and the BIOS will have to switch to protected mode transparently to you during VBE execution, which goes beyond limits of v8086. For this problem, it is recommended to configure VESA in plain 16-bit real mode, before 32-bit/64-bit mode.
</p><p><b>Need code?</b>
Here's a function to set a VESA mode directly from a specified width/height/bpp, copied and pasted from my OS code. Notice that it runs in 16-bit real mode with DS = ES = FS = GS = 0.
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">; vbe_set_mode:</span>
<span class="c1">; Sets a VESA mode</span>
<span class="c1">; In\	AX = Width</span>
<span class="c1">; In\	BX = Height</span>
<span class="c1">; In\	CL = Bits per pixel</span>
<span class="c1">; Out\	FLAGS = Carry clear on success</span>
<span class="c1">; Out\	Width, height, bpp, physical buffer, all set in vbe_screen structure</span>

<span class="nl">vbe_set_mode:</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="p">[.</span><span class="no">width</span><span class="p">],</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="p">[.</span><span class="no">height</span><span class="p">],</span><span class="w"> </span><span class="no">bx</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="p">[.</span><span class="no">bpp</span><span class="p">],</span><span class="w"> </span><span class="no">cl</span><span class="w"></span>

<span class="w">	</span><span class="nf">sti</span><span class="w"></span>

<span class="w">	</span><span class="nf">push</span><span class="w"> </span><span class="no">es</span><span class="w">					</span><span class="c1">; some VESA BIOSes destroy ES, or so I read</span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x4F00</span><span class="w">				</span><span class="c1">; get VBE BIOS info</span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">di</span><span class="p">,</span><span class="w"> </span><span class="no">vbe_info_block</span><span class="w"></span>
<span class="w">	</span><span class="nf">int</span><span class="w"> </span><span class="mi">0x10</span><span class="w"></span>
<span class="w">	</span><span class="nf">pop</span><span class="w"> </span><span class="no">es</span><span class="w"></span>

<span class="w">	</span><span class="nf">cmp</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x4F</span><span class="w">				</span><span class="c1">; BIOS doesn&#39;t support VBE?</span>
<span class="w">	</span><span class="nf">jne</span><span class="w"> </span><span class="no">.error</span><span class="w"></span>

<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="no">word</span><span class="p">[</span><span class="no">vbe_info_block.video_modes</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="p">[.</span><span class="no">offset</span><span class="p">],</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="no">word</span><span class="p">[</span><span class="no">vbe_info_block.video_modes</span><span class="err">+</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="p">[.</span><span class="no">segment</span><span class="p">],</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>

<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">segment</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">fs</span><span class="p">,</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">si</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">offset</span><span class="p">]</span><span class="w"></span>

<span class="nl">.find_mode:</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">dx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">fs</span><span class="p">:</span><span class="no">si</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">add</span><span class="w"> </span><span class="no">si</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="p">[.</span><span class="no">offset</span><span class="p">],</span><span class="w"> </span><span class="no">si</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="p">[.</span><span class="no">mode</span><span class="p">],</span><span class="w"> </span><span class="no">dx</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">fs</span><span class="p">,</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>

<span class="w">	</span><span class="nf">cmp</span><span class="w"> </span><span class="p">[.</span><span class="no">mode</span><span class="p">],</span><span class="w"> </span><span class="mi">0xFFFF</span><span class="w">			</span><span class="c1">; end of list?</span>
<span class="w">	</span><span class="nf">je</span><span class="w"> </span><span class="no">.error</span><span class="w"></span>

<span class="w">	</span><span class="nf">push</span><span class="w"> </span><span class="no">es</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x4F01</span><span class="w">				</span><span class="c1">; get VBE mode info</span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">cx</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">mode</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">di</span><span class="p">,</span><span class="w"> </span><span class="no">mode_info_block</span><span class="w"></span>
<span class="w">	</span><span class="nf">int</span><span class="w"> </span><span class="mi">0x10</span><span class="w"></span>
<span class="w">	</span><span class="nf">pop</span><span class="w"> </span><span class="no">es</span><span class="w"></span>

<span class="w">	</span><span class="nf">cmp</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x4F</span><span class="w"></span>
<span class="w">	</span><span class="nf">jne</span><span class="w"> </span><span class="no">.error</span><span class="w"></span>

<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">width</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">cmp</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">mode_info_block.width</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">jne</span><span class="w"> </span><span class="no">.next_mode</span><span class="w"></span>

<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">height</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">cmp</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">mode_info_block.height</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">jne</span><span class="w"> </span><span class="no">.next_mode</span><span class="w"></span>

<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">al</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">bpp</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">cmp</span><span class="w"> </span><span class="no">al</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">mode_info_block.bpp</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">jne</span><span class="w"> </span><span class="no">.next_mode</span><span class="w"></span>

<span class="w">	</span><span class="c1">; If we make it here, we&#39;ve found the correct mode!</span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">width</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">word</span><span class="p">[</span><span class="no">vbe_screen.width</span><span class="p">],</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">height</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">word</span><span class="p">[</span><span class="no">vbe_screen.height</span><span class="p">],</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">mode_info_block.framebuffer</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">dword</span><span class="p">[</span><span class="no">vbe_screen.physical_buffer</span><span class="p">],</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">mode_info_block.pitch</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">word</span><span class="p">[</span><span class="no">vbe_screen.bytes_per_line</span><span class="p">],</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">al</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">bpp</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">byte</span><span class="p">[</span><span class="no">vbe_screen.bpp</span><span class="p">],</span><span class="w"> </span><span class="no">al</span><span class="w"></span>
<span class="w">	</span><span class="nf">shr</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">dword</span><span class="p">[</span><span class="no">vbe_screen.bytes_per_pixel</span><span class="p">],</span><span class="w"> </span><span class="no">eax</span><span class="w"></span>

<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">width</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">shr</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="w">	</span><span class="nf">dec</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">word</span><span class="p">[</span><span class="no">vbe_screen.x_cur_max</span><span class="p">],</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>

<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">height</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">shr</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="w">	</span><span class="nf">dec</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">word</span><span class="p">[</span><span class="no">vbe_screen.y_cur_max</span><span class="p">],</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>

<span class="w">	</span><span class="c1">; Set the mode</span>
<span class="w">	</span><span class="nf">push</span><span class="w"> </span><span class="no">es</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x4F02</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">bx</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">mode</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">or</span><span class="w"> </span><span class="no">bx</span><span class="p">,</span><span class="w"> </span><span class="mi">0x4000</span><span class="w">			</span><span class="c1">; enable LFB</span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">di</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w">			</span><span class="c1">; not sure if some BIOSes need this... anyway it doesn&#39;t hurt</span>
<span class="w">	</span><span class="nf">int</span><span class="w"> </span><span class="mi">0x10</span><span class="w"></span>
<span class="w">	</span><span class="nf">pop</span><span class="w"> </span><span class="no">es</span><span class="w"></span>

<span class="w">	</span><span class="nf">cmp</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x4F</span><span class="w"></span>
<span class="w">	</span><span class="nf">jne</span><span class="w"> </span><span class="no">.error</span><span class="w"></span>

<span class="w">	</span><span class="nf">clc</span><span class="w"></span>
<span class="w">	</span><span class="nf">ret</span><span class="w"></span>

<span class="nl">.next_mode:</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">ax</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">segment</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">fs</span><span class="p">,</span><span class="w"> </span><span class="no">ax</span><span class="w"></span>
<span class="w">	</span><span class="nf">mov</span><span class="w"> </span><span class="no">si</span><span class="p">,</span><span class="w"> </span><span class="p">[.</span><span class="no">offset</span><span class="p">]</span><span class="w"></span>
<span class="w">	</span><span class="nf">jmp</span><span class="w"> </span><span class="no">.find_mode</span><span class="w"></span>

<span class="nl">.error:</span><span class="w"></span>
<span class="w">	</span><span class="nf">stc</span><span class="w"></span>
<span class="w">	</span><span class="nf">ret</span><span class="w"></span>

<span class="na">.width</span><span class="w">				</span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="na">.height</span><span class="w">				</span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="na">.bpp</span><span class="w">				</span><span class="no">db</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="na">.segment</span><span class="w">			</span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="na">.offset</span><span class="w">				</span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="na">.mode</span><span class="w">				</span><span class="no">dw</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
<p><b>What's next?</b>
Well, that's entirely up to you! Just kidding, here's some tips on implementing a graphics library.
Calculating pixel offset:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">uint32</span><span class="w"> </span><span class="n">pixel_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pitch</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">bpp</span><span class="o">/</span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Where "pitch", "bpp" and "framebuffer" are gotten from the structure returned by function 0x4F01. Then, you can plot a pixel by writing a value there.
For 32-bit modes, each pixel value is 0x00RRGGBB in little endian, so to plot a red pixel, we would write 0x00FF0000. In 24-bit mode, each pixel is 0xRRGGBB in little endian. Due to the bad memory alignment, performance is relatively low with 24-bit modes. In 16-bit modes, we have a total of 64K colors, and the color has 5 bits of red, 6 bits of green, and 5 bits of blue. There is more green because according to Wikipedia, the human eye is more sensitive to green than red and blue...
In 15-bit modes, we have a total of 32K colors, 5 bits of red, 5 bits of green and 5 bits of blue. The highest bit (bit 15, value 0x8000) is unused.
Because my OS supports 32-bit/24-bit modes and 16-bit as a fallback, I will focus on these. Anyway if you want something less than 16-bit your limiting yourself to the obsolete technology...
Just by getting the pixel's offset and writing there, you've implemented a put_pixel() routine!
Now, we want some more things: lines, squares, alpha blending, and some hot graphics! It may seem easy to implement a fill_rect() routine: just put_pixel() everything. That's going to work, but it's not going to work fast. For a 32*32 rectangle, you'll be calculating the pixel offset 1024 times! Instead, a better approach is to calculate the pixel offset one time, and then (REP STOSD/REP STOSW) for one line. Then you can do (offset = offset + pitch) just to skip one line down. This way, you can fill a 512x512 rectangle yet calculate the pixel offset only one time. By calling put_pixel() for every pixel, you'd be calculating the pixel offset 262144 times! Using the method I just said, you can make performance 262144 times better.
For drawing lines, you'll probably implement an existing algorithm. Wikipedia has a good article on drawing lines.
As for alpha blending, Wikipedia also has good information on that.
Now that you have a linear framebuffer, a basic put_pixel() routine and a fill_rect() routine, you can implement a basic graphics library. Programming graphics now is just the same as non-OS graphics programming. Enjoy!
</p><p><b>Keep reading!</b>  
</p><p><a rel="nofollow" class="external text" href="http://www.phatcode.net/res/221/files/vbe20.pdf">VBE 2.0 Specification</a>  
</p><p><a rel="nofollow" class="external text" href="../Drawing_In_Protected_Mode#Drawing_Text">Drawing Text</a>  
</p><p><a rel="nofollow" class="external text" href="../Double_Buffering">Double Buffering - a way of increasing graphics performance</a>  
</p><p><a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Alpha_compositing">Alpha blending</a>
</p>
<!-- 
NewPP limit report
Cached time: 20250211155643
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.049 seconds
Real time usage: 0.838 seconds
Preprocessor visited node count: 28/1000000
Postexpand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 34124/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:3938-0!canonical and timestamp 20250211155642 and revision id 27508.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=User:Omarrx024/VESA_Tutorial&amp;oldid=27508">https://wiki.osdev.org/index.php?title=User:Omarrx024/VESA_Tutorial&amp;oldid=27508</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="../Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=User%3AOmarrx024%2FVESA+Tutorial" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="VESA_Tutorial#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-user" class="selected mw-list-item"><a href="VESA_Tutorial" title="View the user page [c]" accesskey="c"><span>User page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User_talk:Omarrx024/VESA_Tutorial&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="VESA_Tutorial"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Omarrx024/VESA_Tutorial&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Omarrx024/VESA_Tutorial&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="../index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="../index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="../Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="../Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="../OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="../OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="../OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="../Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="../Special:WhatLinksHere/User:Omarrx024/VESA_Tutorial" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/User:Omarrx024/VESA_Tutorial" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-contributions" class="mw-list-item"><a href="../Special:Contributions/Omarrx024" title="A list of contributions by this user"><span>User contributions</span></a></li><li id="t-log" class="mw-list-item"><a href="../Special:Log/Omarrx024"><span>Logs</span></a></li><li id="t-userrights" class="mw-list-item"><a href="../Special:UserRights/Omarrx024"><span>View user groups</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="../Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Omarrx024/VESA_Tutorial&amp;oldid=27508" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Omarrx024/VESA_Tutorial&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 2 December 2022, at 14:40.</li>
	<li id="footer-info-0">This page has been accessed 3,557 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="../OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="../OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="../OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=User:Omarrx024/VESA_Tutorial&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="../resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="../resources/assets/poweredby_mediawiki_132x47.png 1.5x, ../resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.049","walltime":"0.838","ppvisitednodes":{"value":28,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":34124,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20250211155643","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":943});});</script>
</body>
</html>