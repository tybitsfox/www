<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>User:Intx13 - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"237a43c946455c7c273baf3b","wgCSPNonce":false,"wgCanonicalNamespace":"User","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":2,"wgPageName":"User:Intx13","wgTitle":"Intx13","wgCurRevisionId":18482,"wgRevisionId":18482,"wgArticleId":3328,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"User:Intx13","wgRelevantArticleId":3328,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRelevantUserName":"Intx13",
"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head","mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-2 ns-subject page-User_Intx13 rootpage-User_Intx13 skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-namespace">User</span><span class="mw-page-title-separator">:</span><span class="mw-page-title-main">Intx13</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="./User:Intx13#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="./User:Intx13#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="./User:Intx13#Intx13&#39;s_PCI_tutorial"><span class="tocnumber">1</span> <span class="toctext">Intx13's PCI tutorial</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="./User:Intx13#Basics"><span class="tocnumber">1.1</span> <span class="toctext">Basics</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="./User:Intx13#Definitions"><span class="tocnumber">1.1.1</span> <span class="toctext">Definitions</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="./User:Intx13#Geographical_addressing"><span class="tocnumber">1.1.2</span> <span class="toctext">Geographical addressing</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="./User:Intx13#Bridges"><span class="tocnumber">1.1.3</span> <span class="toctext">Bridges</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="./User:Intx13#The_host_controller_as_a_PCI_device"><span class="tocnumber">1.1.4</span> <span class="toctext">The host controller as a PCI device</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="./User:Intx13#Thank_goodness_for_BIOS"><span class="tocnumber">1.1.5</span> <span class="toctext">Thank goodness for BIOS</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="./User:Intx13#Learn_to_love_lspci"><span class="tocnumber">1.1.6</span> <span class="toctext">Learn to love <i>lspci</i></span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-9"><a href="./User:Intx13#Configuration_Space"><span class="tocnumber">1.2</span> <span class="toctext">Configuration Space</span></a>
<ul>
<li class="toclevel-3 tocsection-10"><a href="./User:Intx13#Configuration_Access_Mechanism"><span class="tocnumber">1.2.1</span> <span class="toctext">Configuration Access Mechanism</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="./User:Intx13#A_normal_device&#39;s_configuration_space"><span class="tocnumber">1.2.2</span> <span class="toctext">A normal device's configuration space</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="./User:Intx13#A_bridge&#39;s_configuration_space"><span class="tocnumber">1.2.3</span> <span class="toctext">A bridge's configuration space</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="./User:Intx13#A_host_controller&#39;s_configuration_space"><span class="tocnumber">1.2.4</span> <span class="toctext">A host controller's configuration space</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-14"><a href="./User:Intx13#Base_Address_Registers"><span class="tocnumber">1.3</span> <span class="toctext">Base Address Registers</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="./User:Intx13#Port-mapped_IO_with_PCI_devices"><span class="tocnumber">1.3.1</span> <span class="toctext">Port-mapped IO with PCI devices</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="./User:Intx13#Memory-mapped_IO_with_PCI_devices"><span class="tocnumber">1.3.2</span> <span class="toctext">Memory-mapped IO with PCI devices</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-17"><a href="./User:Intx13#Interrupts"><span class="tocnumber">1.4</span> <span class="toctext">Interrupts</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-18"><a href="./User:Intx13#Recursive_descent_AML_parser"><span class="tocnumber">2</span> <span class="toctext">Recursive descent AML parser</span></a>
<ul>
<li class="toclevel-2 tocsection-19"><a href="./User:Intx13#Recursive_descent_parsing"><span class="tocnumber">2.1</span> <span class="toctext">Recursive descent parsing</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="./User:Intx13#Fixed,_implicit_and_explicit-length_objects"><span class="tocnumber">2.2</span> <span class="toctext">Fixed, implicit and explicit-length objects</span></a>
<ul>
<li class="toclevel-3 tocsection-21"><a href="./User:Intx13#Fixed-length_objects"><span class="tocnumber">2.2.1</span> <span class="toctext">Fixed-length objects</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="./User:Intx13#Implicit-length_objects"><span class="tocnumber">2.2.2</span> <span class="toctext">Implicit-length objects</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="./User:Intx13#Explicit-length_objects"><span class="tocnumber">2.2.3</span> <span class="toctext">Explicit-length objects</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-24"><a href="./User:Intx13#Object_references"><span class="tocnumber">2.3</span> <span class="toctext">Object references</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="./User:Intx13#ACPI_namespace_and_scoping"><span class="tocnumber">2.4</span> <span class="toctext">ACPI namespace and scoping</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="./User:Intx13#AML_errata"><span class="tocnumber">2.5</span> <span class="toctext">AML errata</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span id="Intx13.27s_PCI_tutorial"></span><span class="mw-headline" id="Intx13's_PCI_tutorial">Intx13's PCI tutorial</span></h1>
<p><b>Peripheral Component Interconnect</b> (PCI) provides protocol, signaling, and physical standards that allow third-party components to be connected to a host system. In the x86 architecture, PCI-connected devices are software-accessible via a combination of port-mapped IO, memory-mapped IO, and interrupts.
</p><p><br />
</p>
<h2><span class="mw-headline" id="Basics">Basics</span></h2>
<h3><span class="mw-headline" id="Definitions">Definitions</span></h3>
<p>A <b>bus</b> is a collection of PCI signaling lines. Some of these lines are shared among all components on the bus, such as the address and data lines that carry traffic. Others come in sets with one line available for each possible component on the bus, such as request/grant lines that determine which component gets to use the shared lines and when.
</p><p>A <b>slot</b> is a connection point at which a single component can be attached to a bus. A slot can be a slotted connector into which an <i>expansion card</i> plugs, such as a sound card. A slot can also be location on a motherboard where PCI signals terminate into a <i>planar device</i>, such as an "on-board" network card.
</p><p>A <b>function</b> is an independent hardware capability presented as a unique device to the host system. A planar device or expansion card can provide multiple functions simultaneously, which are treated as separate devices by the host system. For example, some manufacturers sell expansion cards that combine a sound card and a modem. The sound card would appear as one function and the modem as another. While they are attached to the same slot on the same bus, they are typically considered two distinct devices because they are accessed independently by software.
</p><p>Processors do not have a native PCI interface; there is no "read-from-PCI-card" instruction in a processor's instruction set. Instead, a PCI <b>host controller</b> is integrated into the CPU at a level where it can interface with native IO mechanisms. Software communicates with the host controller using these mechanisms and the host controller takes the appropriate action on the PCI bus on behalf of the software. In the x86 architecture, the host controller is integrated into the Southbridge chip. Software uses a combination of port-mapped IO (the <b>in</b> and <b>out</b> instructions) and memory-mapped IO (indirect <b>mov</b> instructions) to access the host controller.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:302px;"><a href="./File:PCI-host-controller-in-x86-architecture.png" class="image"><img alt="caption" src="images/thumb/4/4a/PCI-host-controller-in-x86-architecture.png/300px-PCI-host-controller-in-x86-architecture.png" decoding="async" width="300" height="477" class="thumbimage" srcset="images/thumb/4/4a/PCI-host-controller-in-x86-architecture.png/450px-PCI-host-controller-in-x86-architecture.png 1.5x, images/4/4a/PCI-host-controller-in-x86-architecture.png 2x" data-file-width="562" data-file-height="894" /></a>  <div class="thumbcaption"><div class="magnify"><a href="./File:PCI-host-controller-in-x86-architecture.png" class="internal" title="Enlarge"></a></div>The PCI bus is quite a ways downstream from the CPU, but appears to be directly accessible to software via PMIO and MMIO.</div></div></div></div>
<h3><span class="mw-headline" id="Geographical_addressing">Geographical addressing</span></h3>
<p>A device's <b>geographical address</b> is the bus/slot/function triple that identifies a device with which software wishes to communicate. Buses are numbered <b>0-255</b>. Slots are numbered <b>0-31</b>. Functions are numbered <b>0-7</b>. This means there can be a maximum of 256*32 = 8192 planar devices/expansion cards attached to a single system. If each card utilizes all 8 functions, the system could have up to 8192*8 = 65536 distinct PCI devices. That's a lot!
</p><p>When a vendor develops a new expansion card, they decide if and how to use function numbers. Function 0 must be used, but functions 1 through 7 are optional. Optional function numbers need not be used in order. For example, a card could implement functions 0, 3, and 7. The slot number assigned to a specific slot on a bus cannot be changed. If an expansion card is moved from one slot to another, its geographical address will change. The bus number assigned to a specific bus is fixed by the host controller and cannot be changed. x86 systems include a single host controller which has at least one bus. One of its buses will always be numbered 0, but the other numbers could be arbitrary.
</p>
<h3><span class="mw-headline" id="Bridges">Bridges</span></h3>
<p>A <b>bridge</b> is a planar device/expansion card that exposes additional PCI buses to the host. For example, a host controller might only implement one bus with a few slots. A bridge (representing a single bus with its own set of slots) could be plugged into one of those slots, allowing for additional cards to be connected. It's not uncommon to find on-board bridges on modern desktop motherboards.
</p><p>The host controller does not need to be configured by system software in order to know how to communicate across with the devices attached to its slots, because host controllers are integrated into the Southbridge and their bus/slot numbers are fixed at the time of manufacture. However, bridges must be configured at runtime with a bus number that doesn't conflict with any pre-existing bus. Bridges must also be "daisy-chained" to one another, with the host controller itself being daisy-chained to the first bridge. When software tells the host controller to communicate with a device on a bus that the host controller itself does not provide, it must know to which bridge device the traffic must be sent. The traffic "hops" along the chain until the bridge responsible for the bus number accepts it.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:302px;"><a href="./File:Correct-flow-of-PCI-traffic.png" class="image"><img alt="caption" src="images/thumb/1/13/Correct-flow-of-PCI-traffic.png/300px-Correct-flow-of-PCI-traffic.png" decoding="async" width="300" height="244" class="thumbimage" srcset="images/thumb/1/13/Correct-flow-of-PCI-traffic.png/450px-Correct-flow-of-PCI-traffic.png 1.5x, images/thumb/1/13/Correct-flow-of-PCI-traffic.png/600px-Correct-flow-of-PCI-traffic.png 2x" data-file-width="712" data-file-height="579" /></a>  <div class="thumbcaption"><div class="magnify"><a href="./File:Correct-flow-of-PCI-traffic.png" class="internal" title="Enlarge"></a></div>Bridges daisy-chained from the host controller.</div></div></div></div>
<p>(Although it's of little relevance to the operating system developer, the "hopping" of traffic from one device to another doesn't actually require repeated transmission of data, due to the shared data lines that PCI uses.)
</p>
<h3><span class="mw-headline" id="The_host_controller_as_a_PCI_device">The host controller as a PCI device</span></h3>
<p>As described previously, the host controller is a distinct hardware component that resides within the Southbridge to provide PCI bus access to software. However, the host controller also sits on the PCI bus like a device! This can be thought of as a "management interface", so that the host controller itself can be configured over PCI. Some host controllers might provide multiple buses. In this case, the host controller acts as <i>multiple</i> devices on the PCI bus: one for each bus.
</p><p>A host controller always appears on slot 0 of bus 0. The function numbers of the host controller represent the bus numbers that the host controller supports. Note that this means a host controller can only provide 8 buses, numbered 0-7. The system can have up to 256 buses, so the other 248 can only be provided by bridges. Software can communicate with the host controller at geographical addresses 0/0/* to configure the individual buses the host controller supports.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:302px;"><a href="./File:Multi-bus-PCI-host-controller-with-multiple-bridges.png" class="image"><img alt="caption" src="images/thumb/5/59/Multi-bus-PCI-host-controller-with-multiple-bridges.png/300px-Multi-bus-PCI-host-controller-with-multiple-bridges.png" decoding="async" width="300" height="195" class="thumbimage" srcset="images/thumb/5/59/Multi-bus-PCI-host-controller-with-multiple-bridges.png/450px-Multi-bus-PCI-host-controller-with-multiple-bridges.png 1.5x, images/thumb/5/59/Multi-bus-PCI-host-controller-with-multiple-bridges.png/600px-Multi-bus-PCI-host-controller-with-multiple-bridges.png 2x" data-file-width="918" data-file-height="598" /></a>  <div class="thumbcaption"><div class="magnify"><a href="./File:Multi-bus-PCI-host-controller-with-multiple-bridges.png" class="internal" title="Enlarge"></a></div>Things get complicated when the PCI host controller supports multiple buses which might have multiple bridges.</div></div></div></div>
<p><br />
</p>
<h3><span class="mw-headline" id="Thank_goodness_for_BIOS">Thank goodness for BIOS</span></h3>
<p>Early configuration of the PCI bus includes assigning bus numbers to all bridges and daisy-chaining them together. It also includes BAR mapping, which we will get into later. Luckily, BIOS will do all of this at start-up. Operating systems may choose to reconfigure the PCI bus by reassigning bus numbers, re-daisy-chaining bridges, and remapping BARs, but if BIOS can be trusted this isn't necessary. Linux does not bother to reconfigure PCI bridges or remap BARs. TODO: What about BSD? Windows? Should be easy to check; compare their "lspci" equivalents to what Linux reports on the same system.
</p><p>The remainder of this document will therefore not cover the configuration of bridges or host controllers or BAR remapping.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Learn_to_love_lspci">Learn to love <i>lspci</i></span></h3>
<p>The <b>lspci</b> Linux program retrieves information from the kernel about the PCI buses in the system. If executed as <b>lspci -n</b>, the program will display geographical addresses, class codes, and vendor/product/revision IDs for all configured PCI devices. Because Linux sticks with whatever bridge configuration and BAR mapping BIOS arranged, <b>lspci</b> tells you what your code <i>should</i> see. The output of <b>lspci -n</b> is formatted as below.
</p>
<pre> xx:yy.z ccss: vvvv:pppp (rev rr)
 
 xx    Bus number
 yy    Slot number
 z     Function number
 
 cc    Class code
 ss    Sub-class code
 
 vvvv  Vendor ID
 pppp  Product ID
 rr    Revision ID
</pre>
<p>If you haven't read the rest of this document, class codes and vendor/product/revision IDs aren't something you're interested in just yet. However, you can learn some interesting information about the layout of the PCI buses just by looking at the geographical addresses.
</p>
<pre> $ lspci -n
 00:00.0 0600 8086:7190 (rev 01)
 00:01.0 0604 8086:7191 (rev 01)
 ...
 02:00.0 0200 8086:100f (rev 01)
</pre>
<p>In the above example, we see right away that the system's host controller only provides one bus. We know this because the host controller will appear as a PCI device on bus 0 slot 0 with a function for every bus it supports, but this system only has a single device on bus 0 slot 0 (namely, geographical address 00:00.0). At the same time we see a device (02:00.0) whose geographical address indicates it is attached to bus 2. This means there must be a bridge in the system. As it happens, the second device listed (geographical address 00:01.0) is that bridge. Using only the geographical addresses we can put together a map of the host controller, the buses it provides, and any other buses that are provided by bridges, along with the number of slots and functions that are used on each bus. Until we learn a little more, however, we won't know which devices are those bridges and which devices are other useful things, like network cards.
</p>
<h2><span class="mw-headline" id="Configuration_Space">Configuration Space</span></h2>
<p>Every PCI device has a set of internal registers called its <b>configuration space</b>. The host controller provides port-mapped IO that allows software to read and write registers within each device's configuration space. This port-mapped IO is called the <b>Configuration Access Mechanism</b>, or <b>CAM</b>. The contents of a device's configuration space includes many useful fields that describe the purpose of the device. The configuration space also includes <b>BARs</b>, which tells us how to interact with the device beyond CAM. To put it shortly, CAM retrieves "header" information that can be parsed without knowing the details of the device, while BARs would be used by drivers to interact with the guts of the device.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Configuration_Access_Mechanism">Configuration Access Mechanism</span></h3>
<p>The host controller implements CAM through PIO ports <b>0x0CF8</b> and <b>0x0CFC</b>. Writing a 32-bit value to port 0x0CF8 informs the host controller which device (by geographical address) and which register number within that device we are interested in reading or writing. Reading from port 0x0CFC will cause the host controller to read that register in that device's configuration space and return it to software. Writing to port 0x0CFC will cause the host controller to write to that register in that device's configuration space.
</p><p>(figure here, illustrating this standard method of accessing "shadowed" registers)
</p><p>The 32-bit value written to port 0x0CF8 breaks down as follows.
</p><p>(figure here)
</p><p>The following pseudocode selects a register within a device by geographical address.
</p>
<pre> <b>cam_select</b>: <b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b>
 
 <b>val32</b> = 
      0x80000000
    | <b>bus</b> &lt;&lt; 16
    | <b>slot</b> &lt;&lt; 11
    | <b>function</b> &lt;&lt; 8
    | <b>register</b> &lt;&lt; 2
 
 out(0x0CF8, <b>val32</b>)
</pre>
<p><br />
The following pseudocode reads 32-bit, 16-bit, and 8-bit registers from within a device.
</p>
<pre> <b>cam_read_32</b>: <b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b> -&gt; <b>val</b>
 
 cam_select(<b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b>)
 <b>val</b> = in(0x0CFC)
</pre>
<pre> <b>cam_read_16_0</b>: <b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b> -&gt; <b>val</b>
 
 <b>val32</b> = cam_read_32(<b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b>)
 <b>val</b> = <b>val32</b>(15:0)
</pre>
<pre> <b>cam_read_16_1</b>: <b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b> -&gt; <b>val</b>
 
 <b>val32</b> = cam_read_32(<b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b>)
 <b>val</b> = <b>val32</b>(31:16)
</pre>
<pre> <b>cam_read_8_0</b>: <b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b> -&gt; <b>val</b>
 
 <b>val32</b> = cam_read_32(<b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b>)
 <b>val</b> = <b>val32</b>(7:0)
</pre>
<pre> <b>cam_read_8_1</b>: <b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b> -&gt; <b>val</b>
 
 <b>val32</b> = cam_read_32(<b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b>)
 <b>val</b> = <b>val32</b>(15:8)
</pre>
<pre> <b>cam_read_8_2</b>: <b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b> -&gt; <b>val</b>
 
 <b>val32</b> = cam_read_32(<b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b>)
 <b>val</b> = <b>val32</b>(23:16)
</pre>
<pre> <b>cam_read_8_3</b>: <b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b> -&gt; <b>val</b>
 
 <b>val32</b> = cam_read_32(<b>bus</b>, <b>slot</b>, <b>function</b>, <b>register</b>)
 <b>val</b> = <b>val32</b>(31:24)
</pre>
<p><br />
</p>
<h3><span id="A_normal_device.27s_configuration_space"></span><span class="mw-headline" id="A_normal_device's_configuration_space">A normal device's configuration space</span></h3>
<p>TODO
</p><p><br />
</p>
<h3><span id="A_bridge.27s_configuration_space"></span><span class="mw-headline" id="A_bridge's_configuration_space">A bridge's configuration space</span></h3>
<p>TODO
</p><p><br />
</p>
<h3><span id="A_host_controller.27s_configuration_space"></span><span class="mw-headline" id="A_host_controller's_configuration_space">A host controller's configuration space</span></h3>
<p>TODO
</p><p><br />
</p>
<h2><span class="mw-headline" id="Base_Address_Registers">Base Address Registers</span></h2>
<p>TODO
</p>
<h3><span class="mw-headline" id="Port-mapped_IO_with_PCI_devices">Port-mapped IO with PCI devices</span></h3>
<p>TODO
</p>
<h3><span class="mw-headline" id="Memory-mapped_IO_with_PCI_devices">Memory-mapped IO with PCI devices</span></h3>
<p>TODO
</p><p><br />
</p>
<h2><span class="mw-headline" id="Interrupts">Interrupts</span></h2>
<p>TODO
</p><p><br />
</p>
<h1><span class="mw-headline" id="Recursive_descent_AML_parser">Recursive descent AML parser</span></h1>
<p>The latest ACPI specification defines TODO AML objects. Most of them are just wrappers/containers for other objects. For example, a TermObj is either a NameSpaceModifierObj, a NamedObj, a Type1Opcode, or a Type2Opcode. And a NameSpaceModifierObj is either a DefAlias, a DefName, or a DefScope. And so on.
</p><p>The goal of an AML parser is to transform a blob of AML bytecode in memory into a parse tree, which can subsequently be walked to look for various types of objects. Pages 814 through 825 of the ACPI specification provide the formal grammar for every AML object. For example, a null-terminated ASCII string is defined as follows.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="nl">String</span><span class="w">        </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">StringPrefix</span><span class="w"> </span><span class="n">AsciiCharList</span><span class="w"> </span><span class="n">NullChar</span><span class="w"></span>
<span class="nl">StringPrefix</span><span class="w">  </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mh">0x0D</span><span class="w"></span>
<span class="nl">AsciiCharList</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">Nothing</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;</span><span class="n">AsciiChar</span><span class="w"> </span><span class="n">AsciiCharList</span><span class="o">&gt;</span><span class="w"></span>
<span class="nl">AsciiChar</span><span class="w">     </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x7F</span><span class="w"></span>
<span class="nl">NullChar</span><span class="w">      </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="w"></span>
</pre></div>
<p>You can read this out loud as below:
</p>
<blockquote><p>A String consists of three objects: a StringPrefix followed by an AsciiCharList followed by a NullChar. A StringPrefix is a single byte with value 0x0D. An AsciiCharList is either Nothing or an AsciiChar followed by another AsciiCharList. An AsciiChar is a single byte with value between 0x01 and 0x7F, inclusive. A NullChar is a single byte with value 0x00.</p></blockquote>
<p>If you wanted to represent the string "cat" in AML, you would build a parse tree like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">String</span><span class="w"></span>
<span class="w">  </span><span class="n">StringPrefix</span><span class="w"> </span><span class="p">(</span><span class="mh">0x0D</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">AsciiCharList</span><span class="w"></span>
<span class="w">    </span><span class="n">AsciiChar</span><span class="w"> </span><span class="p">(</span><span class="mh">0x63</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">AsciiCharList</span><span class="w"></span>
<span class="w">      </span><span class="n">AsciiChar</span><span class="w"> </span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">AsciiCharList</span><span class="w"></span>
<span class="w">        </span><span class="n">AsciiChar</span><span class="w"> </span><span class="p">(</span><span class="mh">0x74</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">AsciiCharList</span><span class="w"></span>
<span class="w">          </span><span class="n">Nothing</span><span class="w"></span>
<span class="w">  </span><span class="n">NullChar</span><span class="w"> </span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>The resulting bytecode would look like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="mi">0</span><span class="n">D</span><span class="w"> </span><span class="mi">63</span><span class="w"> </span><span class="mi">61</span><span class="w"> </span><span class="mi">74</span><span class="w"> </span><span class="mo">00</span><span class="w"></span>
</pre></div>
<p>The job of a parser (for the String object anyway) is to take that bytecode and produce the corresponding parse tree.
</p>
<h2><span class="mw-headline" id="Recursive_descent_parsing">Recursive descent parsing</span></h2>
<p>Many AML objects (like String) are defined in terms of other objects. Others (like AsciiChar and NullChar) are defined in terms of bytes consumed from a blob of AML. This suggests that a "recursive descent" parser might be a good choice for parsing AML. When writing a recursive descent parser you write a parsing function for every object. Many of those parsers (like the parser for String) just call other parsers and collect their results, while some parsers (like AsciiChar and NullChar) actually read bytes from a blob of AML.
</p><p>Below is a pseudocode example of a recursive descent parser for String and related objects. In this example and throughout this document, <i>blob</i> is some global object from which bytes of AML can be read. We'll start by writing the simple parsers: the ones that aren't defined in terms of any other objects.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">function</span><span class="w"> </span><span class="n">ParseStringPrefix</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">blob</span><span class="p">.</span><span class="n">NextByte</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x0D</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">blob</span><span class="p">.</span><span class="n">ConsumeByte</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">StringPrefix</span><span class="w"></span>
<span class="w">  </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>

<span class="n">function</span><span class="w"> </span><span class="n">ParseAsciiChar</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w">     </span><span class="n">blob</span><span class="p">.</span><span class="n">NextByte</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mh">0x01</span><span class="w"></span>
<span class="w">     </span><span class="n">and</span><span class="w"> </span><span class="n">blob</span><span class="p">.</span><span class="n">NextByte</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">0x7F</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">byte</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blob</span><span class="p">.</span><span class="n">ConsumeByte</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">AsciiChar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>

<span class="n">function</span><span class="w"> </span><span class="n">ParseNullChar</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">blob</span><span class="p">.</span><span class="n">NextByte</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x00</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">blob</span><span class="p">.</span><span class="n">ConsumeByte</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">NullChar</span><span class="w"></span>
<span class="w">  </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>

<span class="n">function</span><span class="w"> </span><span class="n">ParseNothing</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Nothing</span><span class="w"></span>
</pre></div>
<p><br />
Note how ParseStringPrefix and ParseNullChar just check whether the next byte in the blob is the value they're expecting, and if so, consume it and return the appropriate object. ParseAsciiChar does the same, but it also attaches the consumed byte to the object being returned, so that the parse tree will contain the characters from the string. The parser for Nothing is simple: it always returns a Nothing object, without consuming any bytes of AML. Now let's write a parser for AsciiCharList, which is a little trickier, because it's defined recursively in terms of itself.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">function</span><span class="w"> </span><span class="n">ParseAsciiCharList</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseAsciiChar</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseAsciiCharList</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">AsciiCharList</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>
<span class="w">  </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ParseNothing</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>ParseAsciiCharList first calls ParseAsciiChar. If that parser succeeded (meaning that the next byte in the blob was an ASCII character and it's been returned inside of an AsciiChar object) then ParseAsciiCharList calls itself recursively. It then returns an AsciiCharList object consisting of the AsciiChar object and whatever the recursive call returns. If the ParseAsciiChar parser failed (meaning that the next byte in the blob was <i>not</i> an ASCII character) then ParseAsciiCharList calls the ParseNothing parser and returns whatever it returns. This is a tail-recursive function.
</p><p>Finally, let's write the parser for the String object.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">function</span><span class="w"> </span><span class="n">ParseString</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseStringPrefix</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseAsciiCharList</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseNullChar</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="n">c</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">String</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>
<span class="w">    </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>
<span class="w">  </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>
</pre></div>
<p>ParseString doesn't touch the contents of the AML blob at all. It just calls three other parsers and if they all succeed, it returns a String object containing them.
</p><p>We could continue along this path, writing recursive descent parsers for every AML object. The syntax of the formal grammar by which AML objects are defined makes this very straightforward, although somewhat tedious. Unfortunately, there are two big problems with writing a recursive descent AML parser.
</p>
<h2><span id="Fixed.2C_implicit_and_explicit-length_objects"></span><span class="mw-headline" id="Fixed,_implicit_and_explicit-length_objects">Fixed, implicit and explicit-length objects</span></h2>
<p>AML objects can be sorted into three types: fixed-length, implicit-length, and explicit-length.
</p>
<h3><span class="mw-headline" id="Fixed-length_objects">Fixed-length objects</span></h3>
<p>A fixed-length object is an object that always consumes the same number of bytes of AML (if it exists in the AML, of course.) AsciiChar and NullChar are examples of fixed-length objects; if present, they each consume a single byte. Fixed-length objects are the easiest to parse, because you simply consume the required number of bytes and make sure they are correct for the type of object being parsed.
</p>
<h3><span class="mw-headline" id="Implicit-length_objects">Implicit-length objects</span></h3>
<p>Implicit-length objects can take up different numbers of bytes of AML. AsciiCharList and String are examples of implicit-length objects. When parsing a String, you don't know how many bytes of AML you are ultimately going to consume. When parsing an AsciiCharList you don't know how deep the call to ParseAsciiCharList is going to recurse. For some AML objects, like String and AsciiCharList, you don't <i>care</i> how many bytes you'll ultimately consume. You simply call the parsing function and it happily recurses until eventually the recursion terminates (for example, when ParseAsciiChar fails to find any more ASCII characters and so ParseAsciiCharList calls ParseNothing instead). These "don't-care" implicit-length objects are easy to parse using recursion.
</p><p>For some implicit-length objects, however, you <i>have</i> to know when to stop parsing, because there's no "end point" or "terminating byte" that causes recursion to stop. The AML objects that behave like this are too complex to look at right now, so instead we'll make up an object that contains a list of zeroes. Here is the grammar for this made-up object.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="nl">ZeroList</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">Nothing</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Zero</span><span class="w"> </span><span class="n">ZeroList</span><span class="o">&gt;</span><span class="w"></span>
<span class="nl">Zero</span><span class="w">     </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="w"></span>
</pre></div>
<p>Now suppose the AML bytecode that you wanted to parse consisted of two bytes:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="mo">00</span><span class="w"> </span><span class="mo">00</span><span class="w"></span>
</pre></div>
<p>Now ask yourself, is this a single ZeroList containing two Zero objects? Or is <i>two</i> ZeroLists, each containing <i>one</i> Zero object? Does the parse tree look like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">ZeroList</span><span class="w"></span>
<span class="w">  </span><span class="n">Zero</span><span class="w"></span>
<span class="w">  </span><span class="n">ZeroList</span><span class="w"></span>
<span class="w">    </span><span class="n">Zero</span><span class="w"></span>
<span class="w">    </span><span class="n">ZeroList</span><span class="w"></span>
<span class="w">      </span><span class="n">Nothing</span><span class="w"></span>
</pre></div>
<p>Or this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">ZeroList</span><span class="w"></span>
<span class="w">  </span><span class="n">Zero</span><span class="w"></span>
<span class="w">  </span><span class="n">ZeroList</span><span class="w"></span>
<span class="w">    </span><span class="n">Nothing</span><span class="w"></span>
<span class="n">ZeroList</span><span class="w"></span>
<span class="w">  </span><span class="n">Zero</span><span class="w"></span>
<span class="w">  </span><span class="n">ZeroList</span><span class="w"></span>
<span class="w">    </span><span class="n">Nothing</span><span class="w"></span>
</pre></div>
<p>Both of those are perfectly valid ways to parse that AML bytecode. Note that AsciiCharList avoids this confusion because it only ever appears within a String, and it's book-ended by a StringPrefix on one side, and a NullChar on the other. But there are quite a few real AML objects that behave just like our ZeroList example.
</p><p>When parsing these "must-know" implicit-length objects, the parser needs to know how many bytes it should parse before stopping. The parsers for Zero and ZeroList could look like this.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">function</span><span class="w"> </span><span class="n">ParseZero</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">blob</span><span class="p">.</span><span class="n">NextByte</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x00</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Zero</span><span class="w"></span>
<span class="w">  </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>

<span class="n">function</span><span class="w"> </span><span class="n">ParseZeroList</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Nothing</span><span class="w"></span>
<span class="w">  </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseZero</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">ZeroList</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ParseZeroList</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>
</pre></div>
<p>Notice how ParseZeroList decrements the "count" variable before recursing, and if count ever reaches zero it knows that it's time to apply the "end-of-recursion" case.
</p><p>But where does the "count" variable come from? Well, "must-know" implicit-length objects always appear inside of explicit-length objects, which we will discuss next.
</p>
<h3><span class="mw-headline" id="Explicit-length_objects">Explicit-length objects</span></h3>
<p>Explicit-length objects are objects whose AML bytecode includes the actual total length of the object (and of any sub-objects it contains). The total length of an object is stored in a PkgLength object. We won't look at the encoding for a PkgLength object right now, but it's usually a single byte that says how many bytes are in the current object, from the PkgLength onwards. We'll make up another object to illustrate this.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="nl">Happy</span><span class="w">       </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">HappyPrefix</span><span class="w"> </span><span class="n">PkgLength</span><span class="w"> </span><span class="n">ZeroList</span><span class="w"></span>
<span class="nl">HappyPrefix</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mh">0xFF</span><span class="w"></span>
</pre></div>
<p>Like our made-up Happy object, real AML explicit-length objects always include a PkgLength object, typically as the second object, just after an "opcode" style object and just before a "must-know" implicit-length list. Suppose we were parsing the following AML.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">FF</span><span class="w"> </span><span class="mo">03</span><span class="w"> </span><span class="mo">00</span><span class="w"> </span><span class="mo">00</span><span class="w"> </span><span class="mo">00</span><span class="w"></span>
</pre></div>
<p>We begin executing a parsing function for Happy, which might look something like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">function</span><span class="w"> </span><span class="n">ParseHappy</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseHappyPrefix</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParsePkgLength</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">Value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseZeroList</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="n">c</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Happy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>
<span class="w">    </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>
<span class="w">  </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>
</pre></div>
<p>First we call ParseHappyPrefix, which consumes the first byte of the blob, 0xFF. Then we call ParsePkgLength, which consumes the second byte of the blob, 0x03. We take the value consumed and subtract one to account for the length of the PkgLength object itself. Then we call ParseZeroList, passing along the remaining number of bytes to be consumed.
</p><p>With one exception, every "must-know" implicit-length AML object appears within an explicit-length object (although it might be nested rather deep within it). That one exception is the other big difficulty in parsing AML, to be addressed next.
</p>
<h2><span class="mw-headline" id="Object_references">Object references</span></h2>
<p>AML objects are often referenced by-name within other AML objects. The MethodInvocation object is used to represent object references and calls to methods defined within the AML. (A simple object reference is the same as a method that doesn't take any arguments.) We're not going to look at the DefMethod object right now, which defines a method to be invoked, but it specifies the name of the method, the number of arguments it takes, and a list of objects - usually math or comparison operations - to be performed on them. A simplified version of the MethodInvocation object is defined below.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="nl">MethodInvocation</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">TermArgList</span><span class="w"></span>
<span class="nl">TermArgList</span><span class="w">      </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">Nothing</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;</span><span class="n">TermArg</span><span class="w"> </span><span class="n">TermArgList</span><span class="o">&gt;</span><span class="w"></span>
<span class="nl">TermArg</span><span class="w">          </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">MethodInvocation</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
<p>From the grammar we can see that a MethodInvocation consists of the name of the method to be invoked, followed by a list of arguments passed to the method. Each argument is itself a MethodInvocation. A simple object reference has no arguments, so its TermArgList is Nothing.
</p><p>Unfortunately, while TermArgList is a "must-know" implicit-length object, MethodInvocation is <i>not</i> an explicit-length object. For example, consider the following AML.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="mi">0</span><span class="n">D</span><span class="w"> </span><span class="mi">63</span><span class="w"> </span><span class="mi">61</span><span class="w"> </span><span class="mi">74</span><span class="w"> </span><span class="mo">00</span><span class="w"> </span><span class="mi">0</span><span class="n">D</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mf">6F</span><span class="w"> </span><span class="mi">67</span><span class="w"> </span><span class="mo">00</span><span class="w"> </span><span class="mi">0</span><span class="n">D</span><span class="w"> </span><span class="mi">66</span><span class="w"> </span><span class="mf">6F</span><span class="w"> </span><span class="mf">6F</span><span class="w"> </span><span class="mo">00</span><span class="w"> </span><span class="mi">0</span><span class="n">D</span><span class="w"> </span><span class="mi">62</span><span class="w"> </span><span class="mi">61</span><span class="w"> </span><span class="mi">72</span><span class="w"> </span><span class="mo">00</span><span class="w"></span>
</pre></div>
<p>This AML consists of four strings in a row: "cat", "dog", "foo", and "bar". So is this an invocation of the "cat" method, taking three arguments, which are references to the "dog", "foo", and "bar" objects...
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">cat</span><span class="p">(</span><span class="n">dog</span><span class="p">,</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">bar</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>...or is it an invocation of the "cat" method, taking <i>two</i> arguments, the first of which is a reference to the "dog" object, and the second is an invocation of the "foo" method, which itself takes a single argument, the "bar" object...
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">cat</span><span class="p">(</span><span class="n">dog</span><span class="p">,</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>...or is it something else? There is no way to know how to parse a MethodInvocation without knowing whether an object is a simple object or a method, and if a method, how many arguments it requires. A parser might look like this.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">function</span><span class="w"> </span><span class="n">ParseMethodInvocation</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseString</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">IsMethod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="n">num_args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetNumArgs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">[</span><span class="n">num_args</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">num_arguments</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseMethodInvocation</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">MethodInvocation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">MethodInvocation</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nl">else</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">null</span><span class="w"></span>
</pre></div>
<p>So where do the IsMethod and GetNumArgs functions get their information? The parser must store this information somewhere whenever a named object is parsed, as illustrated below for the DefMethod object.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">function</span><span class="w"> </span><span class="n">ParseDefMethod</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Not actually showing how to parse a DefMethod, but it includes</span>
<span class="w">  </span><span class="c1">// the name of the method and the number of arguments the method</span>
<span class="w">  </span><span class="c1">// requires.</span>
<span class="w">  </span><span class="n">SetIsMethod</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">StoreNumArgs</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">num_arguments</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">DefMethod</span><span class="p">(...)</span><span class="w"></span>
</pre></div>
<p>But what if the corresponding named object is defined <i>after</i> the MethodInvocation? These kinds of "forward references" mean that you cannot parse AML in a single pass. Whenever you encounter a MethodInvocation but have not yet encountered an object with the name of the method being invoked the parser must stop and backtrack all the way back to the nearest explicit-length object. All the AML for that object must be stored for later parsing.
</p><p>An example will make this clearer. Consider the following grammar for some made-up objects.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="nl">Funky</span><span class="w">       </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">FunkyPrefix</span><span class="w"> </span><span class="n">PkgLength</span><span class="w"> </span><span class="n">Goofy</span><span class="w"></span>
<span class="nl">FunkyPrefix</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mh">0xAA</span><span class="w"></span>
<span class="nl">Goofy</span><span class="w">       </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">GoofyPrefix</span><span class="w"> </span><span class="n">MethodInvocation</span><span class="w"></span>
<span class="nl">GoofyPrefix</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mh">0xBB</span><span class="w"></span>
</pre></div>
<p>Consider the following AML.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">AA</span><span class="w"> </span><span class="mo">07</span><span class="w"> </span><span class="n">BB</span><span class="w"> </span><span class="mi">0</span><span class="n">D</span><span class="w"> </span><span class="mi">62</span><span class="w"> </span><span class="mi">61</span><span class="w"> </span><span class="mi">72</span><span class="w"> </span><span class="mo">00</span><span class="w"> </span><span class="mo">01</span><span class="w"> </span><span class="mo">02</span><span class="w"> </span><span class="mo">03</span><span class="w"> </span><span class="mf">04.</span><span class="p">..</span><span class="w"></span>
</pre></div>
<p>Clearly we have a FunkyPrefix followed by a PkgLength with value 0x07, which tells us that the next 6 bytes are part of the Funky object. The partial parse tree might look like this.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">Funky</span><span class="w"></span>
<span class="w">  </span><span class="n">FunkyPrefix</span><span class="w"></span>
<span class="w">  </span><span class="n">PkgLength</span><span class="w"> </span><span class="p">(</span><span class="mh">0x07</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">Unparsed</span><span class="w"> </span><span class="n">AML</span><span class="o">:</span><span class="w"> </span><span class="n">BB</span><span class="w"> </span><span class="mi">0</span><span class="n">D</span><span class="w"> </span><span class="mi">62</span><span class="w"> </span><span class="mi">61</span><span class="w"> </span><span class="mi">72</span><span class="w"> </span><span class="mo">00</span><span class="w"> </span><span class="mo">01</span><span class="w"> </span><span class="mo">02</span><span class="w"> </span><span class="mo">03</span><span class="w"> </span><span class="mo">04</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
</pre></div>
<p>Continuing on, we have a GoofyPrefix and we expect there to be a MethodInvocation afterwards. We parse the String and find that the method to be invoked is named "bar". Now our partial parse tree might look like this.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">Funky</span><span class="w"></span>
<span class="w">  </span><span class="n">FunkyPrefix</span><span class="w"></span>
<span class="w">  </span><span class="n">PkgLength</span><span class="w"> </span><span class="p">(</span><span class="mh">0x07</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">Goofy</span><span class="w"></span>
<span class="w">    </span><span class="n">GoofyPrefix</span><span class="w"></span>
<span class="w">    </span><span class="n">MethodInvocation</span><span class="w"></span>
<span class="w">      </span><span class="n">String</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">Unparsed</span><span class="w"> </span><span class="n">AML</span><span class="o">:</span><span class="w"> </span><span class="mo">01</span><span class="w"> </span><span class="mo">02</span><span class="w"> </span><span class="mo">03</span><span class="w"> </span><span class="mo">04</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
</pre></div>
<p>Suppose we look up "bar" in our database of methods, but we don't find anything - clearly we haven't found an object with the name "bar" yet. This means we can't finish parsing the MethodInvocation. If we can't finish parsing the MethodInvocation, we can't finish parsing the Goofy object either. And if we can't finish parsing the Goofy object we can't finish parsing the Funky object. However, the Funky object is an explicit-length object, so we know how much AML is inside it. So we can wrap that AML up in a special object temporarily, and continue parsing. Now our parse tree looks like this.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">Funky</span><span class="w"></span>
<span class="w">  </span><span class="n">FunkyPrefix</span><span class="w"></span>
<span class="w">  </span><span class="n">PkgLength</span><span class="w"> </span><span class="p">(</span><span class="mh">0x07</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">AML</span><span class="w"> </span><span class="n">wrapper</span><span class="w"> </span><span class="p">{</span><span class="n">BB</span><span class="w"> </span><span class="mi">0</span><span class="n">D</span><span class="w"> </span><span class="mi">62</span><span class="w"> </span><span class="mi">61</span><span class="w"> </span><span class="mi">72</span><span class="w"> </span><span class="mo">00</span><span class="p">}</span><span class="w"></span>
<span class="p">(</span><span class="n">Unparsed</span><span class="w"> </span><span class="n">AML</span><span class="o">:</span><span class="w"> </span><span class="mo">01</span><span class="w"> </span><span class="mo">02</span><span class="w"> </span><span class="mo">03</span><span class="w"> </span><span class="mo">04</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
</pre></div>
<p>Suppose we continue parsing the unparsed AML and eventually we find a DefMethod object with name "bar", and it says that the "bar" method doesn't take any arguments. Now we can revisit the AML wrapped inside the Funky object and parse it again. We work our way back to the MethodInvocation and this time we know that there's nothing expected after the "bar" method name. Our completely parsed Funky object looks like this.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">Funky</span><span class="w"></span>
<span class="w">  </span><span class="n">FunkyPrefix</span><span class="w"></span>
<span class="w">  </span><span class="n">PkgLength</span><span class="w"> </span><span class="p">(</span><span class="mh">0x07</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">Goofy</span><span class="w"></span>
<span class="w">    </span><span class="n">GoofyPrefix</span><span class="w"></span>
<span class="w">    </span><span class="n">MethodInvocation</span><span class="w"></span>
<span class="w">      </span><span class="n">String</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="w"></span>
</pre></div>
<p>This isn't too bad, right? You just have to keep a registry of method and object names as you parse them, and wait until you've parsed all of them before you attempt to parse any MethodInvocations.
</p><p>Unfortunately, in this document so far we've described method/object names as Strings, but that's not the case. Instead, method/object names are NameString objects, which are more like paths in a filesystem. To find the corresponding DefMethod (or other named object definition) for a particular MethodInvocation you have to understand the ACPI namespace and AML scoping. Have faith: this is the last AML concept needed to completely parse arbitrary AML with a recursive descent parser.
</p>
<h2><span class="mw-headline" id="ACPI_namespace_and_scoping">ACPI namespace and scoping</span></h2>
<p>TODO
</p>
<h2><span class="mw-headline" id="AML_errata">AML errata</span></h2>
<p>The ACPI specification includes a number of mistakes in the AML grammar.
TODO: summarize all the mistakes I've found
</p>
<!-- 
NewPP limit report
Cached time: 20250211155951
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.144 seconds
Real time usage: 3.497 seconds
Preprocessor visited node count: 210/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 35711/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:3328-0!canonical and timestamp 20250211155948 and revision id 18482.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=User:Intx13&amp;oldid=18482">https://wiki.osdev.org/index.php?title=User:Intx13&amp;oldid=18482</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=User%3AIntx13" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="./User:Intx13#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-user" class="selected mw-list-item"><a href="./User:Intx13" title="View the user page [c]" accesskey="c"><span>User page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User_talk:Intx13&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="./User:Intx13"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Intx13&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Intx13&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/User:Intx13" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/User:Intx13" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-contributions" class="mw-list-item"><a href="./Special:Contributions/Intx13" title="A list of contributions by this user"><span>User contributions</span></a></li><li id="t-log" class="mw-list-item"><a href="./Special:Log/Intx13"><span>Logs</span></a></li><li id="t-userrights" class="mw-list-item"><a href="./Special:UserRights/Intx13"><span>View user groups</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Intx13&amp;oldid=18482" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Intx13&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 9 November 2015, at 18:30.</li>
	<li id="footer-info-0">This page has been accessed 1,377 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=User:Intx13&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.144","walltime":"3.497","ppvisitednodes":{"value":210,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":35711,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20250211155951","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":3613});});</script>
</body>
</html>