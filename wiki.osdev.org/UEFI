<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>UEFI - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"3e22fc6438cbf042213a6fa2","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"UEFI","wgTitle":"UEFI","wgCurRevisionId":29353,"wgRevisionId":29353,"wgArticleId":2924,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","X86","X86-64","ARM","Firmware","UEFI"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"UEFI","wgRelevantArticleId":2924,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],
"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head","mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-UEFI rootpage-UEFI skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">UEFI</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="UEFI#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="UEFI#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>(U)EFI or (Unified) Extensible Firmware Interface is a specification for x86, x86-64, ARM, and Itanium platforms that defines a software interface between the operating system and the platform firmware/BIOS. The original EFI was developed in the mid-1990s by Intel for use developing firmware/BIOS for Itanium platforms. In 2005 Intel transitioned the specification to a new working group called the Unified EFI Forum, consisting of companies such as AMD, Microsoft, Apple, and Intel itself. All modern PCs ship with UEFI firmware and UEFI is widely supported by both commercial and open source operating systems. Backwards compatibility is provided for legacy operating systems.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="UEFI#UEFI_basics"><span class="tocnumber">1</span> <span class="toctext">UEFI basics</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="UEFI#Downloading_UEFI_images"><span class="tocnumber">1.1</span> <span class="toctext">Downloading UEFI images</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="UEFI#UEFI_vs._legacy_BIOS"><span class="tocnumber">1.2</span> <span class="toctext">UEFI vs. legacy BIOS</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="UEFI#Platform_initialization"><span class="tocnumber">1.2.1</span> <span class="toctext">Platform initialization</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="UEFI#Boot_mechanism"><span class="tocnumber">1.2.2</span> <span class="toctext">Boot mechanism</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="UEFI#System_discovery"><span class="tocnumber">1.2.3</span> <span class="toctext">System discovery</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="UEFI#Convenience_functions"><span class="tocnumber">1.2.4</span> <span class="toctext">Convenience functions</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="UEFI#Development_environment"><span class="tocnumber">1.2.5</span> <span class="toctext">Development environment</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="UEFI#Emulation"><span class="tocnumber">1.2.6</span> <span class="toctext">Emulation</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-10"><a href="UEFI#Legacy_bootloader_or_UEFI_application?"><span class="tocnumber">1.3</span> <span class="toctext">Legacy bootloader or UEFI application?</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="UEFI#UEFI_class_0-3_and_CSM"><span class="tocnumber">1.4</span> <span class="toctext">UEFI class 0-3 and CSM</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="UEFI#Secure_Boot"><span class="tocnumber">1.5</span> <span class="toctext">Secure Boot</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="UEFI#How_to_use_UEFI"><span class="tocnumber">1.6</span> <span class="toctext">How to use UEFI</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="UEFI#Developing_with_POSIX-UEFI"><span class="tocnumber">2</span> <span class="toctext">Developing with POSIX-UEFI</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="UEFI#Developing_with_GNU-EFI"><span class="tocnumber">3</span> <span class="toctext">Developing with GNU-EFI</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="UEFI#Emulation_with_QEMU_and_OVMF"><span class="tocnumber">4</span> <span class="toctext">Emulation with QEMU and OVMF</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="UEFI#Creating_disk_images"><span class="tocnumber">4.1</span> <span class="toctext">Creating disk images</span></a>
<ul>
<li class="toclevel-3 tocsection-18"><a href="UEFI#uefi-run_helper_application"><span class="tocnumber">4.1.1</span> <span class="toctext">uefi-run helper application</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="UEFI#Linux,_root_required"><span class="tocnumber">4.1.2</span> <span class="toctext">Linux, root required</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="UEFI#Linux,_root_not_required"><span class="tocnumber">4.1.3</span> <span class="toctext">Linux, root not required</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="UEFI#FreeBSD,_root_required"><span class="tocnumber">4.1.4</span> <span class="toctext">FreeBSD, root required</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="UEFI#Mac_OS_(root_not_required)"><span class="tocnumber">4.1.5</span> <span class="toctext">Mac OS (root not required)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-23"><a href="UEFI#Launching_UEFI_applications"><span class="tocnumber">4.2</span> <span class="toctext">Launching UEFI applications</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="UEFI#Debugging"><span class="tocnumber">4.3</span> <span class="toctext">Debugging</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-25"><a href="UEFI#Running_on_real_hardware"><span class="tocnumber">5</span> <span class="toctext">Running on real hardware</span></a>
<ul>
<li class="toclevel-2 tocsection-26"><a href="UEFI#NVRAM_variables"><span class="tocnumber">5.1</span> <span class="toctext">NVRAM variables</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="UEFI#Bootable_UEFI_applications"><span class="tocnumber">5.2</span> <span class="toctext">Bootable UEFI applications</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="UEFI#Exposed_functionality"><span class="tocnumber">5.3</span> <span class="toctext">Exposed functionality</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="UEFI#PC_firmware_developers"><span class="tocnumber">5.4</span> <span class="toctext">PC firmware developers</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-30"><a href="UEFI#UEFI_applications_in_detail"><span class="tocnumber">6</span> <span class="toctext">UEFI applications in detail</span></a>
<ul>
<li class="toclevel-2 tocsection-31"><a href="UEFI#Binary_Format"><span class="tocnumber">6.1</span> <span class="toctext">Binary Format</span></a>
<ul>
<li class="toclevel-3 tocsection-32"><a href="UEFI#Initialization"><span class="tocnumber">6.1.1</span> <span class="toctext">Initialization</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="UEFI#Memory"><span class="tocnumber">6.1.2</span> <span class="toctext">Memory</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-34"><a href="UEFI#Calling_Conventions"><span class="tocnumber">6.2</span> <span class="toctext">Calling Conventions</span></a>
<ul>
<li class="toclevel-3 tocsection-35"><a href="UEFI#POSIX-UEFI,_GNU-EFI_and_GCC"><span class="tocnumber">6.2.1</span> <span class="toctext">POSIX-UEFI, GNU-EFI and GCC</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-36"><a href="UEFI#Language_binding"><span class="tocnumber">6.3</span> <span class="toctext">Language binding</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="UEFI#EFI_Byte_Code"><span class="tocnumber">6.4</span> <span class="toctext">EFI Byte Code</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-38"><a href="UEFI#Common_Problems"><span class="tocnumber">7</span> <span class="toctext">Common Problems</span></a>
<ul>
<li class="toclevel-2 tocsection-39"><a href="UEFI#My_UEFI_application_hangs/resets_after_about_5_minutes"><span class="tocnumber">7.1</span> <span class="toctext">My UEFI application hangs/resets after about 5 minutes</span></a></li>
<li class="toclevel-2 tocsection-40"><a href="UEFI#My_bootloader_hangs_if_I_use_user_defined_EFI_MEMORY_TYPE_values"><span class="tocnumber">7.2</span> <span class="toctext">My bootloader hangs if I use user defined EFI_MEMORY_TYPE values</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-41"><a href="UEFI#See_also"><span class="tocnumber">8</span> <span class="toctext">See also</span></a>
<ul>
<li class="toclevel-2 tocsection-42"><a href="UEFI#Articles"><span class="tocnumber">8.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-43"><a href="UEFI#External_Links"><span class="tocnumber">8.2</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="UEFI_basics">UEFI basics</span></h2>
<h3><span class="mw-headline" id="Downloading_UEFI_images">Downloading UEFI images</span></h3>
<p>If you choose <a href="VirtualBox" title="VirtualBox">VirtualBox</a> for virtualization, then UEFI is already included, no need to download the image manually. You just have to enable it in the VM's preferences by clicking "Settings" / "Systems" / "Enable EFI (special OSes only)" checkbox.
</p><p>Otherwise for emulation and virtual machines, you'll need an OVMF.fd firmware image. It might be tricky to find, so here are some alternative download links too:
</p>
<ul><li><a rel="nofollow" class="external text" href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">TianoCore Download</a> (official link)</li>
<li><a rel="nofollow" class="external text" href="https://github.com/BlankOn/ovmf-blobs">OVMF-blobs</a> (unofficial precompiled 32 bit and 64 bit versions, easy to use)</li>
<li><a rel="nofollow" class="external text" href="https://www.kraxel.org/repos/">RPM packages</a> (official TianoCore packages)</li>
<li><a rel="nofollow" class="external text" href="https://packages.debian.org/sid/ovmf">Debian packages</a></li>
<li><a rel="nofollow" class="external text" href="https://packages.gentoo.org/useflags/ovmf">Gentoo packages</a></li>
<li><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/ovmf-git/?comments=all">Arch packages</a></li></ul>
<p>Under Linux, you can also install these with your distro's package manager, for example:
</p><p><b>Debian / Ubuntu</b>
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span><span class="c1"># apt-get install ovmf</span>
</pre></div>
<p><b>RedHat / CentOS</b>
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span><span class="c1"># yum install ovmf</span>
</pre></div>
<p><b>MacOS</b>
</p><p>Use the OVMF-blobs repo.
</p><p><b>Windows</b>
</p><p>Use the OVMF-blobs repo or download the RPM version, then use <i>7-Zip File Manager</i> to extract the OVMF.fd file from the downloaded archive.
</p>
<h3><span class="mw-headline" id="UEFI_vs._legacy_BIOS">UEFI vs. legacy BIOS</span></h3>
<p>A common misconception is that UEFI and BIOS are mutually exclusive. In reality, both legacy motherboards and UEFI-based motherboards both include BIOS ROMs. The differences are in where they find the bootloader/OS, how they prepare the system before executing it, and what convenience functions they provide.
</p>
<h4><span class="mw-headline" id="Platform_initialization">Platform initialization</span></h4>
<p>On a legacy system, BIOS performs all the usual platform initialization (memory controller configuration, PCI bus configuration and BAR mapping, graphics card initialization, etc.), but then drops into a backwards-compatible real mode environment. The bootloader must enable the A20 gate, configure a GDT and an IDT, switch to protected mode, and for x86-64 CPUs, configure paging and switch to long mode.
</p><p>UEFI firmware performs those same steps, but it also enables the A20 gate and prepares either protected mode environment with flat segmentation (for 32-bit x86 processors) or a long mode environment with identity-mapped paging (for x86-64 processors).
</p><p>Additionally, the platform initialization procedure of UEFI firmware is standardized. This allows UEFI firmware to be extended in a vendor-neutral way.
</p>
<h4><span class="mw-headline" id="Boot_mechanism">Boot mechanism</span></h4>
<p>A legacy BIOS loads a 512 byte flat binary blob from the MBR of the boot device into memory at physical address 7C00 and jumps to it. The bootloader cannot return back to BIOS. UEFI firmware loads an arbitrary sized UEFI application (a relocatable PE executable file) from a FAT partition on a GPT or MBR partitioned boot device to some address selected at run-time. Then it calls that application's main entry point. The application can return control to the firmware, which will continue searching for another boot device or bring up a diagnostic menu.
</p>
<h4><span class="mw-headline" id="System_discovery">System discovery</span></h4>
<p>A legacy bootloader scans memory for structures like the <a href="EBDA" class="mw-redirect" title="EBDA">EBDA</a>, <a href="SMBIOS" class="mw-redirect" title="SMBIOS">SMBIOS</a>, and <a href="ACPI" title="ACPI">ACPI</a> tables. It uses PIO to talk to the root <a href="PCI" title="PCI">PCI</a> controller and scan the PCI bus. It is possible that redundant tables may be present in memory (for example, the <a href="MP_Specification" title="MP Specification">MP</a> table in the SMBIOS contains information that's also present in the ACPI <a href="DSDT" title="DSDT">DSDT</a> and <a href="MADT" title="MADT">MADT</a>) and the bootloader can choose which to use.
</p><p>When UEFI firmware calls a UEFI application's entry point function, it passes a "System Table" structure, which contains pointers to all of the system's ACPI tables, memory map, and other information relevant to an OS. Legacy tables (like MP tables) may not be present in memory.
</p>
<h4><span class="mw-headline" id="Convenience_functions">Convenience functions</span></h4>
<p>A legacy BIOS hooks a variety of interrupts which a bootloader can trigger to access system resources like disks and the screen. These interrupts are not standardized, except by historical convention. Each interrupt uses a different register passing convention.
</p><p>UEFI firmware establishes many callable functions in memory, which are grouped into sets called "protocols" and are discoverable through the System Table. The behavior of each function in each protocol is defined by specification. UEFI applications can define their own protocols and persist them in memory for other UEFI applications to use. Functions are called with a standardized, modern calling convention supported by many C compilers.
</p>
<h4><span class="mw-headline" id="Development_environment">Development environment</span></h4>
<p>Legacy bootloaders can be developed in any environment that can generate flat binary images: NASM, GCC, etc. UEFI applications can be developed in any language that can be compiled and linked into a <a href="PE" title="PE">PE</a> executable file and supports the calling convention used to access functions established in memory by the UEFI firmware. In practice this means one of three development environments: EDK2, GNU-EFI or POSIX-UEFI.
</p><p><a href="EDK2" title="EDK2">EDK2</a> is a large and complex, yet feature filled environment with its own build system. It can be configured to use GCC, LLVM, MinGW, Microsoft Visual C++, etc. as a cross-compiler. Not only can it be used to compile UEFI applications, but it can also be used to compile UEFI firmware to be flashed to a BIOS ROM.
</p><p><a href="GNU-EFI" title="GNU-EFI">GNU-EFI</a> is a set of libraries and headers for compiling UEFI applications with a system's native GCC (does not work with LLVM CLang). It can't be used to compile UEFI firmware. Since it's just a couple of libraries against which a UEFI application can be linked, it is much easier to use than TianoCore ( EDK2 ).
</p><p><a href="POSIX-UEFI" title="POSIX-UEFI">POSIX-UEFI</a> is very similar to GNU-EFI, but it is distributed mainly as a source, not as a binary library, has ANSI C like names and works with GCC as well as LLVM CLang. It's shipped with a Makefile that sets up the compiler flags for you.
</p>
<h4><span class="mw-headline" id="Emulation">Emulation</span></h4>
<p><a href="OVMF" title="OVMF">OVMF</a>, a popular open source UEFI firmware, has been ported to the QEMU (but not Bochs) emulated machine. Because it implements the UEFI specification, it behaves very similarly to commercial UEFI firmware on real machines. (OVMF itself is built with TianoCore, and its source ship with it as well, but pre-built images are available.)
</p>
<h3><span id="Legacy_bootloader_or_UEFI_application.3F"></span><span class="mw-headline" id="Legacy_bootloader_or_UEFI_application?">Legacy bootloader or UEFI application?</span></h3>
<p>If you are targeting legacy systems for which UEFI is not available or is not reliable, you should develop a legacy bootloader. This requires intimate knowledge of 16-bit addressing and the backwards-compatibility features of an x86 or x86-64 CPU.  If you are targeting modern systems you should develop a UEFI application. Many UEFI firmwares can be configured to emulate a legacy BIOS, but there is even more variation among these emulated environments than among real legacy BIOS.
</p><p>Although there is a slight learning curve to become familiar with the UEFI development environments, using the System Table, and accessing UEFI-provided protocols (functions), there are far fewer "gotchas" than trying to remain compatible with the wide variety of quickly-becoming-obsolete legacy BIOSs on real machines. UEFI is the standard for all modern PCs.
</p>
<h3><span class="mw-headline" id="UEFI_class_0-3_and_CSM">UEFI class 0-3 and CSM</span></h3>
<p>PCs are categorized as UEFI class 0, 1, 2, or 3. A class 0 machine is a legacy system with a legacy BIOS; i.e. not a UEFI system at all.
</p><p>A class 1 machine is a UEFI system that runs exclusively in Compatibility Support Module (CSM) mode. CSM is a specification for how UEFI firmware can emulate a legacy BIOS. UEFI firmware in CSM mode loads legacy bootloaders. A class 1 UEFI system may not advertise UEFI support at all, since it isn't exposed to the bootloader. It's only UEFI "within" the BIOS.
</p><p>A class 2 machine is a UEFI system that can launch UEFI applications but also includes the option to run in CSM mode. The majority of modern PCs are UEFI class 2 machines. Sometimes the choice to run UEFI applications vs. CSM is a one-or-the-other setting in the BIOS configuration, and other times the BIOS will decide which to use after selecting the boot device and checking whether it has a legacy bootloader or a UEFI application.
</p><p>A class 3 machine is a UEFI system that does not support CSM. UEFI class 3 machines only run UEFI applications and do not implement CSM for backwards compatibility with legacy bootloaders.
</p>
<h3><span class="mw-headline" id="Secure_Boot">Secure Boot</span></h3>
<p>Secure Boot is a digital signature scheme for UEFI applications that consists of four components:
</p>
<ul><li><b>PK</b>: Platform Key</li>
<li><b>KEK</b>: Key Exchange Keys</li>
<li><b>db</b>: Whitelist database</li>
<li><b>dbx</b>: Blacklist database</li></ul>
<p>UEFI firmware that supports Secure Boot is always in one of three states:
</p>
<ul><li>Setup mode, Secure Boot <i>off</i></li>
<li>User mode, Secure Boot <i>off</i></li>
<li>User mode, Secure Boot <i>on</i></li></ul>
<p>In setup mode, any UEFI application can change or delete the PK, add/remove keys from the KEK, and add/remove whitelist or blacklist entries from the db or dbx.
</p><p>In user mode, regardless of whether Secure Boot is on or off:
</p>
<ul><li>The PK may only be changed or deleted by a UEFI application that already has the current PK.</li>
<li>Keys can only be added/removed from the KEK by a UEFI application that has the PK.</li>
<li>Whitelist and blacklist entries can only be added/removed from the db and dbx by a UEFI application that has any one of the keys in the KEK.</li></ul>
<p>Finally, in user mode with Secure Boot <i>on</i>, UEFI applications must meet one of the following four requirements to be launched:
</p>
<ul><li>Signed, with signature in db and not in dbx</li>
<li>Signed by a key in db and not in dbx</li>
<li>Signed by a key in the KEK</li>
<li>Unsigned, but a hash of the application is in db and not in dbx</li></ul>
<p>Note that UEFI applications are not signed by the PK, unless the PK also happens to be in the KEK.
</p><p>Not all UEFI firmwares support Secure Boot, although it is a requirement for Windows 8. Some UEFI firmwares support Secure Boot and there's no option to be disabled, which poses a problem for independent developers that do not have access to the PK or any of the keys in the KEK, and therefore can't install their own key or application signature or hash to the whitelist database. Independent developers should develop on systems that either do not support Secure Boot or has an option for Secure Boot to be turned off.
</p><p>An easy way out to use a loader that is signed by Microsoft, and allows you to load another binary signed by a key and certificate owned by you (called MOK, Machine Owner's Key). Such a loader is <a rel="nofollow" class="external text" href="https://github.com/rhboot/shim">shim</a>, used by RedHat, Fedora, Suse, Ubuntu, Arch and many other distros to load GRUB. The filename of the EFI executable is hardwired in shim, but if you rename your loader to GRUBX64.EFI (or GRUBIA32.EFI), you sign it with your MOK key and certificate using <a rel="nofollow" class="external text" href="https://github.com/imedias/sbsigntool">sbsigntool</a>, then you can load any loader in Secure Boot you want.
</p>
<h3><span class="mw-headline" id="How_to_use_UEFI">How to use UEFI</span></h3>
<p>Traditional operating systems like Windows and Linux have an existing software architecture and a large code base to perform system configuration and device discovery. With their sophisticated layers of abstraction they don't directly benefit from UEFI. As a result, their UEFI bootloaders do little but prepare the environment for them to run.
</p><p>An independent developer may find more value in using UEFI to write feature-full UEFI applications, rather than viewing UEFI as a temporary start-up environment to be jettisoned during the boot process. Unlike legacy bootloaders, which typically interact with BIOS only enough to bring up the OS, a UEFI application can implement sophisticated behavior with the help of UEFI. In other words, an independent developer shouldn't be in a rush to leave "UEFI-land".
</p><p>A good starting point is writing a UEFI application that uses the System Table to fetch a memory map, and uses the "File" protocol to read files from FAT-formatted disks. The next step might be to use the System Table to locate ACPI tables.
</p>
<h2><span class="mw-headline" id="Developing_with_POSIX-UEFI">Developing with POSIX-UEFI</span></h2>
<dl><dd><i>Main article: <a href="POSIX-UEFI" title="POSIX-UEFI">POSIX-UEFI</a></i></dd></dl>
<p>One option to compile UEFI applications on POSIX like systems is POSIX-UEFI. It provides a <a href="Libc" class="mw-redirect" title="Libc">libc</a>-like API for your EFI application, and ships with a Makefile that can detect and set up the toolchain for you. It can use GCC or LLVM, and defaults to using the host compiler, but a cross compiler is still recommended.
</p><p>It uses POSIX style typedefs (like <i>uintn_t</i> instead of <i>UINTN</i>), and it does not ship with the standard EFI headers. You can still get interfaces not covered by POSIX-UEFI (such as GOP) by installing the EFI headers from GNU-EFI or EDK2. Also, it compiles with the MS ABI, meaning that UEFI services can be called natively (i.e., without uefi_call_wrapper) so long as your apps are compiled with it as well.
The traditional "Hello, world" UEFI program goes like this.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;uefi.h&gt;</span><span class="cp"></span>
<span class="w"> </span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Makefile looks like this:
</p>
<div class="mw-highlight mw-highlight-lang-make mw-content-ltr" dir="ltr"><pre><span></span><span class="nv">TARGET</span> <span class="o">=</span> main.efi
<span class="cp">include uefi/Makefile</span>
</pre></div>
<p>Run make to build it. The result of this process is a PE executable file <i>main.efi</i>.
</p>
<h2><span class="mw-headline" id="Developing_with_GNU-EFI">Developing with GNU-EFI</span></h2>
<dl><dd><i>Main article: <a href="GNU-EFI" title="GNU-EFI">GNU-EFI</a></i></dd></dl>
<p>GNU-EFI can be used to develop both 32-bit and 64-bit UEFI applications. This section will address 64-bit UEFI applications only, and assumes that the development environment itself is running on an x86_64 system, so that no cross-compiler is needed. For a more thorough walk-through of a proper (non-gnu-efi) development environment, see <a href="UEFI_App_Bare_Bones" title="UEFI App Bare Bones">UEFI App Bare Bones</a>.
</p><p>GNU-EFI includes four things:
</p>
<ul><li><b>crt0-efi-x86_64.o</b>: A CRT0 (C runtime initialization code) that provides an entry point that UEFI firmware will call when launching the application, which will in turn call the "efi_main" function that the developer writes.</li>
<li><b>libgnuefi.a</b>: A library containing a single function (<i>_relocate</i>) that is used by the CRT0.</li>
<li><b>elf_x86_64_efi.lds</b>: A linker script used to link ELF binaries into UEFI applications.</li>
<li><b>efi.h</b> and other headers: Convenience headers that provide structures, typedefs, and constants improve readability when accessing the System Table and other UEFI resources.</li>
<li><b>libefi.a</b>: A library containing convenience functions like CRC computation, string length calculation, and easy text printing.</li>
<li><b>efilib.h</b>: Header for <i>libefi.a</i>.</li></ul>
<p>At a bare minimum, a 64-bit UEFI application will need to link against <i>crt0-efi-x86_64.o</i> and <i>libgnuefi.a</i> using the <i>elf_x86_64_efi.lds</i> linker script. Most likely you will want to use the provided headers and the convenience library as well, and this section will assume that going forward.
</p><p>The traditional "Hello, world" UEFI program is shown below.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;efi.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;efilib.h&gt;</span><span class="cp"></span>

<span class="n">EFI_STATUS</span><span class="w"></span>
<span class="n">EFIAPI</span><span class="w"></span>
<span class="n">efi_main</span><span class="w"> </span><span class="p">(</span><span class="n">EFI_HANDLE</span><span class="w"> </span><span class="n">ImageHandle</span><span class="p">,</span><span class="w"> </span><span class="n">EFI_SYSTEM_TABLE</span><span class="w"> </span><span class="o">*</span><span class="n">SystemTable</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">InitializeLib</span><span class="p">(</span><span class="n">ImageHandle</span><span class="p">,</span><span class="w"> </span><span class="n">SystemTable</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">Print</span><span class="p">(</span><span class="sa">L</span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">EFI_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>A few notes:
</p>
<ul><li>efi.h is included so we can use types like EFI_STATUS, EFI_HANDLE, and EFI_SYSTEM_TABLE.</li>
<li>When creating a 32-bit UEFI application, EFIAPI is empty; GCC will compile the "efi_main" function using the standard C calling convention. When creating a 64-bit UEFI application, EFIAPI expands to "__attribute__((ms_abi))" and GCC will compile the "efi_main" function using Microsoft's x64 calling convention, as specified by UEFI. Only functions that will be called directly from UEFI (including main, but also callbacks) need to use the UEFI calling convention.</li>
<li>"InitializeLib" and "Print" are convenience functions provided by libefi.a with prototypes in efilib.h. "InitializeLib" lets libefi.a store a reference to the ImageHandle and SystemTable provided by BIOS. "Print" uses those stored references to print a string by reaching out to UEFI-provided functions in memory. (Later on we will see how to find and call UEFI-provided functions manually.)</li></ul>
<p>This program is compiled and linked as below.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ gcc main.c                             <span class="se">\</span>
      -c                                 <span class="se">\</span>
      -fno-stack-protector               <span class="se">\</span>
      -fpic                              <span class="se">\</span>
      -fshort-wchar                      <span class="se">\</span>
      -mno-red-zone                      <span class="se">\</span>
      -I /path/to/gnu-efi/headers        <span class="se">\</span>
      -I /path/to/gnu-efi/headers/x86_64 <span class="se">\</span>
      -DEFI_FUNCTION_WRAPPER             <span class="se">\</span>
      -o main.o

$ ld main.o                         <span class="se">\</span>
     /path/to/crt0-efi-x86_64.o     <span class="se">\</span>
     -nostdlib                      <span class="se">\</span>
     -znocombreloc                  <span class="se">\</span>
     -T /path/to/elf_x86_64_efi.lds <span class="se">\</span>
     -shared                        <span class="se">\</span>
     -Bsymbolic                     <span class="se">\</span>
     -L /path/to/libs               <span class="se">\</span>
     -l:libgnuefi.a                 <span class="se">\</span>
     -l:libefi.a                    <span class="se">\</span>
     -o main.so

$ objcopy -j .text                <span class="se">\</span>
          -j .sdata               <span class="se">\</span>
          -j .data                <span class="se">\</span>
          -j .dynamic             <span class="se">\</span>
          -j .dynsym              <span class="se">\</span>
          -j .rel                 <span class="se">\</span>
          -j .rela                <span class="se">\</span>
          -j .reloc               <span class="se">\</span>
          --target<span class="o">=</span>efi-app-x86_64 <span class="se">\</span>
          main.so                 <span class="se">\</span>
          main.efi
</pre></div>
<p>The result of this process is a 44 kB PE executable file <i>main.efi</i>. On a real project you'll probably want to use make or another build tool, and may need to build a cross-compiler. The way GNU-EFI works is a bit contrived: you are wrapping an ELF file built by your normal compiler into PE.
</p>
<h2><span class="mw-headline" id="Emulation_with_QEMU_and_OVMF">Emulation with QEMU and OVMF</span></h2>
<p>Any recent version of QEMU with a recent version of OVMF will be sufficient to run a UEFI application. QEMU binaries are available for many platforms, and a binary OVMF image (OVMF.fd) can be found on the <a rel="nofollow" class="external text" href="http://www.tianocore.org/ovmf/">TianoCore</a> website. QEMU (without any boot disk) can be invoked as below. (To prevent recent versions of QEMU from attempting a PXE (network) boot when no boot disk is found, use <code>-net none</code>.
</p><p>The recommended way to use OVMF (for QEMU 1.6 or newer) is with a <code>pflash</code> parameter. The instructions below assume you have an OVMF image split into separate CODE and VARS sections.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ qemu-system-x86_64 -cpu qemu64 <span class="se">\</span>
  -drive <span class="k">if</span><span class="o">=</span>pflash,format<span class="o">=</span>raw,unit<span class="o">=</span><span class="m">0</span>,file<span class="o">=</span>path_to_OVMF_CODE.fd,readonly<span class="o">=</span>on <span class="se">\</span>
  -drive <span class="k">if</span><span class="o">=</span>pflash,format<span class="o">=</span>raw,unit<span class="o">=</span><span class="m">1</span>,file<span class="o">=</span>path_to_OVMF_VARS.fd <span class="se">\</span>
  -net none
</pre></div>
<p>If you prefer to work on a terminal without a display, or via SSH/telnet, you will want to run QEMU without graphics support, using the <code>-nographic</code> flag.
</p><p>If OVMF does not find a boot disk with a properly named UEFI application (more on this later) it will drop into a UEFI shell.
</p><p><a href="./File:OVMF_shell.png" class="image"><img alt="OVMF shell.png" src="images/f/f8/OVMF_shell.png" decoding="async" width="669" height="397" data-file-width="669" data-file-height="397" /></a>
</p><p>You can find a list of shell commands <a rel="nofollow" class="external text" href="http://www.sysadminshare.com/2012/01/efi-shell-commands.html">here</a> or you can type <i>help</i> at the shell.
</p>
<h3><span class="mw-headline" id="Creating_disk_images">Creating disk images</span></h3>
<dl><dd><i>Main article: <a href="Bootable_Disk" title="Bootable Disk">Bootable Disk</a></i></dd></dl>
<p>To launch a UEFI application you will need to create a disk image and present it to QEMU. UEFI firmware expects UEFI applications to be stored in a FAT12, FAT16, or FAT32 file system on a <a href="GPT" title="GPT">GPT</a> or <a href="MBR" class="mw-redirect" title="MBR">MBR</a>-partitioned disk. Many firmwares only support FAT32, so that's what you'll want to use. Depending on your platform, there are several different ways to create a disk image containing your UEFI application, but they all start by creating a zeroed disk image file. The minimum FAT32 partition size is 33,548,800 bytes, plus you will need space for the primary and secondary GPT tables, plus some slack space so the partition can be aligned correctly. Throughout these examples we will be creating a 48,000,000 byte (93750 512-byte sectors, or 48 MB) disk image.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/path/to/uefi.img <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">93750</span>
</pre></div>
<h4><span class="mw-headline" id="uefi-run_helper_application">uefi-run helper application</span></h4>
<p>The uefi-run application is useful for quick testing. It creates a temporary FAT image containing your EFI application and starts qemu.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ uefi-run -b /path/to/OVMF.fd -q /path/to/qemu app.efi -- &lt;extra_qemu_args&gt;
</pre></div>
<p>uefi-run is not currently packaged for any distribution. You can install it using cargo (the Rust package manager) though ("cargo install uefi-run").
</p>
<h4><span id="Linux.2C_root_required"></span><span class="mw-headline" id="Linux,_root_required">Linux, root required</span></h4>
<p>This approach requires root privileges and uses <b>gdisk</b>, <b>losetup</b>, and <b>mkdosfs</b>. First, use gdisk to create a GPT partition table with a single <a href="EFI_System_Partition" title="EFI System Partition">EFI System Partition</a>.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ gdisk /path/to/uefi.img
GPT fdisk <span class="o">(</span>gdisk<span class="o">)</span> version <span class="m">0</span>.8.10

Partition table scan:
  MBR: not present
  BSD: not present
  APM: not present
  GPT: not present

Creating new GPT entries.

Command <span class="o">(</span>? <span class="k">for</span> <span class="nb">help</span><span class="o">)</span>: o
This option deletes all partitions and creates a new protective MBR.
Proceed? <span class="o">(</span>Y/N<span class="o">)</span>: y

Command <span class="o">(</span>? <span class="k">for</span> <span class="nb">help</span><span class="o">)</span>: n
Partition number <span class="o">(</span><span class="m">1</span>-128, default <span class="m">1</span><span class="o">)</span>: <span class="m">1</span>
First sector <span class="o">(</span><span class="m">34</span>-93716, <span class="nv">default</span> <span class="o">=</span> <span class="m">2048</span><span class="o">)</span> or <span class="o">{</span>+-<span class="o">}</span>size<span class="o">{</span>KMGTP<span class="o">}</span>: <span class="m">2048</span>
Last sector <span class="o">(</span><span class="m">2048</span>-93716, <span class="nv">default</span> <span class="o">=</span> <span class="m">93716</span><span class="o">)</span> or <span class="o">{</span>+-<span class="o">}</span>size<span class="o">{</span>KMGTP<span class="o">}</span>: <span class="m">93716</span>
Current <span class="nb">type</span> is <span class="s1">&#39;Linux filesystem&#39;</span>
Hex code or GUID <span class="o">(</span>L to show codes, <span class="nv">Enter</span> <span class="o">=</span> <span class="m">8300</span><span class="o">)</span>: ef00
Changed <span class="nb">type</span> of partition to <span class="s1">&#39;EFI System&#39;</span>

Command <span class="o">(</span>? <span class="k">for</span> <span class="nb">help</span><span class="o">)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="o">(</span>Y/N<span class="o">)</span>: y
OK<span class="p">;</span> writing new GUID partition table <span class="o">(</span>GPT<span class="o">)</span> to uefi.img.
Warning: The kernel is still using the old partition table.
The new table will be used at the next reboot.
The operation has completed successfully.
</pre></div>
<p>Now you have disk image with <a href="GPT" title="GPT">GUID partition table</a> on it and an unformatted EFI partition starting at sector 2048. Unless you deviated from the commands shown above, the disk image will use 512-byte sectors, so the EFI partition starts at byte 1,048,576 and is 46,934,528 bytes in length. Use losetup to present the partition to Linux on a loopback device.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>losetup --offset <span class="m">1048576</span> --sizelimit <span class="m">46934528</span> /dev/loop0 /path/to/uefi.img
</pre></div>
<p>(If /dev/loop0 is already in use you will need to select a different loopback device.)
</p><p>Format the partition for FAT32 with mkdosfs.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>mkdosfs -F <span class="m">32</span> /dev/loop0
</pre></div>
<p>The partition can now be mounted, so that we can copy files to it. In this example we use the "/mnt" directory, but you could also create a local directory for temporary use.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>mount /dev/loop0 /mnt
</pre></div>
<p>Copy any UEFI applications you want to test to the file system.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ cp /path/to/main.efi /mnt/
$ ...
</pre></div>
<p>Finally, unmount the partition and free the loopback device.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ umount /mnt
$ losetup -d /dev/loop0
</pre></div>
<p><i>uefi.img</i> is now a disk image containing primary and secondary GPT tables, containing a single partition of type EFI, containing a FAT32 file system, containing one or more UEFI applications.
</p>
<h4><span id="Linux.2C_root_not_required"></span><span class="mw-headline" id="Linux,_root_not_required">Linux, root not required</span></h4>
<p>This approach uses <b>parted</b>, <b>mformat</b>, and <b>mcopy</b> and can be performed with user privileges. First, use parted to create primary and secondary GPT headers, and a single EFI partition spanning the same range as the approach above.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ parted /path/to/uefi.img -s -a minimal mklabel gpt
$ parted /path/to/uefi.img -s -a minimal mkpart EFI FAT16 2048s 93716s
$ parted /path/to/uefi.img -s -a minimal toggle <span class="m">1</span> boot
</pre></div>
<p>Now create a new temporary image file that will contain the EFI partition data and use mformat to format it with FAT16.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/tmp/part.img <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">91669</span>
mformat -i /tmp/part.img -h <span class="m">32</span> -t <span class="m">32</span> -n <span class="m">64</span> -c <span class="m">1</span>
</pre></div>
<p>Use mcopy to copy any UEFI applications you want to test to the file system.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ mcopy -i /tmp/part.img /path/to/main.efi&#160;::
$ ...
</pre></div>
<p>Finally, write the partition image into the main disk image.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ dd <span class="k">if</span><span class="o">=</span>/tmp/part.img <span class="nv">of</span><span class="o">=</span>/path/to/uefi.img <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">91669</span> <span class="nv">seek</span><span class="o">=</span><span class="m">2048</span> <span class="nv">conv</span><span class="o">=</span>notrunc
</pre></div>
<p><i>uefi.img</i> is now a disk image containing primary and secondary GPT tables, containing a single partition of type EFI, containing a FAT16 file system, containing one or more UEFI applications.
</p>
<h4><span id="FreeBSD.2C_root_required"></span><span class="mw-headline" id="FreeBSD,_root_required">FreeBSD, root required</span></h4>
<p>This approach requires root privileges and uses <b>mdconfig</b>, <b>gpart</b>, <b>newfs_msdos</b>, and <b>mount_msdosfs</b>. First, create a device node that presents the zeroed disk image as a block device. This will let us work on it using standard partitioning and formatting tools.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ mdconfig -f /path/to/uefi.img
md0
</pre></div>
<p>In this example the new block device is <i>md0</i>. Now create the empty primary and secondary GPT tables on the device.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ gpart create -s GPT md0
md0 created
</pre></div>
<p>Now we can add a partition to the disk. We'll specify an "EFI" partition, which just means that GPT will set that partition's GUID to the special "EFI" type. Not all BIOSs require this, and the partition will still be able to be mounted and browsed normally on Linux, FreeBSD, and Windows.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ gpart add -t efi md0
md0p1 added
</pre></div>
<p>Next, create a FAT16 file system on the new partition. You can specify various parameters for the file system if you'd like, but it isn't necessary. Ideally you would create a FAT32 partition for best firmware compatibility but FreeBSD seems to create FAT32 partitions that OVMF can't read.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ newfs_msdos -F <span class="m">16</span> md0p1
newfs_msdos: trim <span class="m">2</span> sectors to adjust to a multiple of <span class="m">9</span>
/dev/md2p1: <span class="m">93552</span> sectors <span class="k">in</span> <span class="m">11694</span> FAT16 clusters <span class="o">(</span><span class="m">4096</span> bytes/cluster<span class="o">)</span>
<span class="nv">BytesPerSec</span><span class="o">=</span><span class="m">512</span> <span class="nv">SecPerClust</span><span class="o">=</span><span class="m">8</span> <span class="nv">ResSectors</span><span class="o">=</span><span class="m">1</span> <span class="nv">FATs</span><span class="o">=</span><span class="m">2</span> <span class="nv">RootDirEnts</span><span class="o">=</span><span class="m">512</span> <span class="nv">Media</span><span class="o">=</span>0xf0 <span class="nv">FATsecs</span><span class="o">=</span><span class="m">46</span> <span class="nv">SecPerTrack</span><span class="o">=</span><span class="m">9</span> <span class="nv">Heads</span><span class="o">=</span><span class="m">16</span> <span class="nv">HiddenSecs</span><span class="o">=</span><span class="m">0</span> <span class="nv">HugeSectors</span><span class="o">=</span><span class="m">93681</span>
</pre></div>
<p>The partition can now be mounted, so that we can copy files to it. In this example we use the <i>/mnt</i> directory, but you could also create a local directory for temporary use.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ mount_msdosfs /dev/md0p1 /mnt
</pre></div>
<p>Copy any UEFI applications you want to test to the file system.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ cp /path/to/main.efi /mnt/
$ ...
</pre></div>
<p>Finally, unmount the partition and free the block device.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ umount /mnt
$ mdconfig -d -u md0
</pre></div>
<p><i>uefi.img</i> is now a disk image containing primary and secondary GPT tables, containing a single partition of type EFI, containing a FAT16 file system, containing one or more UEFI applications.
</p>
<h4><span id="Mac_OS_.28root_not_required.29"></span><span class="mw-headline" id="Mac_OS_(root_not_required)">Mac OS (root not required)</span></h4>
<p>Mac OS has a single tool (hdiutil) that creates the disk image and copy files at same time.
</p><p>Let's say that you're creating a UEFI boot for x86_64. By definition the file name should be BOOTX64.EFI and this file should be located in the /EFI/BOOT folder.
</p><p>First, let's create a temporary folder that will contains all files and folders required for booting UEFI.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ mkdir -p diskImage/EFI/BOOT
</pre></div>
<p>Secondly, let's copy the boot application to the required location:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ cp bootx64.efi diskImage/EFI/BOOT/BOOTX64.EFI
</pre></div>
<p>Finally, let's create a disk image partitioned with GPT, formatted with fat32 (-fs fat32), overriding destination file if needed (-ov), define disk size (-size 48m), define volume name (-volname NEWOS), the file format which the disk will be encoded (-format UDTO - the same used for DVDs/CDs) and the source folder containing the files that will be copied to the new disk:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ hdiutil create -fs fat32 -ov -size 48m -volname NEWOS -format UDTO -srcfolder diskImage uefi.cdr
</pre></div>
<p>uefi.cdr should be ready to be used by QEMU.
</p>
<h3><span class="mw-headline" id="Launching_UEFI_applications">Launching UEFI applications</span></h3>
<p>Once your disk image is ready, you can invoke QEMU as below.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ qemu-system-x86_64 -cpu qemu64 -bios /path/to/OVMF.fd -drive <span class="nv">file</span><span class="o">=</span>uefi.disk,if<span class="o">=</span>ide
</pre></div>
<p>When OVMF drops into the UEFI shell, you will see an additional entry in the "Mapping table", labeled "FS0". This indicates that the firmware detected the disk, discovered the partition, and was able to mount the file system. You can explore the file system by switching to it using the DOS-style syntax "FS0:", as illustrated below.
</p><p><a href="./File:OVMF_browse_fs.png" class="image"><img alt="OVMF browse fs.png" src="images/7/7f/OVMF_browse_fs.png" decoding="async" width="669" height="396" data-file-width="669" data-file-height="396" /></a>
</p><p>You can launch a UEFI application by entering its name.
</p><p><a href="./File:OVMF_run_app.png" class="image"><img alt="OVMF run app.png" src="images/f/fe/OVMF_run_app.png" decoding="async" width="669" height="397" data-file-width="669" data-file-height="397" /></a>
</p><p>Notice that the UEFI shell resumed once the application terminated. Of course if this was a proper bootloader it would never resume, but rather launch an OS.
</p><p>Some commercial UEFI firmware provides UEFI shells or the capability to launch user-selected UEFI applications, such as the firmware that ships with the HP EliteBook line of laptops. Most, however, do not expose this functionality to the end-user.
</p>
<h3><span class="mw-headline" id="Debugging">Debugging</span></h3>
<p>OVMF can be built in debug mode, and it will output logging messages to IO port 0x402.
You can use some flags like the ones below to capture the output.
</p><p><code>-debugcon file:uefi_debug.log -global isa-debugcon.iobase=0x402</code>
</p><p>Note that release builds will not output debug messages, or will have reduced output.
</p><p>See <a href="Debugging_UEFI_applications_with_GDB" title="Debugging UEFI applications with GDB">Debugging UEFI applications with GDB</a>.
</p>
<h2><span class="mw-headline" id="Running_on_real_hardware">Running on real hardware</span></h2>
<h3><span class="mw-headline" id="NVRAM_variables">NVRAM variables</span></h3>
<dl><dd><i>Main article:</i> <a href="UEFI_NVRAM" title="UEFI NVRAM">UEFI NVRAM</a></dd></dl>
<p>A UEFI firmware will present most of its configuration options through a text or graphical configuration menu, just like a legacy BIOS. Selections made in these menus are stored in the NVRAM chip between reboots. Unlike legacy BIOS, however, the firmware developer has the option to expose some or all of these "NVRAM variables" to the OS and end-user via convenience functions made resident in RAM by the firmware at boot.
</p><p>The Linux <b>efivarfs</b> kernel module will use these functions to list NVRAM variables in the <i>/sys/firmware/efi/efivars</i> file. NVRAM variables can also be dumped from within the UEFI shell itself with the <b>dmpstore</b> command. Device boot order is always accessible via NVRAM variables. The Linux program <b>efibootmgr</b> works specifically with the boot order NVRAM variables. The UEFI shell offers the <b>bcfg</b> command for the same purpose.
</p>
<h3><span class="mw-headline" id="Bootable_UEFI_applications">Bootable UEFI applications</span></h3>
<p>The boot order NVRAM variables determine where firmware will look for UEFI applications to be launched at boot. Although this can be changed (for example, an OS installer might customize the boot entry for the hard drive to which it was installed) firmware typically looks for a UEFI application named "BOOTIA32.efi" (for 32-bit applications) or "BOOTX64.efi" (for 64-bit applications) stored in the "/EFI/BOOT" path in the boot device's file system. This is the default path and name for OVMF.
</p><p>Unlike a UEFI application launched from the shell, if a bootable UEFI application returns BIOS will continue searching for other boot devices.
</p>
<h3><span class="mw-headline" id="Exposed_functionality">Exposed functionality</span></h3>
<p>Real PCs vary in the amount of UEFI capability they expose to the user. For example, even a class 3 machine may not make any mention of UEFI in its BIOS configuration and may not offer a UEFI shell. Additionally, some BIOS vendors make their UEFI firmware configuration screens look identical to their legacy BIOS configuration screens. Class 2 machines may present somewhat confusing boot menus and configuration options. For example, one laptop manufacturer includes a configuration option to enable/disable UEFI (i.e. switch between UEFI and CSM behavior), named "OS: Windows 8". Another laptop, if it fails to find a bootable UEFI application on the selected boot device (or if that application returns a status other than EFI_SUCCESS) will fall back to CSM behavior and then complain that the drive has a corrupted MBR. With time, and with the emergence of class 3 machines, clarity of UEFI boot behavior will improve.
</p><p>To make testing on real hardware easier, you can install a bootable UEFI application to the internal hard drive of the system that provides a boot menu, such as <a rel="nofollow" class="external text" href="http://www.rodsbooks.com/refind/">rEFInd</a>. This may also be convenient for multi-boot scenarios.
</p>
<h3><span class="mw-headline" id="PC_firmware_developers">PC firmware developers</span></h3>
<p>On x86 and x86-64 platforms, the following BIOS developers offer UEFI firmware:
</p>
<ul><li>AMI (Aptio).</li>
<li>Phoenix (SecureCore, TrustedCore, AwardCore).</li>
<li>Insyde (InsydeH20).</li></ul>
<h2><span class="mw-headline" id="UEFI_applications_in_detail">UEFI applications in detail</span></h2>
<h3><span class="mw-headline" id="Binary_Format">Binary Format</span></h3>
<p>UEFI executables are regular PE32 / PE32+ (Windows x32 / x64) images, with a specific <b>subsystem</b>.
Every UEFI application is basically a windows EXE (or DLL) without symbol tables.
</p>
<table class="wikitable">
<caption>Types of UEFI images
</caption>
<tbody><tr>
<th>Type
</th>
<th>Description
</th>
<th>Subsystem
</th></tr>
<tr>
<td>Applications</td>
<td>OS loaders and other utility programs.</td>
<td>10
</td></tr>
<tr>
<td>Boot service driver</td>
<td>Drivers used by the firmware when booting (e.g. disk drivers, network drivers).</td>
<td>11
</td></tr>
<tr>
<td>Runtime driver</td>
<td>Drivers which may stay loaded even after the OS loads and exits the boot services.</td>
<td>12
</td></tr></tbody></table>
<p>UEFI images must also specify the type of machine code they contain. A UEFI loader will refuse to boot an incompatible image.
</p>
<table class="wikitable">
<caption>Types of machines
</caption>
<tbody><tr>
<th>Name / arch
</th>
<th>Value
</th></tr>
<tr>
<td>x86</td>
<td>0x014c
</td></tr>
<tr>
<td>x86_64</td>
<td>0x8664
</td></tr>
<tr>
<td>Itanium x64</td>
<td>0x0200
</td></tr>
<tr>
<td>UEFI Byte Code</td>
<td>0x0EBC
</td></tr>
<tr>
<td>ARM<sup>1</sup></td>
<td>0x01C2
</td></tr>
<tr>
<td>AArch (ARM x64)</td>
<td>0xAA64
</td></tr>
<tr>
<td>RISC-V x32</td>
<td>0x5032
</td></tr>
<tr>
<td>RISC-V x64</td>
<td>0x5064
</td></tr>
<tr>
<td>RISC-V x128</td>
<td>0x5128
</td></tr></tbody></table>
<p>[1] ARM means you can use Thumb / Thumb 2 instructions, but UEFI interfaces are in ARM mode.
</p>
<h4><span class="mw-headline" id="Initialization">Initialization</span></h4>
<p>Applications must either load an OS and exit boot services, or return from the main function (in which case the boot loader will look for the next app to load).
</p><p>Drivers must initialize and then return 0 on success, or an error code. A computer might fail to boot if a required driver fails to load.
</p>
<h4><span class="mw-headline" id="Memory">Memory</span></h4>
<p>The memory map returned by UEFI will mark the memory areas which drivers use.
</p><p>Once your OS loader finished, your kernel is allowed to reuse the memory where the boot loader was loaded.
</p><p>The memory types are <code>Efi{Loader/BootServices/RuntimeServices}{Code/Data}</code>.
</p><p>After exiting the boot services, you may reuse whatever non-read-only memory the boot drivers used.
</p><p>However, memory used by the runtime drivers must <b>never</b> be touched - the runtime drivers stay active and loaded for as long as the computer runs.
</p><p>
One way to see a breakdown of a PE file containing a UEFI application is by</p><div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>$ objdump --all-headers /path/to/main.efi
</pre></div>
<p>Its output is quite long. Among other things, it shows the <b>subsystem</b>, that is the type of the UEFI image, mentioned earlier.
</p>
<h3><span class="mw-headline" id="Calling_Conventions">Calling Conventions</span></h3>
<p>UEFI specifies the following calling conventions:
</p>
<ul><li><b>cdecl</b> for x86 UEFI functions</li>
<li><b>Microsoft's 64-bit calling convention</b> for x86-64 UEFI functions</li>
<li><b>SMC</b> for ARM UEFI functions</li></ul>
<p>This has two impacts on UEFI application developers:
</p>
<ul><li>A UEFI application's main entry point must expect to be called with the corresponding calling convention.</li>
<li>Any UEFI-provided functions that a UEFI application calls must be called with the corresponding calling convention.</li></ul>
<p>Note that functions strictly internal to the application can use whatever calling convention the developer chooses.
</p>
<h4><span id="POSIX-UEFI.2C_GNU-EFI_and_GCC"></span><span class="mw-headline" id="POSIX-UEFI,_GNU-EFI_and_GCC">POSIX-UEFI, GNU-EFI and GCC</span></h4>
<dl><dd><i>Main article:</i> <a href="GNU-EFI" title="GNU-EFI">GNU-EFI</a></dd></dl>
<p>cdecl is the standard calling convention used by GCC, so no special attributes or modifiers are needed for writing the main entry point or calling UEFI functions in an x86 UEFI application developed with GNU-EFI. For x86-64, however, the entry point function must be declared with the "___attribute___((ms_abi))" modifier and all calls to UEFI-provided functions must be made through the "uefi_call_wrapper" thunk. This thunk is called with cdecl, but then translates to the Microsoft x86-64 calling convention before calling the requested UEFI function. This is necessary because older releases of GCC do not support specifying calling conventions for function pointers.
</p><p>For <a href="POSIX-UEFI" title="POSIX-UEFI">POSIX-UEFI</a>, which also uses GCC, your entry point looks like the standard main(), and no special ABI is required. Also the build environment takes care of the compiler flags for you, so you can simply call UEFI functions without "uefi_call_wrapper", no matter if you're using the host gcc or a cross-compiler.
</p><p>For developer convenience, both POSIX-UEFI and GNU-EFI provides the "EFIAPI" macro, which expands to "cdecl" when targeting x86 and "__attribute__(ms_abi))" when targeting x86-64. Additionally, the "uefi_call_wrapper" thunk will simply pass the call through on x86. This allows the same source code to target x86 and x86-64. For example, the following main function will compile with the correct calling convention on both x86 and x86-64 and the call through the "uefi_call_wrapper" thunk will select the correct calling convention to use when calling the UEFI function (in this case, printing a string).
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">EFI_STATUS</span><span class="w"> </span><span class="n">EFIAPI</span><span class="w"> </span><span class="n">efi_main</span><span class="p">(</span><span class="n">EFI_HANDLE</span><span class="w"> </span><span class="n">ImageHandle</span><span class="p">,</span><span class="w"> </span><span class="n">EFI_SYSTEM_TABLE</span><span class="w"> </span><span class="o">*</span><span class="n">SystemTable</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">EFI_STATUS</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uefi_call_wrapper</span><span class="p">(</span><span class="n">SystemTable</span><span class="o">-&gt;</span><span class="n">ConOut</span><span class="o">-&gt;</span><span class="n">OutputString</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">SystemTable</span><span class="o">-&gt;</span><span class="n">ConOut</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="sa">L</span><span class="s">&quot;Hello, World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Language_binding">Language binding</span></h3>
<p>UEFI applications are typically written in C, although bindings could be written for any other language that compiles to machine code. Assembly is also an option; a <a href="Uefi.inc" title="Uefi.inc">uefi.inc</a> is available for <a href="FASM" title="FASM">FASM</a> that allows UEFI applications to be written as below.
</p>
<div class="mw-highlight mw-highlight-lang-asm mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">format</span><span class="w"> </span><span class="no">pe64</span><span class="w"> </span><span class="no">dll</span><span class="w"> </span><span class="no">efi</span><span class="w"></span>
<span class="nf">entry</span><span class="w"> </span><span class="no">main</span><span class="w"></span>

<span class="nf">section</span><span class="w"> </span><span class="err">&#39;</span><span class="no">.text</span><span class="err">&#39;</span><span class="w"> </span><span class="no">code</span><span class="w"> </span><span class="no">executable</span><span class="w"> </span><span class="no">readable</span><span class="w"></span>

<span class="nf">include</span><span class="w"> </span><span class="err">&#39;</span><span class="no">uefi.inc</span><span class="err">&#39;</span><span class="w"></span>

<span class="nl">main:</span><span class="w"></span>
<span class="w">    </span><span class="c1">; initialize UEFI library</span>
<span class="w">    </span><span class="nf">InitializeLib</span><span class="w"></span>
<span class="w">    </span><span class="nf">jc</span><span class="w"> </span><span class="err">@</span><span class="no">f</span><span class="w"></span>

<span class="w">    </span><span class="c1">; call uefi function to print to screen</span>
<span class="w">    </span><span class="nf">uefi_call_wrapper</span><span class="w"> </span><span class="no">ConOut</span><span class="p">,</span><span class="w"> </span><span class="no">OutputString</span><span class="p">,</span><span class="w"> </span><span class="no">ConOut</span><span class="p">,</span><span class="w"> </span><span class="no">_hello</span><span class="w"></span>

<span class="err">@@:</span><span class="w"> </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">EFI_SUCCESS</span><span class="w"></span>
<span class="w">    </span><span class="nf">retn</span><span class="w"></span>

<span class="nf">section</span><span class="w"> </span><span class="err">&#39;</span><span class="no">.data</span><span class="err">&#39;</span><span class="w"> </span><span class="no">data</span><span class="w"> </span><span class="no">readable</span><span class="w"> </span><span class="no">writeable</span><span class="w"></span>

<span class="nf">_hello</span><span class="w">                                  </span><span class="no">du</span><span class="w"> </span><span class="err">&#39;</span><span class="no">Hello</span><span class="w"> </span><span class="no">World</span><span class="err">&#39;</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="w"></span>

<span class="nf">section</span><span class="w"> </span><span class="err">&#39;</span><span class="no">.reloc</span><span class="err">&#39;</span><span class="w"> </span><span class="no">fixups</span><span class="w"> </span><span class="no">data</span><span class="w"> </span><span class="no">discardable</span><span class="w"></span>
</pre></div>
<p>As a UEFI application contains normal x86 or x86-64 machine code, inline assembly is also an option in compilers that support it.
</p>
<h3><span class="mw-headline" id="EFI_Byte_Code">EFI Byte Code</span></h3>
<p>UEFI also includes a virtual machine specification based on a byte code format called EFI Byte Code (EBC), which can be used to write platform-independent device drivers, but not UEFI applications. As of 2015 there has been limited use of EBC.
</p>
<h2><span class="mw-headline" id="Common_Problems">Common Problems</span></h2>
<h3><span id="My_UEFI_application_hangs.2Fresets_after_about_5_minutes"></span><span class="mw-headline" id="My_UEFI_application_hangs/resets_after_about_5_minutes">My UEFI application hangs/resets after about 5 minutes</span></h3><p>
When control is handed to your UEFI application by firmware, it sets a watchdog timer for 5 minutes, after which the firmware is reinvoked as it assumes your application has hung.  The firmware in this case will normally try to reset the system (although the OVMF firmware in VirtualBox simply causes the screen to go black and hang).  To counteract this, you are required to refresh the watchdog timer before it times out.  Alternatively, you can disable it completely with code like </p><div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">SystemTable</span><span class="o">-&gt;</span><span class="n">BootServices</span><span class="o">-&gt;</span><span class="n">SetWatchdogTimer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
</pre></div><p>Obviously this is not a problem for most bootloaders, but can cause an issue if you have an interactive loader which waits for user input.  Also note that you are required to disable the watchdog timer if you exit back to the firmware.
</p><h3><span class="mw-headline" id="My_bootloader_hangs_if_I_use_user_defined_EFI_MEMORY_TYPE_values">My bootloader hangs if I use user defined EFI_MEMORY_TYPE values</span></h3>
<p>For the memory management functions in EFI, an OS is meant to be able to use "memory type" values above 0x80000000 for its own purposes. In the OVMF EFI firmware release "r11337" (for Qemu, etc) there is a bug where the firmware assumes the memory type is within the range of values defined for EFI's own use, and uses the memory type as an array index. The end result is an "array index out of bounds" bug; where the higher memory type values (e.g. perfectly legal values above 0x80000000) cause the 64-bit version of the firmware to crash (page fault), and cause incorrect "attribute" values to be reported by the 32-bit version of the firmware. This same bug is also present in whatever version of the EFI firmware VirtualBox uses (which looks like an older version of OVMF); and I suspect (but don't know) that the bug may be present in a wide variety of firmware that was derived from the tianocore project (not just OVMF).
</p>
<h2><span class="mw-headline" id="See_also">See also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="UEFI_Bare_Bones" class="mw-redirect" title="UEFI Bare Bones">UEFI Bare Bones</a></li>
<li><a href="EFI_System_Partition" title="EFI System Partition">EFI System Partition</a></li>
<li><a href="PE" title="PE">PE</a> file format</li>
<li><a href="EDK2" title="EDK2">EDK2</a></li>
<li><a href="POSIX-UEFI" title="POSIX-UEFI">POSIX-UEFI</a></li>
<li><a href="GNU-EFI" title="GNU-EFI">GNU-EFI</a></li>
<li><a rel="nofollow" class="external text" href="https://github.com/nebulaeonline/nebulae/tree/UefiBarebones">Uefi Barebones MSVC/Clang/Visual Studio</a></li></ul>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="https://uefi.org/specifications">UEFI specifications et al.</a></li>
<li><a rel="nofollow" class="external text" href="http://www.tianocore.org/">Intel TianoCore EDK2</a></li>
<li><a rel="nofollow" class="external text" href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">OVMF firmware images</a> for use with <a href="QEMU" title="QEMU">QEMU</a></li>
<li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20181028201454/http://wiki.phoenix.com/wiki/index.php/Main_Page">Phoenix UEFI Wiki</a></li>
<li><a rel="nofollow" class="external text" href="http://x86asm.net/articles/others/index.html">Several articles about UEFI</a></li>
<li><a rel="nofollow" class="external text" href="https://www.microsoft.com/en-us/download/details.aspx?id=19509">PE specification covering the (U)EFI binary format</a></li>
<li><a rel="nofollow" class="external text" href="https://uefi.blogspot.com/">Blog about UEFI, with bits about UEFI development</a></li>
<li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20160316192235/http://internshipatdell.wikispaces.com/file/view/How+to+build+an+UEFI+application.pptx">Presentation guiding through simple UEFI application setup</a></li>
<li><a rel="nofollow" class="external text" href="https://uefi.org/sites/default/files/resources/UEFI-Plugfest-WindowsBootEnvironment.pdf">Presentation giving an overview of windows uefi booting</a></li>
<li><a rel="nofollow" class="external text" href="https://gitlab.com/bztsrc/posix-uefi">POSIX-UEFI</a> documentation and source</li>
<li><a href="https://wikipedia.org/wiki/Extensible_Firmware_Interface" class="extiw" title="wikipedia:Extensible Firmware Interface">Wikipedia Article on EFI</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250212005401
Cache expiry: 86400
Reduced expiry: false
Complications: [showtoc]
CPU time usage: 0.174 seconds
Real time usage: 4.466 seconds
Preprocessor visited node count: 346/1000000
Postexpand include size: 63/2097152 bytes
Template argument size: 17/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 21594/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  138.261      1 -total
  0.71%    0.977      2 Template:Main
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2924-0!canonical and timestamp 20250212005356 and revision id 29353.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=UEFI&amp;oldid=29353">https://wiki.osdev.org/index.php?title=UEFI&amp;oldid=29353</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:X86" title="Category:X86">X86</a></li><li><a href="./Category:X86-64" title="Category:X86-64">X86-64</a></li><li><a href="./Category:ARM" title="Category:ARM">ARM</a></li><li><a href="./Category:Firmware" title="Category:Firmware">Firmware</a></li><li><a href="./Category:UEFI" title="Category:UEFI">UEFI</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=UEFI" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="UEFI#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="UEFI" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:UEFI" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="UEFI"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=UEFI&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=UEFI&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/UEFI" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="./Special:RecentChangesLinked/UEFI" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=UEFI&amp;oldid=29353" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=UEFI&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/Unified_Extensible_Firmware_Interface" title="Unified Extensible Firmware Interface  Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 29 January 2025, at 17:42.</li>
	<li id="footer-info-0">This page has been accessed 52,141 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=UEFI&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.174","walltime":"4.466","ppvisitednodes":{"value":346,"limit":1000000},"postexpandincludesize":{"value":63,"limit":2097152},"templateargumentsize":{"value":17,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":21594,"limit":5000000},"timingprofile":["100.00%  138.261      1 -total","  0.71%    0.977      2 Template:Main"]},"cachereport":{"timestamp":"20250212005401","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":94});});</script>
</body>
</html>