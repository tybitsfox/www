<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Double Buffering - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"dfd980fe5a6fc27271bd11a5","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Double_Buffering","wgTitle":"Double Buffering","wgCurRevisionId":28579,"wgRevisionId":28579,"wgArticleId":2489,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using duplicate arguments in template calls","Pages using deprecated source tags","Level 1 Tutorials","Video"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Double_Buffering","wgRelevantArticleId":2489,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,
"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head","mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Double_Buffering rootpage-Double_Buffering skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Double Buffering</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="Double_Buffering#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="Double_Buffering#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><table style="font-size:95%; line-height:1.5em; padding:0.25em; float:right; margin: 0 0 8px 15px; clear:right; border:1px solid #aaaaaa; background:#eee; text-align:center;;"><tbody><tr><th>Difficulty level</th></tr><tr><td><a href="./File:Difficulty_1.png" class="image"><img alt="Difficulty 1.png" src="images/d/d3/Difficulty_1.png" decoding="async" width="46" height="14" data-file-width="46" data-file-height="14" /></a><br />Beginner</td></tr></tbody></table>
<p>Double-buffering is a term that is well known throughout the graphics industry. Most applications (primarily games) seldom work without it as it has many advantages over single-buffering (but also has a few disadvantages).
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Double_Buffering#What_Is_It?"><span class="tocnumber">1</span> <span class="toctext">What Is It?</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="Double_Buffering#The_Buffers"><span class="tocnumber">1.1</span> <span class="toctext">The Buffers</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="Double_Buffering#Where_To_Write_To"><span class="tocnumber">1.2</span> <span class="toctext">Where To Write To</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="Double_Buffering#What_Actually_Is_Seen"><span class="tocnumber">1.3</span> <span class="toctext">What Actually Is Seen</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="Double_Buffering#Important_Note"><span class="tocnumber">1.4</span> <span class="toctext">Important Note</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="Double_Buffering#Example"><span class="tocnumber">1.5</span> <span class="toctext">Example</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="Double_Buffering#Advantages"><span class="tocnumber">2</span> <span class="toctext">Advantages</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="Double_Buffering#Disadvantages"><span class="tocnumber">3</span> <span class="toctext">Disadvantages</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="Double_Buffering#Memory_requirement"><span class="tocnumber">3.1</span> <span class="toctext">Memory requirement</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="Double_Buffering#Speed"><span class="tocnumber">3.2</span> <span class="toctext">Speed</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="Double_Buffering#Tearing"><span class="tocnumber">3.3</span> <span class="toctext">Tearing</span></a>
<ul>
<li class="toclevel-3 tocsection-12"><a href="Double_Buffering#Vertical_Synchronization"><span class="tocnumber">3.3.1</span> <span class="toctext">Vertical Synchronization</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="Double_Buffering#Triple_buffering"><span class="tocnumber">3.3.2</span> <span class="toctext">Triple buffering</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="Double_Buffering#Something_unique?"><span class="tocnumber">3.3.3</span> <span class="toctext">Something unique?</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-15"><a href="Double_Buffering#Examples"><span class="tocnumber">4</span> <span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="Double_Buffering#Buffer_creation"><span class="tocnumber">4.1</span> <span class="toctext">Buffer creation</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="Double_Buffering#Double_buffering"><span class="tocnumber">4.2</span> <span class="toctext">Double buffering</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span id="What_Is_It.3F"></span><span class="mw-headline" id="What_Is_It?">What Is It?</span></h2>
<h4><span class="mw-headline" id="The_Buffers">The Buffers</span></h4>
<p>Double-buffering possibly sounds harder than it actually is. In theory, you have a buffer A and a buffer B, which are usually respectively called the front-and back-buffer. On single-buffered displays, you draw straight to video memory, so suppose video memory is located at address <code>0xB8000</code> (like console video memory is), you just start modifying values starting from this address (as you probably know) to show characters on the screen. If you would do this with double-buffering (which isn't a very good idea with console video memory, by the way), <code>0xB8000</code> would represent buffer A (the front-buffer) whilst buffer B is created and allocated by your favourite <code>malloc</code> function (or <code>new[]</code> operator).
</p>
<h4><span class="mw-headline" id="Where_To_Write_To">Where To Write To</span></h4>
<p>Instead of writing directly to console video memory (at <code>0xB8000</code>), you write everything to the address where Buffer B is located. The process of drawing characters is exactly the same as before, except you're now writing to another memory address.
When you're done drawing, you copy the contents of the back buffer (buffer B) to the front buffer (buffer A). This process is commonly called 'swapping the buffers', though swapping isn't interpreted as switching the contents around, but more of in 'switching the order of the buffers'. By 'swapping the buffers', the back buffer is now seen by the user and carries the same pixel values as the front buffer. The back buffer can then be freely modified again until ready to be then swapped again.
</p>
<h4><span class="mw-headline" id="What_Actually_Is_Seen">What Actually Is Seen</span></h4>
<p>When using double-buffering, the user is looking at Buffer A while you're drawing to Buffer B. When using single-buffering, the user is looking at buffer A at the same time you're modifying that buffer. So that means the user doesn't see any pixels being modified when they are looking at the screen. They will notice the changes as soon as you swap the buffers.
</p>
<h4><span class="mw-headline" id="Important_Note">Important Note</span></h4>
<p>I used console video memory as an example here, as practically every OS developer knows how to use this, but it is still not recommended to use double-buffering on a console display, as it is practically useless and wastes memory (unless you're using some kind of game loop for your OS). Double-buffering can be very useful when you're building your own GUI though. On console displays, you usually also don't need double-buffering since there are no problems with artifacts.
</p>
<h4><span class="mw-headline" id="Example">Example</span></h4>
<p>For example, without double buffering consider a simple game rendering like the following:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">running</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* update input */</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* update game logic */</span><span class="w"></span>

<span class="w">        </span><span class="n">clear_screen</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">draw_background</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">draw_levels</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">draw_picksup</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">draw_characters</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Now imagine if each of those functions drew directly to the frame buffer. The video card and monitor may update just after you have drawn the background, or it may update just after you have cleared the screen. More likely, you're going to end up with a combination of effects with resulting in your screen flickering and seeing through objects.
</p><p>Now imagine if each of these functions drew to a secondary buffer the size of the frame buffer. Each time you modify a pixel it won't be writing directly to the video card. Instead, after <code>draw_characters()</code> you would call:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">memcpy</span><span class="p">(</span><span class="n">framebuffer</span><span class="p">,</span><span class="w"> </span><span class="n">backbuffer</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bytesperpixel</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>so the final image in its entirety is sent to the frame buffer, not just parts of it.
</p>
<h2><span class="mw-headline" id="Advantages">Advantages</span></h2>
<p>Now why would you want to use double-buffering over single buffering in e.g. your GUI, games, or video displays? Well, the main advantages of double-buffering are:
</p>
<ul><li>The user does not see every pixel modification (so if the same pixel gets modified 5 times, the user will only see the last one). This helps preventing 'flickering' (or screen flashes).</li>
<li>Double-buffering usually takes care of artifacts you or the user might be experiencing.</li>
<li>Writing to video memory is only performed once, on the buffer swap, instead of repeatedly for every pixel of which some might be overlapped later and might be invisible.</li>
<li>Some use cases (e.g. scrolling text, writing transparent pixels, etc) require reading previously written pixels. With double buffering, you use the front buffer instead of the back buffer. Reading from the video memory is much slower than reading from main memory.</li></ul>
<h2><span class="mw-headline" id="Disadvantages">Disadvantages</span></h2>
<p>Even though double-buffering is useful, it also has negative characteristics. Each is listed with an explanation and a possible solution.
</p>
<h3><span class="mw-headline" id="Memory_requirement">Memory requirement</span></h3>
<p>You need to create a second buffer with the same size of the video memory (and for large displays such as 1280x1024x32 this can be an expensive cost).
</p><p>This is more of an issue on embedded and older systems with limited memory. In the example of 1280x1024x32, this would mean your application or video driver would need to allocate an extra 5 megabytes, which isn't an expensive once off cost in a modern system that has between several hundred megabytes to several gigabytes of memory.
</p><p>Also, virtually every modern desktop computer has a dedicated graphics accelerator card which has its own inbuilt memory. While older graphics cards may only have 8MB, many newer high-end models can have close to several gigabytes. This is more than sufficient to store the back buffer in, as well as being optimized for this purpose. An OS should allow the video driver to allocate and manage the double buffer since each graphics vendor will usually have their own implementation.
</p><p>Note that the buffer doesn't always have to have the same size as the video memory, there are also other ways to do double-buffering, for one you could also have some sort of fast run-length encoded compression system. Then again, that would have an extra performance cost if not done efficiently.
</p><p>You don't have to double buffer the entire screen. For example, if only part of the screen is constantly updating (the output of a media program or a video game) then only that section of the screen needs to be double buffered and the rest of the screen can be drawn directly to the front buffer. This method saves both memory and performance.
</p>
<h3><span class="mw-headline" id="Speed">Speed</span></h3>
<p>You need to copy the back buffer to the front buffer every time the buffer needs to be swapped (in games with a frame-rate of 30, 30 times each second). So better make sure your <code>memcpy</code> and other memory functions are optimized!
</p><p>However, some graphics cards have the ability to specify the address in memory where the buffer used for rendering is stored. If you're redrawing the entire scene each frame (which is often the case when rendering video or 3D), you simply need to swap two pointers (the pointer to the buffer you're drawing to, and the pointer to the buffer being drawn on screen).
</p>
<h3><span class="mw-headline" id="Tearing">Tearing</span></h3>
<p>Tearing (<a rel="nofollow" class="external text" href="https://web.archive.org/web/20070321063820/http://www.nhancer.com/help/images/VSync.jpg">example image</a>) is an artifact when the buffer is being updated while the graphics card and monitor are midway through updating the screen. The side effect is that parts of multiple frames end up being sent to the monitor at the same time. Tearing is most noticeable at animation at extremely high frame rates (100fps+) with low refresh rates (60Hz) and less noticeable vice versa, though it happens whenever the refresh rate does not match the frame rate.
</p><p>Tearing can usually be ignored in general applications (office suites, web browsers, terminals) since the entire screen isn't constantly being updated. However, it still occurs, for example dragging a window around fast in a window manager that does not account for tearing (<a rel="nofollow" class="external text" href="https://web.archive.org/web/20120102123417/http://yfrog.com/j1nouveauwindowmovep">example</a>).
</p>
<h4><span class="mw-headline" id="Vertical_Synchronization">Vertical Synchronization</span></h4>
<p><a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Vertical_synchronization">Vertical synchronization</a>, more commonly known as v-sync, is when the frame rate is synchronized to match the vertical refresh rate of the screen. This means the double buffer is copied to screen's buffer in a small period between frames known as the <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Vertical_blanking_interval">vertical blanking interval</a>. By updating the screen's buffer between frames, you ensure that only full frames are shown at a time.
</p><p>To aid in synchronizing, virtually all video cards since the first home computers have the capability to enable an interrupt at the beginning of each vertical blanking interval (known as VBLANK).
</p><p>An example of vertical synchronization is as follows:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* handle VBLANK, called by the interrupt handler */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vga_handleVBlank</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">vga_framerendered</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="n">vga_screen</span><span class="p">,</span><span class="w"> </span><span class="n">vga_backbuffer</span><span class="p">,</span><span class="w"> </span><span class="n">vga_width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vga_depth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vga_bytesperpixel</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">vga_framerendered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* called when you finish drawing to the double buffer */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vga_sync</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">vga_framerendered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* stick in a loop until the interrupt is fired */</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">vga_framerendered</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>There is no reason you HAVE to synchronize, another method could be you place a spinlock on the buffer, if you fail to acquire the lock simply skip that frame until you do. This may work fine in a video game where you redraw the frame over and over again so if you miss drawing something to the screen it will be redrawn on the following frame, but in a modern multitasking GUI environment, this is unacceptable.
</p><p>In a GUI environment synchronization becomes somewhat more complex. For example see below.
</p><p>Unrelated, there is also a horizontal blanking interval, which is rarely utilized. The HBLANK interrupt fires when the display has finished drawing a line. This was used by some early systems to load in a new colour palettes per-line, enabling a wider range of colours on screen at once than the hardware was designed for. HBLANK synchronization is considered depreciated on modern hardware as displays operating over digital connectors such as DVI can receive the entire frame at once, rather than line by line with a blanking interval in-between. Modern video cards may emulate HBLANK with DVI displays to a varying degree, mostly to remain compatible with legacy VGA software, however don't assume it'll be available or reliable in every video mode.
</p>
<h4><span class="mw-headline" id="Triple_buffering">Triple buffering</span></h4>
<p><a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Triple_buffering">Triple buffering</a> is when three or more buffers are being used, at the cost of more memory to store these buffers in.
</p><p>In a real-time application (such as a game) utilizing triple buffering there are two back buffers and one front buffer. The system renders one frame to one back buffer, the next frame the other back buffer, the next frame to the original back buffer, etc, constantly interchanging between the two. When the VBLANK interrupt fires, the last frame fully rendered is copied to the front buffer (done efficiently, this can be a case of testing one value and swapping two pointers inside the interrupt handler without any locking).
</p><p>In a system already utilizing double buffering, triple buffering is simple to implement. In most cases it can be added to the video driver without the underlying system requiring any modifications.
</p><p>If losing a few MBs of memory is not an issue then triple buffering provides several advantages. First off, there is no need to synchronize frames, so the drawing algorithm can run as often and as fast as it can. Secondly, some real time applications <em>must</em> perform a consistent number of update cycles each second, in which case synchronizing with the refresh rate (which will cause the program to slow down to the speed of the monitor) or skipping frames (the time it takes to execute a single update will not be consistent; some will render frames, some won't) is not an option.
</p>
<h4><span id="Something_unique.3F"></span><span class="mw-headline" id="Something_unique?">Something unique?</span></h4>
<p>In GUI applications, where multiple programs are rendering to multiple front and back buffers each at their own speed you need to be somewhat creative.
</p><p>For example, a method that will work is: each window could consist of a double buffer (or a single buffer that is updated on a redraw/paint event), as well as a double buffer for the entire screen. That way each program can draw on its back buffer and send it its own front buffer when it has finished drawing (either swapping pointers or <code>memcpy</code>) as often as it wants (wrapping a lock around the back buffer), then when the GUI has detected the back buffer has changed, it copies the window's front buffer (locking it temporarily) into the screen's back buffer, then when the VBLANK fires the screen's back buffer is copied to the front buffer if the screen's back buffer has changed.
</p><p>Ultimately, if memory was not an issue then the best system would be to triple buffer each window and the entire desktop, allowing every window, the desktop manager, and the video card to update at it's own speed. In some GUIs each window is allowed to draw directly to the desktop's back buffer. For example in early versions of Windows programs drew directly to the desktop's back buffer, this meant that all windows overlapping that window also had to be redrawn. The disadvantage of this is that if an application doesn't respond to a redraw request straight away then you can get a visual artefact (<a rel="nofollow" class="external text" href="http://i.msdn.microsoft.com/dynimg/IC405533.png">example</a>).
</p><p>Each window manager usually has its own method. But like mentioned above, tearing is a relatively minor issue in most general GUI programs that can often be overlooked, since you will be dealing with text and images that won't be updating. Therefore, if the front buffer is in the middle of outputting to the monitor while copying the next frame to it, you might notice a slight flicker that lasts for all but 1 monitor refresh (which is no less than 1/60th of a second on most monitors).
</p>
<h2><span class="mw-headline" id="Examples">Examples</span></h2>
<p>Articles with all theory are boring, so here are some examples of how to use double-buffering.
</p>
<h4><span class="mw-headline" id="Buffer_creation">Buffer creation</span></h4>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* Supposing the display is 800x600 with 32 bpp (meaning 32/8 = 4 bytes per pixel). */</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">BackBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="mi">800</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">600</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">)));</span><span class="w"></span>
</pre></div>
<p>This implementation absorbs the same amount of memory the real video memory does, in this case, 800 * 600 * 4 = 1920000 bytes = about 1,83 MB. While using single-buffering needs 1,83 MB of RAM with our video resolution (only the display itself), double-buffering would require 2 * 1,83 MB = about 3,66 MB. The higher the resolution, the more memory is required. There are of course implementations that can use up less than that with special techniques, but for some OS developers, high resolutions, and especially with double-buffering, are expensive features.
</p><p>If 3,66MB does not seem like much then if you imagine a video playing program that implements triple buffering running on a modern 1920x1080@32bpp LCD display, then the total amount of video memory to store the 3 buffers would be 24,47MB. Fortunately, as display resolution increased so does memory, so using 25MB of memory on a modern computer to play a video may be acceptable.
</p>
<h4><span class="mw-headline" id="Double_buffering">Double buffering</span></h4>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VidMem</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BackBuffer</span><span class="p">;</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">ScrW</span><span class="p">,</span><span class="w"> </span><span class="n">ScrH</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">Bpp</span><span class="p">,</span><span class="w"> </span><span class="n">PixelStride</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">Pitch</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Initializes video, creates a back buffer, changes video modes.</span>
<span class="cm"> * Remember that you need some kind of memory allocation!</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">InitVideo</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">ScreenWidth</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">ScreenHeight</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">BitsPerPixel</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* Convert bits per pixel into bytes per pixel. Take care of 15-bit modes as well */</span><span class="w"></span>
<span class="w">        </span><span class="n">PixelStride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BitsPerPixel</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* The pitch is the amount of bytes between the start of each row. This isn&#39;t always bytes * width. */</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* This should work for the basic 16 and 32 bpp modes (but not 24) */</span><span class="w"></span>
<span class="w">        </span><span class="n">Pitch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScrenWidth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PixelStride</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Warning: 0xEEEEEEE servces as an example, you should fill in the address of your video memory here. */</span><span class="w"></span>
<span class="w">	</span><span class="n">VidMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">byte</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mh">0xEEEEEEE</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">BackBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">byte</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">ScreenHeight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Pitch</span><span class="p">)));</span><span class="w"></span>

<span class="w">	</span><span class="n">ScrW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScreenWidth</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ScrH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScreenHeight</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">Bpp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BitsPerPixel</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Switch resolutions if needed... */</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* Do some more stuff... */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Draws a pixel onto the backbuffer.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">SetPixel</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">Colour</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w">	</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PixelStride</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Pitch</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Put a pixel onto the back buffer here. */</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* Remember to write to the BACK buffer instead of the FRONT buffer (the front buffer represents your video memory). */</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* Take care of writing exactly PixelStride bytes as well */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Swaps the back and front buffer.</span>
<span class="cm"> * Most commonly done by simply copying the back buffer to the front buffer.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">SwapBuffers</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* Copy the contents of the back buffer to the front buffer. */</span><span class="w"></span>
<span class="w">	</span><span class="n">memcpy</span><span class="p">(</span><span class="n">VidMem</span><span class="p">,</span><span class="w"> </span><span class="n">BackBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">ScrH</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Pitch</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * An example of how to use these functions.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">ProgramLoop</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">while</span><span class="p">(</span><span class="n">Program_Is_Running</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* Handle events, update window coordinates and other things, ... */</span><span class="w"></span>

<span class="w">		</span><span class="cm">/*</span>
<span class="cm">		 * You should probably implement some sort of FillScreen or FillRect function,</span>
<span class="cm">		 * or something that clears the back buffer before drawing. Setting the entire</span>
<span class="cm">		 * back buffer to 0 (black) will suffice for a basic system.</span>
<span class="cm">		 */</span><span class="w"></span>
<span class="w">		</span><span class="n">memset</span><span class="p">(</span><span class="n">Backbuffer</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">ScrH</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Pitch</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* Draw everything: a GUI, windows, other things. This example puts 2 white pixels on the screen. */</span><span class="w"></span>
<span class="w">		</span><span class="n">SetPixel</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mh">0xFFFFFF</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">SetPixel</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mh">0xFFFFFF</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* When done drawing, swap the buffers and let the user see what you&#39;ve drawn. */</span><span class="w"></span>
<span class="w">		</span><span class="n">SwapBuffers</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>I believe this example is mostly clear. As there are too many different ways of changing video modes or putting pixels, I'm going to let you fill that in yourself. If you want more information, you can go to the <a href="GUI" title="GUI">GUI</a> or the <a href="Drawing_In_Protected_Mode" class="mw-redirect" title="Drawing In Protected Mode">Drawing In Protected Mode</a> pages.
</p><p>Note also that the above code might be very 'irregular'. As you know, there is no limit on the drawing, so it is possibly that the first draw takes 30 milliseconds, while the second draw takes 40 milliseconds or the first few seconds, you have a frame-rate of 100 frames per second whilst the next couple of seconds, you have a frame-rate of only 20 frames per second. Because of this, drawing times are usually capped. In the most common GUIs (such as the one in Windows), this is not really of any importance, since only parts of the screen are redrawn if they are 'invalidated' (usually referred to as 'Invalidated rectangles'), but in games, the screen is being constantly redrawn, usually up to 60 times per second. Today's APIs usually clamp this value to the screen refresh rate, this is why they usually have values such as '60' or '75'. Normally, a frame-rate of 25 to 30 suffices to have a 'smooth' display.
</p><p>I've used some sort of loop here (it looks like a game loop), but remember that most GUIs on most OSes do not work with game loops, they usually work with some sort of invalidation system. Meaning a control is redrawn only if it is invalidated, which happens on occasions such as moving or resizing the control.
</p>
<!-- 
NewPP limit report
Cached time: 20250212010953
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.048 seconds
Real time usage: 0.688 seconds
Preprocessor visited node count: 137/1000000
Post‐expand include size: 340/2097152 bytes
Template argument size: 44/2097152 bytes
Highest expansion depth: 15/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 16442/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    3.655      1 Template:Rating
100.00%    3.655      1 -total
 83.34%    3.046      2 Template:If
 69.31%    2.533      2 Template:Show1
 25.18%    0.920      2 Template:Eq
 12.25%    0.448      2 Template:Eq1
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2489-0!canonical and timestamp 20250212010952 and revision id 28579.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Double_Buffering&amp;oldid=28579">https://wiki.osdev.org/index.php?title=Double_Buffering&amp;oldid=28579</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_duplicate_arguments_in_template_calls&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using duplicate arguments in template calls (page does not exist)">Pages using duplicate arguments in template calls</a></li><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Level_1_Tutorials" title="Category:Level 1 Tutorials">Level 1 Tutorials</a></li><li><a href="./Category:Video" title="Category:Video">Video</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Double+Buffering" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="Double_Buffering#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Double_Buffering" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:Double_Buffering" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Double_Buffering"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Double_Buffering&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Double_Buffering&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Double_Buffering" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/Double_Buffering" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Double_Buffering&amp;oldid=28579" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Double_Buffering&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/Double_Buffering" title="Double Buffering – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 26 January 2024, at 16:31.</li>
	<li id="footer-info-0">This page has been accessed 11,733 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Double_Buffering&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.048","walltime":"0.688","ppvisitednodes":{"value":137,"limit":1000000},"postexpandincludesize":{"value":340,"limit":2097152},"templateargumentsize":{"value":44,"limit":2097152},"expansiondepth":{"value":15,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":16442,"limit":5000000},"timingprofile":["100.00%    3.655      1 Template:Rating","100.00%    3.655      1 -total"," 83.34%    3.046      2 Template:If"," 69.31%    2.533      2 Template:Show1"," 25.18%    0.920      2 Template:Eq"," 12.25%    0.448      2 Template:Eq1"]},"cachereport":{"timestamp":"20250212010953","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":792});});</script>
</body>
</html>