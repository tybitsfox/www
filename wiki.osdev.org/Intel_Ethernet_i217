<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Intel Ethernet i217 - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"49e2ec0279b79886c53b797d","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Intel_Ethernet_i217","wgTitle":"Intel Ethernet i217","wgCurRevisionId":27712,"wgRevisionId":27712,"wgArticleId":3768,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Articles Written in First Person","Network Hardware"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Intel_Ethernet_i217","wgRelevantArticleId":3768,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,
"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Intel_Ethernet_i217 rootpage-Intel_Ethernet_i217 skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Intel Ethernet i217</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="Intel_Ethernet_i217#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="Intel_Ethernet_i217#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><center>
<table style="border: 1px solid #cfcfbf; margin-top: 25px; margin-bottom: 25px; background-color: #f0f0ff; text-align: center;">
<tbody><tr>
<td>
<p>This page or section refers to its readers or editors using <i>I</i>, <i>my</i>, <i>we</i> or <i>us</i>. It should be <a rel="nofollow" class="external text" href="https://wiki.osdev.org/index.php?title=Intel_Ethernet_i217&amp;action=edit">edited</a> to be in an encyclopedic tone.
</p>
</td></tr></tbody></table>
</center>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Intel_Ethernet_i217#Network_Driver_for_Intel_Ethernet_Cards_I217_and_82577LM"><span class="tocnumber">1</span> <span class="toctext">Network Driver for Intel Ethernet Cards I217 and 82577LM</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Intel_Ethernet_i217#Card_Addresses_and_Data_Structures"><span class="tocnumber">2</span> <span class="toctext">Card Addresses and Data Structures</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="Intel_Ethernet_i217#The_Driver_Class_Header_(Class_Definition)"><span class="tocnumber">3</span> <span class="toctext">The Driver Class Header (Class Definition)</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="Intel_Ethernet_i217#How_the_Gears_Move_(Class_methods_implementation)"><span class="tocnumber">4</span> <span class="toctext">How the Gears Move (Class methods implementation)</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="Intel_Ethernet_i217#Summary_and_Wrap_Up"><span class="tocnumber">5</span> <span class="toctext">Summary and Wrap Up</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="Intel_Ethernet_i217#Manuals"><span class="tocnumber">6</span> <span class="toctext">Manuals</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Network_Driver_for_Intel_Ethernet_Cards_I217_and_82577LM">Network Driver for Intel Ethernet Cards I217 and 82577LM</span></h2>
<p>I am writing this Wiki as a demonstration of my own experience of getting a working driver for the Intel I217 and 82577LM network cards to work, on a real native bare metal hardware, namely Thinkpads W540 and W510. Linux uses the e1000e network driver for those cards. I have started from a working e1000 driver that I have developed for my OS and which is operational on Qemu, Bochs, and VirtualBox. The main objective of this Wiki is to try to highlight the differences and the addition needed on an operations e1000 driver to work handle network cards that work with the e1000e. So the provided knowledge in this wiki might be applicable on other Intel interfaces. For completion, I will present in this wiki my e1000 driver with the additions that made it work on those native NICs, I217 and 82577LM. I built my original e1000 driver based on information from OSDev and some hobby operating systems on github.
</p><p>It is very important to highlight that this wiki does not utilize all the features in the above NICs, but it show how to configure the NICs for basic functionality such as initialization, read packets, and write packets. 
</p>
<h2><span class="mw-headline" id="Card_Addresses_and_Data_Structures">Card Addresses and Data Structures</span></h2>
<p>To start with, lets state some macro definitions that we are going to use in the code.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define INTEL_VEND     0x8086  </span><span class="c1">// Vendor ID for Intel </span>
<span class="cp">#define E1000_DEV      0x100E  </span><span class="c1">// Device ID for the e1000 Qemu, Bochs, and VirtualBox emmulated NICs</span>
<span class="cp">#define E1000_I217     0x153A  </span><span class="c1">// Device ID for Intel I217</span>
<span class="cp">#define E1000_82577LM  0x10EA  </span><span class="c1">// Device ID for Intel 82577LM</span>


<span class="c1">// I have gathered those from different Hobby online operating systems instead of getting them one by one from the manual</span>

<span class="cp">#define REG_CTRL        0x0000</span>
<span class="cp">#define REG_STATUS      0x0008</span>
<span class="cp">#define REG_EEPROM      0x0014</span>
<span class="cp">#define REG_CTRL_EXT    0x0018</span>
<span class="cp">#define REG_IMASK       0x00D0</span>
<span class="cp">#define REG_RCTRL       0x0100</span>
<span class="cp">#define REG_RXDESCLO    0x2800</span>
<span class="cp">#define REG_RXDESCHI    0x2804</span>
<span class="cp">#define REG_RXDESCLEN   0x2808</span>
<span class="cp">#define REG_RXDESCHEAD  0x2810</span>
<span class="cp">#define REG_RXDESCTAIL  0x2818</span>

<span class="cp">#define REG_TCTRL       0x0400</span>
<span class="cp">#define REG_TXDESCLO    0x3800</span>
<span class="cp">#define REG_TXDESCHI    0x3804</span>
<span class="cp">#define REG_TXDESCLEN   0x3808</span>
<span class="cp">#define REG_TXDESCHEAD  0x3810</span>
<span class="cp">#define REG_TXDESCTAIL  0x3818</span>


<span class="cp">#define REG_RDTR         0x2820 </span><span class="c1">// RX Delay Timer Register</span>
<span class="cp">#define REG_RXDCTL       0x2828 </span><span class="c1">// RX Descriptor Control</span>
<span class="cp">#define REG_RADV         0x282C </span><span class="c1">// RX Int. Absolute Delay Timer</span>
<span class="cp">#define REG_RSRPD        0x2C00 </span><span class="c1">// RX Small Packet Detect Interrupt</span>



<span class="cp">#define REG_TIPG         0x0410      </span><span class="c1">// Transmit Inter Packet Gap</span>
<span class="cp">#define ECTRL_SLU        0x40        </span><span class="c1">//set link up</span>


<span class="cp">#define RCTL_EN                         (1 &lt;&lt; 1)    </span><span class="c1">// Receiver Enable</span>
<span class="cp">#define RCTL_SBP                        (1 &lt;&lt; 2)    </span><span class="c1">// Store Bad Packets</span>
<span class="cp">#define RCTL_UPE                        (1 &lt;&lt; 3)    </span><span class="c1">// Unicast Promiscuous Enabled</span>
<span class="cp">#define RCTL_MPE                        (1 &lt;&lt; 4)    </span><span class="c1">// Multicast Promiscuous Enabled</span>
<span class="cp">#define RCTL_LPE                        (1 &lt;&lt; 5)    </span><span class="c1">// Long Packet Reception Enable</span>
<span class="cp">#define RCTL_LBM_NONE                   (0 &lt;&lt; 6)    </span><span class="c1">// No Loopback</span>
<span class="cp">#define RCTL_LBM_PHY                    (3 &lt;&lt; 6)    </span><span class="c1">// PHY or external SerDesc loopback</span>
<span class="cp">#define RTCL_RDMTS_HALF                 (0 &lt;&lt; 8)    </span><span class="c1">// Free Buffer Threshold is 1/2 of RDLEN</span>
<span class="cp">#define RTCL_RDMTS_QUARTER              (1 &lt;&lt; 8)    </span><span class="c1">// Free Buffer Threshold is 1/4 of RDLEN</span>
<span class="cp">#define RTCL_RDMTS_EIGHTH               (2 &lt;&lt; 8)    </span><span class="c1">// Free Buffer Threshold is 1/8 of RDLEN</span>
<span class="cp">#define RCTL_MO_36                      (0 &lt;&lt; 12)   </span><span class="c1">// Multicast Offset - bits 47:36</span>
<span class="cp">#define RCTL_MO_35                      (1 &lt;&lt; 12)   </span><span class="c1">// Multicast Offset - bits 46:35</span>
<span class="cp">#define RCTL_MO_34                      (2 &lt;&lt; 12)   </span><span class="c1">// Multicast Offset - bits 45:34</span>
<span class="cp">#define RCTL_MO_32                      (3 &lt;&lt; 12)   </span><span class="c1">// Multicast Offset - bits 43:32</span>
<span class="cp">#define RCTL_BAM                        (1 &lt;&lt; 15)   </span><span class="c1">// Broadcast Accept Mode</span>
<span class="cp">#define RCTL_VFE                        (1 &lt;&lt; 18)   </span><span class="c1">// VLAN Filter Enable</span>
<span class="cp">#define RCTL_CFIEN                      (1 &lt;&lt; 19)   </span><span class="c1">// Canonical Form Indicator Enable</span>
<span class="cp">#define RCTL_CFI                        (1 &lt;&lt; 20)   </span><span class="c1">// Canonical Form Indicator Bit Value</span>
<span class="cp">#define RCTL_DPF                        (1 &lt;&lt; 22)   </span><span class="c1">// Discard Pause Frames</span>
<span class="cp">#define RCTL_PMCF                       (1 &lt;&lt; 23)   </span><span class="c1">// Pass MAC Control Frames</span>
<span class="cp">#define RCTL_SECRC                      (1 &lt;&lt; 26)   </span><span class="c1">// Strip Ethernet CRC</span>

<span class="c1">// Buffer Sizes</span>
<span class="cp">#define RCTL_BSIZE_256                  (3 &lt;&lt; 16)</span>
<span class="cp">#define RCTL_BSIZE_512                  (2 &lt;&lt; 16)</span>
<span class="cp">#define RCTL_BSIZE_1024                 (1 &lt;&lt; 16)</span>
<span class="cp">#define RCTL_BSIZE_2048                 (0 &lt;&lt; 16)</span>
<span class="cp">#define RCTL_BSIZE_4096                 ((3 &lt;&lt; 16) | (1 &lt;&lt; 25))</span>
<span class="cp">#define RCTL_BSIZE_8192                 ((2 &lt;&lt; 16) | (1 &lt;&lt; 25))</span>
<span class="cp">#define RCTL_BSIZE_16384                ((1 &lt;&lt; 16) | (1 &lt;&lt; 25))</span>


<span class="c1">// Transmit Command</span>

<span class="cp">#define CMD_EOP                         (1 &lt;&lt; 0)    </span><span class="c1">// End of Packet</span>
<span class="cp">#define CMD_IFCS                        (1 &lt;&lt; 1)    </span><span class="c1">// Insert FCS</span>
<span class="cp">#define CMD_IC                          (1 &lt;&lt; 2)    </span><span class="c1">// Insert Checksum</span>
<span class="cp">#define CMD_RS                          (1 &lt;&lt; 3)    </span><span class="c1">// Report Status</span>
<span class="cp">#define CMD_RPS                         (1 &lt;&lt; 4)    </span><span class="c1">// Report Packet Sent</span>
<span class="cp">#define CMD_VLE                         (1 &lt;&lt; 6)    </span><span class="c1">// VLAN Packet Enable</span>
<span class="cp">#define CMD_IDE                         (1 &lt;&lt; 7)    </span><span class="c1">// Interrupt Delay Enable</span>


<span class="c1">// TCTL Register</span>

<span class="cp">#define TCTL_EN                         (1 &lt;&lt; 1)    </span><span class="c1">// Transmit Enable</span>
<span class="cp">#define TCTL_PSP                        (1 &lt;&lt; 3)    </span><span class="c1">// Pad Short Packets</span>
<span class="cp">#define TCTL_CT_SHIFT                   4           </span><span class="c1">// Collision Threshold</span>
<span class="cp">#define TCTL_COLD_SHIFT                 12          </span><span class="c1">// Collision Distance</span>
<span class="cp">#define TCTL_SWXOFF                     (1 &lt;&lt; 22)   </span><span class="c1">// Software XOFF Transmission</span>
<span class="cp">#define TCTL_RTLC                       (1 &lt;&lt; 24)   </span><span class="c1">// Re-transmit on Late Collision</span>

<span class="cp">#define TSTA_DD                         (1 &lt;&lt; 0)    </span><span class="c1">// Descriptor Done</span>
<span class="cp">#define TSTA_EC                         (1 &lt;&lt; 1)    </span><span class="c1">// Excess Collisions</span>
<span class="cp">#define TSTA_LC                         (1 &lt;&lt; 2)    </span><span class="c1">// Late Collision</span>
<span class="cp">#define LSTA_TU                         (1 &lt;&lt; 3)    </span><span class="c1">// Transmit Underrun</span>
</pre></div>
<p>Now lets define the data structures for the transmit and receive buffers
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define E1000_NUM_RX_DESC 32</span>
<span class="cp">#define E1000_NUM_TX_DESC 8</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">e1000_rx_desc</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">checksum</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">errors</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">special</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">e1000_tx_desc</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">cso</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">cmd</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">css</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">special</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>And finally some helper static methods for MMIO read/write operations and Ports I/O
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">class</span><span class="w"> </span><span class="n">MMIOUtils</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">read8</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">read16</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">read32</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">read64</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">write8</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">,</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">p_value</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">write16</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">,</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_value</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">write32</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">,</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">p_value</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">write64</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">,</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_value</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>


<span class="kt">uint8_t</span><span class="w"> </span><span class="nf">MMIOUtils::read8</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)(</span><span class="n">p_address</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="nf">MMIOUtils::read16</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint16_t</span><span class="o">*</span><span class="p">)(</span><span class="n">p_address</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span>
<span class="p">}</span><span class="w"></span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">MMIOUtils::read32</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">p_address</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span>
<span class="p">}</span><span class="w"></span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="nf">MMIOUtils::read64</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">p_address</span><span class="p">));</span><span class="w">    </span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MMIOUtils::write8</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">,</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">p_value</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)(</span><span class="n">p_address</span><span class="p">)))</span><span class="o">=</span><span class="p">(</span><span class="n">p_value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MMIOUtils::write16</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">,</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_value</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint16_t</span><span class="o">*</span><span class="p">)(</span><span class="n">p_address</span><span class="p">)))</span><span class="o">=</span><span class="p">(</span><span class="n">p_value</span><span class="p">);</span><span class="w">    </span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MMIOUtils::write32</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">,</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">p_value</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">p_address</span><span class="p">)))</span><span class="o">=</span><span class="p">(</span><span class="n">p_value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MMIOUtils::write64</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">,</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p_value</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">p_address</span><span class="p">)))</span><span class="o">=</span><span class="p">(</span><span class="n">p_value</span><span class="p">);</span><span class="w">    </span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#ifndef PORTS_H_</span>
<span class="cp">#define PORTS_H_</span>


<span class="n">class</span><span class="w"> </span><span class="n">Ports</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">outportb</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">,</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">outportw</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">,</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">outportl</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">,</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="nf">inportb</span><span class="p">(</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">inportw</span><span class="p">(</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">inportl</span><span class="p">(</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="cp">#endif </span><span class="cm">/* PORTS_H_ */</span><span class="cp"></span>


<span class="cm">/* void Ports::outportb (uint16_t p_port,uint8_t p_data)</span>
<span class="cm"> * </span>
<span class="cm"> * This method outputs a byte to a hardware port.</span>
<span class="cm"> * It uses an inline asm with the volatile keyword</span>
<span class="cm"> * to disable compiler optimization.</span>
<span class="cm"> * </span>
<span class="cm"> *  p_port: the port number to output the byte p_data to.</span>
<span class="cm"> *  p_data: the byte to to output to the port p_port.</span>
<span class="cm"> * </span>
<span class="cm"> * Notice the input constraint</span>
<span class="cm"> *      &quot;dN&quot; (port)&#160;: indicates using the DX register to store the </span>
<span class="cm"> *                  value of port in it</span>
<span class="cm"> *      &quot;a&quot;  (data)&#160;: store the value of data into </span>
<span class="cm"> * </span>
<span class="cm"> * The above constraint will instruct the compiler to generate assembly</span>
<span class="cm"> * code that looks like that</span>
<span class="cm"> *      mov    %edi,%edx</span>
<span class="cm"> *      mov    %esi,%eax</span>
<span class="cm"> *      out    %eax,(%dx)</span>
<span class="cm"> * </span>
<span class="cm"> * According the ABI, the edi will have the value of p_port and esi will have</span>
<span class="cm"> * the value of the p_data</span>
<span class="cm"> * </span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Ports::outportb</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">,</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">p_data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;outb %1, %0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;dN&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">p_port</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">p_data</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* void Ports::outportw (uint16_t p_port,uint16_t p_data)</span>
<span class="cm"> * </span>
<span class="cm"> * This method outputs a word to a hardware port.</span>
<span class="cm"> * </span>
<span class="cm"> *  p_port: the port number to output the byte p_data to.</span>
<span class="cm"> *  p_data: the byte to to output to the port p_port.</span>
<span class="cm"> * </span>
<span class="cm"> */</span><span class="w"></span>


<span class="kt">void</span><span class="w"> </span><span class="nf">Ports::outportw</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">,</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;outw %1, %0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;dN&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">p_port</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">p_data</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* void Ports::outportl (uint16_t p_port,uint32_t p_data)</span>
<span class="cm"> * </span>
<span class="cm"> * This method outputs a double word to a hardware port.</span>
<span class="cm"> * </span>
<span class="cm"> *  p_port: the port number to output the byte p_data to.</span>
<span class="cm"> *  p_data: the byte to to output to the port p_port.</span>
<span class="cm"> * </span>
<span class="cm"> */</span><span class="w"></span>


<span class="kt">void</span><span class="w"> </span><span class="nf">Ports::outportl</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">,</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">p_data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;outl %1, %0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;dN&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">p_port</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">p_data</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* uint8_t Ports::inportb( uint16_t p_port)</span>
<span class="cm"> * </span>
<span class="cm"> * This method reads a byte from a hardware port.</span>
<span class="cm"> * </span>
<span class="cm"> *  p_port: the port number to read the byte from.</span>
<span class="cm"> *  return value&#160;: a byte read from the port p_port.</span>
<span class="cm"> * </span>
<span class="cm"> * Notice the output constraint &quot;=a&quot;, this tells the compiler </span>
<span class="cm"> * to expect the save the value of register AX into the variable l_ret</span>
<span class="cm"> * The register AX should contain the result of the inb instruction.</span>
<span class="cm"> * </span>
<span class="cm"> * </span>
<span class="cm"> */</span><span class="w"></span>

<span class="kt">uint8_t</span><span class="w"> </span><span class="nf">Ports::inportb</span><span class="p">(</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">l_ret</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;inb %1, %0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=a&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">l_ret</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;dN&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">p_port</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">l_ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* uint16_t Ports::inportw( uint16_t p_port)</span>
<span class="cm"> * </span>
<span class="cm"> * This method reads a word from a hardware port.</span>
<span class="cm"> * </span>
<span class="cm"> *  p_port: the port number to read the word from.</span>
<span class="cm"> *  return value&#160;: a word read from the port p_port.</span>
<span class="cm"> * </span>
<span class="cm"> */</span><span class="w"></span>


<span class="kt">uint16_t</span><span class="w"> </span><span class="nf">Ports::inportw</span><span class="p">(</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">l_ret</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;inw %1, %0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=a&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">l_ret</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;dN&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">p_port</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">l_ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="cm">/* uint16_t Ports::inportl( uint16_t p_port)</span>
<span class="cm"> * </span>
<span class="cm"> * This method reads a double word from a hardware port.</span>
<span class="cm"> * </span>
<span class="cm"> *  p_port: the port number to read the double word from.</span>
<span class="cm"> *  return value&#160;: a double word read from the port p_port.</span>
<span class="cm"> * </span>
<span class="cm"> */</span><span class="w"></span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">Ports::inportl</span><span class="p">(</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_port</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">l_ret</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;inl %1, %0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=a&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">l_ret</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;dN&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">p_port</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">l_ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span id="The_Driver_Class_Header_.28Class_Definition.29"></span><span class="mw-headline" id="The_Driver_Class_Header_(Class_Definition)">The Driver Class Header (Class Definition)</span></h2>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">class</span><span class="w"> </span><span class="n">E1000</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">public</span><span class="w"> </span><span class="n">NetworkDriver</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">private</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span>
<span class="w">        </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bar_type</span><span class="p">;</span><span class="w">     </span><span class="c1">// Type of BAR0</span>
<span class="w">        </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">io_base</span><span class="p">;</span><span class="w">     </span><span class="c1">// IO Base Address</span>
<span class="w">        </span><span class="kt">uint64_t</span><span class="w">  </span><span class="n">mem_base</span><span class="p">;</span><span class="w">   </span><span class="c1">// MMIO Base Address</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">eerprom_exists</span><span class="p">;</span><span class="w">  </span><span class="c1">// A flag indicating if eeprom exists</span>
<span class="w">        </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">mac</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">];</span><span class="w">      </span><span class="c1">// A buffer for storing the mack address</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">e1000_rx_desc</span><span class="w"> </span><span class="o">*</span><span class="n">rx_descs</span><span class="p">[</span><span class="n">E1000_NUM_RX_DESC</span><span class="p">];</span><span class="w"> </span><span class="c1">// Receive Descriptor Buffers</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">e1000_tx_desc</span><span class="w"> </span><span class="o">*</span><span class="n">tx_descs</span><span class="p">[</span><span class="n">E1000_NUM_TX_DESC</span><span class="p">];</span><span class="w"> </span><span class="c1">// Transmit Descriptor Buffers</span>
<span class="w">        </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">rx_cur</span><span class="p">;</span><span class="w">      </span><span class="c1">// Current Receive Descriptor Buffer</span>
<span class="w">        </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">tx_cur</span><span class="p">;</span><span class="w">      </span><span class="c1">// Current Transmit Descriptor Buffer</span>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">        </span><span class="c1">// Send Commands and read results From NICs either using MMIO or IO Ports</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">writeCommand</span><span class="p">(</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">p_value</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">readCommand</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">);</span><span class="w"></span>


<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">detectEEProm</span><span class="p">();</span><span class="w"> </span><span class="c1">// Return true if EEProm exist, else it returns false and set the eerprom_existsdata member</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">eepromRead</span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w"> </span><span class="c1">// Read 4 bytes from a specific EEProm Address</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">readMACAddress</span><span class="p">();</span><span class="w">       </span><span class="c1">// Read MAC Address</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">startLink</span><span class="w"> </span><span class="p">();</span><span class="w">           </span><span class="c1">// Start up the network</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">rxinit</span><span class="p">();</span><span class="w">               </span><span class="c1">// Initialize receive descriptors an buffers</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">txinit</span><span class="p">();</span><span class="w">               </span><span class="c1">// Initialize transmit descriptors an buffers</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">enableInterrupt</span><span class="p">();</span><span class="w">      </span><span class="c1">// Enable Interrupts</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">handleReceive</span><span class="p">();</span><span class="w">        </span><span class="c1">// Handle a packet reception.</span>
<span class="w">    </span><span class="n">public</span><span class="o">:</span><span class="w"></span>

<span class="w">        </span><span class="n">E1000</span><span class="p">(</span><span class="n">PCIConfigHeader</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_pciConfigHeader</span><span class="p">);</span><span class="w"> </span><span class="c1">// Constructor. takes as a parameter a pointer to an object that encapsulate all he PCI configuration data of the device</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">start</span><span class="w"> </span><span class="p">();</span><span class="w">                             </span><span class="c1">// perform initialization tasks and starts the driver</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">fire</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptContext</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_interruptContext</span><span class="p">);</span><span class="w">  </span><span class="c1">// This method should be called by the interrupt handler </span>
<span class="w">        </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">getMacAddress</span><span class="w"> </span><span class="p">();</span><span class="w">                         </span><span class="c1">// Returns the MAC address</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">sendPacket</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_data</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_len</span><span class="p">);</span><span class="w">  </span><span class="c1">// Send a packet</span>
<span class="w">        </span><span class="o">~</span><span class="n">E1000</span><span class="p">();</span><span class="w">                                             </span><span class="c1">// Default Destructor</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<h2><span id="How_the_Gears_Move_.28Class_methods_implementation.29"></span><span class="mw-headline" id="How_the_Gears_Move_(Class_methods_implementation)">How the Gears Move (Class methods implementation)</span></h2>
<p>First of all we need to be able to send commands and read results from the NIC. It is important to detect the type of BAR0 and based on that the correct communication mechanism should be adopted. The following two methods encapsulate the read/write commands and uses MMIO or IO ports based on the value in BAR0 which is reflected in bar_type data member flag.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">E1000::writeCommand</span><span class="p">(</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">p_value</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">bar_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">MMIOUtils</span><span class="o">::</span><span class="n">write32</span><span class="p">(</span><span class="n">mem_base</span><span class="o">+</span><span class="n">p_address</span><span class="p">,</span><span class="n">p_value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Ports</span><span class="o">::</span><span class="n">outportl</span><span class="p">(</span><span class="n">io_base</span><span class="p">,</span><span class="w"> </span><span class="n">p_address</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">Ports</span><span class="o">::</span><span class="n">outportl</span><span class="p">(</span><span class="n">io_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">p_value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">E1000::readCommand</span><span class="p">(</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_address</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">bar_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">MMIOUtils</span><span class="o">::</span><span class="n">read32</span><span class="p">(</span><span class="n">mem_base</span><span class="o">+</span><span class="n">p_address</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Ports</span><span class="o">::</span><span class="n">outportl</span><span class="p">(</span><span class="n">io_base</span><span class="p">,</span><span class="w"> </span><span class="n">p_address</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Ports</span><span class="o">::</span><span class="n">inportl</span><span class="p">(</span><span class="n">io_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><br />
Now we need to detect if the card has an EEPROM or not. The Qemu and Bochs emulate EEPROM, but the I217 and 82577LM do not. The following first method tries to read the status field of the EEPROM, the status field should contain the value 0x10, and based on the result the internal data member eerprom_exists. The second method performs a 2-bytes read operation from the EEPROM
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">E1000::detectEEProm</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_EEPROM</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">eerprom_exists</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readCommand</span><span class="p">(</span><span class="w"> </span><span class="n">REG_EEPROM</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x10</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="n">eerprom_exists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">else</span><span class="w"></span>
<span class="w">                    </span><span class="n">eerprom_exists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">eerprom_exists</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">E1000::eepromRead</span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">eerprom_exists</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            	</span><span class="n">writeCommand</span><span class="p">(</span><span class="w"> </span><span class="n">REG_EEPROM</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">        	</span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">((</span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readCommand</span><span class="p">(</span><span class="n">REG_EEPROM</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">writeCommand</span><span class="p">(</span><span class="w"> </span><span class="n">REG_EEPROM</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">((</span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readCommand</span><span class="p">(</span><span class="n">REG_EEPROM</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)((</span><span class="n">tmp</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFF</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><br />
</p><p>The first thing you will need to do after detecting the BAR0 type and the existence of the EEPROM is to read the hardware MAC address of the NIC. The following method reads the hardware mac address based. If an EEPROM exists it will read it from the EEPROM else it will read it from address 0x5400 where it should be located in that case. It is very important to detect if an EEPROM exists or not prior to reading the MAC address.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">E1000::readMACAddress</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">eerprom_exists</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eepromRead</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">mac</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">mac</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eepromRead</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">mac</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">mac</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eepromRead</span><span class="p">(</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">mac</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">mac</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mem_base_mac_8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">mem_base</span><span class="o">+</span><span class="mh">0x5400</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mem_base_mac_32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">mem_base</span><span class="o">+</span><span class="mh">0x5400</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">mem_base_mac_32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">mac</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem_base_mac_8</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><br />
Now, we need to configure the transmit and receive descriptor buffers, here are the implementation of the corresponding methods. The rxinit method is identical to the one I use for my e1000 driver. The difference is in txinit
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">E1000::rxinit</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">e1000_rx_desc</span><span class="w"> </span><span class="o">*</span><span class="n">descs</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate buffer for receive descriptors. For simplicity, in my case khmalloc returns a virtual address that is identical to it physical mapped address.</span>
<span class="w">    </span><span class="c1">// In your case you should handle virtual and physical addresses as the addresses passed to the NIC should be physical ones</span>
<span class="w"> </span>
<span class="w">    </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">kmalloc_ptr</span><span class="o">-&gt;</span><span class="n">khmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">e1000_rx_desc</span><span class="p">)</span><span class="o">*</span><span class="n">E1000_NUM_RX_DESC</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">16</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">descs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">e1000_rx_desc</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">E1000_NUM_RX_DESC</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">rx_descs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">e1000_rx_desc</span><span class="w"> </span><span class="o">*</span><span class="p">)((</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">descs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">rx_descs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">kmalloc_ptr</span><span class="o">-&gt;</span><span class="n">khmalloc</span><span class="p">(</span><span class="mi">8192</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">16</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">rx_descs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_TXDESCLO</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">ptr</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_TXDESCHI</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">ptr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFFFFFF</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_RXDESCLO</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_RXDESCHI</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_RXDESCLEN</span><span class="p">,</span><span class="w"> </span><span class="n">E1000_NUM_RX_DESC</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_RXDESCHEAD</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_RXDESCTAIL</span><span class="p">,</span><span class="w"> </span><span class="n">E1000_NUM_RX_DESC</span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">rx_cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_RCTRL</span><span class="p">,</span><span class="w"> </span><span class="n">RCTL_EN</span><span class="o">|</span><span class="w"> </span><span class="n">RCTL_SBP</span><span class="o">|</span><span class="w"> </span><span class="n">RCTL_UPE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RCTL_MPE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RCTL_LBM_NONE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RTCL_RDMTS_HALF</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RCTL_BAM</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RCTL_SECRC</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">RCTL_BSIZE_8192</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="p">}</span><span class="w"></span>


<span class="kt">void</span><span class="w"> </span><span class="nf">E1000::txinit</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w">    </span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w">  </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">e1000_tx_desc</span><span class="w"> </span><span class="o">*</span><span class="n">descs</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Allocate buffer for receive descriptors. For simplicity, in my case khmalloc returns a virtual address that is identical to it physical mapped address.</span>
<span class="w">    </span><span class="c1">// In your case you should handle virtual and physical addresses as the addresses passed to the NIC should be physical ones</span>
<span class="w">    </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">kmalloc_ptr</span><span class="o">-&gt;</span><span class="n">khmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">e1000_tx_desc</span><span class="p">)</span><span class="o">*</span><span class="n">E1000_NUM_TX_DESC</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">16</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">descs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">e1000_tx_desc</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">E1000_NUM_TX_DESC</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">tx_descs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">e1000_tx_desc</span><span class="w"> </span><span class="o">*</span><span class="p">)((</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">descs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">tx_descs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">tx_descs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">tx_descs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TSTA_DD</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_TXDESCHI</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">ptr</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_TXDESCLO</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">ptr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFFFFFF</span><span class="p">));</span><span class="w"></span>


<span class="w">    </span><span class="c1">//now setup total length of descriptors</span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_TXDESCLEN</span><span class="p">,</span><span class="w"> </span><span class="n">E1000_NUM_TX_DESC</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>


<span class="w">    </span><span class="c1">//setup numbers</span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="w"> </span><span class="n">REG_TXDESCHEAD</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="w"> </span><span class="n">REG_TXDESCTAIL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">tx_cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_TCTRL</span><span class="p">,</span><span class="w">  </span><span class="n">TCTL_EN</span><span class="w"></span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">TCTL_PSP</span><span class="w"></span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">15</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">TCTL_CT_SHIFT</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">64</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">TCTL_COLD_SHIFT</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">TCTL_RTLC</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// This line of code overrides the one before it but I left both to highlight that the previous one works with e1000 cards, but for the e1000e cards </span>
<span class="w">    </span><span class="c1">// you should set the TCTRL register as follows. For detailed description of each bit, please refer to the Intel Manual.</span>
<span class="w">    </span><span class="c1">// In the case of I217 and 82577LM packets will not be sent if the TCTRL is not configured using the following bits.</span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_TCTRL</span><span class="p">,</span><span class="w">  </span><span class="mb">0b0110000000000111111000011111010</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_TIPG</span><span class="p">,</span><span class="w">  </span><span class="mh">0x0060200A</span><span class="p">);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p><br />
To enable interrupts 
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">E1000::enableInterrupt</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_IMASK</span><span class="w"> </span><span class="p">,</span><span class="mh">0x1F6DC</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_IMASK</span><span class="w"> </span><span class="p">,</span><span class="mh">0xff</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">readCommand</span><span class="p">(</span><span class="mh">0xc0</span><span class="p">);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>As we have defined most of the building blocks and the helper methods lets define the main methods of the class.
</p><p><br />
The constructor is responsible for fetching PCI related data and initialize the object internal state
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">E1000</span><span class="o">::</span><span class="n">E1000</span><span class="p">(</span><span class="n">PCIConfigHeader</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_pciConfigHeader</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">NetworkDriver</span><span class="p">(</span><span class="n">p_pciConfigHeader</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Get BAR0 type, io_base address and MMIO base address</span>
<span class="w">    </span><span class="n">bar_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pciConfigHeader</span><span class="o">-&gt;</span><span class="n">getPCIBarType</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pciConfigHeader</span><span class="o">-&gt;</span><span class="n">getPCIBar</span><span class="p">(</span><span class="n">PCI_BAR_IO</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">mem_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pciConfigHeader</span><span class="o">-&gt;</span><span class="n">getPCIBar</span><span class="p">(</span><span class="w"> </span><span class="n">PCI_BAR_MEM</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mi">3</span><span class="p">;</span><span class="w">    </span>
<span class="w">   </span>
<span class="w">    </span><span class="c1">// Off course you will need here to map the memory address into you page tables and use corresponding virtual addresses</span>

<span class="w">    </span><span class="c1">// Enable bus mastering</span>
<span class="w">    </span><span class="n">pciConfigHeader</span><span class="o">-&gt;</span><span class="n">enablePCIBusMastering</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">eerprom_exists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The start method basically detects the EEPROM, reads the MAC addresses, setup rx and tx buffers, register the interrupt handler, and enable NIC interrupts
</p><p><br />
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">E1000::start</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">detectEEProm</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">readMACAddress</span><span class="p">())</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">printMac</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">startLink</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x80</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">writeCommand</span><span class="p">(</span><span class="mh">0x5200</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">interruptManager</span><span class="o">-&gt;</span><span class="n">registerInterrupt</span><span class="p">(</span><span class="n">IRQ0</span><span class="o">+</span><span class="n">pciConfigHeader</span><span class="o">-&gt;</span><span class="n">getIntLine</span><span class="p">(),</span><span class="n">this</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">enableInterrupt</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">rxinit</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">txinit</span><span class="p">();</span><span class="w">        </span>
<span class="w">        </span><span class="n">video</span><span class="p">.</span><span class="n">putString</span><span class="p">(</span><span class="s">&quot;E1000 card started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">COLOR_RED</span><span class="p">,</span><span class="n">COLOR_WHITE</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><br />
Your interrupt handler should eventually call the fire method which handles the NIC's events
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">E1000::fire</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptContext</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_interruptContext</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">p_interruptContext</span><span class="o">-&gt;</span><span class="n">getInteruptNumber</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pciConfigHeader</span><span class="o">-&gt;</span><span class="n">getIntLine</span><span class="p">()</span><span class="o">+</span><span class="n">IRQ0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w">        </span>
<span class="w">        </span><span class="cm">/* This might be needed here if your handler doesn&#39;t clear interrupts from each device and must be done before EOI if using the PIC.</span>
<span class="cm">           Without this, the card will spam interrupts as the int-line will stay high. */</span><span class="w"></span>
<span class="w">        </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_IMASK</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readCommand</span><span class="p">(</span><span class="mh">0xc0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x04</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">startLink</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x10</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="c1">// good threshold</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x80</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">handleReceive</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">E1000::handleReceive</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">old_cur</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">got_packet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span>
<span class="w">    </span><span class="k">while</span><span class="p">((</span><span class="n">rx_descs</span><span class="p">[</span><span class="n">rx_cur</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x1</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">got_packet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">rx_descs</span><span class="p">[</span><span class="n">rx_cur</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx_descs</span><span class="p">[</span><span class="n">rx_cur</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Here you should inject the received packet into your network stack</span>


<span class="w">            </span><span class="n">rx_descs</span><span class="p">[</span><span class="n">rx_cur</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">old_cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx_cur</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">rx_cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">rx_cur</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">E1000_NUM_RX_DESC</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_RXDESCTAIL</span><span class="p">,</span><span class="w"> </span><span class="n">old_cur</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w">    </span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Finally we define the sendPacket method as follows
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">E1000::sendPacket</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_data</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">p_len</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w">    </span>
<span class="w">    </span><span class="n">tx_descs</span><span class="p">[</span><span class="n">tx_cur</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p_data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tx_descs</span><span class="p">[</span><span class="n">tx_cur</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_len</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tx_descs</span><span class="p">[</span><span class="n">tx_cur</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CMD_EOP</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">CMD_IFCS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">CMD_RS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tx_descs</span><span class="p">[</span><span class="n">tx_cur</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">old_cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tx_cur</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tx_cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tx_cur</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">E1000_NUM_TX_DESC</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">writeCommand</span><span class="p">(</span><span class="n">REG_TXDESCTAIL</span><span class="p">,</span><span class="w"> </span><span class="n">tx_cur</span><span class="p">);</span><span class="w">   </span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tx_descs</span><span class="p">[</span><span class="n">old_cur</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">));</span><span class="w">    </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><br />
This is an example of how to instantiate an object of this class and startup you driver. I assume that you have scanned your PCI buses and loaded the found devices parameters into some data structures; in our example this is done by the PCIConfigManager class, which is outside the scope of this tutorial
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">        </span><span class="n">pciConfigHeaderManager</span><span class="p">.</span><span class="n">initialize</span><span class="p">();</span><span class="w"> </span><span class="c1">// Initialize the PCIConfigHeaderManager Object and scan PCI devices</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">e1000PCIConfigHeader</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">e1000PCIConfigHeader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pciConfigHeaderManager</span><span class="p">.</span><span class="n">getPCIDevice</span><span class="p">(</span><span class="n">INTEL_VEND</span><span class="p">,</span><span class="n">E1000_I217</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">e1000PCIConfigHeader</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">e1000PCIConfigHeader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pciConfigHeaderManager</span><span class="p">.</span><span class="n">getPCIDevice</span><span class="p">(</span><span class="n">INTEL_VEND</span><span class="p">,</span><span class="n">E1000_82577LM</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">e1000PCIConfigHeader</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">E1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">e1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">E1000</span><span class="p">(</span><span class="n">e1000PCIConfigHeader</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">e1000</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">())</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">               </span><span class="c1">// Error starting the NIC</span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="c1">// Intel cards not found</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Summary_and_Wrap_Up">Summary and Wrap Up</span></h2>
<p>I have presented in this Wiki the steps I followed to make an e1000 driver work with the two e1000e NICs Intel I217 and 82577LM. The wiki does not show how to utilize all the features of the NICs, but basically primitive setup and send/receive packets. Three important issues that I faced:
</p>
<ul><li>You need to detect the BAR0 type as some cards uses IO ports and others uses MMIO and you need to communincate with the NIC with the method appropriate to each.</li>
<li>You need to check if the card supports an EEPROM and read the MAC address from the EEPROM if the card supports it or read it from address 0x5400 if it does not support an EEPROM</li>
<li>You need to make sure to setup the card TCTRL register (Transmission Control Register) with the value 0b0110000000000111111000011111010. For more details reference the Intel manual for the meaning of the different bits of the register</li></ul>
<h2><span class="mw-headline" id="Manuals">Manuals</span></h2>
<p>These are the full Intel manuals:
<a rel="nofollow" class="external text" href="http://www.intel.com/content/www/us/en/ethernet-controllers/ethernet-controller-i217-spec-update.html">Intel Ethernet i217 V</a>
<a rel="nofollow" class="external text" href="http://www.intel.com/content/www/us/en/ethernet-controllers/82577-gbe-phy-datasheet.html">Intel 82577 Gigabit Ethernet PHY</a>
</p><p>(Looks like the former manual was moved <a rel="nofollow" class="external text" href="http://www.intel.com/content/www/us/en/embedded/products/networking/i217-ethernet-controller-datasheet.html">here</a>).
</p>
<!-- 
NewPP limit report
Cached time: 20250212010717
Cache expiry: 86400
Reduced expiry: false
Complications: [showtoc]
CPU time usage: 0.118 seconds
Real time usage: 2.063 seconds
Preprocessor visited node count: 103/1000000
Postexpand include size: 862/2097152 bytes
Template argument size: 216/2097152 bytes
Highest expansion depth: 6/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 105849/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    1.762      1 -total
100.00%    1.762      1 Template:FirstPerson
 53.46%    0.942      1 Template:NoteBox
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:3768-0!canonical and timestamp 20250212010715 and revision id 27712.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Intel_Ethernet_i217&amp;oldid=27712">https://wiki.osdev.org/index.php?title=Intel_Ethernet_i217&amp;oldid=27712</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Articles_Written_in_First_Person" title="Category:Articles Written in First Person">Articles Written in First Person</a></li><li><a href="./Category:Network_Hardware" title="Category:Network Hardware">Network Hardware</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Intel+Ethernet+i217" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="Intel_Ethernet_i217#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Intel_Ethernet_i217" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:Intel_Ethernet_i217" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Intel_Ethernet_i217"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Intel_Ethernet_i217&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Intel_Ethernet_i217&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Intel_Ethernet_i217" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/Intel_Ethernet_i217" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Intel_Ethernet_i217&amp;oldid=27712" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Intel_Ethernet_i217&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 30 March 2023, at 20:11.</li>
	<li id="footer-info-0">This page has been accessed 6,212 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Intel_Ethernet_i217&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.118","walltime":"2.063","ppvisitednodes":{"value":103,"limit":1000000},"postexpandincludesize":{"value":862,"limit":2097152},"templateargumentsize":{"value":216,"limit":2097152},"expansiondepth":{"value":6,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":105849,"limit":5000000},"timingprofile":["100.00%    1.762      1 -total","100.00%    1.762      1 Template:FirstPerson"," 53.46%    0.942      1 Template:NoteBox"]},"cachereport":{"timestamp":"20250212010717","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":2171});});</script>
</body>
</html>