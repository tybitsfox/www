<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Network Stack - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"d39051138520fcab514953f1","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Network_Stack","wgTitle":"Network Stack","wgCurRevisionId":23577,"wgRevisionId":23577,"wgArticleId":2538,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["In Progress","Networking"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Network_Stack","wgRelevantArticleId":2538,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":"Networking",
"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgInternalRedirectTargetUrl":"/Network_Stack","wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head","mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="Network_Stack"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Network_Stack rootpage-Network_Stack skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Network Stack</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"><span class="mw-redirectedfrom">(Redirected from <a href="https://wiki.osdev.org/index.php?title=Networking&amp;redirect=no" class="mw-redirect" title="Networking">Networking</a>)</span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="Networking#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="Networking#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><center>
<table style="border: 1px solid #cfcfbf; margin-top: 25px; margin-bottom: 25px; background-color: #f0f0ff; text-align: center;">
<tbody><tr>
<td>
<p><a href="./File:Under_Construction.png" class="image" title="This page is under construction!"><img alt="This page is under construction!" src="images/1/14/Under_Construction.png" decoding="async" width="50" height="50" data-file-width="50" data-file-height="50" /></a>
This page or section is a work in progress and may thus be incomplete. Its content may be changed in the near future.
</p>
</td>
<td>
</td></tr></tbody></table>
</center>
<p>This article is about writing a TCP/IP stack, ie. a subsystem which uses a link layer (eg. ethernet card) to process packets of such protocols as IP, <a href="Address_Resolution_Protocol" title="Address Resolution Protocol">ARP</a>, TCP, UDP.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Networking#Scanning_the_PCI_devices"><span class="tocnumber">1</span> <span class="toctext">Scanning the PCI devices</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Networking#Writing_a_driver_for_your_NIC"><span class="tocnumber">2</span> <span class="toctext">Writing a driver for your NIC</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="Networking#Networking_protocols"><span class="tocnumber">3</span> <span class="toctext">Networking protocols</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="Networking#The_network_stack"><span class="tocnumber">4</span> <span class="toctext">The network stack</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="Networking#Little_and_big_endian"><span class="tocnumber">5</span> <span class="toctext">Little and big endian</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="Networking#Checksums"><span class="tocnumber">6</span> <span class="toctext">Checksums</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="Networking#ARP"><span class="tocnumber">7</span> <span class="toctext">ARP</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="Networking#TCP"><span class="tocnumber">8</span> <span class="toctext">TCP</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="Networking#Establishing_a_connection"><span class="tocnumber">8.1</span> <span class="toctext">Establishing a connection</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="Networking#Transmitting_data"><span class="tocnumber">8.2</span> <span class="toctext">Transmitting data</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="Networking#Closing_the_connection"><span class="tocnumber">8.3</span> <span class="toctext">Closing the connection</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="Networking#An_example"><span class="tocnumber">8.4</span> <span class="toctext">An example</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13"><a href="Networking#What_to_focus_on"><span class="tocnumber">9</span> <span class="toctext">What to focus on</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="Networking#General_considerations"><span class="tocnumber">10</span> <span class="toctext">General considerations</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="Networking#See_Also"><span class="tocnumber">11</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="Networking#Articles"><span class="tocnumber">11.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="Networking#Threads"><span class="tocnumber">11.2</span> <span class="toctext">Threads</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="Networking#External_Links"><span class="tocnumber">11.3</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Scanning_the_PCI_devices">Scanning the PCI devices</span></h2>
<p>The first thing to do is to scan the PCI devices installed on the machine so you can detect an Ethernet card by looking at a specific vendor ID and device ID. See the <a href="PCI" title="PCI">PCI</a> page for more details.
</p>
<h2><span class="mw-headline" id="Writing_a_driver_for_your_NIC">Writing a driver for your NIC</span></h2>
<p>Once you have located the Ethernet card(s), you will need to implement a driver for it to be able to send and receive data. If you are using an emulator, a good card to write a driver for is the Intel E1000 as it is available on a variety of emulators such as VirtualBox - and has a thorough coverage on osdev.org (see <a href="Intel_Ethernet_i217" title="Intel Ethernet i217">Intel Ethernet i217</a>). If you have trouble implementing the E1000 driver, you can start with the <a href="RTL8139" title="RTL8139">RTL8139</a>, an older ethernet card that is much simpler.
</p><p>The first thing to get out of the Ethernet card is the machine's MAC address. This 6-bytes address is needed to exchange data on the local network.
</p><p>The easiest test you can do is to send an ARP broadcast on the network. You can use <a rel="nofollow" class="external text" href="https://www.wireshark.org/">Wireshark</a> both to capture an example of a valid ARP request and to verify your own request has been received by the target host. As far as receiving data, your network card should capture data sent across the local network, even if it is not addressed to your machine.
</p>
<h2><span class="mw-headline" id="Networking_protocols">Networking protocols</span></h2>
<p>Once you can send and receive data through your NIC and have your machine's MAC address, you will have to implement (at least partially) several networking protocols that coexist on top of each other:
</p>
<ul><li>Ethernet: this is the basic protocol that sends data to another machine on your local network using your MAC address. This is the building block for all the rest as you need to send data to the router if you want to communicate with the outside world.
<ul><li><a href="ARP" class="mw-redirect" title="ARP">ARP</a> (Address Resolution Protocol): allows to translate an IPv4 address into a MAC address</li>
<li>IP (Internet Protocol): this sits on top of Ethernet and is required to send data on the Internet given an IP address. The mostly common version is IPv4 which uses a 32-bit IP address, but IPv6 (which is using 128-bit IP addresses) is gaining some traction. Note that IP provides a "best effort" to send a packet, but does not guarantee it will successfully reach its destination, nor that the packets will be received in the order they were sent
<ul><li><a href="ICMP" class="mw-redirect" title="ICMP">ICMP</a> (Internet Control Message Protocol): used by tools such as ping or traceroute</li>
<li>UDP (User Datagram Protocol): a connectionless transmission protocol that adds the notion of source and target ports to IP. Application services can subscribe to one or more port(s) to be notified if a UDP message is sent to that port
<ul><li>DHCP (Dynamic Host Configuration Protocol): allows to request the machine network configuration information such as its IP address, the IP address of the local router, the DNS, etc.</li>
<li>DNS (Domain Name System): get the IP address for a given domain name</li></ul></li>
<li>TCP (Transmission Control Protocol): like UDP, it adds the notion of source and destination port. TCP is however more complex as it creates its own session mechanism and makes sure that the application using it will receive the packets in order, resending packets if need be.
<ul><li><a href="SSL/TLS" title="SSL/TLS">SSL/TLS</a> (optional): if you want to use a secure connection
<ul><li>HTTP (HyperText Transfer Protocol): defines a request and response mechanism to transfer web pages, images and other resources.</li>
<li>Telnet: a protocol to remotely access a machine using a command line shell.</li></ul></li></ul></li></ul></li></ul></li></ul>
<p>A tool of choice to help you will be <a rel="nofollow" class="external text" href="https://www.wireshark.org/">Wireshark</a>, a free network sniffer and analyzer. It is a great tool to understand how the various networking protocols are encoded as it explains in great details what each byte of a packet corresponds to. Note that on Windows, Wireshark does not capture the loopback traffic (i.e. traffic made from localhost to localhost), so may not capture network traffic between an emulator and the host machine. You can however use Rawcap to capture the networking traffic into a file and use Wireshark to examine it.
</p>
<h2><span class="mw-headline" id="The_network_stack">The network stack</span></h2>
<p>Networking protocols are organized as a stack where each layer calls the next layer. A packet sent across the network will be composed of several headers, one for each layer involved.
</p><p>Consider the example of a DHCP request. This is one of the protocols you might want to implement early on as it allows your machine to find its IP address, get the local router IP address, the DNS IP address - the basic information to be able to properly communicate across the network.
</p><p>One way to implement this is as follows:
</p>
<ul><li>The Operating System decides to send a DHCP request, so calls the DHCP layer
<ul><li>The DHCP layer asks the UDP layer to create a packet whose target is IP address 255,255,255,255 (broadcast to the whole local network), port 53, and whose payload size is 300 bytes (the length may vary)
<ul><li>The UDP layer asks the IP layer to create a packet of type UDP to IP address 255,255,255,255, of size 308 bytes
<ul><li>The IP layer asks the Ethernet layer to create a packet of type IPv4 of length 328 bytes whose target is IP address 255,255,255,255
<ul><li>The Ethernet layer creates a packet of size 342 bytes, and writes in the first 14 bytes the Ethernet header, including the source address (the machine's MAC address), the destination MAC address FF:FF:FF:FF:FF:FF (translated from the IP address 255,255,255,255) and sends it back to the IP layer</li></ul></li>
<li>The IP layer writes the IP header in the 20 bytes after the Ethernet header and sends it to the UDP layer</li></ul></li>
<li>The UDP layer writes its header in the 8 bytes after the IP header and sends it to the DHCP layer</li></ul></li>
<li>The DHCP layer writes its request in the 300 bytes left and sends it back to the UDP layer
<ul><li>The UDP layer completes its header by writing its checksum (which encompasses the DHCP message) and sends it to the IP layer
<ul><li>The IP layer sends it to the Ethernet layer
<ul><li>The Ethernet layer sends the packet to the Ethernet card, that sends the message across the network</li></ul></li></ul></li></ul></li></ul></li></ul>
<p>The packet actually sent across the network will look like:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<td>Ethernet header (14 bytes)
</td></tr>
<tr>
<td>IPv4 header (20 bytes)
</td></tr>
<tr>
<td>UDP header (8 bytes)
</td></tr>
<tr>
<td>The DHCP request (300 bytes payload)
</td></tr></tbody></table>
<p>The DHCP response will have the same format as the request, and should be processed as follows:
</p>
<ul><li>The Ethernet card driver will verify that the target MAC is the current machine's, and if so sends the packet to the Ethernet layer</li>
<li>The Ethernet layer will look at the Ethernet header, check the service type (which should be IP) and will send the packet (stripped of its Ethernet header) to the IP layer</li>
<li>The IP layer will check the IP header, verify the checksum and, because its type is UDP will forward the packet (without its IP header) to the UDP layer.</li>
<li>The UDP layer will check the UDP header, verify the checksum, and based on the destination port will send the payload to right service - in this example the DHCP layer (once again stripping the UDP header)</li>
<li>The DHCP layer will read the DHCP message verify that the message type is Response (i.e. It's a response from the router) and will retrieve its IP address, the router's IP address and other networking configuration information.</li></ul>
<p>Note that networking protocols are by definition asynchronously i.e. you send a request on the network and you need to wait for its response. In particular, you have no way of predicting when will a response arrive, if at all. And because an incoming packet is handled by an interrupt handler, it could interrupt your code at any time.
</p>
<h2><span class="mw-headline" id="Little_and_big_endian">Little and big endian</span></h2>
<p>By convention, any message encoded on the Internet is using big endian (the most significant byte goes first). This is something to always keep in mind for people developing on Intel and AMD processors as x86 processors encode numbers using little endian. As a result, you will have to often convert numbers. Here are two functions to convert the endian for 16 and 32-bit integers:
</p>
<pre>   uint16_t switch_endian16(uint16_t nb) {
       return (nb&gt;&gt;8) | (nb&lt;&lt;8);
   }
   
   uint_t switch_endian32(uint_t nb) {
       return ((nb&gt;&gt;24)&amp;0xff)      |
              ((nb&lt;&lt;8)&amp;0xff0000)   |
              ((nb&gt;&gt;8)&amp;0xff00)     |
              ((nb&lt;&lt;24)&amp;0xff000000);
   }
</pre>
<h2><span class="mw-headline" id="Checksums">Checksums</span></h2>
<p>Several networking protocols use a checksum to verify that the message was not accidentally altered during the transport. Without a valid checksum, the packet is likely to be ignored. The checksum is a 16-bit number computed as follows:
</p>
<ul><li>Split the message to checksum into 16-bit chunks</li>
<li>Add those chunks</li>
<li>If the message has an odd number of bytes, the last byte should be counted as the higher byte (e.g. if the last byte is 0x42 then add 0x4200)</li>
<li>If the sum does not fit in a 16-bit number (i.e. is greater than 0xFFFF), strip the top 16 bits and add them to the low 16 bits. Repeat the last step until you have a 16-bit sum</li>
<li>Return the binary inverse of that sum</li></ul>
<p>The IP checksum only covers its own header. The UDP and TCP checksums are a bit more complex as they include the UDP/TCP header, the payload (i.e. anything after the UDP/TCP header) as well as a "pseudo header" composed of the source and target IP addresses, the IP type (0x11 for UDP, 0x06 for TCP) and the UDP/TCP message length (starting with the UDP/TCP header).
</p><p>If properly computing the checksum can be tricky, Wireshark can help you. For this, make sure that it is verifying the checksum (an option not enabled by default) by going to Edit / Preferences / Protocols, select the desired protocol (e.g. UDP, TCP, IPv4) and make sure that "Validate the checksum if possible" is checked. This way, Wireshark will tell you if the checksum is valid, and if not, what its value should be.
</p>
<h2><span class="mw-headline" id="ARP">ARP</span></h2>
<p>The ARP protocol will be one of the first protocols you will need to implement. Without it, you will not be able to communicate on your local network, let alone on the Internet. Fortunately this is a simple protocol which only requires to implement a few functions:
</p>
<ul><li>Sending requests and processing replies: your OS will need to perform a request to convert an IP address into a MAC address, something which is required to even communicate with your local router. This implies not only sending a request packet but also processing the reply when it comes so your OS can update its ARP table</li>
<li>Receiving requests and sending replies: your OS will also need to honor the requests sent its way (e.g. when someone asks what is its MAC address). In particular, the local router will send an ARP requests to your machine on a regular basis. Failure to respond will have the router consider your machine is down, and won't forward any more traffic to it</li></ul>
<h2><span class="mw-headline" id="TCP">TCP</span></h2>
<p>TCP is one of the most complex networking protocols.
</p><p>First of all, it creates a virtual connection between the client and the server. To achieve this, a TCP header contains multiple flags that will be used by both sides to communicate about the status of that connection: SYN (synchronize), ACK (acknowledge), PSH (Push), FIN (finish) and others.
</p><p>On top of that, TCP is trying to alleviate the fact that IP does not guarantee that packets will be received in the order they were sent, let alone received at all. This is why it keeps track of the amount of data actually sent, requires each side to regularly acknowledge the data they have received, and will have packets resent if need be. For this, a TCP header contains a sequence number and an acknowledgement number.
</p><p>In the course of a TCP connection, both sides send each other some data, split across multiple packets. One way to measure where the communication stands is to send the position (in number of bytes) in that communication. The sequence number in a TCP packet is the position the current packet is at. Likewise, the acknowledgement number indicates the position (still in bytes) where one party expects the other party to send.
</p><p>When either side receives a TCP packet with a sequence number S, an acknowledgement number A and a payload of size N, its next packet it sends should have the sequence number A (i.e. it's sending the data the other party expects) and the acknowledgement number S + N (or S+1 if N is null).
</p>
<h3><span class="mw-headline" id="Establishing_a_connection">Establishing a connection</span></h3>
<p>A TCP connection is established with the following 3-way handshake:
</p>
<ul><li>The client sends a SYN request to the server (i.e. a message with the SYN flag set)</li>
<li>The server responds with an SYN+ACK request (the standard also allows it to send an ACK and SYN separately, though that rarely happens).</li>
<li>The client sends an ACK response.</li></ul>
<p>The sequence number used in the SYN packets is the initial sequence number; all further packets shall use sequence numbers that are increments of the initial sequency number.  The sequence number can be reset by sending a new SYN packet with a new sequence number.
</p><p>The initial SYN and SYN+ACK packets "may" also contain data to be sent to the application, but this is rarely used.  The TCP specification states that this data shall not be delivered to the application until the connection is established (i.e. after the final ACK response packet is received).
</p>
<h3><span class="mw-headline" id="Transmitting_data">Transmitting data</span></h3>
<p>To send data, either side can send a PSH, ACK message, with the actual data after the TCP header. The other party will need to send an ACK message to acknowledge it has received the packet. If not, the sender will send again the packet. This is where multiple TCP/IP implementations differ - some may wait more or less long before sending an ACK.
</p>
<h3><span class="mw-headline" id="Closing_the_connection">Closing the connection</span></h3>
<p>The termination of the connection&#160;:
</p>
<ul><li>The side that wants to close the connection sends a packet with a FIN flag</li>
<li>The other side sends a FIN, ACK message</li>
<li>The first side sends an ACK message</li></ul>
<p>Like for the packets used to establish a connection, those packets do not contain any payload - just a TCP header.
</p>
<h3><span class="mw-headline" id="An_example">An example</span></h3>
<p>Let's look at an example of a TCP communication for an HTTP GET request:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Source -&gt; Destination
</th>
<th>Destination -&gt; Source
</th>
<th>Comment
</th></tr>
<tr>
<td>Flag: SYN
<p>seq_nb=0, ack_nb=0
</p>
</td>
<td>
</td>
<td>Beginning of the TCP handshake. It is sending byte #0 (a packet without a payload will be considered to have at least one byte communication) and hasn't received any data yet from the server
</td></tr>
<tr>
<td>
</td>
<td>Flags: SYN, ACK
<p>seq_nb=0, ack_nb=1
</p>
</td>
<td>
</td></tr>
<tr>
<td>Flag: ACK
<p>seq_nb=1, ack_nb=1
</p>
</td>
<td>
</td>
<td>The TCP handshake is completed, the communication can start
</td></tr>
<tr>
<td>Flags: PSH, ACK
<p>seq_nb=1, ack_nb=1, len=77
</p>
</td>
<td>
</td>
<td>This is the HTTP GET request sent by the client. This is the first packet with an actual payload
</td></tr>
<tr>
<td>
</td>
<td>Flag: ACK
<p>seq_nb=1, ack_nb=78
</p>
</td>
<td>The server acknowledges the HTTP request: it has successfully read up to byte #77, so expects the next communication to start at byte #78
</td></tr>
<tr>
<td>
</td>
<td>Flags: PSH, ACK
<p>seq_nb=1, ack_nb=78, len=1009
</p>
</td>
<td>This is the body of the HTML
</td></tr>
<tr>
<td>Flag: ACK
<p>seq_nb=78, ack_nb=1010
</p>
</td>
<td>
</td>
<td>The client acknowledges the message sent by the server: it is sending byte #78, and has receveid up to byte #1009 so expects the next communication to start at byte #1010
</td></tr>
<tr>
<td>Flags: FIN, ACK
<p>seq_nb=78, ack_nb=1010
</p>
</td>
<td>
</td>
<td>The client terminates the TCP connection
</td></tr>
<tr>
<td>
</td>
<td>Flags: FIN, ACK
<p>seq_nb=1010, ack_nb=79
</p>
</td>
<td>
</td></tr>
<tr>
<td>Flag: ACK
<p>seq_nb=79, ack_nb=1011
</p>
</td>
<td>
</td>
<td>The end of the TCP communication
</td></tr></tbody></table>
<h2><span class="mw-headline" id="What_to_focus_on">What to focus on</span></h2>
<p>The shape of the stack will vary on design decisions. These may include
</p>
<ul><li>whether or not a packet is passed between processing layers in one buffer or is copied to a new buffer when passing a layer boundary;</li>
<li>whether in and outbound frames are communicated with the link layer with the use of a dedicated thread, are fully contained in an interrupt handler or in a loop in a single-threaded environment;</li>
<li>whether frames (eg. ethernet frames) are processed immediately or queued;</li>
<li>whether you want TCP support or just UDP or maybe only IP support; TCP is the most complex part of the stack, in the lwip implementation half of the code is specific to TCP.</li></ul>
<p>As an example, a stack might
</p>
<ul><li>have the NIC's API provide three functions: setting up the NIC, poll for a frame and send a frame;</li>
<li>communicate in and outbound frames to the NIC in a one thread;</li>
<li>demultiplex inbound frames from a reception queue in another thread.</li></ul>
<h2><span class="mw-headline" id="General_considerations">General considerations</span></h2>
<ul><li>When writing a stack over an ethernet, you may want to provide support for the ARP protocol and resolve functions.</li>
<li>For the sake of modularity, the station's IP would be better stored in an nic_info struct rather than as a global variable.</li>
<li>You may want to use Wireshark or another packet sniffer to inspect the communication and netcat which would dump debugging data sent from your OS once you have UDP or TCP support. Also, arping is useful when debugging arp code. You may code a trigger which for example reboots your system upon receipt of an ARP who-has for a chosen IP.</li>
<li>You may use a dedicated ethernet card on one computer connected with a crossed over cable to another computer (which runs your operating system) and use static IP. Other options include testing under bochs or qemu after implementing drivers for the network devices they provide.</li></ul>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="Diskless_Booting" title="Diskless Booting">Diskless Booting</a></li>
<li><a href="./Category:Network_Hardware" title="Category:Network Hardware">Network Hardware</a></li></ul>
<h3><span class="mw-headline" id="Threads">Threads</span></h3>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="http://focus.ti.com/lit/an/slaa137a/slaa137a.pdf">Details on a implementation of a embedded web server with overview of the hardware, TCP/IP suite, TCP/IP stack and its API.</a></li>
<li><a rel="nofollow" class="external text" href="http://www.faqs.org/rfcs/rfc793.html">RFC 793 - Transmission Control Protocol</a></li>
<li><a rel="nofollow" class="external text" href="https://www.amazon.com/TCP-Illustrated-Protocols-Addison-Wesley-Professional/dp/0201633469/ref=pd_bbs_sr_1?ie=UTF8&amp;s=books&amp;qid=1229662804&amp;sr=8-1">TCP/IP Illustrated - A must have book for any type of networking, great reference book</a></li></ul>
<p>A number of tcp/ip stacks come with a documentation of their implementations; it makes a good read.
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.cs.northwestern.edu/~pdinda/minet/">Minet: A User-level TCP/IP Stack</a></li>
<li><a rel="nofollow" class="external text" href="http://www.sics.se/~adam/uip/index.php/Main_Page">uIP tiny stack for 8-bit embedded microcontrollers</a></li>
<li><a rel="nofollow" class="external text" href="https://lwip.fandom.com/wiki/LwIP_Wiki">lwIP light-weight implementation</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250212011417
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.020 seconds
Real time usage: 0.021 seconds
Preprocessor visited node count: 74/1000000
Post‐expand include size: 682/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    1.613      1 -total
 57.54%    0.928      1 Template:In_Progress
 23.62%    0.381      2 Template:Wikitable
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2538-0!canonical and timestamp 20250212011417 and revision id 23577.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Network_Stack&amp;oldid=23577">https://wiki.osdev.org/index.php?title=Network_Stack&amp;oldid=23577</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="./Category:In_Progress" title="Category:In Progress">In Progress</a></li><li><a href="./Category:Networking" title="Category:Networking">Networking</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Network+Stack" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="Networking#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Network_Stack" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Talk:Network_Stack&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Network_Stack"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Network_Stack&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Network_Stack&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Network_Stack" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/Network_Stack" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Network_Stack&amp;oldid=23577" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Network_Stack&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 16 April 2019, at 19:16.</li>
	<li id="footer-info-0">This page has been accessed 7,493 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Network_Stack&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.020","walltime":"0.021","ppvisitednodes":{"value":74,"limit":1000000},"postexpandincludesize":{"value":682,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    1.613      1 -total"," 57.54%    0.928      1 Template:In_Progress"," 23.62%    0.381      2 Template:Wikitable"]},"cachereport":{"timestamp":"20250212011417","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":128});});</script>
</body>
</html>