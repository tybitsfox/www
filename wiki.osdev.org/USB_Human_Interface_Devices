<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>USB Human Interface Devices - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"151e8db71278a3049b80bdac","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"USB_Human_Interface_Devices","wgTitle":"USB Human Interface Devices","wgCurRevisionId":28137,"wgRevisionId":28137,"wgArticleId":4063,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","USB","Human Interface Device"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"USB_Human_Interface_Devices","wgRelevantArticleId":4063,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,
"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-USB_Human_Interface_Devices rootpage-USB_Human_Interface_Devices skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">USB Human Interface Devices</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="USB_Human_Interface_Devices#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="USB_Human_Interface_Devices#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p><b>USB Human Interface Devices (HID)</b> are devices that, like the name suggests, allow an interface that lets humans interact with the computer. Common examples include USB mice, USB keyboards, USB joysticks, and other such devices. The protocol used by USB HID devices is defined in the USB HID specification. Some chipsets support emulating USB keyboards and mice as standard PS/2 devices, but many chipsets don't. Thus, a USB HID driver is necessary in some PCs that may not have PS/2 ports at all. 
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="USB_Human_Interface_Devices#Protocol"><span class="tocnumber">1</span> <span class="toctext">Protocol</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="USB_Human_Interface_Devices#Detecting_HID_devices"><span class="tocnumber">1.1</span> <span class="toctext">Detecting HID devices</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="USB_Human_Interface_Devices#&quot;SetProtocol&quot;_request"><span class="tocnumber">1.2</span> <span class="toctext">"SetProtocol" request</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="USB_Human_Interface_Devices#&quot;GetReport&quot;_request"><span class="tocnumber">1.3</span> <span class="toctext">"GetReport" request</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="USB_Human_Interface_Devices#Interrupt_endpoint"><span class="tocnumber">1.4</span> <span class="toctext">Interrupt endpoint</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="USB_Human_Interface_Devices#USB_keyboard"><span class="tocnumber">2</span> <span class="toctext">USB keyboard</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="USB_Human_Interface_Devices#Report_format"><span class="tocnumber">2.1</span> <span class="toctext">Report format</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="USB_Human_Interface_Devices#Keypress_mechanism"><span class="tocnumber">2.2</span> <span class="toctext">Keypress mechanism</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="USB_Human_Interface_Devices#Auto-repeat"><span class="tocnumber">2.3</span> <span class="toctext">Auto-repeat</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="USB_Human_Interface_Devices#LED_lamps"><span class="tocnumber">2.4</span> <span class="toctext">LED lamps</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="USB_Human_Interface_Devices#USB_mouse"><span class="tocnumber">3</span> <span class="toctext">USB mouse</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="USB_Human_Interface_Devices#Report_format_2"><span class="tocnumber">3.1</span> <span class="toctext">Report format</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13"><a href="USB_Human_Interface_Devices#USB_Report_Protocol"><span class="tocnumber">4</span> <span class="toctext">USB Report Protocol</span></a>
<ul>
<li class="toclevel-2 tocsection-14"><a href="USB_Human_Interface_Devices#Country_Codes"><span class="tocnumber">4.1</span> <span class="toctext">Country Codes</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="USB_Human_Interface_Devices#Report_Descriptor"><span class="tocnumber">4.2</span> <span class="toctext">Report Descriptor</span></a>
<ul>
<li class="toclevel-3 tocsection-16"><a href="USB_Human_Interface_Devices#Short_Item"><span class="tocnumber">4.2.1</span> <span class="toctext">Short Item</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="USB_Human_Interface_Devices#Long_Item"><span class="tocnumber">4.2.2</span> <span class="toctext">Long Item</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-18"><a href="USB_Human_Interface_Devices#Parsing"><span class="tocnumber">4.3</span> <span class="toctext">Parsing</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="USB_Human_Interface_Devices#Physical_Descriptors"><span class="tocnumber">4.4</span> <span class="toctext">Physical Descriptors</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-20"><a href="USB_Human_Interface_Devices#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a>
<ul>
<li class="toclevel-2 tocsection-21"><a href="USB_Human_Interface_Devices#Articles"><span class="tocnumber">5.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="USB_Human_Interface_Devices#External_links"><span class="tocnumber">5.2</span> <span class="toctext">External links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Protocol">Protocol</span></h2>
<p>USB HID devices are mainly based on two protocols: the report protocol and the boot protocol. A report is a data structure that is sent to the host from the device, or can also be sent from the host to the device. When a device sends a report to the host, it normally contains status change information, such as a keypress, mouse movement, etc. When the host sends a report to the device, it normally contains commands for configuring the device, such as setting LEDs on a keyboard, for example. This protocol of course depends on the <a href="USB#USB_Device_Framework" class="mw-redirect" title="USB">standard USB framework</a>. USB HID devices communicate using interrupt transfers, as they don't always transfer data, but when they do, they require very fast response from the software as well as the data transferred is normally small. Reports generally have two types, depending on the protocol type. Report protocols are based on the concept of "items," and their structures are defined in report descriptors. The boot protocol is much simpler, and follows standard structures for mice and keyboards. For simplicity's sake, this article will discuss the boot protocol only, for now at least. 
</p>
<h3><span class="mw-headline" id="Detecting_HID_devices">Detecting HID devices</span></h3>
<p>HID devices have class/sub-class values of both zeroes in their device descriptors, and instead have the class/sub-class values valid in their interface descriptors. Keep in mind that interface descriptors cannot be manually requested, and must be acquired along with the configuration and endpoint descriptors. The class value that identifies a HID device in the interface descriptors is 3. The sub-class value in the interface descriptor can be either 1 to indicate the device supports the boot protocol, or zero to indicate the device only supports the report protocol. The protocol field in the interface descriptor as well determines it is a mouse or a keyboard. Specifically, 1 indicates the HID device is a keyboard, while 2 indicates the HID device is a mouse. 
</p>
<h3><span id=".22SetProtocol.22_request"></span><span class="mw-headline" id="&quot;SetProtocol&quot;_request">"SetProtocol" request</span></h3>
<p>Assuming a USB HID device supports the boot protocol, as explained in the section above, where is has a class value of 3 and a sub-class value of 1, the driver software can select the protocol to use. It uses the "SetProtocol" request to tell the device whether it wants to use the report protocol or the boot protocol. For simplicity's sake, this article will describe the boot protocol only, for now. To send the "SetProtocol" request, software sends a regular SETUP transaction to the device's control endpoint zero. The SETUP packet's request type would contain 0x21, the request code for "SetProtocol" is 0x0B, and the value field of the SETUP packet should contain 0 to indicate boot protocol, or 1 to indicate report protocol. The index and length fields both must be zero, as the index is unused and this request has no data stages. This command is only supported on device that support the boot protocol at all. After this command has been used, all reports sent from the device to the host will be either boot reports or regular reports, depending on the type the software requests. 
</p>
<h3><span id=".22GetReport.22_request"></span><span class="mw-headline" id="&quot;GetReport&quot;_request">"GetReport" request</span></h3>
<p>The software can request a report from a USB device using the control endpoint and the regular SETUP packet. The SETUP packet's request type would contain 0xA1, the request code for "GetReport" is 1, the SETUP packet's "value" field would contain 0x0100, to request an input packet with ID zero, and the length field would be the length of the data stage the host wishes to receive. The SETUP packet should be sent to the device endpoint 0 (control endpoint.) For keyboards, the data stage is normally 8 bytes, while for mice, the data stage has the first 3 bytes in a standard format, while the rest of it may be used by device-specific features. Receiving reports this way is recommended only to test that the device initialization was completed successfully, or such, and the "GetReport" request should not be used to poll the HID device for changes, as the SETUP and STATUS stages waste too much time. Instead, software should poll the HID using interrupt transfers, using the interrupt IN endpoint. 
</p>
<h3><span class="mw-headline" id="Interrupt_endpoint">Interrupt endpoint</span></h3>
<p>It is generally recommended that the HID reports to the software using interrupt transfers, and that software should normally avoid the "GetReport" request mentioned above. Driver software should request the <a href="USB#CONFIGURATION" class="mw-redirect" title="USB">configuration descriptor</a> for the HID device. A HID device must support at least one configuration. Software should then scan the <a href="USB#INTERFACE" class="mw-redirect" title="USB">endpoint descriptors</a>, searching for a descriptor that indicates an "interrupt IN" type, which is an endpoint that sends device data to the host using interrupt transfers. Software should save the 4-bit ID of the endpoint, as well as the 8-bit interval of the endpoint. The interval value encodes time in milliseconds (ms) in which timespace the software should poll for a report packet once. For example, if the interval value is 8, software should request a report from the device every 8 ms. If software requests a report too early, for example, after 6 ms, the device may send the same packet as before, or it may not send anything, and return NAK instead. If software requests a report after the timespan, say for example 9 ms, then the device will send the new packet. Software constantly polls USB HID devices using this described method. This is also a good chance to optimize your USB code, as the polling functions will be run hundreds of times per second. Specifically in Bochs, the interval value of the USB mouse is 10 ms, and so software polls the USB device 100 times per second. 
</p>
<h2><span class="mw-headline" id="USB_keyboard">USB keyboard</span></h2>
<p>USB keyboards communicate with software using reports, just like other HID devices. USB keyboards are detected by having a class code of 3 and a protocol value of 1, in the interface descriptor. I will be describing the boot protocol here, for simplicity's sake, for now at least.
</p>
<h3><span class="mw-headline" id="Report_format">Report format</span></h3>
<p>This report must be requested by the software using interrupt transfers once every interval milliseconds, and the interval is defined in the interrupt IN descriptor of the USB keyboard. The USB keyboard report may be up to 8 bytes in size, although not all these bytes are used and it's OK to implement a proper implementation using only the first three or four bytes (and this is how I do it.) Just for completion's sake, however, I will describe the full report mechanism of the keyboard. Notice that the report structure defined below applies to the boot protocol only.
</p>
<table width="70%" border="1">

<tbody><tr>
<td><b>Offset</b>
</td>
<td><b>Size</b>
</td>
<td><b>Description</b>
</td></tr>
<tr>
<td>0
</td>
<td>Byte
</td>
<td>Modifier keys status.
</td></tr>
<tr>
<td>1
</td>
<td>Byte
</td>
<td>Reserved field.
</td></tr>
<tr>
<td>2
</td>
<td>Byte
</td>
<td>Keypress #1.
</td></tr>
<tr>
<td>3
</td>
<td>Byte
</td>
<td>Keypress #2.
</td></tr>
<tr>
<td>4
</td>
<td>Byte
</td>
<td>Keypress #3.
</td></tr>
<tr>
<td>5
</td>
<td>Byte
</td>
<td>Keypress #4.
</td></tr>
<tr>
<td>6
</td>
<td>Byte
</td>
<td>Keypress #5.
</td></tr>
<tr>
<td>7
</td>
<td>Byte
</td>
<td>Keypress #6.
</td></tr></tbody></table>
<p><b>Modifier keys status:</b> This byte is a bitfield, where each bit corresponds to a specific modifier key. When a bit is set to 1, the corresponding modifier key is being pressed. Unlike PS/2 keyboards, USB keyboards don't have "scancodes" for modifier keys. The bit structure of this byte is:
</p>
<table width="70%" border="1">

<tbody><tr>
<td><b>Bit</b>
</td>
<td><b>Bit Length</b>
</td>
<td><b>Description</b>
</td></tr>
<tr>
<td>0
</td>
<td>1
</td>
<td>Left Ctrl.
</td></tr>
<tr>
<td>1
</td>
<td>1
</td>
<td>Left Shift.
</td></tr>
<tr>
<td>2
</td>
<td>1
</td>
<td>Left Alt.
</td></tr>
<tr>
<td>3
</td>
<td>1
</td>
<td>Left GUI (Windows/Super key.)
</td></tr>
<tr>
<td>4
</td>
<td>1
</td>
<td>Right Ctrl.
</td></tr>
<tr>
<td>5
</td>
<td>1
</td>
<td>Right Shift.
</td></tr>
<tr>
<td>6
</td>
<td>1
</td>
<td>Right Alt.
</td></tr>
<tr>
<td>7
</td>
<td>1
</td>
<td>Right GUI (Windows/Super key.)
</td></tr></tbody></table>
<p>When software receives an interrupt and, for example, one of the Shift modifier keys are set to 1, software should use the scancode table for the shift modification to get the key from the scancode.
</p><p><b>Reserved field:</b> This byte is reserved by the USB HID specification, and thus software should ignore it.
</p><p><b>Keypress fields:</b> One keyboard report can indicate up to 6 keypresses. All these values are unsigned 8-bit values (unlike PS/2 scancodes, which are mostly 7-bit) which indicate the key being pressed. A reference on the USB scancode to ASCII character conversion table is in the bottom of the article.
</p>
<h3><span class="mw-headline" id="Keypress_mechanism">Keypress mechanism</span></h3>
<p>USB keyboards send interrupts when a key is pressed or released, just like a PS/2 keyboard. However, unlike PS/2 keyboards, USB keyboard does not have the concept of "make" and "break" scancodes. When a user presses a key, the interrupt comes in with a scancode value in one of the keypress fields. When a key is released, the corresponding keypress field is returned zero in the next packet. To illustrate this more clearly and to illustrate why there are more than one keypress scancode field, let's look at the following examples.
Assume the user pressed the "A" key, which is scancode 0x04. The returned interrupt packet would look like this:
</p>
<pre>00 00 04 00 00 00 00 00
</pre>
<p>Notice the modifier keys are zero, because the user isn't pressing any. The reserved field is also zero, as recommended by the USB HID spec. The first keypress field contains 0x04, which corresponds to the "A" key. Now, let's assume the user lets go of the "A" key. The packet sent would look like:
</p>
<pre>00 00 00 00 00 00 00 00
</pre>
<p>Now, let's assume the user pressed the "A" key, and then pressed the "B" key (scancode 0x05) without letting go of the "A" key:
</p>
<pre>00 00 04 05 00 00 00 00
</pre>
<p>Notice how one interrupt packet is capable of transferring two keypresses together. Now let's assume the user presses the "C" key (scancode 0x06) without letting go of either "A" or "B" key:
</p>
<pre>00 00 04 05 06 00 00 00
</pre>
<p>Now what if the user lets go of the "A" key but keeps pressing the "B" and "C" keys? The keyboard will indicate that "A" is no longer being pressed, and "B" and "C" will move towards the beginning of the packet:
</p>
<pre>00 00 05 06 00 00 00 00
</pre>
<p>As is probably obvious now, the USB keyboard returns scancodes in order of which one was pressed first. As such, if the first keypress field is zero, there are no keys that send scancodes being pressed. If it is not zero, software can check the next fields, to see if another key is being pressed as well.
</p><p>The concept of modifier keys is probably obvious, but just for completion, let's assume the user pressed the left shift key with the "X" key (scancode 0x1B). The interrupt packet sent will contain:
</p>
<pre>02 00 1B 00 00 00 00 00
</pre>
<p>Notice that bit 1 (value 0x02) of the modifier field is set, to indicate that the the left shift key is being pressed.
</p><p>There is also a "phantom condition" which you can think of as an overflow. A USB keyboard packet can indicate up to 6 keypresses in one transfer, but let's imagine someone dropped their keyboard and more than 6 keys were pressed in one time. The keyboard will enter the phantom condition, in which all reported keys will be of the invalid scancode 0x01. Modifier keys will still be reported however. Imagine that 8 keys (or any random number more than 6) are being pressed, and the right shift key is also being pressed. The packet sent would look like:
</p>
<pre>20 00 01 01 01 01 01 01
</pre>
<p>Notice that the modifier keys are still being indicated, but the actual scancodes all return the phantom condition. There are other special scancodes besides the phantom condition: 0x00 indicates there is no scancode and no key being pressed, 0x01 indicates the phantom condition we just explained, 0x02 indicates the keyboard's self-test failed and 0x03 indicates an undefined error occured. Starting from 0x04 the scancodes are valid and correspond to "real" keys. IMHO, a device driver should ignore the phantom condition if it happens.
</p>
<h3><span class="mw-headline" id="Auto-repeat">Auto-repeat</span></h3>
<p>One thing that makes USB keyboards a pain is that there is no mechanism for auto-repeat and auto-repeat delays in hardware; this must be implemented entirely in software, unlike PS/2 keyboards. For an example auto-repeat delay of 500 milliseconds and an auto-repeat speed of 10 characters per second, when software becomes aware that a certain key is being pressed without being released constantly, it ignores all the key presses except the first one for 500 milliseconds (or whatever auto-repeat delay you like), and if this times out and the key is still being pressed, the driver will report 10 keypresses every 1 second, or whatever auto-repeat speed you want as well. This would make the user feel natural, just like you would when you press and hold a key; the first key appears on the screen, the computer waits a short delay, and then the keys keep coming up.
</p>
<h3><span class="mw-headline" id="LED_lamps">LED lamps</span></h3>
<p>LED lamps are also handled in software, and according to the hardware, NumLock, CapsLock and ScrollLock are normal keys that send normal scancodes. The driver is responsible for manipulating the LED lamps when one of these keys are pressed.
</p><p>To set the LED lamps, the driver sends a SetReport request to the device using a standard USB Setup Transaction, with a one-byte data stage. The setup packet's request type should contain 0x21, the request code for SetReport is 0x09. The value field of the setup packet contains the report ID in the low byte, which should be zero. The high byte contains the report type, which should be 0x02 to indicate an output report, or a report that is being sent from the software to the hardware. The index field should contain the interface number of the USB keyboard, which is the number present in the interface descriptor which indicated this device was a USB keyboard at all. The data stage should be 1 byte, which is a bitfield. This Setup Transaction should be transferred to control endpoint zero, which would work on all hardware. Other hardware may or may not support the optional interrupt OUT endpoint. If the hardware supports the interrupt OUT endpoint, you can just transfer the 1 byte data stage to the interrupt OUT endpoint, without the extra overhead of the SETUP stage and STATUS stage. If the hardware support the interrupt OUT endpoint, you should avoid the control endpoint when possible, as the interrupt OUT endpoint is faster and can be programmed with interrupt transfers instead of setup transfers. The format of the 1-byte data stage (for SETUP transaction) or 1-byte interrupt OUT transfer is shown below. When a bit is set to 1, the corresponding LED is turned on.
</p>
<table width="70%" border="1">

<tbody><tr>
<td><b>Bit</b>
</td>
<td><b>Bit Length</b>
</td>
<td><b>Description</b>
</td></tr>
<tr>
<td>0
</td>
<td>1
</td>
<td>Num Lock.
</td></tr>
<tr>
<td>1
</td>
<td>1
</td>
<td>Caps Lock.
</td></tr>
<tr>
<td>2
</td>
<td>1
</td>
<td>Scroll Lock.
</td></tr>
<tr>
<td>3
</td>
<td>1
</td>
<td>Compose.
</td></tr>
<tr>
<td>4
</td>
<td>1
</td>
<td>Kana.
</td></tr>
<tr>
<td>5
</td>
<td>3
</td>
<td>Reserved, must be zero.
</td></tr></tbody></table>
<h2><span class="mw-headline" id="USB_mouse">USB mouse</span></h2>
<p>USB mice, just like any other HID device, communicate with the software using reports, which are sent via interrupt endpoints or can be manually requested with the "GetReport" request. USB mice have a protocol value of 2 in the interface descriptor. 
</p>
<h3><span class="mw-headline" id="Report_format_2">Report format</span></h3>
<p>This report must be requested by the host using interrupt transfers once every interval milliseconds. Interval is defined in the interrupt IN descriptor of the USB mouse device. Only the first three bytes of the USB mouse report are defined. The remaining bytes, if existed, may be used for device-specific features. Software may request only three bytes in an interrupt transfer, and this will not cause an error even if the actual packet is larger. The table below defines the report format for USB mice operating using the boot protocol.
</p>
<table width="70%" border="1">

<tbody><tr>
<td><b>Offset</b>
</td>
<td><b>Size</b>
</td>
<td><b>Description</b>
</td></tr>
<tr>
<td>0
</td>
<td>Byte
</td>
<td>Button status.
</td></tr>
<tr>
<td>1
</td>
<td>Byte
</td>
<td>X movement.
</td></tr>
<tr>
<td>2
</td>
<td>Byte
</td>
<td>Y movement.
</td></tr></tbody></table>
<p><br />
<b>Button status:</b> This byte is a bitfield, in which the lowest three bits are standard format. The remaining 5 bits may be used for device-specific purposes.
</p>
<table width="70%" border="1">

<tbody><tr>
<td><b>Bit</b>
</td>
<td><b>Bit Length</b>
</td>
<td><b>Description</b>
</td></tr>
<tr>
<td>0
</td>
<td>1
</td>
<td>When set to 1, indicates the left mouse button is being clicked.
</td></tr>
<tr>
<td>1
</td>
<td>1
</td>
<td>When set to 1, indicates the right mouse button is being clicked.
</td></tr>
<tr>
<td>2
</td>
<td>1
</td>
<td>When set to 1, indicates the middle mouse button is being clicked.
</td></tr>
<tr>
<td>3
</td>
<td>5
</td>
<td>These bits are reserved for device-specific features.
</td></tr></tbody></table>
<p><br />
<b>X movement:</b> This is a signed 8-bit integer that represents the X movement. Bit 7 (value 0x80) determines the sign of the value. When this value is negative, the mouse is being moved to the left. When this value is positive, the mouse is being moved to the right. Notice that unlike PS/2 mice, the movement values for USB mice are 8-bit signed integers and not 9-bit integers.
</p><p><b>Y movement:</b> This is also a signed 8-bit integer that represents the Y movement. When this value is negative, the mouse is being moved up. When the value is positive, the mouse is being moved down (towards the user.)
</p>
<h2><span class="mw-headline" id="USB_Report_Protocol">USB Report Protocol</span></h2>
<p>This is the complicated one supported by all HID class devices. Mouses, keyboards, joysticks...
</p><p>The interface descriptor will contain an HID descriptor alongside the endpoint descriptors:
</p>
<table width="70%" border="1">
<tbody><tr>
<th>Offset
</th>
<th>Field
</th>
<th>Size
</th>
<th>Type
</th>
<th>Description
</th></tr>
<tr valign="top">
<td align="center">0
</td>
<td>bLength
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Size of this descriptor in bytes
</td></tr>
<tr valign="top">
<td align="center">1
</td>
<td>bDescriptorType
</td>
<td align="center">1
</td>
<td align="center">Constant
</td>
<td>HID Descriptor Type (0x22)
</td></tr>
<tr valign="top">
<td align="center">2
</td>
<td>bcdHID
</td>
<td align="center">2
</td>
<td align="center">BCD
</td>
<td>HID Class Specification Release Number in Binary-Coded Decimal (i.e, 1.10 is expressed as 110h).
</td></tr>
<tr valign="top">
<td align="center">4
</td>
<td>bCountryCode
</td>
<td align="center">1
</td>
<td align="center">ID
</td>
<td>Country code of localised hardware (0 if irrelevant. Mainly for keyboards).
</td></tr>
<tr valign="top">
<td align="center">5
</td>
<td>bNumDescriptors
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Number of descriptors &gt;= 1
</td></tr>
<tr valign="top">
<td align="center">3i+6
</td>
<td>bDescriptorType
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Type of HID descriptor
</td></tr>
<tr valign="top">
<td align="center">3i+7
</td>
<td>wDescriptorLength
</td>
<td align="center">2
</td>
<td align="center">Number
</td>
<td>Length of HID Descriptor
</td></tr></tbody></table>
<p>There is always one descriptor, a Report Descriptor, followed by n Optional Descriptors. The types and lengths only are in an array at the end of the overarching HID Descriptor.
</p><p><b>HID Descriptor Types</b>
</p>
<table border="1" cellpadding="2">
<tbody><tr>
<th>Value
</th>
<th>Description
</th></tr>
<tr>
<td align="center">21h
</td>
<td>HID Descriptor
</td></tr>
<tr>
<td align="center">22h
</td>
<td>Report Descriptor
</td></tr>
<tr>
<td align="center">23h
</td>
<td>Physical Descriptor
</td></tr></tbody></table>
<p>To get the details of these descriptors, use the standard USB <a href="USB#GET_DESCRIPTOR" class="mw-redirect" title="USB">GET_DESCRIPTOR</a>, but with an interface recipient.
</p>
<table align="center" border="1" cellpadding="5">
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th colspan="2">wValue
</th>
<th>wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>10000001b
</td>
<td>GET_DESCRIPTOR<br />6
</td>
<td>Descriptor Type
</td>
<td>Descriptor Index
</td>
<td>Interface Number
</td>
<td>Descriptor<br />Length
</td></tr></tbody></table>
<p>Descriptor Index is 0 except for Physical Descriptors, where Index 0 will enumerate descriptor sets and their sizes.
</p>
<h3><span class="mw-headline" id="Country_Codes">Country Codes</span></h3>
<table border="1" cellpadding="2">
<tbody><tr>
<th>Value
</th>
<th>Country
</th>
<th>Value
</th>
<th>Country
</th>
<th>Value
</th>
<th>Country
</th>
<th>Value
</th>
<th>Country
</th>
<th>Value
</th>
<th>Country
</th></tr>
<tr>
<td align="center">00h
</td>
<td><i>Not Supported</i>
</td>
<td align="center">08h
</td>
<td>French
</td>
<td align="center">10h
</td>
<td>Korean
</td>
<td align="center">18h
</td>
<td>Slovakia
</td>
<td align="center">20h
</td>
<td>UK
</td></tr>
<tr>
<td align="center">01h
</td>
<td>Arabic
</td>
<td align="center">09h
</td>
<td>German
</td>
<td align="center">11h
</td>
<td>Latin American
</td>
<td align="center">19h
</td>
<td>Spanish
</td>
<td align="center">21h
</td>
<td>US
</td></tr>
<tr>
<td align="center">02h
</td>
<td>Belgian
</td>
<td align="center">0Ah
</td>
<td>Greek
</td>
<td align="center">12h
</td>
<td>Netherlands
</td>
<td align="center">1Ah
</td>
<td>Swedish
</td>
<td align="center">22h
</td>
<td>Yugoslavia
</td></tr>
<tr>
<td align="center">03h
</td>
<td>Canadian-Bilingual
</td>
<td align="center">0Bh
</td>
<td>Hebrew
</td>
<td align="center">13h
</td>
<td>Norwegian
</td>
<td align="center">1Bh
</td>
<td>Swiss/French
</td>
<td align="center">23h
</td>
<td>Turkish-F
</td></tr>
<tr>
<td align="center">04h
</td>
<td>Canadian-French
</td>
<td align="center">0Ch
</td>
<td>Hungary
</td>
<td align="center">14h
</td>
<td>Persian
</td>
<td align="center">1Ch
</td>
<td>Swiss/German
</td></tr>
<tr>
<td align="center">05h
</td>
<td>Czechia
</td>
<td align="center">0Dh
</td>
<td>International (ISO)
</td>
<td align="center">15h
</td>
<td>Poland
</td>
<td align="center">1Dh
</td>
<td>Switzerland
</td></tr>
<tr>
<td align="center">06h
</td>
<td>Danish
</td>
<td align="center">0Eh
</td>
<td>Italian
</td>
<td align="center">16h
</td>
<td>Portuguese
</td>
<td align="center">1Eh
</td>
<td>Taiwan
</td></tr>
<tr>
<td align="center">07h
</td>
<td>Finnish
</td>
<td align="center">0Fh
</td>
<td>Japan (Katakana)
</td>
<td align="center">17h
</td>
<td>Russia
</td>
<td align="center">1Fh
</td>
<td>Turkish-Q
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Report_Descriptor">Report Descriptor</span></h3>
<p>This is not a value table, length and content vary as required.
</p><p>It's a sequential list of items. Items come in two basic types, short and long.
</p>
<h4><span class="mw-headline" id="Short_Item">Short Item</span></h4>
<table width="70%" border="1">
<tbody><tr>
<th>Offset
</th>
<th>Field
</th>
<th>Size
</th>
<th>Type
</th>
<th>Description
</th></tr>
<tr valign="top">
<td align="center">0:0
</td>
<td>bSize
</td>
<td align="center">2 bits
</td>
<td align="center">Enum
</td>
<td>Size of optional data in bytes
</td></tr>
<tr valign="top">
<td align="center">0:2
</td>
<td>bType
</td>
<td align="center">2 bits
</td>
<td align="center">Enum
</td>
<td>Type of this descriptor
</td></tr>
<tr valign="top">
<td align="center">0:4
</td>
<td>bTag
</td>
<td align="center">4 bits
</td>
<td align="center">Number
</td>
<td>Function of the item
</td></tr>
<tr valign="top">
<td align="center">1
</td>
<td>Data
</td>
<td align="center">bSize
</td>
<td align="center">Data
</td>
<td>Item data
</td></tr></tbody></table>
<p>Note that as a special case a bSize of 3 corresponds to 4 bytes.
</p><p><b>bType</b>:
</p>
<table border="1" cellpadding="2">
<tbody><tr>
<th>Value
</th>
<th>Description
</th></tr>
<tr>
<td align="center">00h
</td>
<td>Main
</td></tr>
<tr>
<td align="center">01h
</td>
<td>Global
</td></tr>
<tr>
<td align="center">02h
</td>
<td>Local
</td></tr>
<tr>
<td align="center">03h
</td>
<td>Reserved
</td></tr></tbody></table>
<h4><span class="mw-headline" id="Long_Item">Long Item</span></h4>
<table width="70%" border="1">
<tbody><tr>
<th>Offset
</th>
<th>Field
</th>
<th>Size
</th>
<th>Type
</th>
<th>Description
</th></tr>
<tr valign="top">
<td align="center">0:0
</td>
<td>bSize
</td>
<td align="center">2 bits
</td>
<td align="center">Enum
</td>
<td>Size = 2
</td></tr>
<tr valign="top">
<td align="center">0:2
</td>
<td>bType
</td>
<td align="center">2 bits
</td>
<td align="center">Enum
</td>
<td>Type = 3 (Reserved)
</td></tr>
<tr valign="top">
<td align="center">0:4
</td>
<td>bTag
</td>
<td align="center">4 bits
</td>
<td align="center">Number
</td>
<td>1111b - Long
</td></tr>
<tr valign="top">
<td align="center">1
</td>
<td>bDataSize
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Byte count of data
</td></tr>
<tr valign="top">
<td align="center">2
</td>
<td>bLongItemTag
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Long item tag
</td></tr>
<tr valign="top">
<td align="center">3
</td>
<td>Data
</td>
<td align="center">bDataSize
</td>
<td align="center">Number
</td>
<td>Data
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Parsing">Parsing</span></h3>
<p>The report descriptor's items are parsed in a sequential manner. The parser is a state machine. A complete report descriptor may look something like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">hidReportDescriptor</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="mh">0x05</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w">    </span><span class="c1">// UsagePage(Generic Desktop[1])</span>
<span class="w">    </span><span class="mh">0x09</span><span class="p">,</span><span class="w"> </span><span class="mh">0x04</span><span class="p">,</span><span class="w">    </span><span class="c1">// UsageId(Joystick[4])</span>
<span class="w">    </span><span class="mh">0xA1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w">    </span><span class="c1">// Collection(Application)</span>
<span class="w">    </span><span class="mh">0x85</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w">    </span><span class="c1">//     ReportId(1)</span>
<span class="w">    </span><span class="mh">0x09</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w">    </span><span class="c1">//     UsageId(Pointer[1])</span>
<span class="w">    </span><span class="mh">0xA1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w">    </span><span class="c1">//     Collection(Physical)</span>
<span class="w">    </span><span class="mh">0x09</span><span class="p">,</span><span class="w"> </span><span class="mh">0x30</span><span class="p">,</span><span class="w">    </span><span class="c1">//         UsageId(X[48])</span>
<span class="w">    </span><span class="mh">0x09</span><span class="p">,</span><span class="w"> </span><span class="mh">0x31</span><span class="p">,</span><span class="w">    </span><span class="c1">//         UsageId(Y[49])</span>
<span class="w">    </span><span class="mh">0x15</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80</span><span class="p">,</span><span class="w">    </span><span class="c1">//         LogicalMinimum(-128)</span>
<span class="w">    </span><span class="mh">0x25</span><span class="p">,</span><span class="w"> </span><span class="mh">0x7F</span><span class="p">,</span><span class="w">    </span><span class="c1">//         LogicalMaximum(127)</span>
<span class="w">    </span><span class="mh">0x95</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w">    </span><span class="c1">//         ReportCount(2)</span>
<span class="w">    </span><span class="mh">0x75</span><span class="p">,</span><span class="w"> </span><span class="mh">0x08</span><span class="p">,</span><span class="w">    </span><span class="c1">//         ReportSize(8)</span>
<span class="w">    </span><span class="mh">0x81</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w">    </span><span class="c1">//         Input(Data, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition, BitField)</span>
<span class="w">    </span><span class="mh">0x05</span><span class="p">,</span><span class="w"> </span><span class="mh">0x09</span><span class="p">,</span><span class="w">    </span><span class="c1">//         UsagePage(Button[9])</span>
<span class="w">    </span><span class="mh">0x19</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w">    </span><span class="c1">//         UsageIdMin(Button 1[1])</span>
<span class="w">    </span><span class="mh">0x29</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">,</span><span class="w">    </span><span class="c1">//         UsageIdMax(Button 3[3])</span>
<span class="w">    </span><span class="mh">0x15</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w">    </span><span class="c1">//         LogicalMinimum(0)</span>
<span class="w">    </span><span class="mh">0x25</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w">    </span><span class="c1">//         LogicalMaximum(1)</span>
<span class="w">    </span><span class="mh">0x95</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">,</span><span class="w">    </span><span class="c1">//         ReportCount(3)</span>
<span class="w">    </span><span class="mh">0x75</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w">    </span><span class="c1">//         ReportSize(1)</span>
<span class="w">    </span><span class="mh">0x81</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w">    </span><span class="c1">//         Input(Data, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition, BitField)</span>
<span class="w">    </span><span class="mh">0xC0</span><span class="p">,</span><span class="w">          </span><span class="c1">//     EndCollection()</span>
<span class="w">    </span><span class="mh">0x05</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w">    </span><span class="c1">//     UsagePage(Simulation Controls[2])</span>
<span class="w">    </span><span class="mh">0x09</span><span class="p">,</span><span class="w"> </span><span class="mh">0xBB</span><span class="p">,</span><span class="w">    </span><span class="c1">//     UsageId(Throttle[187])</span>
<span class="w">    </span><span class="mh">0x15</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80</span><span class="p">,</span><span class="w">    </span><span class="c1">//     LogicalMinimum(-128)</span>
<span class="w">    </span><span class="mh">0x25</span><span class="p">,</span><span class="w"> </span><span class="mh">0x7F</span><span class="p">,</span><span class="w">    </span><span class="c1">//     LogicalMaximum(127)</span>
<span class="w">    </span><span class="mh">0x95</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w">    </span><span class="c1">//     ReportCount(1)</span>
<span class="w">    </span><span class="mh">0x75</span><span class="p">,</span><span class="w"> </span><span class="mh">0x08</span><span class="p">,</span><span class="w">    </span><span class="c1">//     ReportSize(8)</span>
<span class="w">    </span><span class="mh">0x81</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w">    </span><span class="c1">//     Input(Data, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition, BitField)</span>
<span class="w">    </span><span class="mh">0x75</span><span class="p">,</span><span class="w"> </span><span class="mh">0x05</span><span class="p">,</span><span class="w">    </span><span class="c1">//     ReportSize(5)</span>
<span class="w">    </span><span class="mh">0x81</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">,</span><span class="w">    </span><span class="c1">//     Input(Constant, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition, BitField)</span>
<span class="w">    </span><span class="mh">0xC0</span><span class="p">,</span><span class="w">          </span><span class="c1">// EndCollection()</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Recall the descriptor types.
</p><p><b>Main</b> - This is added to the logical tree. There are 5 subtypes:
</p>
<ul><li><i>Input</i> - 1000 00 nn</li>
<li><i>Output</i> - 1001 00 nn</li>
<li><i>Feature</i> - 1011 00 nn</li>
<li><i>Collection</i> - 1010 00 nn</li>
<li><i>End Collection</i> - 1100 00 nn</li></ul>
<p><b>Global</b> - Adjusts the global state machine. New main items will inherit this state. This is useful where multiple axes are similar, for instance.
</p>
<ul><li><i>Usage Page</i> - 0000 01 nn</li>
<li><i>Logical Minimum</i> - 0001 01 nn</li>
<li><i>Logical Maximum</i> - 0010 01 nn</li>
<li><i>Physical Minimum</i> - 0011 01 nn</li>
<li><i>Physical Maximum</i> - 0100 01 nn</li>
<li><i>Unit Exponent</i> - 0101 01 nn</li>
<li><i>Unit</i> - 0110 01 nn</li>
<li><i>Report Size</i> - 0111 01 nn</li>
<li><i>Report ID</i> - 1000 01 nn</li>
<li><i>Report Count</i> - 1001 01 nn</li>
<li><i>Push</i> - 1010 01 nn</li>
<li><i>Pop</i> - 1011 01 nn</li></ul>
<p><b>Local</b> - Do not carry over to next main item.
</p>
<ul><li><i>Usage</i> - 0000 10 nn</li>
<li><i>Usage Minimum</i> - 0001 10 nn</li>
<li><i>Usage Maximum</i> - 0010 10 nn</li>
<li><i>Designator Index</i> - 0011 10 nn</li>
<li><i>Designator Minimum</i> - 0100 10 nn</li>
<li><i>Designator Maximum</i> - 0101 10 nn</li>
<li><i>String Index</i> - 0111 10 nn</li>
<li><i>String Minimum</i> - 1000 10 nn</li>
<li><i>String Maximum</i> - 1001 10 nn</li>
<li><i>Delimiter</i> - 1010 10 nn</li></ul>
<p>Note that locals can apply to more than one control is a single item.
</p>
<h3><span class="mw-headline" id="Physical_Descriptors">Physical Descriptors</span></h3>
<p>To quote the HID specification:<br />
<i>"Note Physical Descriptors are entirely optional. They add complexity and offer very little in return for most devices. However, some devices, particularly those with a large number of identical controls (for example, buttons) will find that Physical Descriptors help different applications assign functionality to these controls in a more consistent manner. Skip the following section if you do not plan on supporting Physical Descriptors."</i>
</p>
<h2><span class="mw-headline" id="See_also">See also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="Universal_Serial_Bus" title="Universal Serial Bus">Universal Serial Bus</a></li></ul>
<h3><span class="mw-headline" id="External_links">External links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="http://www.usb.org/developers/hidpage/HID1_11.pdf">USB HID specification</a></li>
<li><a rel="nofollow" class="external text" href="https://github.com/haiku/haiku/tree/master/src/add-ons/kernel/drivers/input/usb_hid">Haiku's USB HID implementation</a></li>
<li><a rel="nofollow" class="external text" href="https://www.win.tue.nl/~aeb/linux/kbd/scancodes-14.html">USB scancodes to ASCII characters conversion table</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250212013126
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.035 seconds
Real time usage: 0.168 seconds
Preprocessor visited node count: 79/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 8189/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:4063-0!canonical and timestamp 20250212013126 and revision id 28137.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=USB_Human_Interface_Devices&amp;oldid=28137">https://wiki.osdev.org/index.php?title=USB_Human_Interface_Devices&amp;oldid=28137</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:USB" title="Category:USB">USB</a></li><li><a href="./Category:Human_Interface_Device" title="Category:Human Interface Device">Human Interface Device</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=USB+Human+Interface+Devices" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="USB_Human_Interface_Devices#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="USB_Human_Interface_Devices" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Talk:USB_Human_Interface_Devices&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="USB_Human_Interface_Devices"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=USB_Human_Interface_Devices&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=USB_Human_Interface_Devices&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/USB_Human_Interface_Devices" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/USB_Human_Interface_Devices" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=USB_Human_Interface_Devices&amp;oldid=28137" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=USB_Human_Interface_Devices&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 10 July 2023, at 02:54.</li>
	<li id="footer-info-0">This page has been accessed 19,813 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=USB_Human_Interface_Devices&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.035","walltime":"0.168","ppvisitednodes":{"value":79,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":8189,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20250212013126","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":97});});</script>
</body>
</html>