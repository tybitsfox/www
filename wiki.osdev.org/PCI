<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>PCI - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"7c34153f8c0901f9e873f467","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"PCI","wgTitle":"PCI","wgCurRevisionId":29308,"wgRevisionId":29308,"wgArticleId":1485,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Buses","PCI","Standards"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"PCI","wgRelevantArticleId":1485,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{"search":
false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-PCI rootpage-PCI skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">PCI</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="PCI#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="PCI#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="PCI#The_PCI_Bus"><span class="tocnumber">1</span> <span class="toctext">The PCI Bus</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="PCI#Configuration_Space"><span class="tocnumber">2</span> <span class="toctext">Configuration Space</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="PCI#Configuration_Space_Access_Mechanism_#1"><span class="tocnumber">2.1</span> <span class="toctext">Configuration Space Access Mechanism #1</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="PCI#Configuration_Space_Access_Mechanism_#2"><span class="tocnumber">2.2</span> <span class="toctext">Configuration Space Access Mechanism #2</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="PCI#Memory_Mapped_PCI_Configuration_Space_Access"><span class="tocnumber">2.3</span> <span class="toctext">Memory Mapped PCI Configuration Space Access</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="PCI#Detecting_Configuration_Space_Access_Mechanism/s"><span class="tocnumber">2.4</span> <span class="toctext">Detecting Configuration Space Access Mechanism/s</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="PCI#PCI_Device_Structure"><span class="tocnumber">2.5</span> <span class="toctext">PCI Device Structure</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="PCI#Common_Header_Fields"><span class="tocnumber">2.5.1</span> <span class="toctext">Common Header Fields</span></a>
<ul>
<li class="toclevel-4 tocsection-9"><a href="PCI#Command_Register"><span class="tocnumber">2.5.1.1</span> <span class="toctext">Command Register</span></a></li>
<li class="toclevel-4 tocsection-10"><a href="PCI#Status_Register"><span class="tocnumber">2.5.1.2</span> <span class="toctext">Status Register</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-11"><a href="PCI#Header_Type_0x0"><span class="tocnumber">2.5.2</span> <span class="toctext">Header Type 0x0</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="PCI#Header_Type_0x1_(PCI-to-PCI_bridge)"><span class="tocnumber">2.5.3</span> <span class="toctext">Header Type 0x1 (PCI-to-PCI bridge)</span></a>
<ul>
<li class="toclevel-4 tocsection-13"><a href="PCI#Header_Type_Register"><span class="tocnumber">2.5.3.1</span> <span class="toctext">Header Type Register</span></a></li>
<li class="toclevel-4 tocsection-14"><a href="PCI#BIST_Register"><span class="tocnumber">2.5.3.2</span> <span class="toctext">BIST Register</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-15"><a href="PCI#Header_Type_0x2_(PCI-to-CardBus_bridge)"><span class="tocnumber">2.5.4</span> <span class="toctext">Header Type 0x2 (PCI-to-CardBus bridge)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="PCI#Base_Address_Registers"><span class="tocnumber">2.6</span> <span class="toctext">Base Address Registers</span></a>
<ul>
<li class="toclevel-3 tocsection-17"><a href="PCI#Address_and_size_of_the_BAR"><span class="tocnumber">2.6.1</span> <span class="toctext">Address and size of the BAR</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-18"><a href="PCI#Class_Codes"><span class="tocnumber">2.7</span> <span class="toctext">Class Codes</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="PCI#Enumerating_PCI_Buses"><span class="tocnumber">3</span> <span class="toctext">Enumerating PCI Buses</span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="PCI#&quot;Brute_Force&quot;_Scan"><span class="tocnumber">3.1</span> <span class="toctext">"Brute Force" Scan</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="PCI#Recursive_Scan"><span class="tocnumber">3.2</span> <span class="toctext">Recursive Scan</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="PCI#Recursive_Scan_With_Bus_Configuration"><span class="tocnumber">3.3</span> <span class="toctext">Recursive Scan With Bus Configuration</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="PCI#Configuring_PCI-to-PCI_bridges"><span class="tocnumber">3.4</span> <span class="toctext">Configuring PCI-to-PCI bridges</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-24"><a href="PCI#IRQ_Handling"><span class="tocnumber">4</span> <span class="toctext">IRQ Handling</span></a></li>
<li class="toclevel-1 tocsection-25"><a href="PCI#Message_Signaled_Interrupts"><span class="tocnumber">5</span> <span class="toctext">Message Signaled Interrupts</span></a>
<ul>
<li class="toclevel-2 tocsection-26"><a href="PCI#Enabling_MSI"><span class="tocnumber">5.1</span> <span class="toctext">Enabling MSI</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="PCI#Enabling_MSI-X"><span class="tocnumber">5.2</span> <span class="toctext">Enabling MSI-X</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-28"><a href="PCI#Multi-function_Devices"><span class="tocnumber">6</span> <span class="toctext">Multi-function Devices</span></a></li>
<li class="toclevel-1 tocsection-29"><a href="PCI#Disclaimer"><span class="tocnumber">7</span> <span class="toctext">Disclaimer</span></a></li>
<li class="toclevel-1 tocsection-30"><a href="PCI#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-31"><a href="PCI#See_Also"><span class="tocnumber">9</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-32"><a href="PCI#Articles"><span class="tocnumber">9.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="PCI#External_Links"><span class="tocnumber">9.2</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="The_PCI_Bus">The PCI Bus</span></h2>
<p>The PCI (<a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Conventional_PCI">Peripheral Component Interconnect</a>) bus was defined to establish a high performance and low cost local bus that would remain through several generations of products. By combining a transparent upgrade path from 132 MB/s (32-bit at 33 MHz) to 528 MB/s (64-bit at 66 MHz) and both 5 volt and 3.3 volt signalling environments, the PCI bus meets the needs of both low end desktop systems and high-end LAN servers. The PCI bus component and add-in card interface is processor independent, enabling an efficient transition to future processors, as well as use with multiple processor architectures. The disadvantage of the PCI bus is the limited number of electrical loads it can drive. A single PCI bus can drive a maximum of 10 loads. (Remember when counting the number of loads on the bus, a connector counts as one load and the PCI device counts as another, and sometimes two.)
</p>
<h2><span class="mw-headline" id="Configuration_Space">Configuration Space</span></h2>
<p>The PCI specification provides for totally software driven initialization and configuration of each device (or target) on the PCI Bus via a separate Configuration Address Space. All PCI devices, except host bus bridges, are required to provide 256 bytes of configuration registers for this purpose.
</p><p>Configuration read/write cycles are used to access the Configuration Space of each target device. A target is selected during a configuration access when its IDSEL signal is asserted. The IDSEL acts as the classic "chip select" signal. During the address phase of the configuration cycle, the processor can address one of 64 32-bit registers within the configuration space by placing the required register number on address lines 2 through 7 (AD[7..2]) and the byte enable lines.
</p><p>PCI devices are inherently little-endian, meaning all multiple byte fields have the least significant values at the lower addresses. This requires a big-endian processor, such as a Power PC, to perform the proper byte-swapping of data read from or written to the PCI device, including any accesses to the Configuration Address Space.
</p><p>Systems must provide a mechanism that allows access to the PCI configuration space, as most CPUs do not have any such mechanism. This task is usually performed by the Host to PCI Bridge (Host Bridge). Two distinct mechanisms are defined to allow the software to generate the required configuration accesses. Configuration mechanism #1 is the preferred method, while mechanism #2 is provided for backwards compatibility. Only configuration mechanism #1 will be described here, as it is the only access mechanism that will be used in the future.
</p>
<h3><span id="Configuration_Space_Access_Mechanism_.231"></span><span class="mw-headline" id="Configuration_Space_Access_Mechanism_#1">Configuration Space Access Mechanism #1</span></h3>
<p>Two 32-bit I/O locations are used, the first location (<code>0xCF8</code>) is named CONFIG_ADDRESS, and the second (<code>0xCFC</code>) is called CONFIG_DATA. CONFIG_ADDRESS specifies the configuration address that is required to be accesses, while accesses to CONFIG_DATA will actually generate the configuration access and will transfer the data to or from the CONFIG_DATA register.
</p><p>The CONFIG_ADDRESS is a 32-bit register with the format shown in following figure. Bit 31 is an enable flag for determining when accesses to CONFIG_DATA should be translated to configuration cycles. Bits 23 through 16 allow the configuration software to choose a specific PCI bus in the system. Bits 15 through 11 select the specific device on the PCI Bus. Bits 10 through 8 choose a specific function in a device (if the device supports multiple functions). 
</p><p>The least significant byte selects the offset into the 256-byte configuration space available through this method. Since all reads and writes must be both 32-bits and aligned to work on all implementations, the two lowest bits of CONFIG_ADDRESS must always be zero, with the remaining six bits allowing you to choose each of the 64 32-bit words. If you don't need all 32 bits, you'll have to perform the unaligned access in software by aligning the address, followed by masking and shifting the answer.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bit 31
</th>
<th>Bits 30-24
</th>
<th>Bits 23-16
</th>
<th>Bits 15-11
</th>
<th>Bits 10-8
</th>
<th>Bits 7-0
</th></tr>
<tr>
<td>Enable Bit
</td>
<td>Reserved
</td>
<td>Bus Number
</td>
<td>Device Number
</td>
<td>Function Number
</td>
<td>Register Offset<sup>1</sup>
</td></tr></tbody></table>
<p><sup>1</sup> Register Offset has to point to consecutive DWORDs, ie. bits 1:0 are always 0b00 (they are still part of the Register Offset).
</p><p>The following code segment illustrates the use of configuration mechanism #1 to read 16-bit fields from configuration space. Note that this segment, the outl(port, value) and inl(port) functions refer to the OUTL and INL Pentium assembly language instructions. 
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">pciConfigReadWord</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">slot</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">address</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lbus</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">bus</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lslot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">slot</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lfunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">func</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span>
<span class="w">    </span><span class="c1">// Create configuration address as per Figure 1</span>
<span class="w">    </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="n">lbus</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">lslot</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">              </span><span class="p">(</span><span class="n">lfunc</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFC</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mh">0x80000000</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span>
<span class="w">    </span><span class="c1">// Write out the address</span>
<span class="w">    </span><span class="n">outl</span><span class="p">(</span><span class="mh">0xCF8</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Read in the data</span>
<span class="w">    </span><span class="c1">// (offset &amp; 2) * 8) = 0 will choose the first word of the 32-bit register</span>
<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)((</span><span class="n">inl</span><span class="p">(</span><span class="mh">0xCFC</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">((</span><span class="n">offset</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFF</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>When a configuration access attempts to select a device that does not exist, the host bridge will complete the access without error, dropping all data on writes and returning all ones on reads. The following code segment illustrates the read of a non-existent device.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">pciCheckVendor</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">slot</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">vendor</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* Try and read the first configuration register. Since there are no</span>
<span class="cm">     * vendors that == 0xFFFF, it must be a non-existent device. */</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">vendor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pciConfigReadWord</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">slot</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0xFFFF</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pciConfigReadWord</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">slot</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">vendor</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span id="Configuration_Space_Access_Mechanism_.232"></span><span class="mw-headline" id="Configuration_Space_Access_Mechanism_#2">Configuration Space Access Mechanism #2</span></h3>
<p>This configuration space access mechanism was deprecated in PCI version 2.0. This means it's only likely to exist on hardware from around 1992 (when PCI 1.0 was introduced) to 1993 (when PCI 2.0 was introduced), which limits it to 80486 and early Pentium motherboards.
</p><p>For access mechanism #2, the IO port at <code>0xCF8</code> is an 8-bit port and is used to enable/disable the access mechanism and set the function number. It has the following format:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bits 7-4
</th>
<th>Bits 3-1
</th>
<th>Bit 0
</th></tr>
<tr>
<td>Key (0 = access mechanism disabled, non-zero = access mechanism enabled)
</td>
<td>Function number
</td>
<td>Special cycle enabled if set
</td></tr></tbody></table>
<p>The IO port at <code>0xCFA</code> (the "Forwarding Register") is also an 8-bit port, and is used to set the bus number for subsequent PCI configuration space accesses.
</p><p>Once the access mechanism has been enabled; accesses to IO ports <code>0xC000</code> to <code>0xCFFF</code> are used to access PCI configuration space. The IO port number has the following format:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bits 15-12
</th>
<th>Bits 11-8
</th>
<th>Bits 7-2
</th>
<th>Bits 1-0
</th></tr>
<tr>
<td>Must be 1100b
</td>
<td>Device number
</td>
<td>Register index
</td>
<td>Must be zero
</td></tr></tbody></table>
<p>Note that this limits the system to 16 devices per PCI bus.
</p>
<h3><span class="mw-headline" id="Memory_Mapped_PCI_Configuration_Space_Access">Memory Mapped PCI Configuration Space Access</span></h3>
<p>PCI Express introduced a new way to access PCI configuration space, where it's simply memory mapped and no IO ports are used. This access mechanism is described in <a href="PCI_Express" title="PCI Express">PCI Express</a>.
</p><p>Note that systems that do provide the memory mapped access mechanism are also required to support PCI access mechanism #1 for backwards compatibility.
</p>
<h3><span id="Detecting_Configuration_Space_Access_Mechanism.2Fs"></span><span class="mw-headline" id="Detecting_Configuration_Space_Access_Mechanism/s">Detecting Configuration Space Access Mechanism/s</span></h3>
<p>In general there are 4 cases:
</p>
<ul><li>Computer doesn't support PCI (either the computer is too old, or your OS is being run at some time in the future after PCI has been superseded)</li>
<li>Computer supports mechanism #2</li>
<li>Computer supports mechanism #1 but doesn't support the memory mapped access mechanism</li>
<li>Computer supports both mechanism #1 and the memory mapped access mechanism</li></ul>
<p>For BIOS systems, <code>int 0x1A, AX=0xB101</code> will tell you if the system uses mechanism #1 or mechanism #2. If this function doesn't exist you can't be sure if the computer supports PCI or not. If it says mechanism #1 is supported you won't know if the memory mapped access mechanism is also supported or not.
</p><p>For UEFI systems, it's extremely safe to assume that mechanism #2 is not supported; and you can test to see if the computer supports PCI or not by checking to see if the "PCI bus support" protocol exists. If PCI is supported, there's no easy way to determine if (e.g.) the computer supports mechanism #1 or not.
</p><p>For both BIOS and UEFI systems, you can check the ACPI tables to determine if the memory mapped access mechanism is supported.
</p><p>This leaves a few cases uncovered (e.g. where you don't know if whether mechanism #1 or #2 are supported despite trying all of the above). For these cases the only option left is manual probing. This means 2 specific tests - whether mechanism #1 is supported, and if not whether mechanism #2 is supported. Please note that manual probing has risks; in that if there is no PCI (e.g. the system only has ISA) the IO port accesses might cause undefined behaviour (especially on systems where the ISA bus ignores highest 6 bits of the IO port address, where accessing IO port <code>0xCF8</code> is the same as accessing IO port <code>0xF8</code>).
</p>
<h3><span class="mw-headline" id="PCI_Device_Structure">PCI Device Structure</span></h3>
<p>The PCI Specification defines the organization of the 256-byte Configuration Space registers and imposes a specific template for the space. Figures 2 &amp; 3 show the layout of the 256-byte Configuration space. All PCI compliant devices must support the Vendor ID, Device ID, Command and Status, Revision ID, Class Code and Header Type fields. Implementation of the other registers is optional, depending upon the devices functionality.
</p>
<h4><span class="mw-headline" id="Common_Header_Fields">Common Header Fields</span></h4>
<p>The following field descriptions are common to all Header Types:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Register</th>
<th>Offset</th>
<th>Bits 31-24</th>
<th>Bits 23-16</th>
<th>Bits 15-8</th>
<th>Bits 7-0
</th></tr>
<tr>
<td>0x0
</td>
<td>0x0
</td>
<td colspan="2">Device ID
</td>
<td colspan="2">Vendor ID
</td></tr>
<tr>
<td>0x1
</td>
<td>0x4
</td>
<td colspan="2">Status
</td>
<td colspan="2">Command
</td></tr>
<tr>
<td>0x2
</td>
<td>0x8
</td>
<td>Class code</td>
<td>Subclass</td>
<td>Prog IF</td>
<td>Revision ID
</td></tr>
<tr>
<td>0x3
</td>
<td>0xC
</td>
<td>BIST
</td>
<td>Header type
</td>
<td>Latency Timer
</td>
<td>Cache Line Size
</td></tr>
<tr>
<td>...
</td></tr></tbody></table>
<ul><li><i>Device ID:</i> Identifies the particular device. Where valid IDs are allocated by the vendor.</li>
<li><i>Vendor ID:</i> Identifies the manufacturer of the device. Where valid IDs are allocated by PCI-SIG (the list is <a rel="nofollow" class="external text" href="https://pcisig.com/membership/member-companies">here</a>) to ensure uniqueness and <code>0xFFFF</code> is an invalid value that will be returned on read accesses to Configuration Space registers of non-existent devices.</li>
<li><i><a href="PCI#Status_Register">Status</a>:</i> A register used to record status information for PCI bus related events.</li>
<li><i><a href="PCI#Command_Register">Command</a>:</i> Provides control over a device's ability to generate and respond to PCI cycles. Where the only functionality guaranteed to be supported by all devices is, when a 0 is written to this register, the device is disconnected from the PCI bus for all accesses except Configuration Space access.</li>
<li><i>Class Code:</i> A read-only register that specifies the type of function the device performs.</li>
<li><i>Subclass:</i> A read-only register that specifies the specific function the device performs.</li>
<li><i>Prog IF(Programming Interface Byte):</i> A read-only register that specifies a register-level programming interface the device has, if it has any at all.</li>
<li><i>Revision ID:</i> Specifies a revision identifier for a particular device. Where valid IDs are allocated by the vendor.</li>
<li><i>BIST:</i> Represents that status and allows control of a devices BIST (built-in self test).</li>
<li><i>Header Type:</i> Identifies the layout of the rest of the header beginning at byte <code>0x10</code> of the header. If bit 7 of this register is set, the device has multiple functions; otherwise, it is a single function device. Types:
<ul><li><code>0x0</code>: <a href="PCI#Header_Type_0x0">a general device</a></li>
<li><code>0x1</code>: <a href="PCI#Header_Type_0x1_(PCI-to-PCI_bridge)">a PCI-to-PCI bridge</a></li>
<li><code>0x2</code>: <a href="PCI#Header_Type_0x2_(PCI-to-CardBus_bridge)">a PCI-to-CardBus bridge</a>.</li></ul></li>
<li><i>Latency Timer:</i> Specifies the latency timer in units of PCI bus clocks.</li>
<li><i>Cache Line Size:</i> Specifies the system cache line size in 32-bit units. A device can limit the number of cacheline sizes it can support, if a unsupported value is written to this field, the device will behave as if a value of 0 was written.</li></ul>
<p>Remember that the PCI devices follow little ENDIAN ordering. The lower addresses contain the least significant portions of the field. Software to manipulate this structure must take particular care that the endian-ordering follows the PCI devices, not the CPUs.
</p>
<h5><span class="mw-headline" id="Command_Register">Command Register</span></h5>
<p>Here is the layout of the Command register:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bits 11-15</th>
<th>Bit 10</th>
<th>Bit 9</th>
<th>Bit 8</th>
<th>Bit 7</th>
<th>Bit 6</th>
<th>Bit 5</th>
<th>Bit 4</th>
<th>Bit 3</th>
<th>Bit 2</th>
<th>Bit 1</th>
<th>Bit 0
</th></tr>
<tr>
<td>Reserved
</td>
<td>Interrupt Disable
</td>
<td>Fast Back-to-Back Enable
</td>
<td>SERR# Enable
</td>
<td>Reserved
</td>
<td>Parity Error Response
</td>
<td>VGA Palette Snoop
</td>
<td>Memory Write and Invalidate Enable
</td>
<td>Special Cycles
</td>
<td>Bus Master
</td>
<td>Memory Space
</td>
<td>I/O Space
</td></tr>
<tr>
<td>
</td>
<td>RW
</td>
<td>RO
</td>
<td>RW
</td>
<td>RO
</td>
<td>RW
</td>
<td>RO
</td>
<td>RO
</td>
<td>RO
</td>
<td>RW
</td>
<td>RW
</td>
<td>RW
</td></tr></tbody></table>
<ul><li><i>Interrupt Disable</i> - If set to 1 the assertion of the devices INTx# signal is disabled; otherwise, assertion of the signal is enabled.</li>
<li><i>Fast Back-Back Enable</i> - If set to 1 indicates a device is allowed to generate fast back-to-back transactions; otherwise, fast back-to-back transactions are only allowed to the same agent.</li>
<li><i>SERR# Enable</i> - If set to 1 the SERR# driver is enabled; otherwise, the driver is disabled.</li>
<li><i>Bit 7</i> - As of revision 3.0 of the PCI local bus specification this bit is hardwired to 0. In earlier versions of the specification this bit was used by devices and may have been hardwired to 0, 1, or implemented as a read/write bit.</li>
<li><i>Parity Error Response</i> - If set to 1 the device will take its normal action when a parity error is detected; otherwise, when an error is detected, the device will set bit 15 of the Status register (Detected Parity Error Status Bit), but will not assert the PERR# (Parity Error) pin and will continue operation as normal.</li>
<li><i>VGA Palette Snoop</i> - If set to 1 the device does not respond to palette register writes and will snoop the data; otherwise, the device will trate palette write accesses like all other accesses.</li>
<li><i>Memory Write and Invalidate Enable</i> - If set to 1 the device can generate the Memory Write and Invalidate command; otherwise, the Memory Write command must be used.</li>
<li><i>Special Cycles</i> - If set to 1 the device can monitor Special Cycle operations; otherwise, the device will ignore them.</li>
<li><i>Bus Master</i> - If set to 1 the device can behave as a bus master; otherwise, the device can not generate PCI accesses.</li>
<li><i>Memory Space</i> - If set to 1 the device can respond to Memory Space accesses; otherwise, the device's response is disabled.</li>
<li><i>I/O Space</i> - If set to 1 the device can respond to I/O Space accesses; otherwise, the device's response is disabled.</li></ul>
<p>If the kernel configures the BARs of the devices, the kernel also have to enable bits 0 and 1 for it to activate.
</p>
<h5><span class="mw-headline" id="Status_Register">Status Register</span></h5>
<p>Here is the layout of the Status register:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bit 15</th>
<th>Bit 14</th>
<th>Bit 13</th>
<th>Bit 12</th>
<th>Bit 11</th>
<th>Bits 9-10</th>
<th>Bit 8</th>
<th>Bit 7</th>
<th>Bit 6</th>
<th>Bit 5</th>
<th>Bit 4</th>
<th>Bit 3</th>
<th>Bits 0-2
</th></tr>
<tr>
<td>Detected Parity Error
</td>
<td>Signaled System Error
</td>
<td>Received Master Abort
</td>
<td>Received Target Abort
</td>
<td>Signaled Target Abort
</td>
<td>DEVSEL Timing
</td>
<td>Master Data Parity Error
</td>
<td>Fast Back-to-Back Capable
</td>
<td>Reserved
</td>
<td>66 MHz Capable
</td>
<td>Capabilities List
</td>
<td>Interrupt Status
</td>
<td>Reserved
</td></tr>
<tr>
<td>RW1C
</td>
<td>RW1C
</td>
<td>RW1C
</td>
<td>RW1C
</td>
<td>RW1C
</td>
<td>RO
</td>
<td>RW1C
</td>
<td>RO
</td>
<td>RO
</td>
<td>RO
</td>
<td>RO
</td>
<td>RO
</td>
<td>
</td></tr></tbody></table>
<ul><li><i>Detected Parity Error</i> - This bit will be set to 1 whenever the device detects a parity error, even if parity error handling is disabled.</li>
<li><i>Signalled System Error</i> - This bit will be set to 1 whenever the device asserts SERR#.</li>
<li><i>Received Master Abort</i> - This bit will be set to 1, by a master device, whenever its transaction (except for Special Cycle transactions) is terminated with Master-Abort.</li>
<li><i>Received Target Abort</i> - This bit will be set to 1, by a master device, whenever its transaction is terminated with Target-Abort.</li>
<li><i>Signalled Target Abort</i> - This bit will be set to 1 whenever a target device terminates a transaction with Target-Abort.</li>
<li><i>DEVSEL Timing</i> - Read only bits that represent the slowest time that a device will assert DEVSEL# for any bus command except Configuration Space read and writes. Where a value of <code>0x0</code> represents fast timing, a value of <code>0x1</code> represents medium timing, and a value of <code>0x2</code> represents slow timing.</li>
<li><i>Master Data Parity Error</i> - This bit is only set when the following conditions are met. The bus agent asserted PERR# on a read or observed an assertion of PERR# on a write, the agent setting the bit acted as the bus master for the operation in which the error occurred, and bit 6 of the Command register (Parity Error Response bit) is set to 1.</li>
<li><i>Fast Back-to-Back Capable</i> - If set to 1 the device can accept fast back-to-back transactions that are not from the same agent; otherwise, transactions can only be accepted from the same agent.</li>
<li><i>Bit 6</i> - As of revision 3.0 of the PCI Local Bus specification this bit is reserved. In revision 2.1 of the specification this bit was used to indicate whether or not a device supported User Definable Features.</li>
<li><i>66 MHz Capable</i> - If set to 1 the device is capable of running at 66 MHz; otherwise, the device runs at 33 MHz.</li>
<li><i>Capabilities List</i> - If set to 1 the device implements the pointer for a New Capabilities Linked list at offset <code>0x34</code>; otherwise, the linked list is not available.</li>
<li><i>Interrupt Status</i> - Represents the state of the device's INTx# signal. If set to 1 and bit 10 of the Command register (Interrupt Disable bit) is set to 0 the signal will be asserted; otherwise, the signal will be ignored.</li></ul>
<h4><span class="mw-headline" id="Header_Type_0x0">Header Type 0x0</span></h4>
<p>This table is applicable if the Header Type is <code>0x0</code>. (Figure 2)
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Register</th>
<th>Offset</th>
<th>Bits 31-24</th>
<th>Bits 23-16</th>
<th>Bits 15-8</th>
<th>Bits 7-0
</th></tr>
<tr>
<td>0x0
</td>
<td>0x0
</td>
<td colspan="2">Device ID
</td>
<td colspan="2">Vendor ID
</td></tr>
<tr>
<td>0x1
</td>
<td>0x4
</td>
<td colspan="2">Status
</td>
<td colspan="2">Command
</td></tr>
<tr>
<td>0x2
</td>
<td>0x8
</td>
<td>Class code</td>
<td>Subclass</td>
<td>Prog IF</td>
<td>Revision ID
</td></tr>
<tr>
<td>0x3
</td>
<td>0xC
</td>
<td>BIST
</td>
<td>Header type
</td>
<td>Latency Timer
</td>
<td>Cache Line Size
</td></tr>
<tr>
<td>0x4
</td>
<td>0x10
</td>
<td colspan="4">Base address #0 (BAR0)
</td></tr>
<tr>
<td>0x5
</td>
<td>0x14
</td>
<td colspan="4">Base address #1 (BAR1)
</td></tr>
<tr>
<td>0x6
</td>
<td>0x18
</td>
<td colspan="4">Base address #2 (BAR2)
</td></tr>
<tr>
<td>0x7
</td>
<td>0x1C
</td>
<td colspan="4">Base address #3 (BAR3)
</td></tr>
<tr>
<td>0x8
</td>
<td>0x20
</td>
<td colspan="4">Base address #4 (BAR4)
</td></tr>
<tr>
<td>0x9
</td>
<td>0x24
</td>
<td colspan="4">Base address #5 (BAR5)
</td></tr>
<tr>
<td>0xA
</td>
<td>0x28
</td>
<td colspan="4">Cardbus CIS Pointer
</td></tr>
<tr>
<td>0xB
</td>
<td>0x2C
</td>
<td colspan="2">Subsystem ID
</td>
<td colspan="2">Subsystem Vendor ID
</td></tr>
<tr>
<td>0xC
</td>
<td>0x30
</td>
<td colspan="4">Expansion ROM base address
</td></tr>
<tr>
<td>0xD
</td>
<td>0x34
</td>
<td colspan="3">Reserved
</td>
<td>Capabilities Pointer
</td></tr>
<tr>
<td>0xE
</td>
<td>0x38
</td>
<td colspan="4">Reserved
</td></tr>
<tr>
<td>0xF
</td>
<td>0x3C
</td>
<td>Max latency</td>
<td>Min Grant</td>
<td>Interrupt PIN</td>
<td>Interrupt Line
</td></tr></tbody></table>
<p>The following field descriptions apply if the Header Type is <code>0x0</code>:
</p>
<ul><li><i>CardBus CIS Pointer:</i> Points to the Card Information Structure and is used by devices that share silicon between CardBus and PCI.</li></ul>
<ul><li><i>Interrupt Line:</i> Specifies which input of the system interrupt controllers the device's interrupt pin is connected to and is implemented by any device that makes use of an interrupt pin. For the x86 architecture this register corresponds to the PIC IRQ numbers 0-15 (and not I/O APIC IRQ numbers) and a value of <code>0xFF</code> defines no connection.</li></ul>
<ul><li><i>Interrupt Pin:</i> Specifies which interrupt pin the device uses. Where a value of <code>0x1</code> is INTA#, <code>0x2</code> is INTB#, <code>0x3</code> is INTC#, <code>0x4</code> is INTD#, and <code>0x0</code> means the device does not use an interrupt pin.</li></ul>
<ul><li><i>Max Latency:</i> A read-only register that specifies how often the device needs access to the PCI bus (in 1/4 microsecond units).</li></ul>
<ul><li><i>Min Grant:</i> A read-only register that specifies the burst period length, in 1/4 microsecond units, that the device needs (assuming a 33 MHz clock rate).</li></ul>
<ul><li><i>Capabilities Pointer:</i> Points (i.e. an offset into this function's configuration space) to a linked list of new capabilities implemented by the device. Used if bit 4 of the status register (Capabilities List bit) is set to 1. The bottom two bits are reserved and should be masked before the Pointer is used to access the Configuration Space.</li></ul>
<h4><span id="Header_Type_0x1_.28PCI-to-PCI_bridge.29"></span><span class="mw-headline" id="Header_Type_0x1_(PCI-to-PCI_bridge)">Header Type 0x1 (PCI-to-PCI bridge)</span></h4>
<p>This table is applicable if the Header Type is <code>0x1</code> (PCI-to-PCI bridge) (Figure 3)
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Register</th>
<th>Offset</th>
<th>Bits 31-24</th>
<th>Bits 23-16</th>
<th>Bits 15-8</th>
<th>Bits 7-0
</th></tr>
<tr>
<td>0x0
</td>
<td>0x0
</td>
<td colspan="2">Device ID
</td>
<td colspan="2">Vendor ID
</td></tr>
<tr>
<td>0x1
</td>
<td>0x4
</td>
<td colspan="2">Status
</td>
<td colspan="2">Command
</td></tr>
<tr>
<td>0x2
</td>
<td>0x8
</td>
<td>Class code</td>
<td>Subclass</td>
<td>Prog IF</td>
<td>Revision ID
</td></tr>
<tr>
<td>0x3
</td>
<td>0xC
</td>
<td>BIST
</td>
<td>Header type
</td>
<td>Latency Timer
</td>
<td>Cache Line Size
</td></tr>
<tr>
<td>0x4
</td>
<td>0x10
</td>
<td colspan="4">Base address #0 (BAR0)
</td></tr>
<tr>
<td>0x5
</td>
<td>0x14
</td>
<td colspan="4">Base address #1 (BAR1)
</td></tr>
<tr>
<td>0x6
</td>
<td>0x18
</td>
<td>Secondary Latency Timer
</td>
<td>Subordinate Bus Number
</td>
<td>Secondary Bus Number
</td>
<td>Primary Bus Number
</td></tr>
<tr>
<td>0x7
</td>
<td>0x1C
</td>
<td colspan="2">Secondary Status
</td>
<td>I/O Limit
</td>
<td>I/O Base
</td></tr>
<tr>
<td>0x8
</td>
<td>0x20
</td>
<td colspan="2">Memory Limit
</td>
<td colspan="2">Memory Base
</td></tr>
<tr>
<td>0x9
</td>
<td>0x24
</td>
<td colspan="2">Prefetchable Memory Limit
</td>
<td colspan="2">Prefetchable Memory Base
</td></tr>
<tr>
<td>0xA
</td>
<td>0x28
</td>
<td colspan="4">Prefetchable Base Upper 32 Bits
</td></tr>
<tr>
<td>0xB
</td>
<td>0x2C
</td>
<td colspan="4">Prefetchable Limit Upper 32 Bits
</td></tr>
<tr>
<td>0xC
</td>
<td>0x30
</td>
<td colspan="2">I/O Limit Upper 16 Bits
</td>
<td colspan="2">I/O Base Upper 16 Bits
</td></tr>
<tr>
<td>0xD
</td>
<td>0x34
</td>
<td colspan="3">Reserved
</td>
<td>Capability Pointer
</td></tr>
<tr>
<td>0xE
</td>
<td>0x38
</td>
<td colspan="4">Expansion ROM base address
</td></tr>
<tr>
<td>0xF
</td>
<td>0x3C
</td>
<td colspan="2">Bridge Control</td>
<td>Interrupt PIN</td>
<td>Interrupt Line
</td></tr></tbody></table>
<h5><span class="mw-headline" id="Header_Type_Register">Header Type Register</span></h5>
<p>Here is the layout of the Header Type register:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bit 7</th>
<th>Bits 6-0
</th></tr>
<tr>
<td>MF
</td>
<td>Header Type
</td></tr></tbody></table>
<ul><li><i>MF</i> - If MF = 1 Then this device has multiple functions.</li>
<li><i>Header Type</i> - <code>0x0</code> Standard Header - <code>0x1</code> PCI-to-PCI Bridge - <code>0x2</code> CardBus Bridge</li></ul>
<h5><span class="mw-headline" id="BIST_Register">BIST Register</span></h5>
<p>Here is the layout of the BIST register:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bit 7</th>
<th>Bit 6</th>
<th>Bits 4-5</th>
<th>Bits 0-3
</th></tr>
<tr>
<td>BIST Capable</td>
<td>Start BIST</td>
<td>Reserved</td>
<td>Completion Code
</td></tr></tbody></table>
<ul><li><i>BIST Capable</i> - Will return 1 the device supports BIST.</li>
<li><i>Start BIST</i> - When set to 1 the BIST is invoked. This bit is reset when BIST completes. If BIST does not complete after 2 seconds the device should be failed by system software.</li>
<li><i>Completion Code</i> - Will return 0, after BIST execution, if the test completed successfully.</li></ul>
<h4><span id="Header_Type_0x2_.28PCI-to-CardBus_bridge.29"></span><span class="mw-headline" id="Header_Type_0x2_(PCI-to-CardBus_bridge)">Header Type 0x2 (PCI-to-CardBus bridge)</span></h4>
<p>This table is applicable if the Header Type is <code>0x2</code> (PCI-to-CardBus bridge)
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Register</th>
<th>Offset</th>
<th>Bits 31-24</th>
<th>Bits 23-16</th>
<th>Bits 15-8</th>
<th>Bits 7-0
</th></tr>
<tr>
<td>0x0
</td>
<td>0x0
</td>
<td colspan="2">Device ID
</td>
<td colspan="2">Vendor ID
</td></tr>
<tr>
<td>0x1
</td>
<td>0x4
</td>
<td colspan="2">Status
</td>
<td colspan="2">Command
</td></tr>
<tr>
<td>0x2
</td>
<td>0x8
</td>
<td>Class code</td>
<td>Subclass</td>
<td>Prog IF</td>
<td>Revision ID
</td></tr>
<tr>
<td>0x3
</td>
<td>0xC
</td>
<td>BIST
</td>
<td>Header type
</td>
<td>Latency Timer
</td>
<td>Cache Line Size
</td></tr>
<tr>
<td>0x4
</td>
<td>0x10
</td>
<td colspan="4">CardBus Socket/ExCa base address
</td></tr>
<tr>
<td>0x5
</td>
<td>0x14
</td>
<td colspan="2">Secondary status
</td>
<td>Reserved
</td>
<td>Offset of capabilities list
</td></tr>
<tr>
<td>0x6
</td>
<td>0x18
</td>
<td>CardBus latency timer
</td>
<td>Subordinate bus number
</td>
<td>CardBus bus number
</td>
<td>PCI bus number
</td></tr>
<tr>
<td>0x7
</td>
<td>0x1C
</td>
<td colspan="4">Memory Base Address 0
</td></tr>
<tr>
<td>0x8
</td>
<td>0x20
</td>
<td colspan="4">Memory Limit 0
</td></tr>
<tr>
<td>0x9
</td>
<td>0x24
</td>
<td colspan="4">Memory Base Address 1
</td></tr>
<tr>
<td>0xA
</td>
<td>0x28
</td>
<td colspan="4">Memory Limit 1
</td></tr>
<tr>
<td>0xB
</td>
<td>0x2C
</td>
<td colspan="4">I/O Base Address 0
</td></tr>
<tr>
<td>0xC
</td>
<td>0x30
</td>
<td colspan="4">I/O Limit 0
</td></tr>
<tr>
<td>0xD
</td>
<td>0x34
</td>
<td colspan="4">I/O Base Address 1
</td></tr>
<tr>
<td>0xE
</td>
<td>0x38
</td>
<td colspan="4">I/O Limit 1
</td></tr>
<tr>
<td>0xF
</td>
<td>0x3C
</td>
<td colspan="2">Bridge Control
</td>
<td>Interrupt PIN
</td>
<td>Interrupt Line
</td></tr>
<tr>
<td>0x10
</td>
<td>0x40
</td>
<td colspan="2">Subsystem Vendor ID
</td>
<td colspan="2">Subsystem Device ID
</td></tr>
<tr>
<td>0x11
</td>
<td>0x44
</td>
<td colspan="4">16-bit PC Card legacy mode base address
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Base_Address_Registers">Base Address Registers</span></h3>
<p>Base Address Registers (or BARs) can be used to hold memory addresses used by the device, or offsets for port addresses. Typically, memory address BARs need to be located in physical ram while I/O space BARs can reside at any memory address (even beyond physical memory). To distinguish between them, you can check the value of the lowest bit. The following tables describe the two types of BARs:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<caption>Memory Space BAR Layout
</caption>
<tbody><tr>
<th>Bits 31-4
</th>
<th>Bit 3
</th>
<th>Bits 2-1
</th>
<th>Bit 0
</th></tr>
<tr>
<td>16-Byte Aligned Base Address
</td>
<td>Prefetchable
</td>
<td>Type
</td>
<td>Always 0
</td></tr></tbody></table>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">
<caption>I/O Space BAR Layout
</caption>
<tbody><tr>
<th>Bits 31-2
</th>
<th>Bit 1
</th>
<th>Bit 0
</th></tr>
<tr>
<td>4-Byte Aligned Base Address
</td>
<td>Reserved
</td>
<td>Always 1
</td></tr></tbody></table>
<p>The Type field of the Memory Space BAR Layout specifies the size of the base register and where in memory it can be mapped. If it has a value of <code>0x0</code> then the base register is 32-bits wide and can be mapped anywhere in the 32-bit Memory Space. A value of <code>0x2</code> means the base register is 64-bits wide and can be mapped anywhere in the 64-bit Memory Space (A 64-bit base address register consumes 2 of the base address registers available). A value of <code>0x1</code> is reserved as of revision 3.0 of the PCI Local Bus Specification. In earlier versions it was used to support memory space below 1MB (16-bit wide base register that can be mapped anywhere in the 16-bit Memory Space).
</p><p>When a base address register is marked as Prefetchable, it means that the region does not have read side effects (reading from that memory range doesn't change any state), and it is allowed for the CPU to cache loads from that memory region and read it in bursts (typically cache line sized). Hardware is also allowed to merge repeated stores to the same address into one store of the latest value. If you are using paging and want maximum performance, you should map prefetchable MMIO regions as WT (write-through) instead of UC (uncacheable). On x86, frame buffers are the exception, they should be almost always be mapped WC (write-combining).
</p>
<h4><span class="mw-headline" id="Address_and_size_of_the_BAR">Address and size of the BAR</span></h4>
<p>When you want to retrieve the actual base address of a BAR, be sure to mask the lower bits. For 16-bit Memory Space BARs, you calculate <code>(BAR[x] &amp; 0xFFF0)</code>. For 32-bit Memory Space BARs, you calculate <code>(BAR[x] &amp; 0xFFFFFFF0)</code>. For 64-bit Memory Space BARs, you calculate <code>((BAR[x] &amp; 0xFFFFFFF0) + ((BAR[x + 1] &amp; 0xFFFFFFFF) &lt;&lt; 32))</code> For I/O Space BARs, you calculate <code>(BAR[x] &amp; 0xFFFFFFFC)</code>.
</p><p>Before attempting to read the information about the BAR, make sure to disable both I/O and memory decode in the command byte. You can restore the original value after completing the BAR info read. This is needed as some devices are known to decode the write of all ones to the register as an (unintended) access.
</p><p>To determine the amount of address space needed by a PCI device, you must save the original value of the BAR, write a value of all 1's to the register, then read it back. The amount of memory can then be determined by masking the information bits, performing a bitwise NOT ('~' in C), and incrementing the value by 1. The original value of the BAR should then be restored. The BAR register is naturally aligned and as such you can only modify the bits that are set. For example, if a device utilizes 16 MB it will have BAR0 filled with 0xFF000000 (0x1000000 after decoding) and you can only modify the upper 8-bits. <a rel="nofollow" class="external autonumber" href="https://web.archive.org/web/20150101180929/https://www.pcisig.com/reflector/msg05233.html">[1]</a>
</p>
<h3><span class="mw-headline" id="Class_Codes">Class Codes</span></h3>
<p>The Class Code, Subclass, and Prog IF registers are used to identify the device's type, the device's function, and the device's register-level programming interface, respectively.
</p><p>The following table details most of the known device types and functions:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Class Code</th>
<th>Subclass</th>
<th>Prog IF
</th></tr>
<tr>
<td rowspan="2">0x0 - Unclassified
</td>
<td>0x0 - Non-VGA-Compatible Unclassified Device</td>
<td>--
</td></tr>
<tr>
<td>0x1 - VGA-Compatible Unclassified Device</td>
<td>--
</td></tr>
<tr>
<td rowspan="22">0x1 - Mass Storage Controller
</td>
<td>0x0 - SCSI Bus Controller</td>
<td>--
</td></tr>
<tr>
<td rowspan="8">0x1 - IDE Controller
</td>
<td>0x0 - ISA Compatibility mode-only controller
</td></tr>
<tr>
<td>0x5 - PCI native mode-only controller
</td></tr>
<tr>
<td>0xA - ISA Compatibility mode controller, supports both channels switched to PCI native mode
</td></tr>
<tr>
<td>0xF - PCI native mode controller, supports both channels switched to ISA compatibility mode
</td></tr>
<tr>
<td>0x80 - ISA Compatibility mode-only controller, supports bus mastering
</td></tr>
<tr>
<td>0x85 - PCI native mode-only controller, supports bus mastering
</td></tr>
<tr>
<td>0x8A - ISA Compatibility mode controller, supports both channels switched to PCI native mode, supports bus mastering
</td></tr>
<tr>
<td>0x8F - PCI native mode controller, supports both channels switched to ISA compatibility mode, supports bus mastering
</td></tr>
<tr>
<td>0x2 - Floppy Disk Controller</td>
<td>--
</td></tr>
<tr>
<td>0x3 - IPI Bus Controller</td>
<td>--
</td></tr>
<tr>
<td>0x4 - RAID Controller</td>
<td>--
</td></tr>
<tr>
<td rowspan="2">0x5 - ATA Controller
</td>
<td>0x20 - Single DMA
</td></tr>
<tr>
<td>0x30 - Chained DMA
</td></tr>
<tr>
<td rowspan="3">0x6 - Serial ATA Controller
</td>
<td>0x0 - Vendor Specific Interface
</td></tr>
<tr>
<td>0x1 - AHCI 1.0
</td></tr>
<tr>
<td>0x2 - Serial Storage Bus
</td></tr>
<tr>
<td rowspan="2">0x7 - Serial Attached SCSI Controller
</td>
<td>0x0 - SAS
</td></tr>
<tr>
<td>0x1 - Serial Storage Bus
</td></tr>
<tr>
<td rowspan="2">0x8 - Non-Volatile Memory Controller
</td>
<td>0x1 - NVMHCI
</td></tr>
<tr>
<td>0x2 - NVM Express
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="10">0x2 - Network Controller
</td>
<td>0x0 - Ethernet Controller</td>
<td>--
</td></tr>
<tr>
<td>0x1 - Token Ring Controller</td>
<td>--
</td></tr>
<tr>
<td>0x2 - FDDI Controller</td>
<td>--
</td></tr>
<tr>
<td>0x3 - ATM Controller</td>
<td>--
</td></tr>
<tr>
<td>0x4 - ISDN Controller</td>
<td>--
</td></tr>
<tr>
<td>0x5 - WorldFip Controller</td>
<td>--
</td></tr>
<tr>
<td>0x6 - PICMG 2.14 Multi Computing Controller</td>
<td>--
</td></tr>
<tr>
<td>0x7 - Infiniband Controller</td>
<td>--
</td></tr>
<tr>
<td>0x8 - Fabric Controller</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="5">0x3 - Display Controller
</td>
<td rowspan="2">0x0 - VGA Compatible Controller
</td>
<td>0x0 - VGA Controller
</td></tr>
<tr>
<td>0x1 - 8514-Compatible Controller
</td></tr>
<tr>
<td>0x1 - XGA Controller</td>
<td>--
</td></tr>
<tr>
<td>0x2 - 3D Controller (Not VGA-Compatible)</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="5">0x4 - Multimedia Controller
</td>
<td>0x0 - Multimedia Video Controller</td>
<td>--
</td></tr>
<tr>
<td>0x1 - Multimedia Audio Controller</td>
<td>--
</td></tr>
<tr>
<td>0x2 - Computer Telephony Device</td>
<td>--
</td></tr>
<tr>
<td>0x3 - Audio Device</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="3">0x5 - Memory Controller
</td>
<td>0x0 - RAM Controller</td>
<td>--
</td></tr>
<tr>
<td>0x1 - Flash Controller</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="15">0x6 - Bridge
</td>
<td>0x0 - Host Bridge</td>
<td>--
</td></tr>
<tr>
<td>0x1 - ISA Bridge</td>
<td>--
</td></tr>
<tr>
<td>0x2 - EISA Bridge</td>
<td>--
</td></tr>
<tr>
<td>0x3 - MCA Bridge</td>
<td>--
</td></tr>
<tr>
<td rowspan="2">0x4 - PCI-to-PCI Bridge
</td>
<td>0x0 - Normal Decode
</td></tr>
<tr>
<td>0x1 - Subtractive Decode
</td></tr>
<tr>
<td>0x5 - PCMCIA Bridge</td>
<td>--
</td></tr>
<tr>
<td>0x6 - NuBus Bridge</td>
<td>--
</td></tr>
<tr>
<td>0x7 - CardBus Bridge</td>
<td>--
</td></tr>
<tr>
<td rowspan="2">0x8 - RACEway Bridge
</td>
<td>0x0 - Transparent Mode
</td></tr>
<tr>
<td>0x1 - Endpoint Mode
</td></tr>
<tr>
<td rowspan="2">0x9 - PCI-to-PCI Bridge
</td>
<td>0x40 - Semi-Transparent, Primary bus towards host CPU
</td></tr>
<tr>
<td>0x80 - Semi-Transparent, Secondary bus towards host CPU
</td></tr>
<tr>
<td>0x0A - InfiniBand-to-PCI Host Bridge</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="21">0x7 - Simple Communication Controller
</td>
<td rowspan="7">0x0 - Serial Controller
</td>
<td>0x0 - 8250-Compatible (Generic XT)
</td></tr>
<tr>
<td>0x1 - 16450-Compatible
</td></tr>
<tr>
<td>0x2 - 16550-Compatible
</td></tr>
<tr>
<td>0x3 - 16650-Compatible
</td></tr>
<tr>
<td>0x4 - 16750-Compatible
</td></tr>
<tr>
<td>0x5 - 16850-Compatible
</td></tr>
<tr>
<td>0x6 - 16950-Compatible
</td></tr>
<tr>
<td rowspan="5">0x1 - Parallel Controller
</td>
<td>0x0 - Standard Parallel Port
</td></tr>
<tr>
<td>0x1 - Bi-Directional Parallel Port
</td></tr>
<tr>
<td>0x2 - ECP 1.X Compliant Parallel Port
</td></tr>
<tr>
<td>0x3 - IEEE 1284 Controller
</td></tr>
<tr>
<td>0xFE - IEEE 1284 Target Device
</td></tr>
<tr>
<td>0x2 - Multiport Serial Controller</td>
<td>--
</td></tr>
<tr>
<td rowspan="5">0x3 - Modem
</td>
<td>0x0 - Generic Modem
</td></tr>
<tr>
<td>0x1 - Hayes 16450-Compatible Interface
</td></tr>
<tr>
<td>0x2 - Hayes 16550-Compatible Interface
</td></tr>
<tr>
<td>0x3 - Hayes 16650-Compatible Interface
</td></tr>
<tr>
<td>0x4 - Hayes 16750-Compatible Interface
</td></tr>
<tr>
<td>0x4 - IEEE 488.1/2 (GPIB) Controller</td>
<td>--
</td></tr>
<tr>
<td>0x5 - Smart Card Controller</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="18">0x8 - Base System Peripheral
</td>
<td rowspan="5">0x0 - PIC
</td>
<td>0x0 - Generic 8259-Compatible
</td></tr>
<tr>
<td>0x1 - ISA-Compatible
</td></tr>
<tr>
<td>0x2 - EISA-Compatible
</td></tr>
<tr>
<td>0x10 - I/O APIC Interrupt Controller
</td></tr>
<tr>
<td>0x20 - I/O(x) APIC Interrupt Controller
</td></tr>
<tr>
<td rowspan="3">0x01 - DMA Controller
</td>
<td>0x00 - Generic 8237-Compatible
</td></tr>
<tr>
<td>0x01 - ISA-Compatible
</td></tr>
<tr>
<td>0x02 - EISA-Compatible
</td></tr>
<tr>
<td rowspan="4">0x02 - Timer
</td>
<td>0x00 - Generic 8254-Compatible
</td></tr>
<tr>
<td>0x01 - ISA-Compatible
</td></tr>
<tr>
<td>0x02 - EISA-Compatible
</td></tr>
<tr>
<td>0x03 - HPET
</td></tr>
<tr>
<td rowspan="2">0x3 - RTC Controller
</td>
<td>0x0 - Generic RTC
</td></tr>
<tr>
<td>0x1 - ISA-Compatible
</td></tr>
<tr>
<td>0x4 - PCI Hot-Plug Controller</td>
<td>--
</td></tr>
<tr>
<td>0x5 - SD Host controller</td>
<td>--
</td></tr>
<tr>
<td>0x6 - IOMMU</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="7">0x9 - Input Device Controller
</td>
<td>0x0 - Keyboard Controller</td>
<td>--
</td></tr>
<tr>
<td>0x1 - Digitizer Pen</td>
<td>--
</td></tr>
<tr>
<td>0x2 - Mouse Controller</td>
<td>--
</td></tr>
<tr>
<td>0x3 - Scanner Controller</td>
<td>--
</td></tr>
<tr>
<td rowspan="2">0x4 - Gameport Controller
</td>
<td>0x0 - Generic
</td></tr>
<tr>
<td>0x10 - Extended
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="2">0xA - Docking Station
</td>
<td>0x0 - Generic</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="9">0xB - Processor
</td>
<td>0x0 - 386</td>
<td>--
</td></tr>
<tr>
<td>0x1 - 486</td>
<td>--
</td></tr>
<tr>
<td>0x2 - Pentium</td>
<td>--
</td></tr>
<tr>
<td>0x3 - Pentium Pro</td>
<td>--
</td></tr>
<tr>
<td>0x10 - Alpha</td>
<td>--
</td></tr>
<tr>
<td>0x20 - PowerPC</td>
<td>--
</td></tr>
<tr>
<td>0x30 - MIPS</td>
<td>--
</td></tr>
<tr>
<td>0x40 - Co-Processor</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="19">0xC - Serial Bus Controller
</td>
<td rowspan="2">0x0 - FireWire (IEEE 1394) Controller
</td>
<td>0x0 - Generic
</td></tr>
<tr>
<td>0x10 - OHCI
</td></tr>
<tr>
<td>0x1 - ACCESS Bus Controller</td>
<td>--
</td></tr>
<tr>
<td>0x2 - SSA</td>
<td>--
</td></tr>
<tr>
<td rowspan="6">0x3 - USB Controller
</td>
<td>0x0 - UHCI Controller
</td></tr>
<tr>
<td>0x10 - OHCI Controller
</td></tr>
<tr>
<td>0x20 - EHCI (USB2) Controller
</td></tr>
<tr>
<td>0x30 - XHCI (USB3) Controller
</td></tr>
<tr>
<td>0x80 - Unspecified
</td></tr>
<tr>
<td>0xFE - USB Device (Not a host controller)
</td></tr>
<tr>
<td>0x4 - Fibre Channel</td>
<td>--
</td></tr>
<tr>
<td>0x5 - SMBus Controller</td>
<td>--
</td></tr>
<tr>
<td>0x6 - InfiniBand Controller</td>
<td>--
</td></tr>
<tr>
<td rowspan="3">0x7 - IPMI Interface
</td>
<td>0x0 - SMIC
</td></tr>
<tr>
<td>0x1 - Keyboard Controller Style
</td></tr>
<tr>
<td>0x2 - Block Transfer
</td></tr>
<tr>
<td>0x8 - SERCOS Interface (IEC 61491)</td>
<td>--
</td></tr>
<tr>
<td>0x9 - CANbus Controller</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="8">0xD - Wireless Controller
</td>
<td>0x0 - iRDA Compatible Controller</td>
<td>--
</td></tr>
<tr>
<td>0x1 - Consumer IR Controller</td>
<td>--
</td></tr>
<tr>
<td>0x10 - RF Controller</td>
<td>--
</td></tr>
<tr>
<td>0x11 - Bluetooth Controller</td>
<td>--
</td></tr>
<tr>
<td>0x12 - Broadband Controller</td>
<td>--
</td></tr>
<tr>
<td>0x20 - Ethernet Controller (802.1a)</td>
<td>--
</td></tr>
<tr>
<td>0x21 - Ethernet Controller (802.1b)</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td>0xE - Intelligent Controller</td>
<td>0x0 - I20</td>
<td>--
</td></tr>
<tr>
<td rowspan="4">0xF - Satellite Communication Controller
</td>
<td>0x1 - Satellite TV Controller</td>
<td>--
</td></tr>
<tr>
<td>0x2 - Satellite Audio Controller</td>
<td>--
</td></tr>
<tr>
<td>0x3 - Satellite Voice Controller</td>
<td>--
</td></tr>
<tr>
<td>0x4 - Satellite Data Controller</td>
<td>--
</td></tr>
<tr>
<td rowspan="3">0x10 - Encryption Controller
</td>
<td>0x0 - Network and Computing Encrpytion/Decryption</td>
<td>--
</td></tr>
<tr>
<td>0x10 - Entertainment Encryption/Decryption</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td rowspan="5">0x11 - Signal Processing Controller
</td>
<td>0x0 - DPIO Modules</td>
<td>--
</td></tr>
<tr>
<td>0x1 - Performance Counters</td>
<td>--
</td></tr>
<tr>
<td>0x10 - Communication Synchronizer</td>
<td>--
</td></tr>
<tr>
<td>0x20 - Signal Processing Management</td>
<td>--
</td></tr>
<tr>
<td>0x80 - Other</td>
<td>--
</td></tr>
<tr>
<td>0x12 - Processing Accelerator</td>
<td>--</td>
<td>--
</td></tr>
<tr>
<td>0x13 - Non-Essential Instrumentation</td>
<td>--</td>
<td>--
</td></tr>
<tr>
<td>0x14 - 0x3F (Reserved)</td>
<td>--</td>
<td>--
</td></tr>
<tr>
<td>0x40 - Co-Processor</td>
<td>--</td>
<td>--
</td></tr>
<tr>
<td>0x41 - 0xFE (Reserved)</td>
<td>--</td>
<td>--
</td></tr>
<tr>
<td>0xFF - Unassigned Class (Vendor specific)</td>
<td>--</td>
<td>--
</td></tr>
</tbody></table>
<h2><span class="mw-headline" id="Enumerating_PCI_Buses">Enumerating PCI Buses</span></h2>
<p>There are 3 ways to enumerate devices on PCI buses. The first way is "brute force", checking every device on every PCI bus (regardless of whether the PCI bus exists or not). The second way avoids a lot of work by figuring out valid bus numbers while it scans, and is a little more complex as it involves recursion. For both of these methods you rely on something (firmware) to have configured PCI buses properly (setting up PCI to PCI bridges to forward request from one bus to another). The third method is like the second method, except that you configure PCI bridges while you're doing it.
</p><p>For all 3 methods, you need to be able to check if a specific device on a specific bus is present and if it is multi-function or not. Pseudo-code might look like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkDevice</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">device</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">     </span><span class="n">vendorID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getVendorID</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vendorID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xFFFF</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"> </span><span class="c1">// Device doesn&#39;t exist</span>
<span class="w">     </span><span class="n">checkFunction</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="n">headerType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getHeaderType</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">headerType</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x80</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="c1">// It&#39;s a multi-function device, so check remaining functions</span>
<span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">             </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">getVendorID</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0xFFFF</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                 </span><span class="n">checkFunction</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">);</span><span class="w"></span>
<span class="w">             </span><span class="p">}</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkFunction</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">function</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>Please note that if you don't check bit 7 of the header type and scan all functions, then some single-function devices will report details for "function 0" for every function.
</p>
<h3><span id=".22Brute_Force.22_Scan"></span><span class="mw-headline" id="&quot;Brute_Force&quot;_Scan">"Brute Force" Scan</span></h3>
<p>For the brute force method, the remaining code is relatively simple. Pseudo-code might look like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkAllBuses</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">bus</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>

<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">bus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bus</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span><span class="w"> </span><span class="n">bus</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">device</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">             </span><span class="n">checkDevice</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>For this method, there are 32 devices per bus and 256 buses, so you call "checkDevice()" 8192 times.
</p>
<h3><span class="mw-headline" id="Recursive_Scan">Recursive Scan</span></h3>
<p>The first step for the recursive scan is to implement a function that scans one bus. Pseudo-code might look like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkBus</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bus</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>

<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">device</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">checkDevice</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>The next step is to add code in "checkFunction()" that detects if the function is a PCI to PCI bridge. If the device is a PCI to PCI bridge then you want to extract the "secondary bus number" from the bridge's configuration space and call "checkBus()" with the number of the bus on the other side of the bridge.
</p><p>Pseudo-code might look like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkFunction</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">function</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">baseClass</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">subClass</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">secondaryBus</span><span class="p">;</span><span class="w"></span>

<span class="w">     </span><span class="n">baseClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getBaseClass</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="n">subClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSubClass</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">baseClass</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x6</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">subClass</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x4</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">secondaryBus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSecondaryBus</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="n">checkBus</span><span class="p">(</span><span class="n">secondaryBus</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>The final step is to handle systems with multiple PCI host controllers correctly. Start by checking if the device at bus 0, device 0 is a multi-function device. If it's not a multi-function device, then there is only one PCI host controller and bus 0, device 0, function 0 will be the PCI host controller responsible for bus 0. If it's a multi-function device, then bus 0, device 0, function 0 will be the PCI host controller responsible for bus 0; bus 0, device 0, function 1 will be the PCI host controller responsible for bus 1, etc (up to the number of functions supported).
</p><p>Pseudo-code might look like this:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkAllBuses</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">function</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bus</span><span class="p">;</span><span class="w"></span>

<span class="w">     </span><span class="n">headerType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getHeaderType</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">headerType</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x80</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="c1">// Single PCI host controller</span>
<span class="w">         </span><span class="n">checkBus</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="c1">// Multiple PCI host controllers</span>
<span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">             </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">getVendorID</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0xFFFF</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">             </span><span class="n">bus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">;</span><span class="w"></span>
<span class="w">             </span><span class="n">checkBus</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Recursive_Scan_With_Bus_Configuration">Recursive Scan With Bus Configuration</span></h3>
<p>This is similar to the recursive scan above; except that you set the "secondary bus" field in PCI to PCI bridges (using something like <code>setSecondaryBus(bus, device, function, nextBusNumber++);</code> instead of the <code>getSecondaryBus();</code>). However; if you are configuring PCI buses you are also responsible for configuring the memory areas/BARs in PCI functions, and ensuring that PCI bridges forward requests from their primary bus to their secondary buses.
</p><p>Writing code to support this without a deep understanding of PCI specifications is not recommended; and if you have a deep understanding of PCI specifications you have no need for pseudo code. For this reason there will be no example code for this method here.
</p>
<h3><span class="mw-headline" id="Configuring_PCI-to-PCI_bridges">Configuring PCI-to-PCI bridges</span></h3>
<p>To configure this the kernel has to forget about BIOS for a moment, first scan the root PCI device, (check if it is multi-function to scan multiple buses). Root bus is always 0.
</p><p>Secondary and subordinate bus acts as a range start-end of what buses the PCI-to-PCI bridge will manage.
</p><p>Then, after this step it's up to implementation: Scan each device, then if a bridge is found, allocate a bus number to it (note: PCI-to-PCI bridges can have multiple bridges within them). Scan that bus and find more devices, once you find more bridges add 1 to the subordinate bus for each bridge found, because PCI-to-PCI bridges can manage multiple bridges.
</p><p>And this is just the beginning: After allocating bus numbers, you need to allocate MMIO, it would be trivial if it wasn't for the fact that PCI has 3 areas the kernel manages: IO, Prefetch and Memory.
</p><p>A bridge can manage multiple buses, but that means it spans all the memory of these buses, if device 1 is behind bridge 2, which is behind bridge 1, then bridge 2 will contain the memory area of device 1 + any other device's areas, supposing IO is 4M, Memory is 16M and Prefetch is 5MB (supposing there are 3 devices in bridge's 2 bus), bridge 2 would contain those, take in reference table for Header type <code>0x1</code>. However, bridge 1 will contain the areas of bridge 2 + any other devices in bridge's 1 bus.
</p><p>Once all memory areas are allocated, the devices can be used. Note that PCI-to-PCI bridges also have BAR's.
</p><p>If the kernel does not configure a PCI-to-PCI bridge, the BIOS will probably do, however on environments without BIOS, this method is mandatory otherwise devices behind that bridge won't show up.
</p>
<h2><span class="mw-headline" id="IRQ_Handling">IRQ Handling</span></h2>
<p>If you're using the old <a href="PIC" class="mw-redirect" title="PIC">PIC</a>, your life is really easy. You have the <i>Interrupt Line</i> field of the header, which is read/write (you can change it's value!) and it says which interrupt will the PCI device fire when it needs attention.
</p><p>If you plan to use the <a href="I/O_APIC" class="mw-redirect" title="I/O APIC">I/O APIC</a>, things aren't so easy. Basically the PCI bus specifies that there are 4 interrupt pins. They are labeled INTA#, INTB#, INTC#, and INTD#. You find out what pin a device is using by reading the <i>Interrupt Pin</i> field of the header. So far, so good. 
</p><p>The only problem is that the PCI pins correspond to an arbitrary I/O APIC pin. It's up to the programmer to find the mapping. How is that done? You must parse the <a href="https://wiki.osdev.org/index.php?title=MP&amp;action=edit&amp;redlink=1" class="new" title="MP (page does not exist)">MP</a> Tables or the <a href="ACPI" title="ACPI">ACPI</a> tables. The MP tables are easy, only they aren't supported on newer hardware. The ACPI tables, however, involve parsing AML, which is not an easy task. If one wants to take a shortcut, you can use <a href="ACPICA" title="ACPICA">ACPICA</a>. 
</p><p>Once you've found the I/O APIC pin, all you do is map that to an IRQ using the I/O APIC redirection table. See the <a href="I/O_APIC" class="mw-redirect" title="I/O APIC">I/O APIC</a> article for more information on this.
</p><p>Alternatively, you could just use MSI or MSI-X, and skip complicated ACPI.
</p>
<h2><span class="mw-headline" id="Message_Signaled_Interrupts">Message Signaled Interrupts</span></h2>
<p>Message Signaled Interrupts, or MSI, have been supported since PCI 2.2. However, support for them is <i>mandatory</i> in PCIe devices, so you can be sure that they're usable on modern hardware. There are two versions of MSI implementation. First implementation called MSI and its evolution called MSI-X. They have different PCI capability and different ways how to handle multiple device interrupts and masking of such interrupts. The both implementations are exclusive and either MSI or MSI-X needs to be enabled.
</p><p>Unlike legacy PCI interrupt, which is level triggered and routed usually through I/O APIC pin, the device might support multiple interrupt sources with MSI or MSI-X or both. The PCI device signals the interrupt by issuing a 32-bit write transaction on PCI bus with the target address taken from address data pair described below.
</p><p>The legacy MSI supports single address data pair (Message Address / Message Data) with some editing of data allowed if multiple device interrupts are enabled. The MSI-X has for each device interrupt own address/data pair.
</p><p>The message address/data pair needs to be supplied by the driver/OS and needs to target some special hardware register which in turn generates the interrupt. Therefore the exact values of address and data pairs are specific to the architecture. The format is described in detail in the <a href="https://wiki.osdev.org/index.php?title=MSI_Register_Format&amp;action=edit&amp;redlink=1" class="new" title="MSI Register Format (page does not exist)">MSI Register Format</a>. 
</p>
<h3><span class="mw-headline" id="Enabling_MSI">Enabling MSI</span></h3>
<p>First, check that the device has a pointer to the capabilities list (status register bit 4 set to 1).
Then, traverse the capabilities list. The low 8 bits of a capability register are the ID - <code>0x05</code> for MSI. The next 8 bits are the offset (in <a href="PCI#Configuration_Space">PCI Configuration Space</a>) of the next capability.
</p><p>The MSI capability is as follows:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Register</th>
<th>Offset</th>
<th>Bits 31-24</th>
<th>Bits 23-16</th>
<th>Bits 15-8</th>
<th>Bits 7-0
</th></tr>
<tr>
<td>Cap + 0x0
</td>
<td>Cap + 0x0
</td>
<td colspan="2">Message Control
</td>
<td>Next pointer</td>
<td>Capability ID = 05
</td></tr>
<tr>
<td>Cap + 0x1
</td>
<td>Cap + 0x4
</td>
<td colspan="4">Message Address [Low]
</td></tr>
<tr>
<td>Cap + 0x2
</td>
<td>Cap + 0x8
</td>
<td colspan="4">[Message Address High]
</td></tr>
<tr>
<td>Cap + 0x2/0x3
</td>
<td>Cap + 0x8/0xC
</td>
<td colspan="2">Reserved
</td>
<td colspan="2">Message Data
</td></tr>
<tr>
<td>Cap + 0x4
</td>
<td>Cap + 0x10
</td>
<td colspan="4">[Mask]
</td></tr>
<tr>
<td>Cap + 0x5
</td>
<td>Cap + 0x14
</td>
<td colspan="4">[Pending]
</td></tr></tbody></table>
<p>Here is the layout of the message control register:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bits 15-9</th>
<th>Bit 8</th>
<th>Bit 7</th>
<th>Bits 6-4</th>
<th>Bits 3-1</th>
<th>Bit 0
</th></tr>
<tr>
<td>Reserved
</td>
<td>Per-vector masking
</td>
<td>64-bit
</td>
<td>Multiple Message Enable
</td>
<td>Multiple Message Capable
</td>
<td>Enable
</td></tr></tbody></table>
<p><b>Multiple messages:</b>
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>MME / MMI</th>
<th>Interrupts
</th></tr>
<tr>
<td>000</td>
<td>1
</td></tr>
<tr>
<td>001</td>
<td>2
</td></tr>
<tr>
<td>010</td>
<td>4
</td></tr>
<tr>
<td>011</td>
<td>8
</td></tr>
<tr>
<td>100</td>
<td>16
</td></tr>
<tr>
<td>101</td>
<td>32
</td></tr></tbody></table>
<p>In MME, specifies the number of low bits of Message Data that may be modified by the device.
</p><p>Therefore, the interrupt vector block allocated must be aligned accordingly.
</p><p><b>Interrupt masking</b>
</p><p>If capable, you can mask individual messages by setting the corresponding bit (1 &lt;&lt; n), in the mask register.
</p><p>If a message is pending, then the corresponding bit in the pending register is set.
</p><p>Note that the PCI specification doesn't specify the location of these registers if the message address is 32-bit. This is because a function that supports masking is required to implement 64-bit addressing!
</p>
<h3><span class="mw-headline" id="Enabling_MSI-X">Enabling MSI-X</span></h3>
<p>Like for MSI, you have to find the MSI-X capability, but the ID for MSI-X is <b>0x11</b>
</p><p>The structure is as follows:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Register</th>
<th>Offset</th>
<th>Bits 31-24</th>
<th>Bits 23-16</th>
<th>Bits 15-8</th>
<th>Bits 7-3</th>
<th>Bits 2-0
</th></tr>
<tr>
<td>Cap + 0x0
</td>
<td>Cap + 0x0
</td>
<td colspan="2">Message Control
</td>
<td>Next Pointer
</td>
<td colspan="2">Capability ID = 11
</td></tr>
<tr>
<td>Cap + 0x1
</td>
<td>Cap + 0x4
</td>
<td colspan="4">Table Offset
</td>
<td colspan="1">BIR
</td></tr>
<tr>
<td>Cap + 0x2
</td>
<td>Cap + 0x8
</td>
<td colspan="4">Pending Bit Offset
</td>
<td colspan="1">Pending Bit BIR
</td></tr></tbody></table>
<p>Unlike MSI, MSI-X supports 2048 interrupts. This is achieved by maintaining a table of interrupts in the PCI device's address space. The wording of the PCI 3.0 specification indicates that this <i>must</i> be via a Memory BAR.
</p><p><b>BIR</b> specifies which BAR is used for the Message Table. This may be a 64-bit BAR, and is zero-indexed (so BIR=0, BAR0, offset <code>0x10</code> into the header).
</p><p><b>Table Offset</b> is an offset into that BAR where the Message Table lives. Note that it is 8-byte aligned - so simply mask BIR.
</p><p>The format of Message Control is as follows:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bit 15</th>
<th>Bit 14</th>
<th>Bits 13-11</th>
<th>Bits 10-0
</th></tr>
<tr>
<td>Enable
</td>
<td>Function Mask
</td>
<td>Reserved
</td>
<td>Table Size
</td></tr></tbody></table>
<p><b>Table Size</b> is N - 1 encoded, and is the number of entries in the MSI-X table. This field is Read-Only.
</p><p>Now you have all the information you need to find the MSI-X table:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bits 127-96</th>
<th>Bits 95-64</th>
<th>Bits 63-32</th>
<th>Bits 31-0
</th></tr>
<tr>
<td>Vector Control (0)
</td>
<td>Message Data (0)
</td>
<td>Message Address High (0)
</td>
<td>Message Address Low (0)
</td></tr>
<tr>
<td>Vector Control (1)
</td>
<td>Message Data (1)
</td>
<td>Message Address High (1)
</td>
<td>Message Address Low (1)
</td></tr>
<tr>
<td>...
</td>
<td>...
</td>
<td>...
</td>
<td>...
</td></tr>
<tr>
<td>Vector Control (N - 1)
</td>
<td>Message Data (N - 1)
</td>
<td>Message Address High (N - 1)
</td>
<td>Message Address Low (N - 1)
</td></tr></tbody></table>
<p><b>Vector Control</b> is as follows:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Bits 31-1</th>
<th>Bit 0
</th></tr>
<tr>
<td>Reserved
</td>
<td>Masked
</td></tr></tbody></table>
<p>Note that <b>Message Address</b> is is 4-byte aligned, so, again, mask the low bits. The interrupt is masked if <b>Masked</b> is set to 1.
</p><p>Message Address and Data are as they were for MSI - architecture specific. However, unlike with MSI, you can specify independent vectors for all the interrupts, only limited by having the same upper 32-bit message address.
</p>
<h2><span class="mw-headline" id="Multi-function_Devices">Multi-function Devices</span></h2>
<p>Multi-function devices behave in the same manner as normal PCI devices. The easiest way to detect a multi-function device is bit 7 of the header type field. If it is set (value = <code>0x80</code>), the device is multi-function -- else it is not. Make sure you mask this bit when you determine header type. To detect the number of functions you need to scan the PCI configuration space for every function - unused functions have vendor <code>0xFFFF</code>. Device IDs and Class codes vary between functions. Functions are not necessarily in order - you can have function <code>0x0</code>, <code>0x1</code> and <code>0x7</code> in use.
</p>
<h2><span class="mw-headline" id="Disclaimer">Disclaimer</span></h2>
<p>This text originates from "Pentium on VME", unknown author, md5sum d292807a3c56881c6faba7a1ecfd4c79. The original document is apparently no longer present on the Web ...
</p><p>Closest match: <a rel="nofollow" class="external autonumber" href="https://web.archive.org/web/20071009221818/http://www.quicklogic.com/images/appnote10.pdf">[2]</a>
</p>
<h2><span class="mw-headline" id="References">References</span></h2>
<ul><li>PCI Local Bus Specification, revision 3.0, PCI Special Interest Group, August 12, 2002</li></ul>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="PCI_Express" title="PCI Express">PCI Express</a></li></ul>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="https://devicehunt.com/about">Very useful page about VendorID and DeviceID</a></li>
<li><a rel="nofollow" class="external text" href="https://cds.cern.ch/record/551427/files/cer-2308933.pdf">Very detailed PCI-to-PCI architecture specification</a></li>
<li><a rel="nofollow" class="external text" href="http://xillybus.com/tutorials/pci-express-tlp-pcie-primer-tutorial-guide-1">How PCI Express devices talk</a></li>
<li><a rel="nofollow" class="external text" href="https://docs.oracle.com/cd/E19120-01/open.solaris/819-3196/hwovr-22/index.html">PCI Local Bus (Solaris documentation)</a></li>
<li><a rel="nofollow" class="external text" href="https://tldp.org/LDP/tlk/dd/pci.html">PCI in the Linux kernel</a></li>
<li><a rel="nofollow" class="external text" href="https://pci-ids.ucw.cz">More up to date PCI vendor and device numbers</a></li>
<li><a rel="nofollow" class="external text" href="https://msdn.microsoft.com/en-us/library/ms903537.aspx">Structure describes that PCI configuration space for PCI devices</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250211122106
Cache expiry: 86400
Reduced expiry: false
Complications: [showtoc]
CPU time usage: 0.093 seconds
Real time usage: 1.003 seconds
Preprocessor visited node count: 218/1000000
Postexpand include size: 3402/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 24969/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  938.648      1 -total
  0.08%    0.779     21 Template:Wikitable
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1485-0!canonical and timestamp 20250211122105 and revision id 29308.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=PCI&amp;oldid=29308">https://wiki.osdev.org/index.php?title=PCI&amp;oldid=29308</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Buses" title="Category:Buses">Buses</a></li><li><a href="./Category:PCI" title="Category:PCI">PCI</a></li><li><a href="./Category:Standards" title="Category:Standards">Standards</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=PCI" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="PCI#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="PCI" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:PCI" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="PCI"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PCI&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PCI&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/PCI" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/PCI" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PCI&amp;oldid=29308" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PCI&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/Peripheral_Component_Interconnect" title="Peripheral Component Interconnect  Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 25 November 2024, at 20:27.</li>
	<li id="footer-info-0">This page has been accessed 63,008 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=PCI&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.093","walltime":"1.003","ppvisitednodes":{"value":218,"limit":1000000},"postexpandincludesize":{"value":3402,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":24969,"limit":5000000},"timingprofile":["100.00%  938.648      1 -total","  0.08%    0.779     21 Template:Wikitable"]},"cachereport":{"timestamp":"20250211122106","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":103});});</script>
</body>
</html>