<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>User:Pancakes/BitmapHeapImplementationEnhanced - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"118bd0261f0fe4b62b95a403","wgCSPNonce":false,"wgCanonicalNamespace":"User","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":2,"wgPageName":"User:Pancakes/BitmapHeapImplementationEnhanced","wgTitle":"Pancakes/BitmapHeapImplementationEnhanced","wgCurRevisionId":15824,"wgRevisionId":15824,"wgArticleId":3471,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Memory management","Heap"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"User:Pancakes/BitmapHeapImplementationEnhanced","wgRelevantArticleId":3471,"wgIsProbablyEditable":false,
"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRelevantUserName":"Pancakes","wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="../favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="../opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="../api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-2 ns-subject page-User_Pancakes_BitmapHeapImplementationEnhanced rootpage-User_Pancakes skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-namespace">User</span><span class="mw-page-title-separator">:</span><span class="mw-page-title-main">Pancakes/BitmapHeapImplementationEnhanced</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"><span class="subpages">&lt; <a href="https://wiki.osdev.org/User:Pancakes" title="User:Pancakes">User:Pancakes</a></span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="BitmapHeapImplementationEnhanced#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="BitmapHeapImplementationEnhanced#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="BitmapHeapImplementationEnhanced#Bitmap_Heap_Implementation_Enhanced"><span class="tocnumber">1</span> <span class="toctext">Bitmap Heap Implementation Enhanced</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="BitmapHeapImplementationEnhanced#Two_Ways_To_Initialize_That_Are_Equivalent"><span class="tocnumber">1.1</span> <span class="toctext">Two Ways To Initialize That Are Equivalent</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="BitmapHeapImplementationEnhanced#Allocating_Header_And_Bitmap_Outside"><span class="tocnumber">1.2</span> <span class="toctext">Allocating Header And Bitmap Outside</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="BitmapHeapImplementationEnhanced#Allocate_Header_Outside_With_Bitmap_At_Beginning"><span class="tocnumber">1.3</span> <span class="toctext">Allocate Header Outside With Bitmap At Beginning</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="BitmapHeapImplementationEnhanced#Example_To_Manage_Physical_Memory_Using_Two_Heaps"><span class="tocnumber">1.4</span> <span class="toctext">Example To Manage Physical Memory Using Two Heaps</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="BitmapHeapImplementationEnhanced#Feeding_Heap_With_Pages/Chunks/Sections"><span class="tocnumber">1.5</span> <span class="toctext">Feeding Heap With Pages/Chunks/Sections</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="BitmapHeapImplementationEnhanced#=_Allocating_On_Boundaries"><span class="tocnumber">1.6</span> <span class="toctext">= Allocating On Boundaries</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="BitmapHeapImplementationEnhanced#Code"><span class="tocnumber">2</span> <span class="toctext">Code</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="BitmapHeapImplementationEnhanced#Example_Of_Making_The_Most_Of_Memory_On_An_ARM_System"><span class="tocnumber">2.1</span> <span class="toctext">Example Of Making The Most Of Memory On An ARM System</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="BitmapHeapImplementationEnhanced#Original_Implementation"><span class="tocnumber">2.2</span> <span class="toctext">Original Implementation</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Bitmap_Heap_Implementation_Enhanced">Bitmap Heap Implementation Enhanced</span></h2>
<p>I was working on another project and realized that I could use the same code for a heap as I could to manage physical memory. I did not want to clutter that page with lots of code so I placed it here.
</p><p>The original page is <a href="BitmapHeapImplementation" title="User:Pancakes/BitmapHeapImplementation">here</a> and contains a lot of information about using the heap.
</p><p>This heap provides four extra functions.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">k_heapBMAddBlockEx</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">bsize</span><span class="p">,</span><span class="w"> </span><span class="n">KHEAPBLOCKBM</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="n">isBMInside</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">k_heapBMAllocBound</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">mask</span><span class="p">);</span><span class="w"></span>
<span class="n">uintptr</span><span class="w"> </span><span class="nf">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">uintptr</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">bsize</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">k_heapBMSet</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="n">rval</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>The <i>k_heapBMAddBlockEx</i> allows you to set the actual block management structure and <i>bitmap</i> in a different memory location. The is useful because normally the header will offset the actual data onto a CPU word sized boundary. While a CPU word sized (for example 4-byte/32-bit) boundary is useful for a normal heap, when working with say 4KB or 16KB boundary you will have problems and additional complications trying to make it work. For example if you wanted to manage memory from address 0 to the 8MB mark and make the bitmap handle chunks in 4KB sections all aligned on a boundary then the header is going to cause that to be impossible.
</p>
<h4><span class="mw-headline" id="Two_Ways_To_Initialize_That_Are_Equivalent">Two Ways To Initialize That Are Equivalent</span></h4>
<p>To explain let me show you two ways to initialize the bitmap that are equivalent:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">KHEAPBM</span><span class="w">       </span><span class="n">bmh</span><span class="p">;</span><span class="w"></span>

<span class="cp">#define SIZE  0x100000</span>
<span class="cp">#define BSIZE 16</span>

<span class="cm">/* the simple and normal way */</span><span class="w"></span>
<span class="n">k_heapBMInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmh</span><span class="p">);</span><span class="w"></span>
<span class="n">k_heapBMAddBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmh</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">SIZE</span><span class="p">),</span><span class="w"> </span><span class="n">SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">BSIZE</span><span class="p">);</span><span class="w"></span>

<span class="cm">/* the advanced way */</span><span class="w"></span>
<span class="n">uintptr</span><span class="w">       </span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="n">uint8</span><span class="w">         </span><span class="o">*</span><span class="n">bm</span><span class="p">;</span><span class="w"></span>
<span class="n">KHEAPBLOCKBM</span><span class="w">  </span><span class="o">*</span><span class="n">block</span><span class="p">;</span><span class="w"></span>

<span class="n">k_heapBMInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmh</span><span class="p">);</span><span class="w"></span>
<span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">SIZE</span><span class="p">);</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)(</span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">));</span><span class="w"></span>
<span class="n">k_heapBMAddBlockEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmh</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">),</span><span class="w"> </span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">),</span><span class="w"> </span><span class="n">BSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Both, produce the same result. In actuality when you call <i>k_heapBMAddBlock</i> it does this then it calls <i>k_heapBMAddBlockEx</i> where <i>Ex</i> stands for extension. Now, let me show you an advantage of using the extension function.
</p>
<h4><span class="mw-headline" id="Allocating_Header_And_Bitmap_Outside">Allocating Header And Bitmap Outside</span></h4>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">uintptr</span><span class="w">       </span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="n">uint8</span><span class="w">         </span><span class="o">*</span><span class="n">bm</span><span class="p">;</span><span class="w"></span>
<span class="n">KHEAPBLOCKBM</span><span class="w">  </span><span class="o">*</span><span class="n">block</span><span class="p">;</span><span class="w"></span>

<span class="n">k_heapBMInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmh</span><span class="p">);</span><span class="w"></span>
<span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">SIZE</span><span class="p">);</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">));</span><span class="w"></span>
<span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">BSIZE</span><span class="p">));</span><span class="w"></span>
<span class="n">k_heapBMAddBlockEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmh</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">BSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Now, the bitmap and block header are stored outside of the originally allocated data. This is useful because if you want to alloc data aligned on a boundary beyond the CPU word size it is now possible because you have removed the block structure from offsetting your data. But, what about the bitmap? I mean the bitmap would have used whole blocks anyway right? Well, true, but the bitmap might have wasted some precious memory in a machine with a limited amount of memory to begin with because the bitmap will normally occupy whole blocks. So if your block size was 4K and you have 8MB of memory then the bitmap would have used an entire 4K (one block) instead of only 2K which might be kind of wasteful.
</p>
<h4><span class="mw-headline" id="Allocate_Header_Outside_With_Bitmap_At_Beginning">Allocate Header Outside With Bitmap At Beginning</span></h4>
<p>My point is now you not only have control over removing the header, but also the ability to save a little space by also allocating the bitmap outside of the heap data and not have it subject to using whole blocks and that can save a little space.
</p><p>Let me also show you how to leave the bitmap but allocate the header outside:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">k_heapBMInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmh</span><span class="p">);</span><span class="w"></span>
<span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">SIZE</span><span class="p">);</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">));</span><span class="w"></span>
<span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="n">k_heapBMAddBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmh</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">BSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>You can notice the <i>bm</i> is set to the beginning and at the moment the implementation does not support it being set anywhere else unless you use the <i>k_heapBMSet</i> which is explained below.
</p>
<h4><span class="mw-headline" id="Example_To_Manage_Physical_Memory_Using_Two_Heaps">Example To Manage Physical Memory Using Two Heaps</span></h4>
<p>Let me show an example of using the bitmap implementation to manage physical memory.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">        </span><span class="cp">#define KRAMADDR    0x0               </span>
<span class="w">        </span><span class="cp">#define KCHKIOFF    (0x1000 * 4)       </span><span class="cm">/* 16KB */</span><span class="cp"></span>
<span class="w">        </span><span class="cp">#define KCHKISIZE   0x1000             </span><span class="cm">/* 4KB */</span><span class="cp"></span>
<span class="w">        </span><span class="cp">#define KRAMSIZE    (1024 * 1024 * 8)  </span><span class="cm">/* 8 MB */</span><span class="cp"></span>

<span class="w">        </span><span class="n">KHEAPBM</span><span class="w">      </span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">hchk</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">k_heapBMInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hphy</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hchk</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* get a bit of memory to start with for small chunk */</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMAddBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">KCHKIOFF</span><span class="p">,</span><span class="w"> </span><span class="n">KCHKISIZE</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* add block but place header in chunk heap to keep alignment */</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* also allocate bitmap inside chunk heap */</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMAddBlockEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMSIZE</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">)),</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">KRAMSIZE</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">)),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">KCHKIOFF</span><span class="p">,</span><span class="w"> </span><span class="n">KCHKISIZE</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Now, we used <i>k_heapBMSet</i> to remove the region <i>KCHKIOFF</i> of size <i>KCHKISIZE</i> by setting it as used inside the heap basically removing it from being allocated. Now, you can allocate on a 16KB boundary from the beginning of RAM by removing the header and bitmap, and still keeping track of them by allocating an initial small size heap.
</p><p><i>You want a 4KB page then use hphy. You need to allocate a structure then use hchk. You want 16KB then allocate from either hphy and hchk (you need support to code to make hchk allocate more memory if it does not have enough or runs out see blow).</i>
</p><p><i>You need 16KB allocated on a 16KB boundary then see one of the sections below.</i>
</p><p>You may notice the last argument of <i>k_heapBMSet</i> is <i>5</i>. Try not to use the value <i>1</i>, <i>0</i>, or <i>2</i> as the implementation uses that to designate allocations. If you use any of those you will find your region getting freed or allocated. So use something <i>&gt; 2</i>. You can use anything between <i>3</i> and <i>255</i>.
</p>
<h4><span id="Feeding_Heap_With_Pages.2FChunks.2FSections"></span><span class="mw-headline" id="Feeding_Heap_With_Pages/Chunks/Sections">Feeding Heap With Pages/Chunks/Sections</span></h4>
<p>From this point you could keep your small chunk heap (<i>hchk</i>) feed by handing allocates from your larger size heap (<i>hphy</i>). The <i>hphy</i> stands for physical page heap and <i>hchk</i> for chunk heap.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">kalloc</span><span class="p">(</span><span class="n">uintptr</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="cm">/* access hphy and hchk... */</span><span class="w"></span>
<span class="w">     </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="cm">/* try allocation again... */</span><span class="w"></span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mh">0x500</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">             </span><span class="n">k_heapBMAddBlock</span><span class="p">(</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">k_heapAlloc</span><span class="p">(</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">             </span><span class="n">k_heapBMAddBlock</span><span class="p">(</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">k_heapAlloc</span><span class="p">(</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">),</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">         </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="w">     </span><span class="cm">/* either it worked or it did not */</span><span class="w"></span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The above is a rough way to feed your small chunk heap with your larger physical page heap. It can be optimized. For example you might be able to allocate less than <i>size * 2</i> but I just used that because its whole number integer multiplication and simple to understand.
</p>
<h3><span id=".3D_Allocating_On_Boundaries"></span><span class="mw-headline" id="=_Allocating_On_Boundaries">= Allocating On Boundaries</span></h3>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">uintptr</span><span class="w">   </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMAllocBound</span><span class="p">(</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Here we request a pointer to a memory region 16KB in size that is allocated on a 16KB boundary. The 16KB boundary is specified by asking for the bottom 14 bits to be zero. As 16KB is <i>0x4000</i> which has the bottom 14 bits set to zero. If it is unable to find a region that satisfies this condition then you get a null/zero pointer.
</p>
<h2><span class="mw-headline" id="Code">Code</span></h2>
<p>Here is the updated bitmap implementation providing the new extensions:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* Leonard Kevin McGuire Jr (<a href="../cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2f44424c481c1b1e1c6f48424e4643014c4042">[email&#160;protected]</a>) (www.kmcg3413.net) */</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_KHEAPBLOCKBM</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">_KHEAPBLOCKBM</span><span class="w">	</span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">					</span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">					</span><span class="n">used</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">					</span><span class="n">bsize</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">					</span><span class="n">lfb</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uintptr</span><span class="w">					</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">					</span><span class="o">*</span><span class="n">bm</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">KHEAPBLOCKBM</span><span class="p">;</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_KHEAPBM</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">KHEAPBLOCKBM</span><span class="w">			</span><span class="o">*</span><span class="n">fblock</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">KHEAPBM</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">k_heapBMInit</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">k_heapBMAddBlock</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">bsize</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">k_heapBMAddBlockEx</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">bsize</span><span class="p">,</span><span class="w"> </span><span class="n">KHEAPBLOCKBM</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="n">isBMInside</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">k_heapBMAlloc</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">k_heapBMFree</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="n">uintptr</span><span class="w"> </span><span class="nf">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">uintptr</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">bsize</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">k_heapBMAllocBound</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">mask</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">k_heapBMSet</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="n">rval</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">k_heapBMInit</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">fblock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">k_heapBMAddBlock</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">bsize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">KHEAPBLOCKBM</span><span class="w">			</span><span class="o">*</span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uintptr</span><span class="w">					</span><span class="n">bmsz</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">					</span><span class="o">*</span><span class="n">bm</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">bmsz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">bsize</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)(</span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* important to set isBMInside... (last argument) */</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">k_heapBMAddBlockEx</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">),</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">),</span><span class="w"> </span><span class="n">bsize</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">uintptr</span><span class="w"> </span><span class="nf">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">uintptr</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">bsize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">bsize</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">k_heapBMAddBlockEx</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">bsize</span><span class="p">,</span><span class="w"> </span><span class="n">KHEAPBLOCKBM</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="n">isBMInside</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">				</span><span class="n">bcnt</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">				</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bsize</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bm</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">fblock</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">fblock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">bcnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">bsize</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* clear bitmap */</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bcnt</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">bm</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">bcnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">bcnt</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">bsize</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bsize</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bcnt</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">bcnt</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">bsize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bcnt</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">bsize</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* if BM is not inside leave this space avalible */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isBMInside</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* reserve room for bitmap */</span><span class="w"></span>
<span class="w">		</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bcnt</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">bm</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lfb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcnt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">used</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcnt</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="nf">k_heapBMGetNID</span><span class="p">(</span><span class="n">uint8</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">		</span><span class="n">c</span><span class="p">;</span><span class="w">	</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">k_heapBMAlloc</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">k_heapBMAllocBound</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">k_heapBMAllocBound</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">bound</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">KHEAPBLOCKBM</span><span class="w">		</span><span class="o">*</span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">				</span><span class="o">*</span><span class="n">bm</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">				</span><span class="n">bcnt</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">				</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">				</span><span class="n">bneed</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">				</span><span class="n">nid</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">				</span><span class="n">max</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">bound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">bound</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* iterate blocks */</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">fblock</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* check if block has enough room */</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">used</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">bcnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">;</span><span class="w">		</span>
<span class="w">			</span><span class="n">bneed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lfb</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">bcnt</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lfb</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lfb</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="cm">/* just wrap around */</span><span class="w"></span>
<span class="w">				</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">bcnt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">					</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">				</span><span class="p">}</span><span class="w">		</span>
<span class="w">				</span>
<span class="w">				</span><span class="cm">/*</span>
<span class="cm">					this is used to allocate on specified boundaries larger than the block size</span>
<span class="cm">				*/</span><span class="w"></span>
<span class="w">				</span><span class="k">if</span><span class="w"> </span><span class="p">((((</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">bound</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">					</span><span class="k">continue</span><span class="p">;</span><span class="w">	</span>
<span class="w">				</span>
<span class="w">				</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bm</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">	</span>
<span class="w">					</span><span class="cm">/* count free blocks */</span><span class="w"></span>
<span class="w">					</span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcnt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">					</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bm</span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bneed</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">max</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">y</span><span class="p">);</span><span class="w"></span>

<span class="w">					</span><span class="cm">/* we have enough, now allocate them */</span><span class="w"></span>
<span class="w">					</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">bneed</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">						</span><span class="cm">/* find ID that does not match left or right */</span><span class="w"></span>
<span class="w">						</span><span class="n">nid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMGetNID</span><span class="p">(</span><span class="n">bm</span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">bm</span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">]);</span><span class="w"></span>
<span class="w">						</span>
<span class="w">						</span><span class="cm">/* allocate by setting id */</span><span class="w"></span>
<span class="w">						</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">							</span><span class="n">bm</span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nid</span><span class="p">;</span><span class="w"></span>
<span class="w">						</span><span class="p">}</span><span class="w"></span>
<span class="w">						</span><span class="cm">/* optimization */</span><span class="w"></span>
<span class="w">						</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lfb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bneed</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">						</span><span class="cm">/* count used blocks NOT bytes */</span><span class="w"></span>
<span class="w">						</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">used</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">						</span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)((</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">					</span><span class="p">}</span><span class="w"></span>
<span class="w">					</span>
<span class="w">					</span><span class="cm">/* x will be incremented by one ONCE more in our FOR loop */</span><span class="w"></span>
<span class="w">					</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">					</span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">				</span><span class="p">}</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">k_heapBMSet</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="n">rval</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">KHEAPBLOCKBM</span><span class="w">		</span><span class="o">*</span><span class="n">b</span><span class="p">;</span><span class="w">	</span>
<span class="w">	</span><span class="n">uintptr</span><span class="w">				</span><span class="n">ptroff</span><span class="p">,</span><span class="w"> </span><span class="n">endoff</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">				</span><span class="n">bi</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">ei</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">				</span><span class="o">*</span><span class="n">bm</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">				</span><span class="n">id</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">				</span><span class="n">max</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">fblock</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* check if region effects block */</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* head end resides inside block */</span><span class="w"></span>
<span class="w">			</span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* tail end resides inside block */</span><span class="w"></span>
<span class="w">			</span><span class="p">((</span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* spans across but does not start or end in block */</span><span class="w"></span>
<span class="w">			</span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* found block */</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">ptroff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span><span class="w">  </span><span class="cm">/* get offset to get block */</span><span class="w"></span>
<span class="w">				</span><span class="cm">/* block offset in BM */</span><span class="w"></span>
<span class="w">				</span><span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptroff</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="cm">/* do not start negative on bitmap */</span><span class="w"></span>
<span class="w">				</span><span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="cm">/* access bitmap pointer in local variable */</span><span class="w"></span>
<span class="w">			</span><span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm</span><span class="p">;</span><span class="w"></span>

<span class="w">			</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">endoff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="cm">/* end index inside bitmap */</span><span class="w"></span>
<span class="w">			</span><span class="n">ei</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">endoff</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">endoff</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">endoff</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">endoff</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="o">++</span><span class="n">ei</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="cm">/* region could span past end of a block so adjust */</span><span class="w"></span>
<span class="w">			</span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ei</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ei</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="cm">/* set bitmap buckets */</span><span class="w"></span>
<span class="w">			</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bi</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">max</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">bm</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rval</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="cm">/* update free block count */</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">used</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">ei</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">bi</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">used</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">ei</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">bi</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="cm">/* do not return as region could span multiple blocks.. so check the rest */</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* this error needs to be raised or reported somehow */</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">k_heapBMFree</span><span class="p">(</span><span class="n">KHEAPBM</span><span class="w"> </span><span class="o">*</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">KHEAPBLOCKBM</span><span class="w">		</span><span class="o">*</span><span class="n">b</span><span class="p">;</span><span class="w">	</span>
<span class="w">	</span><span class="n">uintptr</span><span class="w">				</span><span class="n">ptroff</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">				</span><span class="n">bi</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">				</span><span class="o">*</span><span class="n">bm</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">				</span><span class="n">id</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">				</span><span class="n">max</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">fblock</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">uintptr</span><span class="p">)</span><span class="n">ptr</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="n">ptr</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* found block */</span><span class="w"></span>
<span class="w">			</span><span class="n">ptroff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="n">ptr</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span><span class="w">  </span><span class="cm">/* get offset to get block */</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* block offset in BM */</span><span class="w"></span>
<span class="w">			</span><span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptroff</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* .. */</span><span class="w"></span>
<span class="w">			</span><span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* clear allocation */</span><span class="w"></span>
<span class="w">			</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bm</span><span class="p">[</span><span class="n">bi</span><span class="p">];</span><span class="w"></span>

<span class="w">			</span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bi</span><span class="p">;</span><span class="w"> </span><span class="n">bm</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">max</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">bm</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* update free block count */</span><span class="w"></span>
<span class="w">			</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">used</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">bi</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* this error needs to be raised or reported somehow */</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Example_Of_Making_The_Most_Of_Memory_On_An_ARM_System">Example Of Making The Most Of Memory On An ARM System</span></h4>
<p>Just for an example. This is how I might start my memory management on an ARM based platform, but 
it could be very similar for the X86/X64 or another architecture. I like the ARM because it is a
bit simpler. The X86 has many more memory areas that need to be protected.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* the intial kernel stack and the exception stack */</span><span class="w"></span>
<span class="cp">#define KSTACKSTART 0x2000		</span><span class="cm">/* descending */</span><span class="cp"></span>
<span class="cp">#define KSTACKEXC   0x3000		</span><span class="cm">/* descending */</span><span class="cp"></span>
<span class="cm">/* somewhere to place the kernel state structure */</span><span class="w"></span>
<span class="cp">#define KSTATEADDR	0x3000</span>
<span class="cm">/* the address of the start of usable RAM and it&#39;s length in bytes */</span><span class="w"></span>
<span class="cp">#define KRAMADDR	0x4000</span>
<span class="cp">#define KRAMSIZE	(1024 * 1024 * 8)</span>
<span class="cm">/* the size of a physical memory page */</span><span class="w"></span>
<span class="cp">#define KPHYPAGESIZE		4096</span>
<span class="cm">/* the block size of the chunk heap (kmalloc, kfree) */</span><span class="w"></span>
<span class="cp">#define KCHKHEAPBSIZE		16</span>

<span class="cm">/* KSTATE is a structure that serves as a global variable area for the kernel */</span><span class="w"></span>
<span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KSTATE</span><span class="o">*</span><span class="p">)</span><span class="n">KSTATEADDR</span><span class="p">;</span><span class="w"></span>

<span class="n">k_heapBMInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">);</span><span class="w"></span>
<span class="n">k_heapBMInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* get a bit of memory to start with for small chunk */</span><span class="w"></span>
<span class="n">k_heapBMAddBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">7</span><span class="p">),</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>

<span class="cm">/* state structure */</span><span class="w"></span>
<span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">KSTATEADDR</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KSTATE</span><span class="p">),</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* stacks (can free KSTACKSTART later) */</span><span class="w"></span>
<span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">KSTACKSTART</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">KSTACKEXC</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>

<span class="cm">/* add block but place header and bitmap in chunk heap to keep alignment */</span><span class="w"></span>
<span class="n">k_heapBMAddBlockEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">)),</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">)),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="cm">/* remove kernel too (you might have to remove it from hchk or hphy), in my case hphy */</span><span class="w"></span>
<span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="mh">0x10000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x4000</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Something to handle is the amount of memory needed to map the maximum memory installed. You may
need to dynamically calculate <i>KRAMADDR</i> so you have enough space to allocate for the <i>KHEAPBLOCKBM</i> structure and the bitmap. For example for 4GB of memory and a 4K page size your bitmap would be 1MB in size. A simple check that displays a message may be sufficient. Such as a 
warning message that says the system was unable to initialize and why. But, actually increasing KRAMADDR if needed should work fine.
</p><p>My chunk heap (small sized allocation heap) uses 16-byte blocks and is initial setup between 
memory address <i>4*7</i> and <i>KRAMSTART</i>. The RAM actually starts at 0x0 so it is a bit misleading. I then
allocate the memory needed for the physical page heap from my chunk heap and set it to go from <i>KRAMADDR</i> with size <i>KRAMADDR - KRAMSIZE</i> since I used a bit out of the total RAM size.
</p><p>Then I set each region as used in my small chunk heap where the initial kernel stack resides and the exception stack. I also skipped past the exception table with <i>4*7</i>. This helps to make the most of my potentially limited memory by allocating 16-byte blocks to live between those areas. Once task switching is up and running and I can free the area occupied by the initial kernel stack.
</p><p>Also, notice I use a <i>6</i> for the initial kernel stack and a <i>7</i> for the exception stack. This is because if I used the same number and tried to free the initial kernel stack it would free both. Unless, I used the k_heapBMSet and gave it a <i>0</i> which is also another way, but I just preferred to 
keep them separate so I did not have to reference the <i>KSTACKSTART</i> again when releasing the memory.
</p>
<h4><span class="mw-headline" id="Original_Implementation">Original Implementation</span></h4>
<p>For the original implementation see <a href="BitmapHeapImplementation" title="User:Pancakes/BitmapHeapImplementation">Bitmap Heap Implementation</a>. I kept these separate to reduce the complexity of people just looking for a basic heap implementation with only the minimal necessary functionality. I would recommend that check out that page just to get an idea of what has changed.
</p>
<!-- 
NewPP limit report
Cached time: 20250212011553
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.091 seconds
Real time usage: 1.264 seconds
Preprocessor visited node count: 75/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 86498/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:3471-0!canonical and timestamp 20250212011552 and revision id 15824.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=User:Pancakes/BitmapHeapImplementationEnhanced&amp;oldid=15824">https://wiki.osdev.org/index.php?title=User:Pancakes/BitmapHeapImplementationEnhanced&amp;oldid=15824</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="../Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="../Category:Memory_management" title="Category:Memory management">Memory management</a></li><li><a href="https://wiki.osdev.org/index.php?title=Category:Heap&amp;action=edit&amp;redlink=1" class="new" title="Category:Heap (page does not exist)">Heap</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=User%3APancakes%2FBitmapHeapImplementationEnhanced" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="BitmapHeapImplementationEnhanced#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-user" class="selected mw-list-item"><a href="BitmapHeapImplementationEnhanced" title="View the user page [c]" accesskey="c"><span>User page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User_talk:Pancakes/BitmapHeapImplementationEnhanced&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="BitmapHeapImplementationEnhanced"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Pancakes/BitmapHeapImplementationEnhanced&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Pancakes/BitmapHeapImplementationEnhanced&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="../index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="../index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="../Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="../Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="../OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="../OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="../OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="../Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="../Special:WhatLinksHere/User:Pancakes/BitmapHeapImplementationEnhanced" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/User:Pancakes/BitmapHeapImplementationEnhanced" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-contributions" class="mw-list-item"><a href="../Special:Contributions/Pancakes" title="A list of contributions by this user"><span>User contributions</span></a></li><li id="t-log" class="mw-list-item"><a href="../Special:Log/Pancakes"><span>Logs</span></a></li><li id="t-userrights" class="mw-list-item"><a href="../Special:UserRights/Pancakes"><span>View user groups</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="../Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Pancakes/BitmapHeapImplementationEnhanced&amp;oldid=15824" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Pancakes/BitmapHeapImplementationEnhanced&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 29 March 2014, at 09:34.</li>
	<li id="footer-info-0">This page has been accessed 1,397 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="../OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="../OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="../OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=User:Pancakes/BitmapHeapImplementationEnhanced&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="../resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="../resources/assets/poweredby_mediawiki_132x47.png 1.5x, ../resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script data-cfasync="false" src="../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.091","walltime":"1.264","ppvisitednodes":{"value":75,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":86498,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20250212011553","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":1391});});</script>
</body>
</html>