<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>User:Pancakes/ARM Integrator-CP IRQTimerPICTasksAndMM - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"6c55abd387789636a50f465b","wgCSPNonce":false,"wgCanonicalNamespace":"User","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":2,"wgPageName":"User:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM","wgTitle":"Pancakes/ARM Integrator-CP IRQTimerPICTasksAndMM","wgCurRevisionId":16198,"wgRevisionId":16198,"wgArticleId":3472,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"User:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM","wgRelevantArticleId":3472,"wgIsProbablyEditable":false,
"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRelevantUserName":"Pancakes","wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="../favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="../opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="../api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-2 ns-subject page-User_Pancakes_ARM_Integrator-CP_IRQTimerPICTasksAndMM rootpage-User_Pancakes skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-namespace">User</span><span class="mw-page-title-separator">:</span><span class="mw-page-title-main">Pancakes/ARM Integrator-CP IRQTimerPICTasksAndMM</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"><span class="subpages">&lt; <a href="https://wiki.osdev.org/User:Pancakes" title="User:Pancakes">User:Pancakes</a></span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#IRQ,_Timer,_PIC,_Tasks,_And_MM_On_The_Integrator-CP"><span class="tocnumber">1</span> <span class="toctext">IRQ, Timer, PIC, Tasks, And MM On The Integrator-CP</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Author"><span class="tocnumber">1.1</span> <span class="toctext">Author</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Note"><span class="tocnumber">1.2</span> <span class="toctext">Note</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#About"><span class="tocnumber">1.3</span> <span class="toctext">About</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Adding_A_Heap_Implementation"><span class="tocnumber">1.3.1</span> <span class="toctext">Adding A Heap Implementation</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-6"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Adding_The_Basic_Memory_Initialization"><span class="tocnumber">1.4</span> <span class="toctext">Adding The Basic Memory Initialization</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#kmalloc_and_kfree"><span class="tocnumber">1.4.1</span> <span class="toctext">kmalloc and kfree</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-8"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#A_Quick_Primer_On_Virtual_Memory"><span class="tocnumber">1.5</span> <span class="toctext">A Quick Primer On Virtual Memory</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Tinkering_With_Virtual_Memory_On_the_ARM_complying_with_VMSA_v6"><span class="tocnumber">1.6</span> <span class="toctext">Tinkering With Virtual Memory On the ARM complying with VMSA v6</span></a>
<ul>
<li class="toclevel-3 tocsection-10"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Defines"><span class="tocnumber">1.6.1</span> <span class="toctext">Defines</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Example_Enabling_Paging"><span class="tocnumber">1.6.2</span> <span class="toctext">Example Enabling Paging</span></a>
<ul>
<li class="toclevel-4 tocsection-12"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Code"><span class="tocnumber">1.6.2.1</span> <span class="toctext">Code</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-13"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#arm4_tlbsetmode(1)"><span class="tocnumber">1.6.3</span> <span class="toctext">arm4_tlbsetmode(1)</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#arm4_tlbsetdom(0x55555555);"><span class="tocnumber">1.6.4</span> <span class="toctext">arm4_tlbsetdom(0x55555555);</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Access_Bits_For_TLB_Entry"><span class="tocnumber">1.6.5</span> <span class="toctext">Access Bits For TLB Entry</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Coarse_Table_(Sub-Page)"><span class="tocnumber">1.6.6</span> <span class="toctext">Coarse Table (Sub-Page)</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Using_64K_Entries_In_Coarse_Table"><span class="tocnumber">1.6.7</span> <span class="toctext">Using 64K Entries In Coarse Table</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Globally_Tagged_Entries"><span class="tocnumber">1.6.8</span> <span class="toctext">Globally Tagged Entries</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Protection_And_Cache_Behavior"><span class="tocnumber">1.6.9</span> <span class="toctext">Protection And Cache Behavior</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-20"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Working_With_Tables_Per_Process"><span class="tocnumber">1.7</span> <span class="toctext">Working With Tables Per Process</span></a>
<ul>
<li class="toclevel-3 tocsection-21"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Utility_Functions"><span class="tocnumber">1.7.1</span> <span class="toctext">Utility Functions</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Initializing_Page_Tables_Per_Process"><span class="tocnumber">1.7.2</span> <span class="toctext">Initializing Page Tables Per Process</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-23"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#Lets_Page_Out_The_Kernel_Space"><span class="tocnumber">1.8</span> <span class="toctext">Lets Page Out The Kernel Space</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span id="IRQ.2C_Timer.2C_PIC.2C_Tasks.2C_And_MM_On_The_Integrator-CP"></span><span class="mw-headline" id="IRQ,_Timer,_PIC,_Tasks,_And_MM_On_The_Integrator-CP">IRQ, Timer, PIC, Tasks, And MM On The Integrator-CP</span></h2>
<p>Well, hopefully, you are coming from some of the earlier examples. But, if not here are the links.
</p>
<table class="wikitable">
<tbody><tr>
<th>Page
</th>
<th>Description
</th></tr>
<tr>
<td><a href="../ARM_Integrator-CP_IRQTimerAndPIC" title="ARM Integrator-CP IRQTimerAndPIC">IRQ, Timer, And PIC</a>
</td>
<td>This demonstration just uses the IRQ, Timer, And PIC.
</td></tr>
<tr>
<td><a href="../ARM_Integrator-CP_IRQTimerAndPICAndTaskSwitch" title="ARM Integrator-CP IRQTimerAndPICAndTaskSwitch">IRQ, Timer, PIC, And Tasks</a>
</td>
<td>This shows how to switch between tasks using the timer, and builds from the previous page.
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Author">Author</span></h3>
<p>I <a href="https://wiki.osdev.org/User:Pancakes" title="User:Pancakes">Pancakes</a> wrote this to help jump start you into developing for the ARM using QEMU or even a real piece of hardware. I have wrote software for both emulators and real hardware, but this has only been tested on QEMU so far. Please make any needed changes if you find problems. Also let me know at <a rel="nofollow" class="external text" href="../cdn-cgi/l/email-protection#acc7c1cfcb9f989d9feccbc1cdc5c082cfc3c1"><span class="__cf_email__" data-cfemail="3952545a5e0a0d080a795e54585055175a5654">[email&#160;protected]</span></a> if you find this useful, have comments, or suggestions.
</p>
<h3><span class="mw-headline" id="Note">Note</span></h3>
<p><i>If you are working with the VMSAv7 such as with the cortex-a9 then there is no bit to disable sub-pages (no backwards compatibility). In the code below I disable sub-pages. So you should omit setting bit 23 of the control register when enabling paging on VMSAv7 systems.</i>
</p>
<h3><span class="mw-headline" id="About">About</span></h3>
<p>I am going to extend the later demonstration of task switching. But, first we are going to need to add in some basic memory management, and then progress to virtual memory afterwards.
</p>
<h4><span class="mw-headline" id="Adding_A_Heap_Implementation">Adding A Heap Implementation</span></h4>
<p>I am going to use a fairly simple heap implementation, <a href="BitmapHeapImplementationEnhanced" title="User:Pancakes/BitmapHeapImplementationEnhanced">Bitmap Heap Implementation Enhanced</a>. I would recommend that you read about it because we will be using all of it's features to implement a memory management system, and it will be needed to implement virtual memory. Also, even if you use your own implementation you might find it helpful to have a general idea of what the codes does. It might even be self explanatory for some readers.
</p><p>To compile and link I would recommend that you place the structures and prototypes in a header called <i>kheap_bm.h</i> and place the implementation into <i>kheap_bm.c</i>. Then when compiling the kernel code just include the header and link with the <i>kheap_bm.o</i> that you should produce and everything should work great.
</p>
<h3><span class="mw-headline" id="Adding_The_Basic_Memory_Initialization">Adding The Basic Memory Initialization</span></h3>
<p>We are going to be basing everything from one of the previous demonstrations shown in the links at the top of this page. To make this page easier to read I am only going to duplicate the code needed to demonstrate. The first modification we are going to make is to the <i>KSTATE</i> structure.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_KSTATE</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">KTHREAD</span><span class="w">			</span><span class="n">threads</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">			</span><span class="n">threadndx</span><span class="p">;</span><span class="w">	</span>
<span class="w">	</span><span class="n">uint8</span><span class="w">			</span><span class="n">iswitch</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">KHEAPBM</span><span class="w">			</span><span class="n">hphy</span><span class="p">;</span><span class="w">		</span><span class="cm">/* physical page heap */</span><span class="w"></span>
<span class="w">	</span><span class="n">KHEAPBM</span><span class="w">			</span><span class="n">hchk</span><span class="p">;</span><span class="w">		</span><span class="cm">/* data chunk heap */</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">KSTATE</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>I have added two new fields <i>hphy</i> and <i>hchk</i>. The <i>hphy</i> will serve as our physical memory manager working with 4KB pages while <i>kchk</i> will work with smaller allocations. If you are using the older demonstration you may be missing the <i>KSTATE</i> structure completely. 
</p><p>Lets make some defines:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/* the intial kernel stack and the exception stack */</span><span class="w"></span>
<span class="cp">#define KSTACKSTART 0x2000		</span><span class="cm">/* descending */</span><span class="cp"></span>
<span class="cp">#define KSTACKEXC   0x3000		</span><span class="cm">/* descending */</span><span class="cp"></span>
<span class="cm">/* somewhere to place the kernel state structure */</span><span class="w"></span>
<span class="cp">#define KSTATEADDR	0x3000</span>
<span class="cm">/* </span>
<span class="cm">	RAM is assumed to start at 0x0, but we have to leave room for a little setup code, and</span>
<span class="cm">	depending on how much physical memory (KRAMSIZE) we are using we might have to adjust</span>
<span class="cm">	KRAMADDR to give a bit more. For example if KRAMSIZE is 4GB then KRAMADDR needs to be</span>
<span class="cm">	larger than 1MB, perferrably 2MB at least.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define KRAMADDR	0x200000</span>
<span class="cp">#define KRAMSIZE	(1024 * 1024 * 8)</span>
<span class="cm">/* </span>
<span class="cm">	kernel virtual memory size </span>
<span class="cm">	</span>
<span class="cm">	KMEMINDEX can be 1 through 7</span>
<span class="cm">	1 = 2GB</span>
<span class="cm">	2 = 1GB</span>
<span class="cm">	3 = 512MB</span>
<span class="cm">	4 = 256MB</span>
<span class="cm">	5 = 128MB</span>
<span class="cm">	6 = 64MB</span>
<span class="cm">	7 = 32MB</span>
<span class="cm">	</span>
<span class="cm">	This is the maximum amount of virtual memory per kernel space.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define KMEMINDEX   3</span>
<span class="cp">#define KMEMSIZE	(0x1000000 &lt;&lt; (8 - KMEMINDEX))</span>
<span class="cm">/* the size of a physical memory page */</span><span class="w"></span>
<span class="cp">#define KPHYPAGESIZE		4096</span>
<span class="cm">/* the block size of the chunk heap (kmalloc, kfree) */</span><span class="w"></span>
<span class="cp">#define KCHKHEAPBSIZE		16</span>
<span class="cm">/* minimum block size for chunk heap */</span><span class="w"></span>
<span class="cp">#define KCHKMINBLOCKSZ		(1024 * 1024)</span>
</pre></div>
<p>You may already have some defines. Just replace them and add any new ones. One important one is <i>KSTATEADDR</i> which defines where our kernel state resides.
</p><p>Now, let us add some entries into our <i>main</i> function of our play kernel.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">start</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="p">.........</span><span class="w"></span>
<span class="w">	</span><span class="n">KSTATE</span><span class="w">      </span><span class="o">*</span><span class="n">ks</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">       </span><span class="o">*</span><span class="n">bm</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KSTATE</span><span class="o">*</span><span class="p">)</span><span class="n">KSTATEADDR</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* create physical page heap */</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">husr</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* get a bit of memory to start with for small chunk */</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMAddBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">7</span><span class="p">),</span><span class="w"> </span><span class="n">KCHKHEAPBSIZE</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* state structure */</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">KSTATEADDR</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KSTATE</span><span class="p">),</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* stacks (can free KSTACKSTART later) */</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">KSTACKSTART</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">KSTACKEXC</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/*</span>
<span class="cm">		I like to identity map my page tables in kernel space because it makes them</span>
<span class="cm">		easy to walk. To do so I have to try to reserve physical memory in the lower</span>
<span class="cm">		half. To do this I have two heaps of physical 4K pages. </span>
<span class="cm">		</span>
<span class="cm">		The user heap is any memory past the KMEMSIZE, and anything below is the kernel</span>
<span class="cm">		heap. Pages are first allocated out of the user heap for any user space process,</span>
<span class="cm">		and if that fails then they are allocated from the kernel heap.</span>
<span class="cm">	*/</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">KMEMSIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* let hphy represent lower memory for kernel so it can be identity mapped */</span><span class="w"></span>
<span class="w">		</span><span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">KMEMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="n">k_heapBMAddBlockEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KMEMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">)),</span><span class="w"> </span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* let husr represent upper memory which does not need to be identity mapped */</span><span class="w"></span>
<span class="w">		</span><span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KMEMSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="n">k_heapBMAddBlockEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">husr</span><span class="p">,</span><span class="w"> </span><span class="n">KMEMSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KMEMSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">)),</span><span class="w"> </span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">		</span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* add block but place header in chunk heap to keep alignment */</span><span class="w"></span>
<span class="w">		</span><span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="n">k_heapBMAddBlockEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">)),</span><span class="w"> </span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span>
<span class="w">	</span><span class="cm">/* </span>
<span class="cm">		remove kernel image region </span>
<span class="cm">		</span>
<span class="cm">		This ensures it does not reside in either one. Because, KRAMADDR can change we can not</span>
<span class="cm">		be sure if it resides in which one or if it spans both somehow so to be safe this works</span>
<span class="cm">		quite well.</span>
<span class="cm">	*/</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_EOI</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_EOI</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">husr</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_EOI</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">..............</span><span class="w"></span>
</pre></div>
<p>I prefer to have the exception handlers setup before this code. I do not show that above, but you can simply move their initialization code to above this code block. The first objective is to create a small allocation heap, <i>hchk</i>, to handle small allocations then place the remaining RAM as 4KB pages into our second heap known as <i>hphy</i>. The <i>phy</i> part stands for physical, and the <i>chk</i> stands for chunk. The <i>hchk</i> heap uses 16-byte blocks and the <i>hphy</i> uses 4K blocks. 
</p><p>You should notice that I first:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="n">k_heapBMAddBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">7</span><span class="p">),</span><span class="w"> </span><span class="n">KCHKHEAPBSIZE</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>This adds a region of memory starting <i>after</i> the exception table (<i>4*7</i>) and extends to the beginning of what I define as remaining RAM with <i>KRAMADDR</i>. RAM actually starts at 0x0, so do not let it be misleading. It is just that I had no better name for it.
</p><p>Next:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="cm">/* state structure */</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">KSTATEADDR</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KSTATE</span><span class="p">),</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* stacks (can free KSTACKSTART later) */</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">KSTACKSTART</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">KSTACKEXC</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Here we set some regions as used in the bitmap. They contain the kernel's initial stack and the exception stack. My exceptions are non-re-entrant so I can get away with one stack for now. Also notice that our heap grows downward which is why I subtract 0x1000. It just makes the code loading the <i>sp</i> register simpler. Also, I consider each stack to be 4KB, but you could change this to a lower amount if you desired. Also, if you have read the <a href="BitmapHeapImplementationEnhanced" title="User:Pancakes/BitmapHeapImplementationEnhanced">Bitmap Heap Implementation Enhanced</a> page you will know that I am distinguishing each specific region with a different identifier in the bitmap by using <i>5</i>, <i>6</i>, and <i>7</i>.
I only remove them from <i>hchk</i> because I think it is fairly safe to assume <i>KRAMADDR</i> will not be lower than <i>KSTACKEXC</i>, but you could add some
type of check to be sure someone compiling your kernel does not happen to make <i>KRAMADDR</i> too low.
</p><p>Finally:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">KMEMSIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* let hphy represent lower memory for kernel so it can be identity mapped */</span><span class="w"></span>
<span class="w">		</span><span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">KMEMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="n">k_heapBMAddBlockEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KMEMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">)),</span><span class="w"> </span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* let husr represent upper memory which does not need to be identity mapped */</span><span class="w"></span>
<span class="w">		</span><span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KMEMSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="n">k_heapBMAddBlockEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">husr</span><span class="p">,</span><span class="w"> </span><span class="n">KMEMSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KMEMSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">)),</span><span class="w"> </span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">		</span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* add block but place header in chunk heap to keep alignment */</span><span class="w"></span>
<span class="w">		</span><span class="n">bm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">k_heapBMGetBMSize</span><span class="p">(</span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="n">k_heapBMAddBlockEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KRAMSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KRAMADDR</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">KHEAPBLOCKBM</span><span class="p">)),</span><span class="w"> </span><span class="n">bm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* remove kernel image region */</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_EOI</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_EOI</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">k_heapBMSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">husr</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_EOI</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_BOI</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>One very important difference is I allocate the block header and bitmap outside of that memory region using <i>k_heapBMAddBlockEx</i>. 
The <i>Ex</i> function adds more control over where the structures are allocated.
I also allocate three heaps. The <i>hphy</i> is physical memory that can be used by the kernel for identity mapping, and 'husr<i> </i>
is memory that can be used for either user space or kernel space. I
make <i>hphy</i> for allocating memory for the page tables because they need to be identity mapped in my kernel just to make 
it easier to walk the tables. The <i>husr</i> is for any pages not inside kernel space. The <i>husr</i> heap could be empty, and
this is okay since we will just use pages from <i>hphy</i>.
</p><p>Then I remove the region of memory where the kernel image is loaded. You could manually enter values here, but I used a symbol
created by the linker script to mark the beginning and end of the kernel. I also remove it from <i>hphy</i>, <i>hchk</i>, and <i>husr</i> because
KRAMADDR could change and it is actually possible it could cause the kernel to span any of them. So just to be safe I try to remove it
from both heap.
</p>
<h4><span class="mw-headline" id="kmalloc_and_kfree">kmalloc and kfree</span></h4>
<p>At this point you can now implement a <i>kmalloc</i> and <i>kfree</i> if you like:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">KSTATE</span><span class="w">			</span><span class="o">*</span><span class="n">ks</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KSTATE</span><span class="o">*</span><span class="p">)</span><span class="n">KSTATEADDR</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">k_heapBMFree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">kmalloc</span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">void</span><span class="w">			</span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">KSTATE</span><span class="w">			</span><span class="o">*</span><span class="n">ks</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="n">_size</span><span class="p">;</span><span class="w">	</span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KSTATE</span><span class="o">*</span><span class="p">)</span><span class="n">KSTATEADDR</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* attempt first allocation try (will fail on very first) */</span><span class="w"></span>
<span class="w">	</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* try adding more memory if failed */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">KCHKMINBLOCKSZ</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* we need to allocate blocks at least this size */</span><span class="w"></span>
<span class="w">			</span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KCHKMINBLOCKSZ</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* this is bigger than KCHKMINBLOCKSZ, so lets double it to be safe */</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* round up allocation to use all the blocks taken */</span><span class="w"></span>
<span class="w">			</span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">_size</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">_size</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* no more physical pages */</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* try allocation once more, should succeed */</span><span class="w"></span>
<span class="w">		</span><span class="n">k_heapBMAddBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">_size</span><span class="p">,</span><span class="w"> </span><span class="n">KCHKHEAPBSIZE</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hchk</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="A_Quick_Primer_On_Virtual_Memory">A Quick Primer On Virtual Memory</span></h3>
<p>If your brand new to virtual memory you might have a difficul time grasping what in the word is going on. So let me
try to explain and then give you some links.
</p><p>Basically, for starters the connection between CPU and memory looks kinda like this:
</p>
<pre>        CPU &lt;-----&gt; MEMORY
</pre>
<p>Now, that is simple right? The CPU accessess RAM directly. Well, lets add something else in there.
</p>
<pre>        CPU &lt;-----&gt; MMU/TLB &lt;-----&gt; MEMORY
</pre>
<p>Basically, the MMU has all addresses lines (at least) pass through it. This gives it the ability to modify
the address and change it. The TLB is the actual buffer that holds either the whole table in memory or parts
of it. When you set the address of a TLB (or likely more accurately a table) it uses this to translate the
addresses. You are basically working with virtual memory addresses when you enable the MMU and it translates
them into physical addresses. This process is transparent to the CPU. The CPU has no idea the address is being
changed which is why you have to invalidate caches and even invalidate the tables the MMU has cached when you
change the mapping through your tables.
</p><p>Virtual memory allows you to do things such as disk swapping where you pretend you have more memory in the
machine than you really do by swapping unused sections to disk, and replacing them with newly accessed
section. A section can be any size and depends on your MMU configuration and your architecture. It also
allows you to present each application with a different view of memory and can handles fragmentation of
your physical memory by arranging the physical pages that may be seperated into a contigious range using
virtual memory mapping. Also, on most architectures virtual memory allows you to create security by restricting
access to certain areas of memory with different modes such as read only or read/write only for privileged code.
</p><p>Your best place for further reading is using Google to search for virtual memory and read up on it. I am afraid
I can only explain so much here, but I hope I have basically given you the basics to get you on your feet a 
little instead of feeling completely lost.
</p>
<pre>TODO: add links to virtual memory in our wiki</pre>
<h3><span class="mw-headline" id="Tinkering_With_Virtual_Memory_On_the_ARM_complying_with_VMSA_v6">Tinkering With Virtual Memory On the ARM complying with VMSA v6</span></h3>
<p>I comform to the VMSA v6 specification. This deals with 16MB super-sections, 1MB sections, 64K entries, and 
4K entries. If your coming from an X86/X64 background your going to find it to be almost identical, except
instead of having 4MB entries on your first level table you have 1MB. The most flexible configuration is 
having your first level table map <i>whole</i> 1MB sections or use a coarse table to map 4KB pages in that 1MB
region. 64K entries and 16MB entries are essentially similar except one is used on the first level table, and
the other on the second level table.
</p><p>Now that we have some basic memory management we can proceed to the fun stuff. Lets start really small until we get a grasp of what we are working with.
</p><p>We need a few utility functions to make life easier:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">arm4_tlbset0</span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">base</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;mcr p15, 0,&#160;%[tlb], c2, c0, 0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">tlb</span><span class="p">]</span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">base</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">arm4_tlbset1</span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">base</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;mcr p15, 0,&#160;%[tlb], c2, c0, 1&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">tlb</span><span class="p">]</span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">base</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">arm4_tlbsetmode</span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;mcr p15, 0,&#160;%[tlb], c2, c0, 2&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">tlb</span><span class="p">]</span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">arm4_tlbsetdom</span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;mcr p15, 0,&#160;%[val], c3, c0, 0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">val</span><span class="p">]</span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">uint32</span><span class="w"> </span><span class="nf">arm4_tlbgetctrl</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="n">ctrl</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;mrc p15, 0, r0, c1, c0, 0 </span><span class="se">\n</span><span class="s">\</span>
<span class="s">	     mov&#160;%[ctrl], r0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">ctrl</span><span class="p">]</span><span class="s">&quot;=r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">ctrl</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">ctrl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">arm4_tlbsetctrl</span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">ctrl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;mcr p15, 0,&#160;%[ctrl], c1, c0, 0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">ctrl</span><span class="p">]</span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">ctrl</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Defines">Defines</span></h4>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="cm">/* first level table */</span><span class="w"></span>
<span class="w">	</span><span class="cp">#define TLB_FAULT			0x000		</span><span class="cm">/* entry is unmapped (bits 32:2 can be used for anything) but access generates an ABORT */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_SECTION			0x002		</span><span class="cm">/* entry maps 1MB chunk */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_COARSE			0x001		</span><span class="cm">/* sub-table */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_DOM_NOACCESS	0x00		</span><span class="cm">/* generates fault on access */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_DOM_CLIENT		0x01		</span><span class="cm">/* checked against permission bits in TLB entry */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_DOM_RESERVED	0x02		</span><span class="cm">/* reserved */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_DOM_MANAGER		0x03		</span><span class="cm">/* no permissions */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_STDFLAGS		0xc00		</span><span class="cm">/* normal flags */</span><span class="cp"></span>
<span class="w">	</span><span class="cm">/* second level coarse table */</span><span class="w"></span>
<span class="w">	</span><span class="cp">#define TLB_C_LARGEPAGE		0x1			</span><span class="cm">/* 64KB page */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_C_SMALLPAGE		0x2			</span><span class="cm">/* 4KB page */</span><span class="cp"></span>
<span class="w">	</span><span class="cm">/* AP (access permission) flags for coarse table [see page 731 in ARM_ARM] */</span><span class="w"></span>
<span class="w">	</span><span class="cp">#define TLB_C_AP_NOACCESS	(0x00&lt;&lt;4)	</span><span class="cm">/* no access */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_C_AP_PRIVACCESS	(0x01&lt;&lt;4)	</span><span class="cm">/* only system access  RWXX */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_C_AP_UREADONLY	(0x02&lt;&lt;4)	</span><span class="cm">/* user read only  RWRX */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_C_AP_FULLACCESS	(0x03&lt;&lt;4)	</span><span class="cm">/* RWRW */</span><span class="cp">	</span>
<span class="w">	</span><span class="cm">/* AP (access permission) flags [see page 709 in ARM_ARM; more listed] */</span><span class="w"></span>
<span class="w">	</span><span class="cp">#define TLB_AP_NOACCESS		(0x00&lt;&lt;10)	</span><span class="cm">/* no access */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_AP_PRIVACCESS	(0x01&lt;&lt;10)	</span><span class="cm">/* only system access  RWXX */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_AP_UREADONLY	(0x02&lt;&lt;10)	</span><span class="cm">/* user read only  RWRX */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_AP_FULLACCESS	(0x03&lt;&lt;10)	</span><span class="cm">/* RWRW */</span><span class="cp"></span>
</pre></div>
<h4><span class="mw-headline" id="Example_Enabling_Paging">Example Enabling Paging</span></h4>
<p>You might notice the word TLB and this stands for transition look-aside buffer. Which, is what we will be
working with to implement paging. If you are coming from X86/X64 architecture you might have already read
or tinkered with paging and it is basically the same on the ARM. One major difference is ARM can work with
two paging tables at the same time. This is intended for one to be used for the kernel and another one to
be process specific. I am going to use them backwards (<i>in this example</i>) because the docs state for 
TTBR0 to be process specific
and TTBR1 to be operating system specific, but TTBR1 gets mapped into the upper 2GB of the 32-bit address
space and TTBR0 in the lower and since our kernel lives low in this code example I am going to use TTBR0 for it,
and it keeps the demonstration simple.
</p><p><i>You might want to consider higher half kernel. Meaning, your kernel is linked for</i>
in upper memory not lower memory because it provides a number of advantages. My example
below is reversed to keep things simple since we are already loaded low in memory.<i></i>
</p><p>You can also further divide the space as follows (not evenly):
</p>
<table class="wikitable">
<tbody><tr>
<th>TTBR0
</th>
<th>TTBR1
</th></tr>
<tr>
<td>2GB
</td>
<td>2GB
</td></tr>
<tr>
<td>1GB
</td>
<td>3GB
</td></tr>
<tr>
<td>512MB
</td>
<td>3584MB
</td></tr>
<tr>
<td>...
</td>
<td>...
</td></tr></tbody></table>
<p>It can actually reach 32MB for the TTBR0 and 4064MB for TTBR1. We are just going to divide it with 2GB for our initial tinkering.
</p>
<h5><span class="mw-headline" id="Code">Code</span></h5>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="cm">/*</span>
<span class="cm">		This says:</span>
<span class="cm">		1. Use the hphy heap.</span>
<span class="cm">		2. Allocate 16KB (1024 * 16)</span>
<span class="cm">		3. Make sure the 16 least significant bits are zero.</span>
<span class="cm">	*/</span><span class="w"></span>
<span class="w">	</span><span class="n">ktlb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMAllocBound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">utlb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMAllocBound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* </span>
<span class="cm">		enable the usage of utlb when bit 31 of virtual address is not zero </span>
<span class="cm">	*/</span><span class="w"></span>
<span class="w">	</span><span class="n">arm4_tlbsetmode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* </span>
<span class="cm">           We are going to identity map 2GB of space.</span>

<span class="cm">           We only need to set 2048 entries, because the remaining entries</span>
<span class="cm">           are ignored in the ktlb. But AFAIK the utlb still needs an entire 16KB which</span>
<span class="cm">           appears to me to be proved by the code below...</span>
<span class="cm">        */</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2048</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">ktlb</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_ACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* </span>
<span class="cm">		Do a little trick to map the same memory twice but in both</span>
<span class="cm">		page tables (TTBR0 and TTBR1)</span>
<span class="cm">	*/</span><span class="w"></span>
<span class="w">	</span><span class="n">utlb</span><span class="p">[</span><span class="mh">0x800</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_ACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">utlb</span><span class="p">[</span><span class="mh">0x801</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_ACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ktlb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_ACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ktlb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_ACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="s">&quot;OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* load location of TLB */</span><span class="w"></span>
<span class="w">	</span><span class="n">arm4_tlbset1</span><span class="p">((</span><span class="n">uintptr</span><span class="p">)</span><span class="n">utlb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">arm4_tlbset0</span><span class="p">((</span><span class="n">uintptr</span><span class="p">)</span><span class="n">ktlb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* set that all domains are checked against the TLB entry access permissions */</span><span class="w"></span>
<span class="w">	</span><span class="n">arm4_tlbsetdom</span><span class="p">(</span><span class="mh">0x55555555</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* enable TLB (0x1) and disable subpages (0x800000) */</span><span class="w"></span>
<span class="w">	</span><span class="n">arm4_tlbsetctrl</span><span class="p">(</span><span class="n">arm4_tlbgetctrl</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x800001</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="s">&quot;OK2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* check trick - as you can see the same 1MB chunk is mapped twice */</span><span class="w"></span>
<span class="w">	</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="mh">0x80000000</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="mh">0x80100000</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ksprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;utlb:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="mh">0x100000</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="mh">0x200000</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x87654321</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ksprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ktlb:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="s">&quot;DONE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="p">(;;);</span><span class="w"></span>
</pre></div>
<p>We have mapped the one region twice at 1MB and 2MB, and mapped the another region twice at 2048MB and 2049MB. We verify it by writing to one region and reading it from another region. <i>Now, this has been tested in QEMU only. On read hardware we could have missed a thing or two. But, this is the basics and if you have done it correctly it should work! Congratulations, you have enabled paging and not crashed your emulator (or maybe real hardware)!</i>
</p><p>The CPU actually supports second level tables for a finer grain of mapping, and even some other configurations that provide mapping of 16MB regions. I just used 1MB sections because it is easier to understand at first.
</p>
<h4><span id="arm4_tlbsetmode.281.29"></span><span class="mw-headline" id="arm4_tlbsetmode(1)">arm4_tlbsetmode(1)</span></h4>
<p><i>This value can be between 0 and 7. I am using a 1 in the above code.</i>
</p><p>Basically, 0 disables the usage of the TTBR1 which means we only use a single TLB. 
In this case your would have to not only swap the TLB on each process change, but 
also update changes to any kernel space on all TLBs for every process.
</p><p>Any value greater than 0 enables the usage of TTBR1. But, it also represents
the number of highest bits in the address that are used to select between TTBR1
and TTBR0. For example:
</p>
<pre>VALUE		BITS IF ZERO USE TTBR0      TTBR0 ADDRESSABLE SPACE     TTBR0 SIZE IN ENTRIES (1MB SECTIONS)
0			-----						4GB (TTBR0)					4096
1			31							2GB (TTBR0)					2048
2			31:30						1GB (TTBR0)					1024
3			31:29						512MB (TTBR0)				512
4			31:28						256MB (TTBR0)				256
5			31:27						128MB (TTBR0)				128
6			31:26						64MB (TTBR0)				64
7			31:25						32MB (TTBR0)				32
</pre>
<p>If you set the appropriate mode and all the bits in the range are zero then it will
use TTBR0, and if any are set it will use TTBR1. If you set the value to 0 then it
will <i>ONLY</i> use TTBR0.
</p><p>Each value also effects how much of the TTBR0 table we have to initialize. So if we use
the value 2 like below. Then we only have to have 1024 entries (of 1MB sections).
However, TTBR1 will always need the full number of entries.
</p><p>From my research it seems that even though the ARM manual recommends TTBR0 be used for
user space and TTBR1 be used for kernel space you can swap them if desired. The major down
side is that your will be allocating a full 16KB for each process at a minimum if using
1MB sections with (or with out) second level tables (second level table further divides the 1MB).
</p><p>On the upside you can give more address space to user space. Of course you could use some of
the TTBR0 for user space, but in that case you would either have to share that space with all
processes (or groups of processes) or swap out both TTBR0 and TTBR1 which would seem to be a 
disadvantage because you would lose the ability to keep a portion of memory (kernel space) validated
in the TLB for a performance increase.
</p>
<h4><span id="arm4_tlbsetdom.280x55555555.29.3B"></span><span class="mw-headline" id="arm4_tlbsetdom(0x55555555);">arm4_tlbsetdom(0x55555555);</span></h4>
<p>Each entry can be assigned a domain value. There are only 16 possible domains. Each domain can be assigned
a rough permission, and this can be changed on the fly.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="cp">#define TLB_DOM_NOACCESS	0x00		</span><span class="cm">/* generates fault on access */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_DOM_CLIENT		0x01		</span><span class="cm">/* checked against permission bits in TLB entry */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_DOM_RESERVED	0x02		</span><span class="cm">/* reserved */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define TLB_DOM_MANAGER		0x03		</span><span class="cm">/* no permissions */</span><span class="cp"></span>
</pre></div>
<p>Each domain is represented by 2 bits. With domain zero starting with the least significant bits.
<i>See page 742 in the ARM architecture manual</i>. 
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="cp">#define TLB_DOM(x)			(x&lt;&lt;5)		</span><span class="cm">/* domain value (16 unique values) */</span><span class="cp"></span>
<span class="w">	</span><span class="cp">#define DOM_TLB(x,y)		(x&lt;&lt;(y*2))	</span><span class="cm">/* helper macro for setting appropriate bits in domain register */</span><span class="cp"></span>
</pre></div>
<p>The <i>TLB_DOM</i> macro allows you to set the domain value in a TLB entry, while <i>DOM_TLB</i> lets you set the
appropriate bits in the domain register. For example:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="n">arm4_tlbsetdom</span><span class="p">(</span><span class="n">DOM_TLB</span><span class="p">(</span><span class="n">TLB_DOM_CLIENT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>The above code would set <i>domain 0</i> to use the permission bits specified in the TLB entry.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="n">arm4_tlbsetdom</span><span class="p">(</span><span class="n">DOM_TLB</span><span class="p">(</span><span class="n">TLB_DOM_CLIENT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">DOM_TLB</span><span class="p">(</span><span class="n">TLB_DOM_MANAGER</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>The above code would set <i>domain 0</i> to use the permission bits specified in the TLB entry, and
<i>domain 1</i> to overide the permission bits in the TLB entry and allow any CPU mode to access the
memory specified by the entries in the TLB that are marked as <i>domain 1</i>.
</p>
<h4><span class="mw-headline" id="Access_Bits_For_TLB_Entry">Access Bits For TLB Entry</span></h4>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="o">*</span><span class="n">tlb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.....;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">tlb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_AP_NOACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">tlb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_AP_PRIVACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">tlb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_AP_UREADONLY</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">tlb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_AP_FULLACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Let me give a table of how this would effect memory access:
</p>
<table class="wikitable">
<tbody><tr>
<th>Virtual Address Range
</th>
<th>Physical Address Range
</th>
<th>Access Description
</th></tr>
<tr>
<td>00000000 - 000FFFFF
</td>
<td>00100000 - 001FFFFF
</td>
<td>Any access by privileged CPU mode or user mode will generate a fault.
</td></tr>
<tr>
<td>00100000 - 001FFFFF
</td>
<td>00100000 - 001FFFFF
</td>
<td>Any access by user mode will generate a fault.
</td></tr>
<tr>
<td>00200000 - 002FFFFF
</td>
<td>00100000 - 001FFFFF
</td>
<td>The user mode can read but not write.
</td></tr>
<tr>
<td>00300000 - 003FFFFF
</td>
<td>00100000 - 001FFFFF
</td>
<td>Any mode can read and write.
</td></tr></tbody></table>
<p>Now, I mapped each 1MB of virtual address section to the same physical address.
</p>
<h4><span id="Coarse_Table_.28Sub-Page.29"></span><span class="mw-headline" id="Coarse_Table_(Sub-Page)">Coarse Table (Sub-Page)</span></h4>
<p>In this example I create a coarse table with two 4KB entries, and I test that they
are mapped at the end. I have a few debug printing statements littered throughout
and decided to leave them in as an example.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="n">ktlb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAllocBound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">utlb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAllocBound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">ksprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ktlb:%x utlb:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ktlb</span><span class="p">,</span><span class="w"> </span><span class="n">utlb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">arm4_tlbsetmode</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">	</span>
<span class="w">	</span><span class="cm">/* </span>
<span class="cm">		map 1GB of space - each entry is 1MB (we are setting N to 2 above) </span>
<span class="cm">	*/</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 0xc02</span>
<span class="w">		</span><span class="n">ktlb</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_AP_PRIVACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* </span>
<span class="cm">		do a little trick to map the same memory twice but in both</span>
<span class="cm">		page tables (TTBR0 and TTBR1)</span>
<span class="cm">	*/</span><span class="w"></span>
<span class="w">	</span><span class="n">utlb</span><span class="p">[</span><span class="mh">0x800</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_AP_PRIVACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">utlb</span><span class="p">[</span><span class="mh">0x801</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_AP_PRIVACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ktlb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_AP_PRIVACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ktlb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_AP_PRIVACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* the coarse table must be aligned on a 1KB boundary */</span><span class="w"></span>
<span class="w">	</span><span class="n">tlbsub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAllocBound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">ksprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tlbsub:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tlbsub</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* link the coarse table to our main table */</span><span class="w"></span>
<span class="w">	</span><span class="n">ktlb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="p">)</span><span class="n">tlbsub</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_COARSE</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* clear coarse table (sub-table) */</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">tlbsub</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">tlbsub</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TLB_C_SMALLPAGE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">((</span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_C_AP_PRIVACCESS</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">tlbsub</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TLB_C_SMALLPAGE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">((</span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_C_AP_PRIVACCESS</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="s">&quot;OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* load location of TLB */</span><span class="w"></span>
<span class="w">	</span><span class="n">arm4_tlbset1</span><span class="p">((</span><span class="n">uintptr</span><span class="p">)</span><span class="n">utlb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">arm4_tlbset0</span><span class="p">((</span><span class="n">uintptr</span><span class="p">)</span><span class="n">ktlb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* set that all domains are checked against the TLB entry access permissions */</span><span class="w"></span>
<span class="w">	</span><span class="n">arm4_tlbsetdom</span><span class="p">(</span><span class="mh">0x55555555</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* enable TLB 0x1 and disable subpages 0x800000 */</span><span class="w"></span>
<span class="w">	</span><span class="n">arm4_tlbsetctrl</span><span class="p">(</span><span class="n">arm4_tlbgetctrl</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x800001</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="s">&quot;OK2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* check sub-pages */</span><span class="w"></span>
<span class="w">	</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="mh">0x300000</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="mh">0x301000</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x22334411</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ksprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;small:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* check trick - as you can see the same 1MB chunk is mapped twice */</span><span class="w"></span>
<span class="w">	</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="mh">0x80000000</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="mh">0x80100000</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ksprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;utlb:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="mh">0x100000</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="mh">0x200000</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x87654321</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ksprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ktlb:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="s">&quot;DONE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="p">(;;);</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Using_64K_Entries_In_Coarse_Table">Using 64K Entries In Coarse Table</span></h4>
<p>I have done some experimenting with 64K page entries in the coarse table. Essentially, you have to create
16-64K entries to map 64K. 
</p><p>Take the normal way to map 64K of memory in a coarse table with 4K entries:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="o">*</span><span class="n">ctbl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="n">offset</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">ctbl</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4096</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">FLAGS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SMALLPAGE4K</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>Let us see the mapping of 64K using 64K entries.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="o">*</span><span class="n">ctbl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="n">offset</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">ctbl</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">FLAGS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">LARGEPAGE64K</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>Now, QEMU will not enforce the entry to be replicated 16 times.
</p><p><i>It appears that real hardware may enforce the 16 count replication in order to reduce memory access and</i>
space used by the TLB cache/memory. QEMU, does not enforce this and will happily work just fine with blank
entries in the 64K mapping or even 4K mappings mixed in. Also, it states in the manual that the entry must
be replicated 16 times. So the safe way is to always follow this rule and it should work with any MMU no
matter if it is software emulated or hardware.<i></i>
</p>
<h4><span class="mw-headline" id="Globally_Tagged_Entries">Globally Tagged Entries</span></h4>
<p><i>...shared</i>
</p>
<h4><span class="mw-headline" id="Protection_And_Cache_Behavior">Protection And Cache Behavior</span></h4>
<p><i>...</i>
</p>
<h3><span class="mw-headline" id="Working_With_Tables_Per_Process">Working With Tables Per Process</span></h3>
<p>Let us now see about working with page tables per process. We need some utility functions. Then we will take a look at actually initializing the page tables per process, and finally the code in our
scheduler that will switch out tables for each process.
</p>
<h4><span class="mw-headline" id="Utility_Functions">Utility Functions</span></h4>
<p>To work with pages tables I have come up with a few utility functions to make life easier. These just make
working with a TLB table much easier. These functions only work with 4K coarse table mapping. One of the
functions can understand 1MB sections, but thats it. They are just basic utility functions to allow you to
have an idea of how you could work with page tables. 
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define KVMM_SUCCESS		1</span>
<span class="cp">#define KVMM_FAILURE		0</span>
<span class="cp">#define KVMM_UNMAP			0x80000000</span>
<span class="cp">#define KVMM_USER			0x40000000</span>
<span class="cp">#define KVMM_KERNEL			0x20000000</span>

<span class="cm">/*</span>
<span class="cm">	kernel kernel page alloc</span>
<span class="cm">	</span>
<span class="cm">	- only alloc from hphy</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">kkpalloc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">KSTATE</span><span class="w">			</span><span class="o">*</span><span class="n">ks</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w">				</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KSTATE</span><span class="o">*</span><span class="p">)</span><span class="n">KSTATEADDR</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">	kernel user page alloc</span>
<span class="cm">	</span>
<span class="cm">	- first try to alloc from husr then hphy</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">kupalloc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">KSTATE</span><span class="w">			</span><span class="o">*</span><span class="n">ks</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w">				</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">void</span><span class="w">			</span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">char</span><span class="w">			</span><span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KSTATE</span><span class="o">*</span><span class="p">)</span><span class="n">KSTATEADDR</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">husr</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">);</span><span class="w"> </span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_heapBMAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="n">KPHYPAGESIZE</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">ksprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;p:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Initialize the paging table structure. */</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">kvmm_init</span><span class="p">(</span><span class="n">KVMMTABLE</span><span class="w"> </span><span class="o">*</span><span class="n">table</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">		</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">KSTATE</span><span class="w">		</span><span class="o">*</span><span class="n">ks</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">char</span><span class="w">		</span><span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KSTATE</span><span class="o">*</span><span class="p">)</span><span class="n">KSTATEADDR</span><span class="p">;</span><span class="w">	</span>
<span class="w">	</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="n">k_heapBMAllocBound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">kserdbg_putc</span><span class="p">(</span><span class="sc">&#39;&amp;&#39;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ksprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;table.table:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">table</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Map contigious range starting at a virtual address and physical of count */</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">kvmm_map</span><span class="p">(</span><span class="n">KVMMTABLE</span><span class="w"> </span><span class="n">table</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">virtual</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">physical</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uintptr</span><span class="w">		</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">		</span><span class="o">*</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">KSTATE</span><span class="w">		</span><span class="o">*</span><span class="n">ks</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">		</span><span class="n">unmap</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KSTATE</span><span class="o">*</span><span class="p">)</span><span class="n">KSTATEADDR</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">unmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">KVMM_UNMAP</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* remove special flags */</span><span class="w"></span>
<span class="w">		</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">unmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* this entire loop could be optimized, but it is simple and straight forward */</span><span class="w"></span>
<span class="w">	</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">virtual</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* create table (alloc on 1KB boundary) */</span><span class="w"></span>
<span class="w">			</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="p">)</span><span class="n">k_heapBMAllocBound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* get sub-table */</span><span class="w"></span>
<span class="w">			</span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">];</span><span class="w"></span>
<span class="w">			</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">TLB_COARSE</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* clear table (all entries throw a fault) */</span><span class="w"></span>
<span class="w">			</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">st</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* get sub-table */</span><span class="w"></span>
<span class="w">			</span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mh">0x3ff</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* map 4K page */</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">unmap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="cm">/* map page */</span><span class="w"></span>
<span class="w">				</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">			</span>
<span class="w">					</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_C_SMALLPAGE</span><span class="p">;</span><span class="w"></span>
<span class="w">				</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">					</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_C_SMALLPAGE</span><span class="p">;</span><span class="w"></span>
<span class="w">				</span><span class="p">}</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="cm">/* unmap page */</span><span class="w"></span>
<span class="w">				</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span>
<span class="w">		</span><span class="o">++</span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="o">++</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Find a region of size within specified boundries. */</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">kvmm_getunusedregion</span><span class="p">(</span><span class="n">KVMMTABLE</span><span class="w"> </span><span class="n">table</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="o">*</span><span class="n">virtual</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">lowerLimit</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">upperLimit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uintptr</span><span class="w">		</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">		</span><span class="o">*</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">KSTATE</span><span class="w">		</span><span class="o">*</span><span class="n">ks</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KSTATE</span><span class="o">*</span><span class="p">)</span><span class="n">KSTATEADDR</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* this entire loop could be optimized, but it is simple and straight forward */</span><span class="w"></span>
<span class="w">	</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">	</span><span class="cm">/* start */</span><span class="w"></span>
<span class="w">	</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="cm">/* count */</span><span class="w"></span>
<span class="w">	</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lowerLimit</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">c</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* get sub-table */</span><span class="w"></span>
<span class="w">			</span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mh">0x3ff</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">c</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="w">				</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span>
<span class="w">		</span><span class="cm">/* if we found a region of size */</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="o">*</span><span class="n">virtual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span>
<span class="w">		</span><span class="o">++</span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w">	</span>
<span class="w">	</span>
<span class="w">	</span><span class="o">*</span><span class="n">virtual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">	This does not support 64K or 16MB mappings, only 1MB and 4K.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">kvmm_getphy</span><span class="p">(</span><span class="n">KVMMTABLE</span><span class="w"> </span><span class="n">table</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">virtual</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="o">*</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="o">*</span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">char</span><span class="w">			</span><span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* not mapped */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">virtual</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="o">*</span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ksprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;table.table[virtual &gt;&gt; 20]:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">virtual</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">20</span><span class="p">]);</span><span class="w"></span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* get 1MB section address */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">virtual</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="o">*</span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">virtual</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mh">0xFFFFF</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* get level 2 table */</span><span class="w"></span>
<span class="w">	</span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)(</span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">virtual</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mh">0x3ff</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">virtual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">virtual</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">ksprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;t[%x]:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">virtual</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">virtual</span><span class="p">]);</span><span class="w"></span>
<span class="w">	</span><span class="n">kserdbg_puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* not mapped on level 2 */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">virtual</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="o">*</span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* get 4K mapping */</span><span class="w"></span>
<span class="w">	</span><span class="o">*</span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">virtual</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mh">0xfff</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Map fresh pages from physical page accounting system.*/</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">kvmm_allocregion</span><span class="p">(</span><span class="n">KVMMTABLE</span><span class="w"> </span><span class="n">table</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">virtual</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uintptr</span><span class="w">		</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">		</span><span class="o">*</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">KSTATE</span><span class="w">		</span><span class="o">*</span><span class="n">ks</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">		</span><span class="n">kspace</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">		</span><span class="n">y</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/*</span>
<span class="cm">		If we are mapping in user space then lets try to use pages from the</span>
<span class="cm">		kusr map, and if for kernel then pull from kphy. </span>
<span class="cm">	*/</span><span class="w"></span>
<span class="w">	</span><span class="n">kspace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">KVMM_USER</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">kspace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">KVMM_KERNEL</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* force specification of either kernel space or user space mapping */</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* remove flags */</span><span class="w"></span>
<span class="w">	</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">KVMM_KERNEL</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">KVMM_USER</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KSTATE</span><span class="o">*</span><span class="p">)</span><span class="n">KSTATEADDR</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* this entire loop could be optimized, but it is simple and straight forward */</span><span class="w"></span>
<span class="w">	</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">virtual</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* create table (alloc on 1KB boundary) */</span><span class="w"></span>
<span class="w">			</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="p">)</span><span class="n">k_heapBMAllocBound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="cm">/* memory failure */</span><span class="w"></span>
<span class="w">				</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">			</span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">];</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">TLB_COARSE</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="cm">/* clear table (all entries throw a fault) */</span><span class="w"></span>
<span class="w">			</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">st</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* get sub-table */</span><span class="w"></span>
<span class="w">			</span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mh">0x3ff</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* return failure because we are mapping over already mapped memory */</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span>
<span class="w">		</span><span class="cm">/* map a page */</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">kspace</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">kserdbg_putc</span><span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="n">kkpalloc</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_C_SMALLPAGE</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">kserdbg_putc</span><span class="p">(</span><span class="sc">&#39;2&#39;</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="n">kupalloc</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_C_SMALLPAGE</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* increment to next virtual address */</span><span class="w"></span>
<span class="w">		</span><span class="o">++</span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w">	</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">	</span>
<span class="p">}</span><span class="w"></span>
<span class="cm">/* Unmap pages and hand them back to the physical page accounting system. */</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">kvmm_freeregion</span><span class="p">(</span><span class="n">KVMMTABLE</span><span class="w"> </span><span class="n">table</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">virtual</span><span class="p">,</span><span class="w"> </span><span class="n">uintptr</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uintptr</span><span class="w">		</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">		</span><span class="o">*</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">KSTATE</span><span class="w">		</span><span class="o">*</span><span class="n">ks</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">KSTATE</span><span class="o">*</span><span class="p">)</span><span class="n">KSTATEADDR</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* this entire loop could be optimized, but it is simple and straight forward */</span><span class="w"></span>
<span class="w">	</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">virtual</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* get sub-table */</span><span class="w"></span>
<span class="w">			</span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="o">*</span><span class="p">)(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mh">0x3ff</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span>
<span class="w">			</span><span class="cm">/* unmap a page */</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="cm">/* determine if it is a kernel or user page */</span><span class="w"></span>
<span class="w">				</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span><span class="w"></span>
<span class="w">				</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">KMEMSIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">					</span><span class="cm">/* user */</span><span class="w"></span>
<span class="w">					</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">k_heapBMFree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">husr</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">						</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">					</span><span class="p">}</span><span class="w"></span>
<span class="w">				</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">					</span><span class="cm">/* kernel */</span><span class="w"></span>
<span class="w">					</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">k_heapBMFree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hphy</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">						</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">					</span><span class="p">}</span><span class="w"></span>
<span class="w">				</span><span class="p">}</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w">	</span>
<span class="w">	</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Initializing_Page_Tables_Per_Process">Initializing Page Tables Per Process</span></h4>
<p>Our code, if you have been following from <a href="../ARM_Integrator-CP_IRQTimerAndPICAndTaskSwitch" title="ARM Integrator-CP IRQTimerAndPICAndTaskSwitch">IRQ, Timer, PIC, And Tasks</a>, included 
a simple scheduler that swapped
state for each thread. What we want to do now is include a virtual address space for each thread. And, 
eventually upgrade the system to support the design of processes and threads. For
now just consider each thread a process, and later we will implement actual threads and processes. This
just helps keep the code simple at first which makes reading and understanding easier.
</p><p>Our first step is to expand our thread structure with a field for the level one page table.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_KVMMTABLE</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="o">*</span><span class="n">table</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">KVMMTABLE</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_KTHREAD</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">			</span><span class="n">valid</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">uint32</span><span class="w">			</span><span class="n">r0</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="n">r3</span><span class="p">,</span><span class="w"> </span><span class="n">r4</span><span class="p">,</span><span class="w"> </span><span class="n">r5</span><span class="p">,</span><span class="w"> </span><span class="n">r6</span><span class="p">,</span><span class="w"> </span><span class="n">r7</span><span class="p">,</span><span class="w"> </span><span class="n">r8</span><span class="p">,</span><span class="w"> </span><span class="n">r9</span><span class="p">,</span><span class="w"> </span><span class="n">r10</span><span class="p">,</span><span class="w"> </span><span class="n">r11</span><span class="p">,</span><span class="w"> </span><span class="n">r12</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="n">lr</span><span class="p">,</span><span class="w"> </span><span class="n">cpsr</span><span class="p">,</span><span class="w"> </span><span class="n">pc</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">KVMMTABLE</span><span class="w">		</span><span class="n">vmm</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">KTHREAD</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Next, lets add a field for the kernel level one page table.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_KSTATE</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">KTHREAD</span><span class="w">			</span><span class="n">threads</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="n">uint8</span><span class="w">			</span><span class="n">threadndx</span><span class="p">;</span><span class="w">	</span>
<span class="w">	</span><span class="n">uint8</span><span class="w">			</span><span class="n">iswitch</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">KHEAPBM</span><span class="w">			</span><span class="n">hphy</span><span class="p">;</span><span class="w">		</span><span class="cm">/* kernel physical page heap */</span><span class="w"></span>
<span class="w">	</span><span class="n">KHEAPBM</span><span class="w">			</span><span class="n">hchk</span><span class="p">;</span><span class="w">		</span><span class="cm">/* data chunk heap */</span><span class="w"></span>
<span class="w">	</span><span class="n">KHEAPBM</span><span class="w">			</span><span class="n">husr</span><span class="p">;</span><span class="w">		</span><span class="cm">/* user physical page heap */</span><span class="w"></span>
<span class="w">	</span><span class="n">KVMMTABLE</span><span class="w">		</span><span class="n">vmmk</span><span class="p">;</span><span class="w">		</span><span class="cm">/* kernel virtual memory map */</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">KSTATE</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Now, we need to initialize the kernel page table.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="cm">/* initialize the kernel memory map */</span><span class="w"></span>
<span class="w">	</span><span class="n">kvmm_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">vmmk</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/* identity map kernel memory (may use all of RAM or not may) */</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4096</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="c1">// TLB_AP_FULLACCESS</span>
<span class="w">		</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">vmmk</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_AP_PRIVACCESS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_SECTION</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>This just identity maps all of RAM. That keeps everything simple at the moment. We can go back later and actually
make the kernel page in what it needs. But, that would complicate our existing code and I want to either
do that later or leave it as an excercise for you. Also, worth nothing, our utility functions will be unable to
work with the kernel table because it uses <i>1MB sections</i> and they do not handle those properly.
</p><p>Also, we used <i>KMEMINDEX</i> to calculate <i>KMEMSIZE</i> which defines the maximum size of the kernel space. So, make sure
that we use it to divide the address space.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">arm4_tlbsetmode</span><span class="p">(</span><span class="n">KMEMINDEX</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Here we initialize the address space of a thread, and we copy some executable code to it.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">	</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x80000000</span><span class="p">;</span><span class="w">         </span><span class="cm">/* set program counter */</span><span class="w"></span>
<span class="w">	</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cpsr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x60000000</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ARM4_MODE_USER</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x90001000</span><span class="p">;</span><span class="w">         </span><span class="cm">/* set stack pointer */</span><span class="w"></span>
<span class="w">	</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">r0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xa0000000</span><span class="p">;</span><span class="w">		</span><span class="cm">/* argument to function we copied */</span><span class="w"></span>
<span class="w">	</span>
<span class="w">        </span><span class="cm">/* initialize the level one table */</span><span class="w"></span>
<span class="w">	</span><span class="n">kvmm_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vmm</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* map in the serial hardware MMIO */</span><span class="w"></span>
<span class="w">	</span><span class="n">kvmm_map</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vmm</span><span class="p">,</span><span class="w"> </span><span class="mh">0xa0000000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x16000000</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">TLB_C_AP_FULLACCESS</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* alloc and map a 4K page for the code */</span><span class="w"></span>
<span class="w">	</span><span class="n">kvmm_allocregion</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vmm</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80000000</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">KVMM_USER</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_C_AP_FULLACCESS</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* alloc and map a 4K page for the stack */</span><span class="w"></span>
<span class="w">	</span><span class="n">kvmm_allocregion</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vmm</span><span class="p">,</span><span class="w"> </span><span class="mh">0x90000000</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">KVMM_USER</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TLB_C_AP_FULLACCESS</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* get the physical page (going to be mapped in kernel space) */</span><span class="w"></span>
<span class="w">	</span><span class="n">kvmm_getphy</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vmm</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80000000</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">page</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* copy some code there */</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="p">((</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="p">)[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">uint8</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">thread1</span><span class="p">)[</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>ARM passes the first few arguments by register so this enables us to pass an argument in <i>R0</i>. We also
map in the serial hardware MMIO so the thread can send some letters to the output to demonstrate that it
is running. The argument is the address of the serial device's memory mapped output register for sending
a character. <i>We are supposed to check if it is ready to recieve another character, but QEMU does not seem</i>
to be effected so this should work fine on it. It is mainly just to demonstrate it working and not for
production usage.<i></i>
</p><p>One <i>VERY</i> important part to understand is that we get the physical page (which we assume is mapped into kernel space), since I am assuming your running with less than 32MB of RAM. This is 
just to keep it simple. We can go back later and improve on this, but for now it will work enough
for you to move forward. If you have more memory than <i>KMEMSIZE</i> then this would not work because
it would allocate a page from the <i>husr</i> heap and that would be above <i>KMEMSIZE</i> meaning the
kernel will not have it identity mapped. I will cover additional ways to access the memory of a
thread/process later. For now just make QEMU have less than <i>KMEMSIZE</i> of RAM.
</p><p>Here is the thread.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">thread1</span><span class="p">(</span><span class="n">uintptr</span><span class="w"> </span><span class="n">serdbgout</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w">			</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0xfffff</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">((</span><span class="n">uint32</span><span class="o">*</span><span class="p">)</span><span class="n">serdbgout</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">72</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Next, we need some code in our scheduler to do this before it returns (after loading the new thread's state).
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">            </span><span class="p">......</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* set TLB table for user space (it can be zero for kernel) */</span><span class="w"></span>
<span class="w">			</span><span class="n">arm4_tlbset1</span><span class="p">((</span><span class="n">uintptr</span><span class="p">)</span><span class="n">kt</span><span class="o">-&gt;</span><span class="n">vmm</span><span class="p">.</span><span class="n">table</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* </span>
<span class="cm">				Invalidate all unlocked entries...</span>
<span class="cm">				</span>
<span class="cm">				..according to the manual there may be a better way to invalidate,</span>
<span class="cm">				only some entries per process. But, for now this should work.</span>
<span class="cm">				</span>
<span class="cm">				If you do not do this then the TLB does not flush and old entries</span>
<span class="cm">				from the previous process will still be in the TLB cache.</span>
<span class="cm">			*/</span><span class="w"></span>
<span class="w">			</span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;mcr p15, #0, r0, c8, c7, #0&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* go back through normal interrupt return process */</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>The <i>above</i> happens after we have restored the registers on the exception stack and the two hidden registers, and is right
before we return from the IRQ generated by the timer hardware. We also invalidate the entire TLB. I assume this invalidates
both TTBR0 and TTBR1 tables.
</p>
<h3><span class="mw-headline" id="Lets_Page_Out_The_Kernel_Space">Lets Page Out The Kernel Space</span></h3>
<p>Ok, you now should have a minimaly functional kernel with user application isolation, memory management, and tasking. Now, you
can continue on with your current memory management system and go quite far, or you could tear it down and build something better
but more complicated. The previous design has some limitations mainly if a user applications exhaust the <i>husr</i> memory and start
grabbing memory from <i>hphy</i>. A large app could essentially end up hogging all the memory the kernel can use and render the system
unusable even if you terminated other tasks. One method to handle this case is to take each page of memory used from <i>hphy</i> 
that has been allocated to user space and copy it (while the system is interrupted) into a page from <i>husr</i> then change the
mapping to point to the <i>husr</i> page. Essentially, swapping pages from <i>kphy</i> to <i>husr</i>.
</p><p><i>Also having a unneeded memory mapped into kernel space poses a hazard from bugs. Mainly, your kernel could have a bug that makes stray writes and corrupts other processes causing really hard to find bugs, and by not mapping unneeded memory you make it more likely that you will catch bugs writing by them writing to invalid memory locations.</i>
</p><p>If you want to explore different solution to managing virtual memory with out identity mapping
the kernel space then checkout the page <a href="ARM_Integrator-CP_VMM2" title="User:Pancakes/ARM Integrator-CP VMM2">VMM2</a> which builds from this page.
</p>
<!-- 
NewPP limit report
Cached time: 20250212020240
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.208 seconds
Real time usage: 3.617 seconds
Preprocessor visited node count: 224/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 172326/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:3472-0!canonical and timestamp 20250212020236 and revision id 16198.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=User:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM&amp;oldid=16198">https://wiki.osdev.org/index.php?title=User:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM&amp;oldid=16198</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="../Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=User%3APancakes%2FARM+Integrator-CP+IRQTimerPICTasksAndMM" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-user" class="selected mw-list-item"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM" title="View the user page [c]" accesskey="c"><span>User page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User_talk:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="ARM_Integrator-CP_IRQTimerPICTasksAndMM"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="../index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="../index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="../Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="../Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="../OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="../OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="../OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="../Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="../Special:WhatLinksHere/User:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/User:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-contributions" class="mw-list-item"><a href="../Special:Contributions/Pancakes" title="A list of contributions by this user"><span>User contributions</span></a></li><li id="t-log" class="mw-list-item"><a href="../Special:Log/Pancakes"><span>Logs</span></a></li><li id="t-userrights" class="mw-list-item"><a href="../Special:UserRights/Pancakes"><span>View user groups</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="../Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM&amp;oldid=16198" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=User:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 15 April 2014, at 17:49.</li>
	<li id="footer-info-0">This page has been accessed 642 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="../OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="../OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="../OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=User:Pancakes/ARM_Integrator-CP_IRQTimerPICTasksAndMM&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="../resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="../resources/assets/poweredby_mediawiki_132x47.png 1.5x, ../resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script data-cfasync="false" src="../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.208","walltime":"3.617","ppvisitednodes":{"value":224,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":172326,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20250212020240","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":3729});});</script>
</body>
</html>