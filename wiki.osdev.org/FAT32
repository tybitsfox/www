<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>FAT - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"57d9fa90477f3c3882b02138","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"FAT","wgTitle":"FAT","wgCurRevisionId":28959,"wgRevisionId":28959,"wgArticleId":1506,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using duplicate arguments in template calls","Pages using deprecated source tags","Filesystems"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"FAT","wgRelevantArticleId":1506,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],
"wgRedirectedFrom":"FAT32","wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgInternalRedirectTargetUrl":"/FAT#FAT_32","wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="FAT#FAT_32"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-FAT rootpage-FAT skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">FAT</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"><span class="mw-redirectedfrom">(Redirected from <a href="https://wiki.osdev.org/index.php?title=FAT32&amp;redirect=no" class="mw-redirect" title="FAT32">FAT32</a>)</span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="FAT32#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="FAT32#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><table style="font-size:95%; line-height:1.5em; padding:0.25em; float:right; margin: 0 0 8px 15px; clear: right; border:1px solid #aaaaaa; background:#eee; text-align:center; width:200px; ;"><tbody><tr><th style="background:#ffce7b; padding:0.3em; font-size:1.1em;"><a href="File_Systems" title="File Systems">Filesystems</a></th></tr><tr><th>Virtual Filesystems</th></tr><tr><td><div>
<p><a href="VFS" title="VFS">VFS</a><br />
</p>
</div></td></tr><tr><th>Disk Filesystems</th></tr><tr><td><div>
<p><a class="mw-selflink selflink">FAT</a> <a href="FAT12" class="mw-redirect" title="FAT12">12</a>/<a href="FAT16" class="mw-redirect" title="FAT16">16</a>/<a href="FAT32" class="mw-redirect" title="FAT32">32</a>, <a href="VFAT" class="mw-redirect" title="VFAT">VFAT</a>, <a href="ExFAT" title="ExFAT">ExFAT</a><br />
<a href="Ext2" title="Ext2">Ext 2</a>/<a href="Ext3" title="Ext3">3</a>/<a href="Ext4" title="Ext4">4</a><br />
<a href="LEAN" title="LEAN">LEAN</a><br />
<a href="HPFS" title="HPFS">HPFS</a><br />
<a href="NTFS" title="NTFS">NTFS</a><br />
<a href="HFS" title="HFS">HFS</a><br />
<a href="HFS+" title="HFS+">HFS+</a><br />
<a href="MFS" title="MFS">MFS</a><br />
<a href="ReiserFS" title="ReiserFS">ReiserFS</a><br />
<a href="FFS_(Amiga)" title="FFS (Amiga)">FFS (Amiga)</a><br />
<a href="FFS_(BSD)" class="mw-redirect" title="FFS (BSD)">FFS (BSD)</a>/<a href="UFS" title="UFS">UFS</a><br />
<a href="BeFS" title="BeFS">BeFS</a><br />
<a href="BFS" title="BFS">BFS</a><br />
<a href="XFS" title="XFS">XFS</a><br />
<a href="SFS" title="SFS">SFS</a><br />
<a href="ZDSFS" title="ZDSFS">ZDSFS</a><br />
<a href="ZFS" title="ZFS">ZFS</a><br />
<a href="USTAR" title="USTAR">USTAR</a><br />
</p>
</div></td></tr><tr><th>CD/DVD Filesystems</th></tr><tr><td><div>
<p><a href="ISO_9660" title="ISO 9660">ISO 9660</a><br />
<a href="Joliet" title="Joliet">Joliet</a><br />
<a href="UDF" title="UDF">UDF</a><br />
</p>
</div></td></tr><tr><th><a href="./Category:Network_Filesystems" title="Category:Network Filesystems">Network Filesystems</a></th></tr><tr><td><div>
<p><a href="NFS" title="NFS">NFS</a><br />
<a href="RFS" title="RFS">RFS</a><br />
<a href="AFS" title="AFS">AFS</a><br />
</p>
</div></td></tr><tr><th>Flash Filesystems</th></tr><tr><td><div>
<p><a href="JFFS2" title="JFFS2">JFFS2</a><br />
<a href="YAFFS" title="YAFFS">YAFFS</a><br />
</p>
</div></td></tr></tbody></table>
<p>The <b>File Allocation Table</b> (<b>FAT</b>) was the native file system of MS-DOS. FAT was originally introduced by Marc McDonald in Stand-alone Disk BASIC with 8-bit FAT entries and 16 byte directory entries. The better known FAT12 variant, with 12-bit FAT entries and 32 byte directory entries, was introduced with DOS. FAT is a very simple file system -- nothing more than a singly-linked list of clusters in a gigantic table. A FAT file system uses very little memory (unless the OS caches the whole allocation table in memory) and is one of, if not the, most basic file system in use today.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="FAT32#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="FAT32#FAT_12"><span class="tocnumber">1.1</span> <span class="toctext">FAT 12</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="FAT32#FAT_16"><span class="tocnumber">1.2</span> <span class="toctext">FAT 16</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="FAT32#FAT_32"><span class="tocnumber">1.3</span> <span class="toctext">FAT 32</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="FAT32#ExFAT"><span class="tocnumber">1.4</span> <span class="toctext">ExFAT</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="FAT32#VFAT"><span class="tocnumber">1.5</span> <span class="toctext">VFAT</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="FAT32#Implementation_Details"><span class="tocnumber">2</span> <span class="toctext">Implementation Details</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="FAT32#Boot_Record"><span class="tocnumber">2.1</span> <span class="toctext">Boot Record</span></a>
<ul>
<li class="toclevel-3 tocsection-9"><a href="FAT32#BPB_(BIOS_Parameter_Block)"><span class="tocnumber">2.1.1</span> <span class="toctext">BPB (BIOS Parameter Block)</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="FAT32#Extended_Boot_Record"><span class="tocnumber">2.1.2</span> <span class="toctext">Extended Boot Record</span></a>
<ul>
<li class="toclevel-4 tocsection-11"><a href="FAT32#FAT_12_and_FAT_16"><span class="tocnumber">2.1.2.1</span> <span class="toctext">FAT 12 and FAT 16</span></a></li>
<li class="toclevel-4 tocsection-12"><a href="FAT32#FAT_32_2"><span class="tocnumber">2.1.2.2</span> <span class="toctext">FAT 32</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-13"><a href="FAT32#FSInfo_Structure_(FAT32_only)"><span class="tocnumber">2.2</span> <span class="toctext">FSInfo Structure (FAT32 only)</span></a>
<ul>
<li class="toclevel-3 tocsection-14"><a href="FAT32#exFat_boot_record"><span class="tocnumber">2.2.1</span> <span class="toctext">exFat boot record</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-15"><a href="FAT32#File_Allocation_Table"><span class="tocnumber">2.3</span> <span class="toctext">File Allocation Table</span></a>
<ul>
<li class="toclevel-3 tocsection-16"><a href="FAT32#FAT_12_2"><span class="tocnumber">2.3.1</span> <span class="toctext">FAT 12</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="FAT32#FAT_16_2"><span class="tocnumber">2.3.2</span> <span class="toctext">FAT 16</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="FAT32#FAT_32_and_exFAT"><span class="tocnumber">2.3.3</span> <span class="toctext">FAT 32 and exFAT</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-19"><a href="FAT32#Directories_on_FAT12/16/32"><span class="tocnumber">2.4</span> <span class="toctext">Directories on FAT12/16/32</span></a>
<ul>
<li class="toclevel-3 tocsection-20"><a href="FAT32#Standard_8.3_format"><span class="tocnumber">2.4.1</span> <span class="toctext">Standard 8.3 format</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="FAT32#Long_File_Names"><span class="tocnumber">2.4.2</span> <span class="toctext">Long File Names</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-22"><a href="FAT32#Directories_on_exFAT"><span class="tocnumber">2.5</span> <span class="toctext">Directories on exFAT</span></a>
<ul>
<li class="toclevel-3 tocsection-23"><a href="FAT32#File_entry"><span class="tocnumber">2.5.1</span> <span class="toctext">File entry</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="FAT32#Stream_&quot;extension&quot;_entry"><span class="tocnumber">2.5.2</span> <span class="toctext">Stream "extension" entry</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="FAT32#File_name_entry"><span class="tocnumber">2.5.3</span> <span class="toctext">File name entry</span></a></li>
<li class="toclevel-3 tocsection-26"><a href="FAT32#Long_File_Names_2"><span class="tocnumber">2.5.4</span> <span class="toctext">Long File Names</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-27"><a href="FAT32#Programming_Guide"><span class="tocnumber">3</span> <span class="toctext">Programming Guide</span></a>
<ul>
<li class="toclevel-2 tocsection-28"><a href="FAT32#Reading_the_Boot_Sector"><span class="tocnumber">3.1</span> <span class="toctext">Reading the Boot Sector</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="FAT32#Reading_Directories"><span class="tocnumber">3.2</span> <span class="toctext">Reading Directories</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="FAT32#Following_Cluster_Chains"><span class="tocnumber">3.3</span> <span class="toctext">Following Cluster Chains</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="FAT32#Reading_extents"><span class="tocnumber">3.4</span> <span class="toctext">Reading extents</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-32"><a href="FAT32#Creating_a_fresh_FAT_filesystem"><span class="tocnumber">4</span> <span class="toctext">Creating a fresh FAT filesystem</span></a></li>
<li class="toclevel-1 tocsection-33"><a href="FAT32#See_Also"><span class="tocnumber">5</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-34"><a href="FAT32#Threads"><span class="tocnumber">5.1</span> <span class="toctext">Threads</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="FAT32#External_Links"><span class="tocnumber">5.2</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Overview">Overview</span></h2>
<p>There are several different versions of the FAT file system. Each version was designed for a different size of storage media. 
</p>
<h3><span class="mw-headline" id="FAT_12">FAT 12</span></h3>
<p>FAT 12 was designed for floppy disks and can manage a maximum size of 16 megabytes because it uses 12 bits to address the clusters.
</p>
<h3><span class="mw-headline" id="FAT_16">FAT 16</span></h3>
<p>FAT 16 was designed for early hard disks and could handle a maximum size of 64K clusters * the cluster size. The larger the hard disk, the larger the cluster size would be, which leads to large amounts of "slack space" on the disk.
</p>
<h3><span class="mw-headline" id="FAT_32">FAT 32</span></h3>
<p>FAT 32 was introduced to us by Windows95-B and Windows98. FAT32 solved some of FAT's problems. No more 64K max clusters! Although FAT32 uses 32 bits per FAT entry, only the bottom 28 bits are actually used to address clusters on the disk (top 4 bits are reserved). With 28 bits per FAT entry, the filesystem can address a maximum of about 270 million clusters in a partition. This enables very large hard disks to still maintain reasonably small cluster sizes and thus reduce slack space between files.
</p>
<h3><span class="mw-headline" id="ExFAT">ExFAT</span></h3>
<dl><dd><i>Main article:</i> <a href="ExFAT" title="ExFAT">ExFAT</a></dd></dl>
<p>ExFAT is the filesystem used on SDXC cards, created by Microsoft. It is FAT32 with actually 32 bits per FAT entry, with the ability to indicate a file is fully consecutive on disk (allowing you to skip reading the FAT), some more advanced features and a fully redesigned file entry system. Since it's so similar to FAT32, please merge any bits of info from the exFAT article into this one.
</p><p>Microsoft has published the official specification at <a rel="nofollow" class="external free" href="https://docs.microsoft.com/en-us/windows/win32/fileio/exfat-specification">https://docs.microsoft.com/en-us/windows/win32/fileio/exfat-specification</a> .
</p>
<h3><span class="mw-headline" id="VFAT">VFAT</span></h3>
<p>VFAT is an extension to the FAT file system that has the ability to use long filenames (up to 255 characters). First introduced by Windows 95, it uses a "kludge" whereby long filenames are marked with a "volume label" attribute and filenames are subsequently stored in 11 byte chunks in sequential directory entries. (This is a bit of an oversimplification, but close enough).
</p>
<h2><span class="mw-headline" id="Implementation_Details">Implementation Details</span></h2>
<p>The FAT file system views the storage media as a flat array of clusters. If the physical media does not address its data as a flat list of sectors (really old hard disks and floppy disks) then the cluster numbers will need to be translated before being sent to the disk. The storage media is organized into three basic areas.
</p>
<ul><li>The boot record</li>
<li>The File Allocation Table (FAT)</li>
<li>The directory and data area</li></ul>
<h3><span class="mw-headline" id="Boot_Record">Boot Record</span></h3>
<p>The boot record occupies one sector, and is always placed in logical sector number zero of the "partition". If the media is not divided into partitions, then this is the beginning of the media. This is the easiest sector on the partition for the computer to locate when it is loaded. If the storage media is partitioned (such as a hard disk), then the beginning of the actual media contains an <a href="MBR_(x86)" title="MBR (x86)">MBR (x86)</a> or other form of partition information. In this case each partition's first sector holds a <a href="Volume_Boot_Record" title="Volume Boot Record">Volume Boot Record</a>.
</p>
<h4><span id="BPB_.28BIOS_Parameter_Block.29"></span><span class="mw-headline" id="BPB_(BIOS_Parameter_Block)">BPB (BIOS Parameter Block)</span></h4>
<p>The boot record contains both code and data, mixed together. The data that isn't code is known as the BPB.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (decimal)
</th>
<th>Offset (hex)
</th>
<th>Size (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>0
</td>
<td>0x00
</td>
<td>3
</td>
<td>The first three bytes EB 3C 90 disassemble to JMP SHORT 3C NOP. (The 3C value may be different.) The reason for this is to jump over the disk format information (the BPB and EBPB). Since the first sector of the disk is loaded into ram at location 0x0000:0x7c00 and executed, without this jump, the processor would attempt to execute data that isn't code. Even for non-bootable volumes, code matching this pattern (or using the E9 jump opcode) is required to be present by both Windows and OS X. To fulfil this requirement, an infinite loop can be placed here with the bytes EB FE 90.
</td></tr>
<tr>
<td>3
</td>
<td>0x03
</td>
<td>8
</td>
<td>OEM identifier. The first 8 Bytes (3 - 10) is the version of DOS being used. The next eight Bytes 29 3A 63 7E 2D 49 48 and 43 read out the name of the version. The official FAT Specification from Microsoft says that this field is really meaningless and is ignored by MS FAT Drivers, however it does recommend the value "MSWIN4.1" as some 3rd party drivers supposedly check it and expect it to have that value. Older versions of dos also report MSDOS5.1, linux-formatted floppy will likely to carry "mkdosfs" here, and FreeDOS formatted disks have been observed to have "FRDOS5.1" here. If the string is less than 8 bytes, it is padded with spaces.
</td></tr>
<tr>
<td>11
</td>
<td>0x0B
</td>
<td>2
</td>
<td>The number of Bytes per sector (remember, all numbers are in the little-endian format).
</td></tr>
<tr>
<td>13
</td>
<td>0x0D
</td>
<td>1
</td>
<td>Number of sectors per cluster.
</td></tr>
<tr>
<td>14
</td>
<td>0x0E
</td>
<td>2
</td>
<td>Number of reserved sectors. The boot record sectors are included in this value.
</td></tr>
<tr>
<td>16
</td>
<td>0x10
</td>
<td>1
</td>
<td>Number of File Allocation Tables (FAT's) on the storage media. Often this value is 2.
</td></tr>
<tr>
<td>17
</td>
<td>0x11
</td>
<td>2
</td>
<td>Number of root directory entries (must be set so that the root directory occupies entire sectors).
</td></tr>
<tr>
<td>19
</td>
<td>0x13
</td>
<td>2
</td>
<td>The total sectors in the logical volume. If this value is 0, it means there are more than 65535 sectors in the volume, and the actual count is stored in the Large Sector Count entry at 0x20.
</td></tr>
<tr>
<td>21
</td>
<td>0x15
</td>
<td>1
</td>
<td>This Byte indicates the <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#BPB20_OFS_0Ah">media descriptor type</a>.
</td></tr>
<tr>
<td>22
</td>
<td>0x16
</td>
<td>2
</td>
<td>Number of sectors per FAT. FAT12/FAT16 only.
</td></tr>
<tr>
<td>24
</td>
<td>0x18
</td>
<td>2
</td>
<td>Number of sectors per track.
</td></tr>
<tr>
<td>26
</td>
<td>0x1A
</td>
<td>2
</td>
<td>Number of heads or sides on the storage media.
</td></tr>
<tr>
<td>28
</td>
<td>0x1C
</td>
<td>4
</td>
<td>Number of hidden sectors. (i.e. the LBA of the beginning of the partition.)
</td></tr>
<tr>
<td>32
</td>
<td>0x20
</td>
<td>4
</td>
<td>Large sector count. This field is set if there are more than 65535 sectors in the volume, resulting in a value which does not fit in the <i>Number of Sectors</i> entry at 0x13.
</td></tr></tbody></table>
<p>Note: the "geometry" of the media (sectors per track, heads, and perhaps the number of bytes in a sector) is not necessarily known correctly by the program that originally formats the media. Also, if the media is moved (from the computer that formatted it) to another machine with a different BIOS -- then the new BIOS may specify a different geometry for the same media. So it is generally a very bad idea to trust the "SPT" or "heads" numbers. Get them from the BIOS instead, if possible.
</p><p>Note2: many of the values in the BPB are not correctly "aligned". That is, word-sized values are not stored on word ("even" address) boundaries. On some architectures, accessing misaligned words may cause the code to crash. Making a copy of the BPB (somewhere else in memory and shifted up one byte) may solve the problem.
</p>
<h4><span class="mw-headline" id="Extended_Boot_Record">Extended Boot Record</span></h4>
<p>The extended boot record information comes right after the BPB. The data at the beginning is known as the EBPB. It contains different information depending on whether this partition is a FAT 12, FAT 16, or FAT 32 filesystem. Immediately following the EBPB is the actual boot code, then the standard 0xAA55 boot signature, to fill out the 512-byte boot sector. Offsets shows are from the start of the standard boot record.
</p>
<h5><span class="mw-headline" id="FAT_12_and_FAT_16">FAT 12 and FAT 16</span></h5>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (decimal)
</th>
<th>Offset (hexadecimal)
</th>
<th>Length (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>36
</td>
<td>0x024
</td>
<td>1
</td>
<td>Drive number. The value here should be identical to the value returned by BIOS interrupt 0x13, or passed in the DL register; i.e. 0x00 for a floppy disk and 0x80 for hard disks. This number is useless because the media is likely to be moved to another machine and inserted in a drive with a different drive number.
</td></tr>
<tr>
<td>37
</td>
<td>0x025
</td>
<td>1
</td>
<td>Flags in Windows NT. Reserved otherwise.
</td></tr>
<tr>
<td>38
</td>
<td>0x026
</td>
<td>1
</td>
<td>Signature (must be 0x28 or 0x29).
</td></tr>
<tr>
<td>39
</td>
<td>0x027
</td>
<td>4
</td>
<td>VolumeID 'Serial' number. Used for tracking volumes between computers. You can ignore this if you want.
</td></tr>
<tr>
<td>43
</td>
<td>0x02B
</td>
<td>11
</td>
<td>Volume label string. This field is padded with spaces.
</td></tr>
<tr>
<td>54
</td>
<td>0x036
</td>
<td>8
</td>
<td>System identifier string. This field is a string representation of the FAT file system type. It is padded with spaces. The spec says never to trust the contents of this string for any use.
</td></tr>
<tr>
<td>62
</td>
<td>0x03E
</td>
<td>448
</td>
<td>Boot code.
</td></tr>
<tr>
<td>510
</td>
<td>0x1FE
</td>
<td>2
</td>
<td>Bootable partition signature 0xAA55.
</td></tr></tbody></table>
<h5><span class="mw-headline" id="FAT_32_2">FAT 32</span></h5>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (decimal)
</th>
<th>Offset (hexadecimal)
</th>
<th>Length (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>36
</td>
<td>0x024
</td>
<td>4
</td>
<td>Sectors per FAT. The size of the FAT in sectors.
</td></tr>
<tr>
<td>40
</td>
<td>0x028
</td>
<td>2
</td>
<td>Flags.
</td></tr>
<tr>
<td>42
</td>
<td>0x02A
</td>
<td>2
</td>
<td>FAT version number. The high byte is the major version and the low byte is the minor version. FAT drivers should respect this field.
</td></tr>
<tr>
<td>44
</td>
<td>0x02C
</td>
<td>4
</td>
<td>The cluster number of the root directory. Often this field is set to 2.
</td></tr>
<tr>
<td>48
</td>
<td>0x030
</td>
<td>2
</td>
<td>The sector number of the FSInfo structure.
</td></tr>
<tr>
<td>50
</td>
<td>0x032
</td>
<td>2
</td>
<td>The sector number of the backup boot sector.
</td></tr>
<tr>
<td>52
</td>
<td>0x034
</td>
<td>12
</td>
<td>Reserved. When the volume is formated these bytes should be zero.
</td></tr>
<tr>
<td>64
</td>
<td>0x040
</td>
<td>1
</td>
<td>Drive number. The values here are identical to the values returned by the BIOS interrupt 0x13. 0x00 for a floppy disk and 0x80 for hard disks.
</td></tr>
<tr>
<td>65
</td>
<td>0x041
</td>
<td>1
</td>
<td>Flags in Windows NT. Reserved otherwise.
</td></tr>
<tr>
<td>66
</td>
<td>0x042
</td>
<td>1
</td>
<td>Signature (must be 0x28 or 0x29).
</td></tr>
<tr>
<td>67
</td>
<td>0x043
</td>
<td>4
</td>
<td>Volume ID 'Serial' number. Used for tracking volumes between computers. You can ignore this if you want.
</td></tr>
<tr>
<td>71
</td>
<td>0x047
</td>
<td>11
</td>
<td>Volume label string. This field is padded with spaces.
</td></tr>
<tr>
<td>82
</td>
<td>0x052
</td>
<td>8
</td>
<td>System identifier string. Always "FAT32&#160;&#160;&#160;". The spec says never to trust the contents of this string for any use.
</td></tr>
<tr>
<td>90
</td>
<td>0x05A
</td>
<td>420
</td>
<td>Boot code.
</td></tr>
<tr>
<td>510
</td>
<td>0x1FE
</td>
<td>2
</td>
<td>Bootable partition signature 0xAA55.
</td></tr></tbody></table>
<p><br />
</p>
<h3><span id="FSInfo_Structure_.28FAT32_only.29"></span><span class="mw-headline" id="FSInfo_Structure_(FAT32_only)">FSInfo Structure (FAT32 only)</span></h3>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (decimal)
</th>
<th>Offset (hexadecimal)
</th>
<th>Length (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>0
</td>
<td>0x0
</td>
<td>4
</td>
<td>Lead signature (must be 0x41615252 to indicate a valid FSInfo structure)
</td></tr>
<tr>
<td>4
</td>
<td>0x4
</td>
<td>480
</td>
<td>Reserved, these bytes should never be used
</td></tr>
<tr>
<td>484
</td>
<td>0x1E4
</td>
<td>4
</td>
<td>Another signature (must be 0x61417272)
</td></tr>
<tr>
<td>488
</td>
<td>0x1E8
</td>
<td>4
</td>
<td>Contains the last known free cluster count on the volume. If the value is 0xFFFFFFFF, then the free count is unknown and must be computed. However, this value might be incorrect and should at least be range checked (&lt;= volume cluster count)
</td></tr>
<tr>
<td>492
</td>
<td>0x1EC
</td>
<td>4
</td>
<td>Indicates the cluster number at which the filesystem driver should start looking for available clusters. If the value is 0xFFFFFFFF, then there is no hint and the driver should start searching at 2. Typically this value is set to the last allocated cluster number. As the previous field, this value should be range checked.
</td></tr>
<tr>
<td>496
</td>
<td>0x1F0
</td>
<td>12
</td>
<td>Reserved
</td></tr>
<tr>
<td>508
</td>
<td>0x1FC
</td>
<td>4
</td>
<td>Trail signature (0xAA550000)
</td></tr></tbody></table>
<h4><span class="mw-headline" id="exFat_boot_record">exFat boot record</span></h4>
<p>For exFAT the whole boot record was recreated from scratch instead of extending the existing FAT12/16/32 boot records even further. You can recognize exFAT by noticing that in the FAT12/16/32 boot record, the "bytes per sector" is zero.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (decimal)
</th>
<th>Offset (hex)
</th>
<th>Size (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>0
</td>
<td>0x00
</td>
<td>3
</td>
<td>The first three bytes EB 3C 90 disassemble to JMP SHORT 3C NOP. (The 3C value may be different.) The reason for this is to jump over the disk format information (the BPB and EBPB). Since the first sector of the disk is loaded into ram at location 0x0000:0x7c00 and executed, without this jump, the processor would attempt to execute data that isn't code. Even for non-bootable volumes, code matching this pattern (or using the E9 jump opcode) is required to be present by both Windows and OS X. To fulfil this requirement, an infinite loop can be placed here with the bytes EB FE 90.
</td></tr>
<tr>
<td>3
</td>
<td>0x03
</td>
<td>8
</td>
<td>OEM identifier. This contains the string "EXFAT   ". Not to be used for filesystem determination, but it's a nice hint.
</td></tr>
<tr>
<td>11
</td>
<td>0x0B
</td>
<td>53
</td>
<td>Set to zero. This makes sure any FAT driver will not be able to load it.
</td></tr>
<tr>
<td>64
</td>
<td>0x40
</td>
<td>8
</td>
<td>Partition offset. No idea why the partition itself would have this, but it's here. Might be wrong. Probably best to just ignore.
</td></tr>
<tr>
<td>72
</td>
<td>0x48
</td>
<td>8
</td>
<td>Volume length.
</td></tr>
<tr>
<td>80
</td>
<td>0x50
</td>
<td>4
</td>
<td>FAT offset (in sectors) from start of partition.
</td></tr>
<tr>
<td>84
</td>
<td>0x54
</td>
<td>4
</td>
<td>FAT length (in sectors).
</td></tr>
<tr>
<td>88
</td>
<td>0x58
</td>
<td>4
</td>
<td>Cluster heap offset (in sectors).
</td></tr>
<tr>
<td>92
</td>
<td>0x5C
</td>
<td>4
</td>
<td>Cluster count
</td></tr>
<tr>
<td>96
</td>
<td>0x60
</td>
<td>4
</td>
<td>Root directory cluster. Typically 4 (but just read this value).
</td></tr>
<tr>
<td>100
</td>
<td>0x64
</td>
<td>4
</td>
<td>Serial number of partition.
</td></tr>
<tr>
<td>104
</td>
<td>0x68
</td>
<td>2
</td>
<td>Filesystem revision
</td></tr>
<tr>
<td>106
</td>
<td>0x6A
</td>
<td>2
</td>
<td>Flags
</td></tr>
<tr>
<td>108
</td>
<td>0x6C
</td>
<td>1
</td>
<td>Sector shift
</td></tr>
<tr>
<td>109
</td>
<td>0x6D
</td>
<td>1
</td>
<td>Cluster shift
</td></tr>
<tr>
<td>110
</td>
<td>0x6E
</td>
<td>1
</td>
<td>Number of FATs
</td></tr>
<tr>
<td>111
</td>
<td>0x6F
</td>
<td>1
</td>
<td>Drive select
</td></tr>
<tr>
<td>112
</td>
<td>0x70
</td>
<td>1
</td>
<td>Percentage in use
</td></tr>
<tr>
<td>113
</td>
<td>0x71
</td>
<td>7
</td>
<td>Reserved (set to 0).
</td></tr></tbody></table>
<p>To read the filesystem, find out how big a 'sector' and a 'cluster' are. A sector is (1 &lt;&lt; sectorshift) bytes, a cluster is (1 &lt;&lt; (sectorshift + clustershift)) bytes. Then, find the start of the FAT and the start of the cluster heap (note that the first cluster is *still* cluster 2).
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">    </span>
<span class="c1">// This allows you to zero-index clusters:</span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">clusterArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clusterheapoffset</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sectorsize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">clustersize</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">fatOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fatoffset</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sectorsize</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">usablespace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clustercount</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">clustersize</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Note that all values in the BPB are now naturally aligned and that this code is *significantly* simpler than FAT32's BPB reading.
</p>
<h3><span class="mw-headline" id="File_Allocation_Table">File Allocation Table</span></h3>
<p>The File Allocation Table (FAT) is a table stored on the storage media that indicates the status and location of all data clusters that are on the disk. It can be considered the "table of contents" of a disk. The cluster may be available for use, it may be reserved by the operating system, it may be unavailable due to a bad sector on the disk, or it may be in use by a file. The clusters of a file need not be right next to each other on the disk. In fact it is likely that they are scattered widely throughout the disk. The FAT allows the operating system to follow the "chain" of clusters in a file. 
</p>
<h4><span class="mw-headline" id="FAT_12_2">FAT 12</span></h4>
<p>FAT 12 uses 12 bits to address the clusters on the disk. Each 12 bit entry in the FAT points to the next cluster of a file on the disk. Given a valid cluster number, here is how you extract the value of the next cluster in the cluster chain:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">FAT_table</span><span class="p">[</span><span class="n">sector_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="c1">// needs two in case we straddle a sector</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fat_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">active_cluster</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">active_cluster</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="c1">// multiply by 1.5</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fat_sector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_fat_sector</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">fat_offset</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sector_size</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ent_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fat_offset</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">sector_size</span><span class="p">;</span><span class="w"></span>

<span class="c1">//at this point you need to read two sectors from disk starting at &quot;fat_sector&quot; into &quot;FAT_table&quot;.</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">table_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">FAT_table</span><span class="p">[</span><span class="n">ent_offset</span><span class="p">];</span><span class="w"></span>

<span class="n">table_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">active_cluster</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">table_value</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">table_value</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xfff</span><span class="p">;</span><span class="w"></span>

<span class="c1">//the variable &quot;table_value&quot; now has the information you need about the next cluster in the chain.</span>
</pre></div>
<p>If "table_value" is greater than or equal to (&gt;=) 0xFF8 then there are no more clusters in the chain. This means that the whole file has been read. If "table_value" equals (==) 0xFF7 then this cluster has been marked as "bad". "Bad" clusters are prone to errors and should be avoided. If "table_value" is not one of the above cases then it is the cluster number of the next cluster in the file.
</p><p>The entries under index 0 and 1 are reserved. Index 0 is used as a value in other entries signifying that the given cluster is free, with the corresponding first entry in the table holding the value of the BPB_Media field in its low 8 bits and 0xf in its top 4 bits. For example, if BPB_Media is 0xF8, then the zeroth entry should hold the value 0xFF8. The second entry (index 1) is unused but must hold the value 0xFFF.
</p><p>FAT12 uses an entry size that is not evenly divisible by 8 bits. This has some consequences.
</p><p>First is storage in the table. Consider successive entries with values 0x123 and 0x456. In the bytes of the table, they'll be stored 0x23 0x61 0x45. Note that if you do little-endian 16-bit loads, you get 0x6123 at offset 0 and 0x4561 at offset 1, letting you recover the original two entry values with the shifts, masks, and offsets seen in the above code block.
</p><p>The second is that, as seen above with the offsets used being 0 and 1, those word bytes might not be 16-bit aligned. That usually just means the x86 takes a slower path to load the word if you do e.g. <tt>*(unsigned short *)bytes</tt>, but if you're use something like UBSan to avoid undefined behavior, those UB-catching routines can be triggered (usually resulting in a panic) if you don't load the two bytes separately and stick them together yourself.
</p><p>The third consequence is that the word bytes might not be *sector* aligned. Which means if your code loads a single sector of the table, it needs a special case where it loads two if the entry straddles the sector-size boundary. Or you can just load two sectors every time as seen above.
</p>
<h4><span class="mw-headline" id="FAT_16_2">FAT 16</span></h4>
<p>FAT 16 uses 16 bits to address the clusters on the disk. Because of this, it is much easier to extract the values out of a 16 bit File Allocation Table. Here is how it is done:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">FAT_table</span><span class="p">[</span><span class="n">sector_size</span><span class="p">];</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fat_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">active_cluster</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fat_sector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_fat_sector</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">fat_offset</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sector_size</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ent_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fat_offset</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">sector_size</span><span class="p">;</span><span class="w"></span>

<span class="c1">//at this point you need to read from sector &quot;fat_sector&quot; on the disk into &quot;FAT_table&quot;.</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">table_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">FAT_table</span><span class="p">[</span><span class="n">ent_offset</span><span class="p">];</span><span class="w"></span>

<span class="c1">//the variable &quot;table_value&quot; now has the information you need about the next cluster in the chain.</span>
</pre></div>
<p>If "table_value" is greater than or equal to (&gt;=) 0xFFF8 then there are no more clusters in the chain. This means that the whole file has been read. If "table_value" equals (==) 0xFFF7 then this cluster has been marked as "bad". "Bad" clusters are prone to errors and should be avoided. If "table_value" is not one of the above cases then it is the cluster number of the next cluster in the file.
</p><p>The entries under index 0 and 1 are reserved. The zeroth entry is reserved because index 0 is used as value of other entries signifying that the given cluster is free. Zeroth entry has to hold value of the BPB_Media field from in the low 8 bits, and the rest of the bits have to be set to zero. For example, if BPB_Media is 0xF8, then the zeroth entry should hold the value 0xFFF8. The first entry is reserved for the future and must to hold the value 0xFFFF.
</p>
<h4><span class="mw-headline" id="FAT_32_and_exFAT">FAT 32 and exFAT</span></h4>
<p>FAT 32 uses 28 bits to address the clusters on the disk. The highest 4 bits are reserved. This means that they should be ignored when read and unchanged when written. exFAT uses the full 32 bit to encode sector numbers. Similar to the same operation on a 16 bit FAT:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">FAT_table</span><span class="p">[</span><span class="n">sector_size</span><span class="p">];</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fat_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">active_cluster</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fat_sector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_fat_sector</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">fat_offset</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sector_size</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ent_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fat_offset</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">sector_size</span><span class="p">;</span><span class="w"></span>

<span class="c1">//at this point you need to read from sector &quot;fat_sector&quot; on the disk into &quot;FAT_table&quot;.</span>

<span class="c1">//remember to ignore the high 4 bits.</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">table_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">FAT_table</span><span class="p">[</span><span class="n">ent_offset</span><span class="p">];</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fat32</span><span class="p">)</span><span class="w"> </span><span class="n">table_value</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="mh">0x0FFFFFFF</span><span class="p">;</span><span class="w"></span>

<span class="c1">//the variable &quot;table_value&quot; now has the information you need about the next cluster in the chain.</span>
</pre></div>
<p>If "table_value" is greater than or equal to (&gt;=) 0x0FFFFFF8 (or 0xFFFFFFF8 for exFAT) then there are no more clusters in the chain. This means that the whole file has been read. If "table_value" equals (==) 0x0FFFFFF7 (or 0xFFFFFFF7 for exFAT) then this cluster has been marked as "bad". "Bad" clusters are prone to errors and should be avoided. If "table_value" is not one of the above cases then it is the cluster number of the next cluster in the file.
</p><p>The entries under index 0 and 1 are reserved. The zeroth entry is reserved because index 0 is used as value of other entries signifying that the given cluster is free. Zeroth entry has to hold value of the BPB_Media field from in the low 8 bits, and the rest of the bits have to be set to zero. For example, if BPB_Media is 0xF8, then the zeroth entry should hold the value 0xFFFFFFF8. The first entry is reserved for the future and must to hold the value 0xFFFFFFFF.
</p><p>Note that on exFAT, some files are not written out into the FAT. In the case that a file is fully contiguous, exFAT allows the operating system to encode this information and not update the FAT for this file. Unlike FAT32 therefore, the FAT table is not used for allocation status of a cluster; instead there is an allocation bitmap to handle that. See below under directory entries for that.
</p>
<h3><span id="Directories_on_FAT12.2F16.2F32"></span><span class="mw-headline" id="Directories_on_FAT12/16/32">Directories on FAT12/16/32</span></h3>
<p>A directory entry simply stores the information needed to know where a file's data or a folder's children are stored on the disk. It also holds information such as the entry's name, size, and creation time. There are two types of directories in a FAT file system. Standard 8.3 directory entries, which appear on all FAT file systems, and Long File Name directory entries which are optionally present to allow for longer file names.
</p>
<h4><span class="mw-headline" id="Standard_8.3_format">Standard 8.3 format</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (in bytes)
</th>
<th>Length (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>0
</td>
<td>11
</td>
<td>8.3 file name. The first 8 characters are the name and the last 3 are the extension.
</td></tr>
<tr>
<td>11
</td>
<td>1
</td>
<td>Attributes of the file. The possible attributes are: <pre>READ_ONLY=0x01 HIDDEN=0x02 SYSTEM=0x04 VOLUME_ID=0x08 DIRECTORY=0x10 ARCHIVE=0x20 LFN=READ_ONLY|HIDDEN|SYSTEM|VOLUME_ID </pre> (LFN means that this entry is a <a href="FAT32#Long_File_Names">long file name entry</a>)
</td></tr>
<tr>
<td>12
</td>
<td>1
</td>
<td>Reserved for use by Windows NT.
</td></tr>
<tr>
<td>13
</td>
<td>1
</td>
<td>Creation time in hundredths of a second, although the official FAT Specification from Microsoft says it is tenths of a second. Range 0-199 inclusive. Based on simple tests, Ubuntu16.10 stores either 0 or 100 while Windows7 stores 0-199 in this field.
</td></tr>
<tr>
<td>14
</td>
<td>2
</td>
<td>The time that the file was created. Multiply Seconds by 2.
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<td>Hour
</td>
<td>5 bits
</td></tr>
<tr>
<td>Minutes
</td>
<td>6 bits
</td></tr>
<tr>
<td>Seconds
</td>
<td>5 bits
</td></tr></tbody></table>
</td></tr>
<tr>
<td>16
</td>
<td>2
</td>
<td>The date on which the file was created.
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<td>Year
</td>
<td>7 bits
</td></tr>
<tr>
<td>Month
</td>
<td>4 bits
</td></tr>
<tr>
<td>Day
</td>
<td>5 bits
</td></tr></tbody></table>
</td></tr>
<tr>
<td>18
</td>
<td>2
</td>
<td>Last accessed date. Same format as the creation date.
</td></tr>
<tr>
<td>20
</td>
<td>2
</td>
<td>The high 16 bits of this entry's first cluster number. For FAT 12 and FAT 16 this is always zero.
</td></tr>
<tr>
<td>22
</td>
<td>2
</td>
<td>Last modification time. Same format as the creation time.
</td></tr>
<tr>
<td>24
</td>
<td>2
</td>
<td>Last modification date. Same format as the creation date.
</td></tr>
<tr>
<td>26
</td>
<td>2
</td>
<td>The low 16 bits of this entry's first cluster number. Use this number to find the first cluster for this entry.
</td></tr>
<tr>
<td>28
</td>
<td>4
</td>
<td>The size of the file in bytes.
</td></tr></tbody></table>
<h4><span class="mw-headline" id="Long_File_Names">Long File Names</span></h4>
<p>Long file name entries <i>always</i> have a regular 8.3 entry to which they belong. The long file name entries are always placed immediately before their 8.3 entry. Here is the format of a long file name entry.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (in bytes)
</th>
<th>Length (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>0
</td>
<td>1
</td>
<td>The order of this entry in the sequence of long file name entries. This value helps you to know where in the file's name the characters from this entry should be placed.
</td></tr>
<tr>
<td>1
</td>
<td>10
</td>
<td>The first 5, 2-byte characters of this entry.
</td></tr>
<tr>
<td>11
</td>
<td>1
</td>
<td>Attribute. Always equals 0x0F. (the long file name attribute)
</td></tr>
<tr>
<td>12
</td>
<td>1
</td>
<td>Long entry type. Zero for name entries.
</td></tr>
<tr>
<td>13
</td>
<td>1
</td>
<td>Checksum generated of the short file name when the file was created. The short filename can change without changing the long filename in cases where the partition is mounted on a system which does not support long filenames.
</td></tr>
<tr>
<td>14
</td>
<td>12
</td>
<td>The next 6, 2-byte characters of this entry.
</td></tr>
<tr>
<td>26
</td>
<td>2
</td>
<td>Always zero.
</td></tr>
<tr>
<td>28
</td>
<td>4
</td>
<td>The final 2, 2-byte characters of this entry.
</td></tr></tbody></table>
<p>Here is an example of what a regular 8.3 entry with one long file name entry preceding it might look like in a hex editor:
</p>
<pre>41 62 00 69 00 6E 00 00 00 FF FF 0F 00 7F FF FF FF FF FF FF FF FF FF FF FF FF 00 00 FF FF FF FF
42 49 4E 20 20 20 20 20 20 20 20 10 00 00 F7 01 D5 38 D5 38 00 00 F7 01 D5 38 03 00 00 00 00 00
</pre>
<p>And in a text editor:
</p>
<pre>Ab.i.n..........................
BIN        ......8.8.....8......
</pre>
<p>The first line is the long file name entry (the second line is the regular 8.3 entry). The very first byte (41) tells us two important pieces of information. First, the one (01) tells us that this is the first long file name entry for the regular 8.3 entry. Second the forty (40) part tells us that this is also the <i>last</i> long file name entry for this regular 8.3 entry. The next 10 bytes spell out the first part of the long file name. In this case they read:
</p>
<pre>b 00 i 00 n 00 00 00 FF FF
</pre>
<p>Notice that each character is two bytes long and that the name is null terminated. The two FF's at the end are the padding at the end of the long file name. This is also what the other FF's in the long file name entry are.
The final important thing to notice about the long file name entry is it's attribute byte at offset 11. the 0x0F attribute allows us to verify that this is indeed a long file name entry.
</p>
<h3><span class="mw-headline" id="Directories_on_exFAT">Directories on exFAT</span></h3>
<p>exFAT redesigned these directory entries from the ground up. 
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (in bytes)
</th>
<th>Length (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>0
</td>
<td>1
</td>
<td>Entry type
</td></tr>
<tr>
<td>1
</td>
<td>31
</td>
<td>Rest of entry.
</td></tr></tbody></table>
<p>The base for every entry is that they are all still 32 bytes, and they all start with the type in the first byte. The types I've encountered that are relevant for reading files from disk:
</p>
<h4><span class="mw-headline" id="File_entry">File entry</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (in bytes)
</th>
<th>Length (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>0
</td>
<td>1
</td>
<td>Entry type = 0x85
</td></tr>
<tr>
<td>1
</td>
<td>1
</td>
<td>Count of secondary entries.
</td></tr>
<tr>
<td>2
</td>
<td>2
</td>
<td>Checksum of entry set
</td></tr>
<tr>
<td>4
</td>
<td>2
</td>
<td>File attributes
</td></tr>
<tr>
<td>6
</td>
<td>2
</td>
<td>Reserved
</td></tr>
<tr>
<td>8
</td>
<td>4
</td>
<td>Creation date and time
</td></tr>
<tr>
<td>12
</td>
<td>4
</td>
<td>Modification date and time
</td></tr>
<tr>
<td>16
</td>
<td>4
</td>
<td>Access date and time
</td></tr>
<tr>
<td>20
</td>
<td>1
</td>
<td>Creation time in hundredths of a second (0-199) to be added to the FAT style date/time for more accuracy. See FAT12 entry for format of date/time.
</td></tr>
<tr>
<td>21
</td>
<td>1
</td>
<td>Modification time in hundredths of a second (0-199).
</td></tr>
<tr>
<td>22
</td>
<td>1
</td>
<td>UTC offset for creation time
</td></tr>
<tr>
<td>23
</td>
<td>1
</td>
<td>UTC offset for modification time
</td></tr>
<tr>
<td>24
</td>
<td>1
</td>
<td>UTC offset for access time
</td></tr>
<tr>
<td>25
</td>
<td>7
</td>
<td>Reserved.
</td></tr></tbody></table>
<h4><span id="Stream_.22extension.22_entry"></span><span class="mw-headline" id="Stream_&quot;extension&quot;_entry">Stream "extension" entry</span></h4>
<p>It's called an extension, but it's 100% required to exist directly after the "file" entry.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (in bytes)
</th>
<th>Length (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>0
</td>
<td>1
</td>
<td>Entry type = 0xC0
</td></tr>
<tr>
<td>1
</td>
<td>1
</td>
<td>Secondary flags
</td></tr>
<tr>
<td>2
</td>
<td>1
</td>
<td>Reserved
</td></tr>
<tr>
<td>3
</td>
<td>1
</td>
<td>Name length
</td></tr>
<tr>
<td>4
</td>
<td>2
</td>
<td>Name hash
</td></tr>
<tr>
<td>6
</td>
<td>2
</td>
<td>Reserved
</td></tr>
<tr>
<td>8
</td>
<td>8
</td>
<td>Valid data length. When writing large files, exFAT allocates the whole file first, and then incrementally updates this as data is written. Not sure what you're supposed to do with this, if it's not dataLength yell at the user?
</td></tr>
<tr>
<td>16
</td>
<td>4
</td>
<td>Reserved
</td></tr>
<tr>
<td>20
</td>
<td>4
</td>
<td>First cluster.
</td></tr>
<tr>
<td>24
</td>
<td>8
</td>
<td>Data length.
</td></tr></tbody></table>
<h4><span class="mw-headline" id="File_name_entry">File name entry</span></h4>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (in bytes)
</th>
<th>Length (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>0
</td>
<td>1
</td>
<td>Entry type = 0xC1
</td></tr>
<tr>
<td>1
</td>
<td>1
</td>
<td>flags
</td></tr>
<tr>
<td>2
</td>
<td>30
</td>
<td>File name characters (15 UTF16 code units).
</td></tr></tbody></table>
<p>To actually use these, they typically come in the order:
</p><p>- File entry
- Stream extension entry
- File name entry
- (Additional file name entries)
</p><p>The file entry has the file metadata info, the stream extension tells you how it's stored and the file name entries tell you what it's called. There is no 8.3 name any more.
</p><p>When reading the file, the second bit in the stream extension secondary flags indicates if it's stored as extent, or if you need to use the FAT table. If it is set, the file is contiguous and the FAT is not up to date, if it is clear, the FAT is accurate and needs to be used (but could still say it's contiguous).
</p>
<h4><span class="mw-headline" id="Long_File_Names_2">Long File Names</span></h4>
<p>Long file name entries <i>always</i> have a regular 8.3 entry to which they belong. The long file name entries are always placed immediately before their 8.3 entry. Here is the format of a long file name entry.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1&#125;&#125;&#125;">

<tbody><tr>
<th>Offset (in bytes)
</th>
<th>Length (in bytes)
</th>
<th>Meaning
</th></tr>
<tr>
<td>0
</td>
<td>1
</td>
<td>The order of this entry in the sequence of long file name entries. This value helps you to know where in the file's name the characters from this entry should be placed.
</td></tr>
<tr>
<td>1
</td>
<td>10
</td>
<td>The first 5, 2-byte characters of this entry.
</td></tr>
<tr>
<td>11
</td>
<td>1
</td>
<td>Attribute. Always equals 0x0F. (the long file name attribute)
</td></tr>
<tr>
<td>12
</td>
<td>1
</td>
<td>Long entry type. Zero for name entries.
</td></tr>
<tr>
<td>13
</td>
<td>1
</td>
<td>Checksum generated of the short file name when the file was created. The short filename can change without changing the long filename in cases where the partition is mounted on a system which does not support long filenames.
</td></tr>
<tr>
<td>14
</td>
<td>12
</td>
<td>The next 6, 2-byte characters of this entry.
</td></tr>
<tr>
<td>26
</td>
<td>2
</td>
<td>Always zero.
</td></tr>
<tr>
<td>28
</td>
<td>4
</td>
<td>The final 2, 2-byte characters of this entry.
</td></tr></tbody></table>
<p><br />
</p>
<h2><span class="mw-headline" id="Programming_Guide">Programming Guide</span></h2>
<p>This section is intended to give you information about common functions that are preformed on a FAT file system.
</p>
<h3><span class="mw-headline" id="Reading_the_Boot_Sector">Reading the Boot Sector</span></h3>
<p>The Boot Sector is always placed at logical sector number zero. You can either read the boot sector into an array and access it's members that way or you can read it into a structure and access it through the structure. Either way, the values in the boot sector need to be readily available in order to do much of anything with a FAT file system.
</p><p>Here is an example of some boot sector structures in C. 
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fat_extBS_32</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">//extended fat32 stuff</span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">		</span><span class="n">table_size_32</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">		</span><span class="n">extended_flags</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">		</span><span class="n">fat_version</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">		</span><span class="n">root_cluster</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">		</span><span class="n">fat_info</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">		</span><span class="n">backup_BS_sector</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> 		</span><span class="n">reserved_0</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">drive_number</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> 		</span><span class="n">reserved_1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">boot_signature</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> 		</span><span class="n">volume_id</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">volume_label</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">fat_type_label</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span><span class="w"></span>

<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span><span class="w"> </span><span class="n">fat_extBS_32_t</span><span class="p">;</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fat_extBS_16</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">//extended fat12 and fat16 stuff</span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">bios_drive_num</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">reserved1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">boot_signature</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">		</span><span class="n">volume_id</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">volume_label</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">fat_type_label</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span>
<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span><span class="w"> </span><span class="n">fat_extBS_16_t</span><span class="p">;</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fat_BS</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> 		</span><span class="n">bootjmp</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> 		</span><span class="n">oem_name</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> 	        </span><span class="n">bytes_per_sector</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">sectors_per_cluster</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">		</span><span class="n">reserved_sector_count</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">table_count</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">		</span><span class="n">root_entry_count</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">		</span><span class="n">total_sectors_16</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">media_type</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">		</span><span class="n">table_size_16</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">		</span><span class="n">sectors_per_track</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">		</span><span class="n">head_side_count</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> 		</span><span class="n">hidden_sector_count</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> 		</span><span class="n">total_sectors_32</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">//this will be cast to it&#39;s specific type once the driver actually knows what type of FAT this is.</span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="n">extended_section</span><span class="p">[</span><span class="mi">54</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span>
<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span><span class="w"> </span><span class="n">fat_BS_t</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Important pieces of information that can be extracted from the boot sector include:
</p><p><b>Total sectors in volume (including VBR):</b>
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">total_sectors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">total_sectors_16</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="w"> </span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">total_sectors_32</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">total_sectors_16</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p><b>FAT size in sectors:</b>
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">fat_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">table_size_16</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="w"> </span><span class="n">fat_boot_ext_32</span><span class="o">-&gt;</span><span class="n">table_size_16</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">table_size_16</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p><b>The size of the root directory (unless you have FAT32, in which case the size will be 0):</b>
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">root_dir_sectors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">root_entry_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">bytes_per_sector</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">bytes_per_sector</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>This calculation will round up. 32 is the size of a FAT directory in bytes.
</p><p><br />
<b>The first data sector (that is, the first sector in which directories and files may be stored):</b>
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">first_data_sector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">reserved_sector_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">table_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fat_size</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">root_dir_sectors</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p><br />
<b>The first sector in the File Allocation Table:</b>
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">first_fat_sector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">reserved_sector_count</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p><br />
<b>The total number of data sectors:</b>
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">data_sectors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_sectors</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">reserved_sector_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">table_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fat_size</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">root_dir_sectors</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p><br />
<b>The total number of clusters:</b>
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">total_clusters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_sectors</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">sectors_per_cluster</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>This rounds down.
</p><p><b>The FAT type of this file system:</b>
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sectorsize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">fat_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExFAT</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">total_clusters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4085</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">fat_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FAT12</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">total_clusters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">65525</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">fat_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FAT16</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span>
<span class="k">else</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">fat_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FAT32</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Reading_Directories">Reading Directories</span></h3>
<p>The first step in reading directories is finding and reading the root directory. On a FAT 12 or FAT 16 volumes the root directory is at a fixed position immediately after the File Allocation Tables:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">first_root_dir_sector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_data_sector</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">root_dir_sectors</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>In FAT32 and exFAT, root directory appears in data area on given cluster and can be a cluster chain. In exFAT it cannot be encoded as extent and will always be present in the FAT.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">root_cluster_32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extBS_32</span><span class="o">-&gt;</span><span class="n">root_cluster</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>For each given cluster number we can calculate the first sector of it (relative to the partition's offset):
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">first_sector_of_cluster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">cluster</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fat_boot</span><span class="o">-&gt;</span><span class="n">sectors_per_cluster</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">first_data_sector</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>After the correct cluster has been loaded into memory, the next step is to read and parse all of the entries in it. Each entry is 32 bytes long. For each 32 byte entry this is the flow of execution:
</p>
<ol><li>If the first byte of the entry is equal to 0 then there are no more files/directories in this directory. FirstByte==0, finish. FirstByte!=0, goto 2.</li>
<li>If the first byte of the entry is equal to 0xE5 then the entry is unused. FirstByte==0xE5, goto 8, FirstByte!=0xE5, goto 3.</li>
<li>Is this entry a long file name entry? If the 11'th byte of the entry equals 0x0F, then it is a long file name entry. Otherwise, it is not. 11thByte==0x0F, goto 4. 11thByte!=0x0F, goto 5.</li>
<li>Read the portion of the long filename into a temporary buffer. Goto 8.</li>
<li>Parse the data for this entry using the table from further up on this page. It would be a good idea to save the data for later. Possibly in a virtual file system structure. goto 6</li>
<li>Is there a long file name in the temporary buffer? Yes, goto 7. No, goto 8</li>
<li>Apply the long file name to the entry that you just read and clear the temporary buffer. goto 8</li>
<li>Increment pointers and/or counters and check the next entry. (goto number 1)</li></ol>
<p>This process should be repeated until all of the entries have been read from the cluster. You should then check to see if there is another cluster following this one in the cluster chain or if this is the last cluster in the chain. See <a href="FAT32#Following_Cluster_Chains">section below</a> and <a href="FAT32#File_Allocation_Table">FAT</a> section for more information. You should do the above process for each cluster in the chain, following it until there are no more clusters left in the chain. Then you can check if any of the entries that you just read are directories. If the are they should each be read in the same way starting with their first cluster number which is stored in the entry.
</p>
<h3><span class="mw-headline" id="Following_Cluster_Chains">Following Cluster Chains</span></h3>
<p>There are two basic steps to following cluster chains. The first step is to find out if there is another "link" (cluster) following the current one in the chain. The second step is to actually use the value read from the FAT to read the next sector. Here is the basic idea:
</p>
<ol><li>Extract the value from the FAT for the _current_ cluster. (Use the previous section on the File Allocation Table for details on how exactly to extract the value.) goto number 2</li>
<li>Is this cluster marked as the last cluster in the chain? (again, see the above section for more details) Yes, goto number 4. No, goto number 3</li>
<li>Read the cluster represented by the extracted value and return for more directory parsing.</li>
<li>The end of the cluster chain has been found. Our work here is finished.&#160;:)</li></ol>
<h3><span class="mw-headline" id="Reading_extents">Reading extents</span></h3>
<p>On exFAT, files can have a bit set in their flags that indicate it is stored as extent-based. This means that the whole file is contiguous, and that the file size plus the first cluster indicate where the (whole) file is. The FAT entries will contain garbage and are not to be trusted.
</p><p>To read this, do the same calculation as above, except you may in every step assume that the next cluster is the numerically next cluster and that enough sectors have been allocated for the file size.
</p>
<h2><span class="mw-headline" id="Creating_a_fresh_FAT_filesystem">Creating a fresh FAT filesystem</span></h2>
<p>Typically during development you want to create a disk image with a FAT filesystem. There are two common approaches for this, either by using a utility that works directly on images, or by using a <a href="Loopback_Device" title="Loopback Device">Loopback Device</a> and using the OS' own driver to work on the image. A less common alternative is to have an actual disk in your drive.
</p><p>The most buildscript-friendly tool is <a href="MTools" title="MTools">MTools</a> - which can do all operations directly on a disk image using the -i argument and supplies every DOS command related to files in this fashion, only prefixed with an <tt>m</tt>. It can also use a configuration file to access drives in their DOS fashion, allowing you to use for instance A: and C: as actual drives. The tool can be built out of the box for Windows and is included in many a linux package manager.
</p><p>Linux-only developers can, often with a bit of sudo and permission magic, automate the <a href="Loopback_Device" title="Loopback Device">Loopback Device</a> in combination with <tt>mkdosfs</tt> or <tt>mkfs.vfat</tt> as well as partition editing. This method is less portable as the commands often can't be reused outside of Linux. Several developers also make the error of passing -F to mkdosfs in an attempt to choose a FAT size, which often has the effect of creating a corrupt filesystem since the result doesn't follow <a href="FAT32#Reading_the_Boot_Sector">the official rule for FAT sizes anymore</a>.
</p><p>Windows users can make use of <a href="Virtual_Floppy_Drive" title="Virtual Floppy Drive">VFD</a> for loopback devices. It comes with a GUI, but at the cost of not being properly automatable in a script.
</p>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Threads">Threads</span></h3>
<ul><li>from raw bits to directory listing (code posted) in the <a href="http://forum.osdev.org/viewtopic.php?t=11247" class="extiw" title="topic:11247">forum</a></li>
<li>Public Domain FAT32 code in the <a href="http://forum.osdev.org/viewtopic.php?t=13993" class="extiw" title="topic:13993">forum</a></li>
<li>FAT12/FAT16 bootsector code in the <a href="http://forum.osdev.org/viewtopic.php?t=21155" class="extiw" title="topic:21155">forum</a></li></ul>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="http://www.osdever.net/downloads/docs/fatgen103.zip">FAT32 File System Specification</a> - from Cottontail OS Development Library</li>
<li><a rel="nofollow" class="external text" href="http://download.microsoft.com/download/1/6/1/161ba512-40e2-4cc9-843a-923143f3456c/fatgen103.doc">FAT32 File System Specification</a> - from Microsoft (documentation, but in tutorial style with many code examples)</li>
<li><a rel="nofollow" class="external text" href="http://board.flatassembler.net/topic.php?t=12680">About an error in the above specification</a></li>
<li><a rel="nofollow" class="external free" href="http://scottie.20m.com/fat.htm">http://scottie.20m.com/fat.htm</a></li>
<li><a rel="nofollow" class="external free" href="http://www.maverick-os.dk/FileSystemFormats/FAT12_FileSystem.html">http://www.maverick-os.dk/FileSystemFormats/FAT12_FileSystem.html</a></li>
<li><a rel="nofollow" class="external free" href="http://www.pjrc.com/tech/8051/ide/fat32.html">http://www.pjrc.com/tech/8051/ide/fat32.html</a></li>
<li><a rel="nofollow" class="external text" href="http://web.archive.org/web/20170112194555/http://www.viralpatel.net/taj/tutorial/fat.php">Intro into Sectors and Addressing</a></li>
<li><a rel="nofollow" class="external free" href="http://elm-chan.org/fsw/ff/00index_e.html">http://elm-chan.org/fsw/ff/00index_e.html</a> - simple (V)FAT12/16/32 read/write library with good documentation</li>
<li><a rel="nofollow" class="external free" href="http://gitorious.org/unix-stuff/fat-util">http://gitorious.org/unix-stuff/fat-util</a> - Utility to read, remove and extract files on FAT12, 16 and 32</li>
<li><a rel="nofollow" class="external free" href="http://www.larwe.com/zws/products/dosfs/index.html">http://www.larwe.com/zws/products/dosfs/index.html</a> - fat12/16/32 compatible fs driver</li>
<li><a rel="nofollow" class="external free" href="http://www.isdaman.com/alsos/protocols/fats/nowhere/FAT.HTM">http://www.isdaman.com/alsos/protocols/fats/nowhere/FAT.HTM</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250212010835
Cache expiry: 86400
Reduced expiry: false
Complications: [showtoc]
CPU time usage: 0.128 seconds
Real time usage: 2.199 seconds
Preprocessor visited node count: 597/1000000
Postexpand include size: 5536/2097152 bytes
Template argument size: 2363/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 30211/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  554.448      1 -total
  1.14%    6.343      1 Template:Filesystems
  0.98%    5.421      1 Template:SmallNavBox
  0.72%    3.968     20 Template:If
  0.47%    2.618     20 Template:Show1
  0.09%    0.478     14 Template:Wikitable
  0.07%    0.366      1 Template:Main
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1506-0!canonical and timestamp 20250212010833 and revision id 28959.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=FAT&amp;oldid=28959#FAT_32">https://wiki.osdev.org/index.php?title=FAT&amp;oldid=28959#FAT_32</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_duplicate_arguments_in_template_calls&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using duplicate arguments in template calls (page does not exist)">Pages using duplicate arguments in template calls</a></li><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Filesystems" title="Category:Filesystems">Filesystems</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=FAT" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="FAT32#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="FAT" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:FAT" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="FAT"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=FAT&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=FAT&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/FAT" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="./Special:RecentChangesLinked/FAT" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=FAT&amp;oldid=28959" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=FAT&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/FAT" title="FAT  Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 6 June 2024, at 17:17.</li>
	<li id="footer-info-0">This page has been accessed 40,463 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=FAT&amp;mobileaction=toggle_view_mobile#FAT_32" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.128","walltime":"2.199","ppvisitednodes":{"value":597,"limit":1000000},"postexpandincludesize":{"value":5536,"limit":2097152},"templateargumentsize":{"value":2363,"limit":2097152},"expansiondepth":{"value":8,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":30211,"limit":5000000},"timingprofile":["100.00%  554.448      1 -total","  1.14%    6.343      1 Template:Filesystems","  0.98%    5.421      1 Template:SmallNavBox","  0.72%    3.968     20 Template:If","  0.47%    2.618     20 Template:Show1","  0.09%    0.478     14 Template:Wikitable","  0.07%    0.366      1 Template:Main"]},"cachereport":{"timestamp":"20250212010835","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":109});});</script>
</body>
</html>