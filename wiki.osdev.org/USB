<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Universal Serial Bus - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"acbde31717e8b1dfa2a773d1","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Universal_Serial_Bus","wgTitle":"Universal Serial Bus","wgCurRevisionId":27651,"wgRevisionId":27651,"wgArticleId":1725,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["USB","Buses"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Universal_Serial_Bus","wgRelevantArticleId":1725,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":"USB",
"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgInternalRedirectTargetUrl":"/Universal_Serial_Bus","wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","mediawiki.page.gallery.styles":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head","mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.visualEditor.desktopArticleTarget.noscript%7Cmediawiki.page.gallery.styles%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="Universal_Serial_Bus"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Universal_Serial_Bus rootpage-Universal_Serial_Bus skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Universal Serial Bus</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"><span class="mw-redirectedfrom">(Redirected from <a href="https://wiki.osdev.org/index.php?title=USB&amp;redirect=no" class="mw-redirect" title="USB">USB</a>)</span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="USB#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="USB#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>The Universal Serial Bus was first introduced in 1994 with the intention of replacing various specialized interfaces, and to simplify the configuration of communication devices.  The communication industry did not develop as the USB-IF foresaw, but the various transfer modes that USB introduced allowed it to become one of the most popular standards in use today.  Virtually every modern computer supports USB.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="USB#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="USB#What_this_text_covers"><span class="tocnumber">1.1</span> <span class="toctext">What this text covers</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="USB#What_this_text_does_not_cover"><span class="tocnumber">1.2</span> <span class="toctext">What this text does not cover</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="USB#Host_Controllers"><span class="tocnumber">2</span> <span class="toctext">Host Controllers</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="USB#USB_1.0_Host_Controllers"><span class="tocnumber">2.1</span> <span class="toctext">USB 1.0 Host Controllers</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="USB#USB_2.0_Host_Controllers"><span class="tocnumber">2.2</span> <span class="toctext">USB 2.0 Host Controllers</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="USB#USB_3.0_Host_Controllers"><span class="tocnumber">2.3</span> <span class="toctext">USB 3.0 Host Controllers</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="USB#Basic_Concepts_and_Nomenclature"><span class="tocnumber">3</span> <span class="toctext">Basic Concepts and Nomenclature</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="USB#USB_System"><span class="tocnumber">3.1</span> <span class="toctext">USB System</span></a>
<ul>
<li class="toclevel-3 tocsection-10"><a href="USB#USB_Device(s)"><span class="tocnumber">3.1.1</span> <span class="toctext">USB Device(s)</span></a>
<ul>
<li class="toclevel-4 tocsection-11"><a href="USB#Functions"><span class="tocnumber">3.1.1.1</span> <span class="toctext">Functions</span></a></li>
<li class="toclevel-4 tocsection-12"><a href="USB#Hubs"><span class="tocnumber">3.1.1.2</span> <span class="toctext">Hubs</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-13"><a href="USB#USB_Interconnect"><span class="tocnumber">3.1.2</span> <span class="toctext">USB Interconnect</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="USB#USB_Host"><span class="tocnumber">3.1.3</span> <span class="toctext">USB Host</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-15"><a href="USB#USB_Communication_Flow"><span class="tocnumber">3.2</span> <span class="toctext">USB Communication Flow</span></a>
<ul>
<li class="toclevel-3 tocsection-16"><a href="USB#Device_Endpoints_and_Endpoint_Numbers"><span class="tocnumber">3.2.1</span> <span class="toctext">Device Endpoints and Endpoint Numbers</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="USB#Endpoint_Zero"><span class="tocnumber">3.2.2</span> <span class="toctext">Endpoint Zero</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="USB#Pipes"><span class="tocnumber">3.2.3</span> <span class="toctext">Pipes</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="USB#Default_Control_Pipe"><span class="tocnumber">3.2.4</span> <span class="toctext">Default Control Pipe</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-20"><a href="USB#Basics_of_USB_Transfers"><span class="tocnumber">3.3</span> <span class="toctext">Basics of USB Transfers</span></a>
<ul>
<li class="toclevel-3 tocsection-21"><a href="USB#Control_Transfers"><span class="tocnumber">3.3.1</span> <span class="toctext">Control Transfers</span></a>
<ul>
<li class="toclevel-4 tocsection-22"><a href="USB#Maximum_Data_Payload_Size"><span class="tocnumber">3.3.1.1</span> <span class="toctext">Maximum Data Payload Size</span></a></li>
<li class="toclevel-4 tocsection-23"><a href="USB#Transmission_Errors"><span class="tocnumber">3.3.1.2</span> <span class="toctext">Transmission Errors</span></a>
<ul>
<li class="toclevel-5 tocsection-24"><a href="USB#Too_Much_Data"><span class="tocnumber">3.3.1.2.1</span> <span class="toctext">Too Much Data</span></a></li>
<li class="toclevel-5 tocsection-25"><a href="USB#Bus_Errors"><span class="tocnumber">3.3.1.2.2</span> <span class="toctext">Bus Errors</span></a></li>
<li class="toclevel-5 tocsection-26"><a href="USB#Halt_Conditions"><span class="tocnumber">3.3.1.2.3</span> <span class="toctext">Halt Conditions</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-3 tocsection-27"><a href="USB#Bulk_Data_Transfers"><span class="tocnumber">3.3.2</span> <span class="toctext">Bulk Data Transfers</span></a>
<ul>
<li class="toclevel-4 tocsection-28"><a href="USB#Maximum_Data_Payload_Size_2"><span class="tocnumber">3.3.2.1</span> <span class="toctext">Maximum Data Payload Size</span></a></li>
<li class="toclevel-4 tocsection-29"><a href="USB#Transmission_Errors_2"><span class="tocnumber">3.3.2.2</span> <span class="toctext">Transmission Errors</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-30"><a href="USB#Interrupt_Data_Transfers"><span class="tocnumber">3.3.3</span> <span class="toctext">Interrupt Data Transfers</span></a>
<ul>
<li class="toclevel-4 tocsection-31"><a href="USB#Maximum_Data_Payload_Size_3"><span class="tocnumber">3.3.3.1</span> <span class="toctext">Maximum Data Payload Size</span></a></li>
<li class="toclevel-4 tocsection-32"><a href="USB#Transmission_Errors_3"><span class="tocnumber">3.3.3.2</span> <span class="toctext">Transmission Errors</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-33"><a href="USB#Isochronous_Data_Transfers"><span class="tocnumber">3.3.4</span> <span class="toctext">Isochronous Data Transfers</span></a>
<ul>
<li class="toclevel-4 tocsection-34"><a href="USB#Maximum_Data_Payload_Size_4"><span class="tocnumber">3.3.4.1</span> <span class="toctext">Maximum Data Payload Size</span></a></li>
<li class="toclevel-4 tocsection-35"><a href="USB#Transmission_Errors_4"><span class="tocnumber">3.3.4.2</span> <span class="toctext">Transmission Errors</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-36"><a href="USB#Advanced_USB_Concepts"><span class="tocnumber">4</span> <span class="toctext">Advanced USB Concepts</span></a>
<ul>
<li class="toclevel-2 tocsection-37"><a href="USB#Distribution_of_Bus_Access_Time"><span class="tocnumber">4.1</span> <span class="toctext">Distribution of Bus Access Time</span></a>
<ul>
<li class="toclevel-3 tocsection-38"><a href="USB#Frames_and_Microframes"><span class="tocnumber">4.1.1</span> <span class="toctext">Frames and Microframes</span></a></li>
<li class="toclevel-3 tocsection-39"><a href="USB#Bus_Time_Rationing"><span class="tocnumber">4.1.2</span> <span class="toctext">Bus Time Rationing</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-40"><a href="USB#High-Speed,_High-Bandwidth_Endpoints"><span class="tocnumber">4.2</span> <span class="toctext">High-Speed, High-Bandwidth Endpoints</span></a></li>
<li class="toclevel-2 tocsection-41"><a href="USB#Supporting_Isochronous_Transfers"><span class="tocnumber">4.3</span> <span class="toctext">Supporting Isochronous Transfers</span></a>
<ul>
<li class="toclevel-3 tocsection-42"><a href="USB#Synchronization"><span class="tocnumber">4.3.1</span> <span class="toctext">Synchronization</span></a>
<ul>
<li class="toclevel-4 tocsection-43"><a href="USB#Asynchronous_Endpoints"><span class="tocnumber">4.3.1.1</span> <span class="toctext">Asynchronous Endpoints</span></a></li>
<li class="toclevel-4 tocsection-44"><a href="USB#Synchronous_Endpoints"><span class="tocnumber">4.3.1.2</span> <span class="toctext">Synchronous Endpoints</span></a></li>
<li class="toclevel-4 tocsection-45"><a href="USB#Adaptive_Endpoints"><span class="tocnumber">4.3.1.3</span> <span class="toctext">Adaptive Endpoints</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-46"><a href="USB#Handling_Errors"><span class="tocnumber">4.3.2</span> <span class="toctext">Handling Errors</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-47"><a href="USB#USB_Protocol"><span class="tocnumber">5</span> <span class="toctext">USB Protocol</span></a>
<ul>
<li class="toclevel-2 tocsection-48"><a href="USB#Packets"><span class="tocnumber">5.1</span> <span class="toctext">Packets</span></a>
<ul>
<li class="toclevel-3 tocsection-49"><a href="USB#SYNC_Field"><span class="tocnumber">5.1.1</span> <span class="toctext">SYNC Field</span></a></li>
<li class="toclevel-3 tocsection-50"><a href="USB#Packet_Identifier_Field"><span class="tocnumber">5.1.2</span> <span class="toctext">Packet Identifier Field</span></a></li>
<li class="toclevel-3 tocsection-51"><a href="USB#Address_Fields"><span class="tocnumber">5.1.3</span> <span class="toctext">Address Fields</span></a>
<ul>
<li class="toclevel-4 tocsection-52"><a href="USB#Address_Field"><span class="tocnumber">5.1.3.1</span> <span class="toctext">Address Field</span></a></li>
<li class="toclevel-4 tocsection-53"><a href="USB#Endpoint_Field"><span class="tocnumber">5.1.3.2</span> <span class="toctext">Endpoint Field</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-54"><a href="USB#Data_Field"><span class="tocnumber">5.1.4</span> <span class="toctext">Data Field</span></a></li>
<li class="toclevel-3 tocsection-55"><a href="USB#Cyclic_Redundancy_Checks"><span class="tocnumber">5.1.5</span> <span class="toctext">Cyclic Redundancy Checks</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-56"><a href="USB#Handshakes"><span class="tocnumber">5.2</span> <span class="toctext">Handshakes</span></a>
<ul>
<li class="toclevel-3 tocsection-57"><a href="USB#Handshake_Packets"><span class="tocnumber">5.2.1</span> <span class="toctext">Handshake Packets</span></a>
<ul>
<li class="toclevel-4 tocsection-58"><a href="USB#ACK"><span class="tocnumber">5.2.1.1</span> <span class="toctext">ACK</span></a></li>
<li class="toclevel-4 tocsection-59"><a href="USB#NAK"><span class="tocnumber">5.2.1.2</span> <span class="toctext">NAK</span></a></li>
<li class="toclevel-4 tocsection-60"><a href="USB#STALL"><span class="tocnumber">5.2.1.3</span> <span class="toctext">STALL</span></a></li>
<li class="toclevel-4 tocsection-61"><a href="USB#NYET"><span class="tocnumber">5.2.1.4</span> <span class="toctext">NYET</span></a></li>
<li class="toclevel-4 tocsection-62"><a href="USB#ERR"><span class="tocnumber">5.2.1.5</span> <span class="toctext">ERR</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-63"><a href="USB#Function/Host_Response_Circumstances"><span class="tocnumber">5.2.2</span> <span class="toctext">Function/Host Response Circumstances</span></a>
<ul>
<li class="toclevel-4 tocsection-64"><a href="USB#Function_Response_to_IN_Transactions"><span class="tocnumber">5.2.2.1</span> <span class="toctext">Function Response to IN Transactions</span></a></li>
<li class="toclevel-4 tocsection-65"><a href="USB#Host_Response_to_IN_Transactions"><span class="tocnumber">5.2.2.2</span> <span class="toctext">Host Response to IN Transactions</span></a></li>
<li class="toclevel-4 tocsection-66"><a href="USB#Function_Response_to_OUT_Transactions"><span class="tocnumber">5.2.2.3</span> <span class="toctext">Function Response to OUT Transactions</span></a></li>
<li class="toclevel-4 tocsection-67"><a href="USB#Function_Response_to_SETUP_Transactions"><span class="tocnumber">5.2.2.4</span> <span class="toctext">Function Response to SETUP Transactions</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-68"><a href="USB#PING_Transaction_Protocol"><span class="tocnumber">5.3</span> <span class="toctext">PING Transaction Protocol</span></a></li>
<li class="toclevel-2 tocsection-69"><a href="USB#Data_Toggle_Synchronization"><span class="tocnumber">5.4</span> <span class="toctext">Data Toggle Synchronization</span></a>
<ul>
<li class="toclevel-3 tocsection-70"><a href="USB#Successful_transmissions"><span class="tocnumber">5.4.1</span> <span class="toctext">Successful transmissions</span></a></li>
<li class="toclevel-3 tocsection-71"><a href="USB#Failed_or_corrupted_data_transmissions"><span class="tocnumber">5.4.2</span> <span class="toctext">Failed or corrupted data transmissions</span></a></li>
<li class="toclevel-3 tocsection-72"><a href="USB#Failed_or_corrupted_ACK_handshake"><span class="tocnumber">5.4.3</span> <span class="toctext">Failed or corrupted ACK handshake</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-73"><a href="USB#USB_Transfers_Revisited"><span class="tocnumber">5.5</span> <span class="toctext">USB Transfers Revisited</span></a>
<ul>
<li class="toclevel-3 tocsection-74"><a href="USB#Control_Transfers_2"><span class="tocnumber">5.5.1</span> <span class="toctext">Control Transfers</span></a></li>
<li class="toclevel-3 tocsection-75"><a href="USB#Bulk_and_Interrupt_Transfers"><span class="tocnumber">5.5.2</span> <span class="toctext">Bulk and Interrupt Transfers</span></a></li>
<li class="toclevel-3 tocsection-76"><a href="USB#Isochronous_Transfers"><span class="tocnumber">5.5.3</span> <span class="toctext">Isochronous Transfers</span></a></li>
<li class="toclevel-3 tocsection-77"><a href="USB#High-Speed,_High-Bandwidth_Isochronous_Transfers"><span class="tocnumber">5.5.4</span> <span class="toctext">High-Speed, High-Bandwidth Isochronous Transfers</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-78"><a href="USB#USB_Device_Framework"><span class="tocnumber">6</span> <span class="toctext">USB Device Framework</span></a>
<ul>
<li class="toclevel-2 tocsection-79"><a href="USB#Functions,_Configurations,_Interfaces,_and_Endpoints"><span class="tocnumber">6.1</span> <span class="toctext">Functions, Configurations, Interfaces, and Endpoints</span></a></li>
<li class="toclevel-2 tocsection-80"><a href="USB#USB_Device_States"><span class="tocnumber">6.2</span> <span class="toctext">USB Device States</span></a></li>
<li class="toclevel-2 tocsection-81"><a href="USB#Remote_Wakeup_Capability"><span class="tocnumber">6.3</span> <span class="toctext">Remote Wakeup Capability</span></a></li>
<li class="toclevel-2 tocsection-82"><a href="USB#USB_Device_Enumeration"><span class="tocnumber">6.4</span> <span class="toctext">USB Device Enumeration</span></a></li>
<li class="toclevel-2 tocsection-83"><a href="USB#USB_Device_Requests"><span class="tocnumber">6.5</span> <span class="toctext">USB Device Requests</span></a></li>
<li class="toclevel-2 tocsection-84"><a href="USB#Standard_Requests"><span class="tocnumber">6.6</span> <span class="toctext">Standard Requests</span></a>
<ul>
<li class="toclevel-3 tocsection-85"><a href="USB#SET_ADDRESS"><span class="tocnumber">6.6.1</span> <span class="toctext">SET_ADDRESS</span></a></li>
<li class="toclevel-3 tocsection-86"><a href="USB#GET_DESCRIPTOR"><span class="tocnumber">6.6.2</span> <span class="toctext">GET_DESCRIPTOR</span></a></li>
<li class="toclevel-3 tocsection-87"><a href="USB#SET_DESCRIPTOR"><span class="tocnumber">6.6.3</span> <span class="toctext">SET_DESCRIPTOR</span></a></li>
<li class="toclevel-3 tocsection-88"><a href="USB#GET_CONFIGURATION"><span class="tocnumber">6.6.4</span> <span class="toctext">GET_CONFIGURATION</span></a></li>
<li class="toclevel-3 tocsection-89"><a href="USB#SET_CONFIGURATION"><span class="tocnumber">6.6.5</span> <span class="toctext">SET_CONFIGURATION</span></a></li>
<li class="toclevel-3 tocsection-90"><a href="USB#GET_INTERFACE"><span class="tocnumber">6.6.6</span> <span class="toctext">GET_INTERFACE</span></a></li>
<li class="toclevel-3 tocsection-91"><a href="USB#SET_INTERFACE"><span class="tocnumber">6.6.7</span> <span class="toctext">SET_INTERFACE</span></a></li>
<li class="toclevel-3 tocsection-92"><a href="USB#CLEAR_FEATURE"><span class="tocnumber">6.6.8</span> <span class="toctext">CLEAR_FEATURE</span></a></li>
<li class="toclevel-3 tocsection-93"><a href="USB#SET_FEATURE"><span class="tocnumber">6.6.9</span> <span class="toctext">SET_FEATURE</span></a></li>
<li class="toclevel-3 tocsection-94"><a href="USB#GET_STATUS"><span class="tocnumber">6.6.10</span> <span class="toctext">GET_STATUS</span></a>
<ul>
<li class="toclevel-4 tocsection-95"><a href="USB#Device_Recipient"><span class="tocnumber">6.6.10.1</span> <span class="toctext">Device Recipient</span></a></li>
<li class="toclevel-4 tocsection-96"><a href="USB#Interface_Recipient"><span class="tocnumber">6.6.10.2</span> <span class="toctext">Interface Recipient</span></a></li>
<li class="toclevel-4 tocsection-97"><a href="USB#Endpoint_Recipient"><span class="tocnumber">6.6.10.3</span> <span class="toctext">Endpoint Recipient</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-98"><a href="USB#SYNCH_FRAME"><span class="tocnumber">6.6.11</span> <span class="toctext">SYNCH_FRAME</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-99"><a href="USB#Standard_USB_Descriptors"><span class="tocnumber">6.7</span> <span class="toctext">Standard USB Descriptors</span></a>
<ul>
<li class="toclevel-3 tocsection-100"><a href="USB#DEVICE"><span class="tocnumber">6.7.1</span> <span class="toctext">DEVICE</span></a></li>
<li class="toclevel-3 tocsection-101"><a href="USB#DEVICE_QUALIFIER"><span class="tocnumber">6.7.2</span> <span class="toctext">DEVICE_QUALIFIER</span></a></li>
<li class="toclevel-3 tocsection-102"><a href="USB#CONFIGURATION"><span class="tocnumber">6.7.3</span> <span class="toctext">CONFIGURATION</span></a></li>
<li class="toclevel-3 tocsection-103"><a href="USB#OTHER_SPEED_CONFIGURATION"><span class="tocnumber">6.7.4</span> <span class="toctext">OTHER_SPEED_CONFIGURATION</span></a></li>
<li class="toclevel-3 tocsection-104"><a href="USB#INTERFACE"><span class="tocnumber">6.7.5</span> <span class="toctext">INTERFACE</span></a></li>
<li class="toclevel-3 tocsection-105"><a href="USB#ENDPOINT"><span class="tocnumber">6.7.6</span> <span class="toctext">ENDPOINT</span></a></li>
<li class="toclevel-3 tocsection-106"><a href="USB#STRING"><span class="tocnumber">6.7.7</span> <span class="toctext">STRING</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-107"><a href="USB#Typical_organization_of_system_software"><span class="tocnumber">7</span> <span class="toctext">Typical organization of system software</span></a>
<ul>
<li class="toclevel-2 tocsection-108"><a href="USB#USB_Device_Drivers"><span class="tocnumber">7.1</span> <span class="toctext">USB Device Drivers</span></a></li>
<li class="toclevel-2 tocsection-109"><a href="USB#USB_Driver"><span class="tocnumber">7.2</span> <span class="toctext">USB Driver</span></a></li>
<li class="toclevel-2 tocsection-110"><a href="USB#USB_Hub_Driver"><span class="tocnumber">7.3</span> <span class="toctext">USB Hub Driver</span></a></li>
<li class="toclevel-2 tocsection-111"><a href="USB#Host_Controller_Driver"><span class="tocnumber">7.4</span> <span class="toctext">Host Controller Driver</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-112"><a href="USB#See_Also"><span class="tocnumber">8</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-113"><a href="USB#External_Links"><span class="tocnumber">8.1</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Introduction">Introduction</span></h2>
<p>Despite how attractive USB support is, the 650-page USB 2.0 specification manages to deter even some of the most driven hobbyists (especially if English isn't their primary language).  Not only is the USB 2.0 specification long, but it's a prerequisite for the <a href="XHCI" class="mw-redirect" title="XHCI">XHCI</a>, <a href="EHCI" class="mw-redirect" title="EHCI">EHCI</a>, <a href="UHCI" class="mw-redirect" title="UHCI">UHCI</a>, and <a href="OHCI" class="mw-redirect" title="OHCI">OHCI</a> specifications, which define the actual hardware OSes interface with. Furthermore, the USB specification defines a plethora of terms, some used interchangeably and seemingly lazily; as a lengthy technical document, it is neither easy nor practical to flip back and forth to clarify a confusing term or concept.
</p>
<h3><span class="mw-headline" id="What_this_text_covers">What this text covers</span></h3>
<p>The truth is that a software developer doesn't need to read the entire USB 2.0 specification; there are sections specific to hardware developers, for example.  The information presented here attempts to summarize chapters 4, 5, and 8 through 10.
</p><p>Chapter 11 is specific to hubs and is also essential for a full USB 2.0 implementation, however it is almost as long as chapters 4, 5, 8, 9, and 10 combined, and could be regarded as the documentation for a specific (albeit special) class of USB devices.  Chapter 11 is covered thusly in its own wiki entry, <a href="USB_Hubs" title="USB Hubs">USB Hubs</a>.  Even so, some concepts which pertain to USB hubs are briefly discussed where relevant in this article.
</p><p>Ideally, the text here will establish familiarity with the terms and concepts that a hobby OS developer needs to begin implementing USB support and, if necessary, easily parse the USB specification without becoming intimidated by the amount of information.  At the very least, the system programmer should keep a copy of the USB 2.0 specification for reference while working with USB-related hardware.
</p><p>Fortunately, all of the necessary documentation is available for free (see <a rel="nofollow" class="external text" href="USB#Links">Links</a>).
</p>
<h3><span class="mw-headline" id="What_this_text_does_not_cover">What this text does not cover</span></h3>
<p>Please note that USB, unlike other standards like <a href="VGA" class="mw-redirect" title="VGA">VGA</a> or <a href="PCI" title="PCI">PCI</a>, is agnostic of the hardware interface to the system bus (and, by extension, to the operating system).  Such an interface is provided by one or more <a href="USB#Host_Controllers">USB host controllers</a> and is defined by the appropriate documentation.  Therefore, one should not expect this text to discuss specifics or code samples (e.g., as one finds in the wiki entries about <a href="VGA" class="mw-redirect" title="VGA">VGA</a> or <a href="PCI" title="PCI">PCI</a>) detailing how the operating system initiates and maintains communication with USB devices.  Although such information may be found on wiki entries discussing a particular <a href="USB#Host_Controller_Driver">Host Controller Driver</a>, those wiki entries assume an understanding of the concepts and terms discussed here.
</p>
<h2><span class="mw-headline" id="Host_Controllers">Host Controllers</span></h2>
<p>The <b>Host Controller</b> is the USB interface to the host computer system.  In other words, the host controller is what the system software uses to communicate with USB devices.
</p>
<h3><span class="mw-headline" id="USB_1.0_Host_Controllers">USB 1.0 Host Controllers</span></h3>
<dl><dd><i>Main article:</i> <a href="Universal_Host_Controller_Interface" title="Universal Host Controller Interface">Universal Host Controller Interface</a></dd>
<dd><i>Main article:</i> <a href="Open_Host_Controller_Interface" title="Open Host Controller Interface">Open Host Controller Interface</a></dd></dl>
<p>Intel brought USB 1.0 to the market with its <b>Universal Host Controller Interface</b> (<b>UHCI</b>), while Compaq, Microsoft, and National Semiconductors did the same with their <b>Open Host Controller Interface</b> (<b>OHCI</b>).  Naturally, the two interfaces are incompatible, and to make things worse, VIA Technologies licensed Intel's UHCI standard, thereby ensuring that both standards survived.  Typically, an on-board chip set will contain a UHCI implementation, whereas a peripheral card typically implements the OHCI standard (but this is by no means a guarantee).
</p>
<h3><span class="mw-headline" id="USB_2.0_Host_Controllers">USB 2.0 Host Controllers</span></h3>
<dl><dd><i>Main article:</i> <a href="Enhanced_Host_Controller_Interface" title="Enhanced Host Controller Interface">Enhanced Host Controller Interface</a></dd></dl>
<div class="thumb tright"><div class="thumbinner" style="width:315px;"><a href="./File:PortRoutingBlockDiagram.gif" class="image"><img alt="" src="images/b/b5/PortRoutingBlockDiagram.gif" decoding="async" width="313" height="223" class="thumbimage" data-file-width="313" data-file-height="223" /></a>  <div class="thumbcaption">Figure 1: Block Diagram of Port Routing Behavior</div></div></div>
<p>In designing USB 2.0, the USB-IF insisted on a single implementation.  That single implementation is Intel's <b>Enhanced Host Controller Interface</b> (<b>EHCI</b>).  However, even though the USB 2.0 specification requires that a USB 2.0 interface support USB 1.0 devices, this doesn't mean that the EHCI must support USB 1.0 devices, and in fact, it doesn't.  Each EHCI host controller is accompanied by (usually several) UHCI and/or OHCI host controllers.  When a USB 1.0 device is attached, the EHCI simply hands control over to a <b>companion controller</b>.  Refer to figure 1 for a simple block diagram implementation of this behavior.  Therefore, the system programmer must support all three standards in order to support USB 2.0. 
</p><p>The EHCI host controller only handles USB 1.0 devices if they are attached indirectly through a USB 2.0 hub.  The specifics of handling USB 1.0 devices attached to a USB 2.0 hub are briefly discussed and illustrated in the <a href="USB#Hubs">hubs</a> section, and in more detail in the wiki entry for <a href="USB_Hubs" title="USB Hubs">USB Hubs</a>. Note that some newer chipsets like the Intel 5-series chipsets do not have companion controllers at all and instead have internal "rate matching" hubs that all USB devices go through.
</p>
<h3><span class="mw-headline" id="USB_3.0_Host_Controllers">USB 3.0 Host Controllers</span></h3>
<dl><dd><i>Main article:</i> <a href="EXtensible_Host_Controller_Interface" title="EXtensible Host Controller Interface">eXtensible Host Controller Interface</a></dd></dl>
<p>Like its predecessor USB 2.0, USB 3.0 has only one host controller specification: Intel's <b>eXtensible Host Controller Interface</b>. Unlike its predecessor EHCI, however, xHCI controllers can and do interface with USB 1.0 and 2.0 devices without the use of companion controllers. Even on early hardware where there was both an EHCI and xHCI controller included (so that OSes which did not yet support xHCI could still use at least some USB devices), ports attached to the EHCI controller could generally be "re-routed" to the xHCI controller, and the EHCI controller disabled entirely.
</p><p>Also unlike its predecessors, xHCI was designed with some degree of <i>forwards compatibility</i>, so that revisions to the USB specification can be made without designing a new host controller interface (for instance, USB 3.1 and 3.2 add new speeds, with only minor updates to the specification to match them.) Unfortunately, this means that xHCI bears only a passing resemblance to the controllers that came before it, and make it challenging to write drivers for.
</p>
<h2><span class="mw-headline" id="Basic_Concepts_and_Nomenclature">Basic Concepts and Nomenclature</span></h2>
<p>The USB is a polled bus, meaning the host controller must initiate all transfers.  Do not mistake this to mean that the system software must poll the USB.  The host controller takes care of polling the bus and can be programmed to issue interrupts to the OS whenever the bus needs attention.
</p>
<h3><span class="mw-headline" id="USB_System">USB System</span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:270px;"><a href="./File:USBSystem.gif" class="image"><img alt="" src="images/a/a9/USBSystem.gif" decoding="async" width="268" height="317" class="thumbimage" data-file-width="268" data-file-height="317" /></a>  <div class="thumbcaption">Figure 2: USB System Illustration</div></div></div>
<p>A <b>USB System</b> consists of three discrete parts: the <b>USB device(s)</b>, the <b>USB interconnect</b>, and the <b>USB host</b>.  Figure 2 illustrates a USB System.
</p>
<h4><span id="USB_Device.28s.29"></span><span class="mw-headline" id="USB_Device(s)">USB Device(s)</span></h4>
<p><b>USB devices</b> are classified as either a <b>hub</b> or a <b>function</b> (not to be confused with a program procedure).  Hubs provide additional attachment points, whereas functions provide capabilities to the system.  Some devices may implement several functions and an embedded hub in one physical package.  These are called <b>compound devices</b>.
</p>
<h5><span class="mw-headline" id="Functions">Functions</span></h5>
<p>All functions understand the USB protocol, respond to standard operations (e.g, configuration or reset), and describe capabilities to the USB host.
</p><p>There are four speed classes of functions:
</p>
<ul><li><b>Super-speed</b> functions operate at up to 5 Gb/s.</li>
<li><b>High-speed</b> functions operate at up to 480 Mb/s.</li>
<li><b>Full-speed</b> functions operate at up to 12 Mb/s.</li>
<li><b>Low-speed</b> functions operate at up to 1.5 Mb/s.</li></ul>
<p>The original USB specification defined low- and full-speed devices, while USB 2.0 added high-speed devices and USB 3.0 added super-speed devices.
</p>
<h5><span class="mw-headline" id="Hubs">Hubs</span></h5>
<p>In a high-speed system, a high-speed hub plays a special role.  Since the high-speed hub establishes a high-speed transfer rate with the host, it must isolate any full- or low-speed signaling from both the host and any attached high-speed devices.
</p><p>To better understand, consider that the EHCI controller is accompanied by one or more companion controllers, as illustrated in figure 1 above.  When a full- or low-speed device is attached directly to the root hub, the EHCI controller can relinquish ownership of that specific port to a companion controller as seen in figure 3.  However, if a high-speed hub is connected to a port, as in Figure 4, then the EHCI controller must retain ownership of the port because it is a high-speed device.  Now suppose other high-speed devices are attached to the high-speed hub in figure 4; obviously the EHCI controller retains control as in figure 5.
</p><p>But what happens when a full- or low-speed device is connected to the high-speed hub in figure 5?  If the EHCI controller were to relinquish ownership of the port, the high-speed devices will no longer be able to operate at high-speed, if at all, as in figure 6.  Instead, the host controller and the hub support a special type of transaction called a split transaction.  A <b>split transaction</b> involves only the host controller and a high-speed hub; it is transparent to any devices.  This scheme of using split-transaction to support low- and full-speed devices on a high-speed hub is illustrated in figure 7.
</p><p>Note that some newer chipsets like the Intel 5-series chipsets do not have companion controllers at all and instead have internal "rate matching" hubs that all USB devices go through.
</p>
<ul class="gallery mw-gallery-traditional" style="max-width: 815px;">
		<li class="gallerybox" style="width: 155px"><div style="width: 155px">
			<div class="thumb" style="width: 150px;"><div style="margin:15px auto;"><a href="./File:LFSpeedDevToHSPort.gif" class="image" title="Figure 3: Low- or Full-speed device connected to a high-speed capable USB port"><img alt="Figure 3: Low- or Full-speed device connected to a high-speed capable USB port" src="images/thumb/7/72/LFSpeedDevToHSPort.gif/91px-LFSpeedDevToHSPort.gif" decoding="async" width="91" height="120" srcset="images/thumb/7/72/LFSpeedDevToHSPort.gif/137px-LFSpeedDevToHSPort.gif 1.5x, images/thumb/7/72/LFSpeedDevToHSPort.gif/183px-LFSpeedDevToHSPort.gif 2x" data-file-width="313" data-file-height="410" /></a></div></div>
			<div class="gallerytext">
<p>Figure 3: Low- or Full-speed device connected to a high-speed capable USB port
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 155px"><div style="width: 155px">
			<div class="thumb" style="width: 150px;"><div style="margin:15px auto;"><a href="./File:HSHubToHSPort.gif" class="image" title="Figure 4: High-speed hub connected to a high-speed capable USB port"><img alt="Figure 4: High-speed hub connected to a high-speed capable USB port" src="images/thumb/6/6f/HSHubToHSPort.gif/91px-HSHubToHSPort.gif" decoding="async" width="91" height="120" srcset="images/thumb/6/6f/HSHubToHSPort.gif/137px-HSHubToHSPort.gif 1.5x, images/thumb/6/6f/HSHubToHSPort.gif/183px-HSHubToHSPort.gif 2x" data-file-width="313" data-file-height="410" /></a></div></div>
			<div class="gallerytext">
<p>Figure 4: High-speed hub connected to a high-speed capable USB port
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 155px"><div style="width: 155px">
			<div class="thumb" style="width: 150px;"><div style="margin:15px auto;"><a href="./File:HSDevsToHSHubToHSPort.gif" class="image" title="Figure 5: High-speed devices connected to a high-speed hub which is connected to a high-speed USB port"><img alt="Figure 5: High-speed devices connected to a high-speed hub which is connected to a high-speed USB port" src="images/thumb/0/0a/HSDevsToHSHubToHSPort.gif/95px-HSDevsToHSHubToHSPort.gif" decoding="async" width="95" height="120" srcset="images/thumb/0/0a/HSDevsToHSHubToHSPort.gif/143px-HSDevsToHSHubToHSPort.gif 1.5x, images/thumb/0/0a/HSDevsToHSHubToHSPort.gif/191px-HSDevsToHSHubToHSPort.gif 2x" data-file-width="397" data-file-height="499" /></a></div></div>
			<div class="gallerytext">
<p>Figure 5: High-speed devices connected to a high-speed hub which is connected to a high-speed USB port
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 155px"><div style="width: 155px">
			<div class="thumb" style="width: 150px;"><div style="margin:15px auto;"><a href="./File:LFHSDevsHSHubHSPortIncorrect.gif" class="image" title="Figure 6: Incorrect illustration of Low- and Full-speed devices on a high-speed bus"><img alt="Figure 6: Incorrect illustration of Low- and Full-speed devices on a high-speed bus" src="images/thumb/9/93/LFHSDevsHSHubHSPortIncorrect.gif/102px-LFHSDevsHSHubHSPortIncorrect.gif" decoding="async" width="102" height="120" srcset="images/thumb/9/93/LFHSDevsHSHubHSPortIncorrect.gif/153px-LFHSDevsHSHubHSPortIncorrect.gif 1.5x, images/thumb/9/93/LFHSDevsHSHubHSPortIncorrect.gif/204px-LFHSDevsHSHubHSPortIncorrect.gif 2x" data-file-width="424" data-file-height="499" /></a></div></div>
			<div class="gallerytext">
<p>Figure 6: Incorrect illustration of Low- and Full-speed devices on a high-speed bus
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 155px"><div style="width: 155px">
			<div class="thumb" style="width: 150px;"><div style="margin:15px auto;"><a href="./File:LFHSDevsHSHubHSPortCorrect.gif" class="image" title="Figure 7: Correct illustration of split transactions allowing Low- and Full-speed devices on a high-speed bus"><img alt="Figure 7: Correct illustration of split transactions allowing Low- and Full-speed devices on a high-speed bus" src="images/thumb/0/04/LFHSDevsHSHubHSPortCorrect.gif/102px-LFHSDevsHSHubHSPortCorrect.gif" decoding="async" width="102" height="120" srcset="images/thumb/0/04/LFHSDevsHSHubHSPortCorrect.gif/153px-LFHSDevsHSHubHSPortCorrect.gif 1.5x, images/thumb/0/04/LFHSDevsHSHubHSPortCorrect.gif/204px-LFHSDevsHSHubHSPortCorrect.gif 2x" data-file-width="424" data-file-height="499" /></a></div></div>
			<div class="gallerytext">
<p>Figure 7: Correct illustration of split transactions allowing Low- and Full-speed devices on a high-speed bus
</p>
			</div>
		</div></li>
</ul>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="./File:USBTopology.gif" class="image"><img alt="" src="images/thumb/8/88/USBTopology.gif/300px-USBTopology.gif" decoding="async" width="300" height="232" class="thumbimage" srcset="images/thumb/8/88/USBTopology.gif/450px-USBTopology.gif 1.5x, images/thumb/8/88/USBTopology.gif/600px-USBTopology.gif 2x" data-file-width="640" data-file-height="495" /></a>  <div class="thumbcaption"><div class="magnify"><a href="./File:USBTopology.gif" class="internal" title="Enlarge"></a></div>Figure 8: USB Topology</div></div></div>
<h4><span class="mw-headline" id="USB_Interconnect">USB Interconnect</span></h4>
<p>The <b>USB interconnect</b> provides a connection from the USB device(s) to the USB host.  Physically, the USB interconnect is a tiered star topology.  A maximum of seven tiers are allowed, and the root hub occupies the first tier.  Since compound devices contain an embedded hub, a compound device cannot be attached in tier 7.  Figure 8 illustrates a USB topology (taken from Figure 4-1 of the USB 2.0 specifications).
</p>
<h4><span class="mw-headline" id="USB_Host">USB Host</span></h4>
<p>A USB system contains only one <b>USB host</b>.  The host interfaces with the USB interconnect via a host controller.  The host includes an embedded hub called the <b>root hub</b> which provides one or more <b>attachment points</b>, or <b>ports</b>.
</p>
<h3><span class="mw-headline" id="USB_Communication_Flow">USB Communication Flow</span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:450px;"><a href="./File:USBDataFlow.gif" class="image"><img alt="" src="images/a/af/USBDataFlow.gif" decoding="async" width="448" height="244" class="thumbimage" data-file-width="448" data-file-height="244" /></a>  <div class="thumbcaption">Figure 9: Illustration of USB Communication Flow</div></div></div>
<p>Figure 9 illustrates the concepts of USB communication flow and is taken from Figure 5-10 of the USB 2.0 Specifications.
</p>
<h4><span class="mw-headline" id="Device_Endpoints_and_Endpoint_Numbers">Device Endpoints and Endpoint Numbers</span></h4>
<p>Each USB device contains a collection of endpoints.  Every endpoint has the following characteristics:
</p>
<ul><li>Bus access frequency/latency requirement</li>
<li>Bandwidth requirement</li>
<li>A unique device-determined identifier called the endpoint number</li>
<li>Error handling behavior requirements</li>
<li>Maximum packet size the endpoint can send or receive</li>
<li>The transfer type of the endpoint</li>
<li>Device-determined direction of data transfer:
<ul><li><b>Input</b>: from the device to the host</li>
<li><b>Output</b>: from the host to the device</li></ul></li></ul>
<p>As an example, consider an “all-in-one” printer/scanner device.  Such a device may implement an endpoint number for printing functionality, and a separate endpoint number for scanning functionality.
</p><p>Although endpoints have a specific direction, two endpoints may have the same endpoint number but opposing data transfer directions.  All functions implement two such endpoints with the endpoint number 0.  Only endpoints with the endpoint number 0 may be accessed as soon as the device is powered and has received a bus reset; all other endpoints are in an undefined state until the device is configured.
</p><p>Besides the two required endpoints, functions may implement additional endpoints as necessary, with the following limitations:
</p>
<ul><li>Low-speed functions may implement up to two additional endpoints.</li>
<li>Full- and high-speed devices may implement up to 15 additional input endpoints and 15 additional output endpoints.  This is a physical limitation of the USB protocol and is discussed under <a href="USB#Endpoint_field">Endpoint_Field</a>.</li></ul>
<h4><span class="mw-headline" id="Endpoint_Zero">Endpoint Zero</span></h4>
<p>All USB devices implement input and output endpoints with an endpoint number of 0.  These endpoints are collectively known as the <b>default control pipe</b>.  Endpoints with an endpoint number 0 are special in that they are accessible whenever the device is attached, powered and has received a bus reset.
</p><p>In the interest of backwards compatibility, all high-speed functions must support these endpoints even when connected to a hub operating at full-speed.  This means that high-speed devices must be able to reset at full-speed, as well as respond successfully to standard requests at full-speed.  The high-speed device is not, however, required to support its intended functionality at full-speed.  This allows USB 1.0 systems to identify a USB 2.0 device and alert the user if the device cannot function properly at full-speed
</p>
<h4><span class="mw-headline" id="Pipes">Pipes</span></h4>
<p>A pipe associates software on the host (specifically, a buffer on the host) with an endpoint on a device.  
</p><p>There are two kinds of pipe communication modes:
</p>
<ul><li><b>Stream pipes</b> impose no structure on the data being transferred.  Stream pipes are always <b>uni-directional</b> in their communication flow.</li>
<li><b>Message pipes</b> impose some structure on the data being transfered.  Message pipes are <b>bi-directional</b>, however data may predominantly transfer in one direction.</li></ul>
<p>Pipes also have the following attributes:
</p>
<ul><li>A claim on bus access and bandwidth usage</li>
<li>A transfer type</li>
<li>The associated endpoint's characteristics</li></ul>
<p>Data flow in one pipe is independent of data flow in any other pipe.  Most pipes are available after a device has been configured, however the <b>default control pipe</b> always exists after a USB device is powered and has received a bus reset.
</p>
<h4><span class="mw-headline" id="Default_Control_Pipe">Default Control Pipe</span></h4>
<p>The <b>default control pipe</b> is a special type of message pipe that is always accessible once a device is powered and has received a bus reset.  Thus, the default control pipe provides a means to identify and configure devices so that additional endpoints, if any, are made available.
</p><p>The information required to completely identify a device is associated with the default control pipe; such information falls into the following categories:
</p>
<ul><li><b>Standard</b> information is common among all USB devices.</li>
<li><b>Class</b> information depends on the class of the USB device, as identified by the standard information.</li>
<li><b>USB Vendor</b> information is free for use by the hardware vendor.</li></ul>
<h3><span class="mw-headline" id="Basics_of_USB_Transfers">Basics of USB Transfers</span></h3>
<p>Most USB transactions consist of three packets:
</p>
<ul><li>A <b>token packet</b> indicates the type and direction of the transaction, the device address, and an endpoint number.</li>
<li>Depending on the direction of the transaction, either the host or the function sends a <b>data packet</b> (which may simply indicate that there is no data to send).</li>
<li>The receiving device responds with a <b>handshake packet</b> to indicate if the transfer was successful.</li></ul>
<p>USB supports four basic types of data transfer which take place via pipes.  A single pipe supports only (and exactly) one transfer type for any given device configuration.  That is, a function may provide a means to change the transfer type of a device-implemented endpoint number.
</p><p>Briefly, the four basic transfer types are:
</p>
<ul><li><b>Control Transfers</b> provide lossless transmissions and are used to configure a device.  Thus, all USB devices must support control transfers at least via the default control pipe.</li>
<li><b>Bulk Data Transfers</b> provide lossless, sequential transmissions and are typically used to transfer large amounts of data.</li>
<li><b>Interrupt Data Transfers</b> provide reliable, limited-latency transmissions typically needed by human input devices such as a mouse or a joystick.</li>
<li><b>Isochronous Data Transfers</b>, also called <b>Streaming Real-time Transfers</b>, negotiate a required bandwidth and latency when initializing the transfer.  This transfer type is predominantly used for such applications as streaming audio.  Since data-delivery rate is considered more important than data integrity for this type of transfer, it does not provide any type of error checking or correction mechanism.</li></ul>
<h4><span class="mw-headline" id="Control_Transfers">Control Transfers</span></h4>
<p>Control transfers support configuration/command/status type communication flow.  The host initiates a control transfer with a SETUP bus transaction to the function, which establishes details of the intended data transfer such as whether the host wishes to send or receive data.  Next, zero or more DATA transactions take place in the appropriate direction.  Finally, a STATUS transaction from the function to the host indicates whether the transfer was successful.
</p><p>Clearly, control transfers adhere to a USB-defined structure, so it should come as no surprise that control transfers may only be carried out via messages pipes.
</p><p>Neither a function nor the host are guaranteed any specific latency or bandwidth for control transfers.
</p>
<h5><span class="mw-headline" id="Maximum_Data_Payload_Size">Maximum Data Payload Size</span></h5>
<p>An endpoint used for a control transfer specifies the <b>maximum data payload size</b> that it can accept or transmit to the bus.  The allowable maximum data payload sizes depend on the speed of the device:
</p>
<ul><li>High-speed device endpoints may only select a maximum data payload size of 64 bytes.</li>
<li>Full-speed device endpoints may select a maximum data payload size of 8, 16, 32, or 64 bytes.</li>
<li>Low-speed device endpoints may only select a maximum data payload size of 8 bytes.</li></ul>
<p>A control transfer always uses it's maximum data payload size for data payloads unless the data payload is less than the maximum data payload size.  That is, if an endpoint has a maximum data payload size of 64 bytes, and a control transfer intends to transmit 100 bytes, the first data payload must contain 64 bytes and no less.  The remaining 36 bytes are transferred in the second payload and need not be padded to 64 bytes.  When the host receives a data payload less than the maximum data payload, the host may consider the transfer complete.
</p><p>A SETUP transaction's data payload is always 8 bytes and thus receivable by the endpoint of any USB device.  Consequently, the host may query the appropriate descriptor from a newly-attached full-speed device during configuration in order to determine the maximum data payload size for any endpoint; the host can then adhere to that maximum for any future transmissions.
</p>
<h5><span class="mw-headline" id="Transmission_Errors">Transmission Errors</span></h5>
<h6><span class="mw-headline" id="Too_Much_Data">Too Much Data</span></h6>
<p>When transferring from host to device, if the host sends more data than negotiated during the SETUP transaction (i.e., the device receives more data than it expects; specifically, the host does not advance to the STATUS stage when the device expects), the device endpoint halts the pipe.
</p><p>When transferring from device to host, if the device sends more data than negotiated during the SETUP transaction (i.e., the host receives an extra data payload, or the final data payload is larger than it should be), the host considers it an error and aborts the transfer.
</p>
<h6><span class="mw-headline" id="Bus_Errors">Bus Errors</span></h6>
<p>In the event of a bus error or anomaly, an endpoint may receive a SETUP packet in the middle of a control transfer.  In such a case, the endpoint must abort the current transfer and handle the unexpected SETUP packet.  This behavior should be completely transparent to the host; the host should neither expect nor take advantage of this behavior.
</p>
<h6><span class="mw-headline" id="Halt_Conditions">Halt Conditions</span></h6>
<p>A control endpoint may recover from a halt condition upon receiving a SETUP packet.  If the endpoint does not recover from a SETUP packet, it may need to be recovered via a different pipe.  If an endpoint with the endpoint number 0 does not recover with a SETUP packet, the host should issue a device reset.
</p>
<h4><span class="mw-headline" id="Bulk_Data_Transfers">Bulk Data Transfers</span></h4>
<p>A pipe with a bulk transfer type provides:
</p>
<ul><li>Access to the USB on a bandwidth-available basis</li>
<li>Retry of transfers that encounter the occasional delivery failure</li>
<li>Guaranteed data integrity, but no guaranteed bandwidth</li></ul>
<p>The host controller gives bulk data transfers low priority; they are generally only processed when bandwidth is available, however software may not assume that a control transfer will be processed before a bulk transfer.  If multiple bulk transfers are pending, the host controller may begin moving bulk transfers over the bus according to an implementation-dependent policy.  The system software may vary the bus time made available for a bulk transfer to a specific endpoint.  
</p><p>The USB does not impose any structure on the data content of a bulk transfer; thus, bulk transfers are carried via stream pipes.
</p>
<h5><span class="mw-headline" id="Maximum_Data_Payload_Size_2">Maximum Data Payload Size</span></h5>
<p>An endpoint used for a bulk data transfer specifies the <b>maximum data payload size</b> that it can accept or transmit to the bus.  The allowable maximum data payload sizes depend on the speed of the device:
</p>
<ul><li>High-sped device endpoints may only select a maximum data payload size of 512 bytes.</li>
<li>Full-speed device endpoints may select a maximum data payload size of 8, 16, 32, or 64 bytes.</li>
<li>Low-speed devices may not implement bulk endpoints.</li></ul>
<p>Like control transfers, a bulk transfer endpoint must transmit data payloads of the maximum data payload size for that endpoint with the exception of the last data payload in a particular transfer.  The last data payload need not (and should not) be padded out to the maximum data payload size.
</p><p>The bulk transfer is considered complete when the endpoint has transferred exactly as much data as expected, the endpoint transfers a packet with a data payload size less than the endpoint's maximum data payload size, or the endpoint transfers a zero-length packet.
</p>
<h5><span class="mw-headline" id="Transmission_Errors_2">Transmission Errors</span></h5>
<p>If a data payload is transferred that is larger than expected, the transfer should be aborted along with any pending bulk transfers through the same pipe.
</p><p>Bulk data transfers employ data toggle bits to both detect errors and provide the necessary synchronization to recover from an error.  If a halt condition is detected, any remaining bulk transfers should be retired.  The halt condition is resolved by means of a separate control pipe.
</p>
<h4><span class="mw-headline" id="Interrupt_Data_Transfers">Interrupt Data Transfers</span></h4>
<p>Interrupt data transfers guarantee a maximum service time for any data transfer.  In the even of a transmission failure, data is retransmitted at the next period.  Thus, an interrupt data transfer is ideal for devices that do not send data often, but when they do, they require timely transmission as well as data integrity; most human input devices have these requirements.
</p><p>Interrupt data transfers are carried out by a stream pipe and thus do not need to adhere to any USB data structure.
</p>
<h5><span class="mw-headline" id="Maximum_Data_Payload_Size_3">Maximum Data Payload Size</span></h5>
<p>An endpoint used for a interrupt data transfer specifies the <b>maximum data payload size</b> that it can accept or transmit to the bus.  The allowable maximum data payload sizes depend on the speed of the device:
</p>
<ul><li>High-speed device endpoints may select a maximum data payload size of up to 1024 bytes.</li>
<li>Full-speed device endpoints may select a maximum data payload size of up to 64 bytes.</li>
<li>Low-speed device endpoints may select a maximum data payload size of up to 8 bytes.</li></ul>
<p>Additionally, a high-speed, high-bandwidth endpoint may specify that it requires two or three transactions per microframe.  High-speed, high-bandwidth endpoints, frames, and microframes will be discussed later.
</p><p>Notice that the maximum data payload size for interrupt data transfers allows for more granularity than control or bulk data transfers.  That is, an interrupt data transfer endpoint for a high-speed device may be any integer from 0 to 1024.  The maximum data payload size for an interrupt transfer endpoint remains constant during the lifetime of the device's configuration.
</p><p>Like control and bulk data transfers, an interrupt transfer endpoint must transmit data payloads of the maximum data payload size for that endpoint with the exception of the last data payload in a particular transfer.  The last data payload need not (and should not) be padded out to the maximum data payload size.
</p><p>The interrupt transfer is considered complete when the endpoint has transferred exactly as much data as expected, the endpoint transfers a packet with a data payload size less than the endpoint's maximum data payload size, or the endpoint transfers a zero-length packet.
</p>
<h5><span class="mw-headline" id="Transmission_Errors_3">Transmission Errors</span></h5>
<p>If a data payload is transferred that is larger than expected, the transfer should be aborted and the pipe stalls any future interrupt transfers until the error is acknowledged and corrected.
</p><p>Interrupt data transfers may use one of two data toggle bit schemes to ensure successful data transmission.  Devices that require higher through-put may choose to toggle every transmission rather than perform a handshake with the host.  This method is more susceptible to errors than the alternative method of toggling bits upon successful transaction (after a handshake).
</p><p>If a halt condition is detected, any pending interrupt transfers should be retired.  The halt condition is resolved via a separate control pipe.
</p>
<h4><span class="mw-headline" id="Isochronous_Data_Transfers">Isochronous Data Transfers</span></h4>
<p>Isochronous data transfers are similar to interrupt transfers in that they guarantee a maximum service time for any transfer, but isochronous data transfers do not ensure data integrity.  When data is ready to be transmitted to or from an isochronous endpoint, the data is always transferred at a constant rate.
</p><p>The data being transmitted via an isochronous pipe need not have any specific structure, therefore isochronous pipes are stream pipes.
</p>
<h5><span class="mw-headline" id="Maximum_Data_Payload_Size_4">Maximum Data Payload Size</span></h5>
<p>An endpoint used for a isochronous data transfer specifies the <b>maximum data payload size</b> that it can accept or transmit to the bus.  The allowable maximum data payload sizes depend on the speed of the device:
</p>
<ul><li>High-speed device endpoints may select a maximum data payload size of up to 1024 bytes.</li>
<li>Full-speed device endpoints may select a maximum data payload size of up to 1023 bytes.</li>
<li>Low-speed devices may not implement isochronous endpoints.</li></ul>
<p>Like interrupt endpoints, isochronous endpoints may specify a maximum data payload size with byte granularity.  Also like interrupt endpoints, high-speed, high-bandwidth isochronous endpoints may specify if they require two or three transactions per microframe.
</p><p>Unlike any other transfer types, isochronous transfers may transmit any amount of data up to the maximum data payload size during any transaction.
</p>
<h5><span class="mw-headline" id="Transmission_Errors_4">Transmission Errors</span></h5>
<p>Isochronous transfers are meant for devices where data transmission rate is more important than data integrity.  For that reason, isochronous transfers do not allow handshakes and thus cannot stall.  It is still important that the agent of an isochronous transfer know if an error occurred, and possibly how much data was lost.  The USB protocol provides several mechanisms for detecting data transmission errors in an isochronous transfer, these mechanisms will be discussed later.  Determining the amount of data lost is implementation-dependent.  It is up to the software on the host or firmware on the function to implement any sort of data corruption detection/correction.
</p>
<h2><span class="mw-headline" id="Advanced_USB_Concepts">Advanced USB Concepts</span></h2>
<p>The topics in this section build upon the topics previously discussed.  The information in this section provides some useful lower-level details about USB systems.
</p>
<h3><span class="mw-headline" id="Distribution_of_Bus_Access_Time">Distribution of Bus Access Time</span></h3>
<h4><span class="mw-headline" id="Frames_and_Microframes">Frames and Microframes</span></h4>
<p>To ensure synchronization between the host and the functions, the USB divides bus time into fixed-length segments.  For low- or full-speed buses, the USB divides the bus time into 1 millisecond units, called <b>frames</b>.  For a high-speed bus, the USB divides the bus time into 125 microsecond units, called <b>microframes</b>.
</p><p>Note that frames and microframes do not coexist on one bus; low- and full-speed buses used frames, but in developing a high-speed bus, a shorter frame was necessary because the significantly higher signaling bit rate is more sensitive to smaller shifts in synchronization between the host and the function.
</p><p>Frames and microframes are mostly a physical-layer detail and should not be confused with any of the previous concepts.  Frames and microframes do not correspond to any packet or transaction; in fact, several transactions usually take place during one (micro)frame.  The host controller issues a <b>start-of-frame</b> (<b>SOF</b>) packet at the beginning of every (micro)frame.  The remainder of the (micro)frame is available for the host controller to carry out transactions.  A transaction may not take place if it cannot be completed in the same (micro)frame (because otherwise the next SOF packet would interrupt the transaction).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:652px;"><a href="./File:Usbframes.gif" class="image"><img alt="" src="images/1/1c/Usbframes.gif" decoding="async" width="650" height="283" class="thumbimage" data-file-width="650" data-file-height="283" /></a>  <div class="thumbcaption">Figure 10: Illustration of USB (micro)frames.</div></div></div></div>
<p>It is important to realize that the host controller may rearrange transactions to make better use of the available bandwidth.  Of course, two transactions through the same pipe must occur in the correct order, but the transactions of two separate transfers may be reordered at the host controller's discretion.  Consider a pending bulk transfer and two pending control transfers.  The host could potentially reorder the transfers on the bus as in Figure 11.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:668px;"><a href="./File:Usbtransactionreorder.gif" class="image"><img alt="" src="images/7/79/Usbtransactionreorder.gif" decoding="async" width="666" height="489" class="thumbimage" data-file-width="666" data-file-height="489" /></a>  <div class="thumbcaption">Figure 11: Illustrates how a host controller may potentially reorder a bulk transfer and two control transfers on the USB.</div></div></div></div>
<h4><span class="mw-headline" id="Bus_Time_Rationing">Bus Time Rationing</span></h4>
<p>There are separate rules for the allocation of frames on a full-/low-speed bus, and for the allocation of microframes on a high-speed bus.
</p><p>For full- or low- speed buses:
</p>
<ul><li>If a control transfer requires less than 10% of a frame, the remaining bus time can be used to support bulk transfers</li>
<li>If there are more control transfers than reserved time, yet additional frame time that is unused by interrupt or isochronous transfers, the host controller may move additional control transfers onto the bus.</li>
<li>No more than 90% of a frame may be allocated for periodic (isochronous and interrupt) transfers.</li>
<li>The host must not issue more than 1 transaction in a single frame for a specific isochronous endpoint.</li></ul>
<p>For a high-speed bus:
</p>
<ul><li>If a control transfer requires less than 20% of a microframe, the remaining bus time can be used to support bulk transfers.</li>
<li>If there are more control transfers than reserved time, yet additional microframe time that is unused by interrupt or isochronous transfers, the host controller may move additional control transfers onto the bus.</li>
<li>No more than 80% of a frame may be allocated for periodic (isochronous and interrupt) transfers.</li>
<li>The host must not issue more than 1 transaction in a single microframe for a specific isochronous endpoint unless it is a high-speed, high-bandwidth endpoint.</li>
<li>Split transaction bus access time is allocated from the 80% of the microframe guaranteed to periodic transfers.</li></ul>
<h3><span id="High-Speed.2C_High-Bandwidth_Endpoints"></span><span class="mw-headline" id="High-Speed,_High-Bandwidth_Endpoints">High-Speed, High-Bandwidth Endpoints</span></h3>
<p>High-speed interrupt or isochronous endpoints that require high bandwidth may specify that they support up to three transaction in a single (micro)frame.  In this case, all but the last transaction in a particular (micro)frame must have a data payload of the maximum data payload size for that endpoint.
</p><p>The host controller never retries a transaction with an isochronous endpoint.  If a transaction with a high-speed, high-bandwidth interrupt endpoint fails, the host controller may retry the transaction during the same (micro)frame if the maximum number of transactions per (micro)frame has not been reached.  Otherwise, the transaction is retried at the next period.
</p>
<h3><span class="mw-headline" id="Supporting_Isochronous_Transfers">Supporting Isochronous Transfers</span></h3>
<p>Recall that isochronous transfers occur over stream pipes, which provide one-way data transfer.  On one of the pipe, called the <b>source</b>, data is produced, and on the other end, called the <b>sink</b>, data is delivered.
</p><p>Devices that implement isochronous endpoints require that data be transmitted from source to sink at a certain rate, sometimes in large payloads (e.g, streaming audio or video).  This section discusses how the USB accomplishes these requirements.
</p>
<h4><span class="mw-headline" id="Synchronization">Synchronization</span></h4>
<p>Due to application-specific sampling rates, different hardware clock designs, scheduling policies in the operating system, or even physical anomalies, the host and isochronous device could fall out of synchronization.  Therefore, special consideration is required to maintain synchronization.  Isochronous endpoints specify one of three synchronization types.
</p>
<h5><span class="mw-headline" id="Asynchronous_Endpoints">Asynchronous Endpoints</span></h5>
<p><b>Asynchronous</b> endpoints are incapable of synchronizing to SOF packet frequency (1ms periods for full-speed endpoints, 125 microsecond periods for high-speed endpoints).  These endpoints have either:a set of one or more fixed data sampling rates, or a continuously programmable data rate.  The device must report the programmability of an asynchronous endpoint in some manner (defined by the class of the device rather than by the USB specifications); if the data rate is programmable, then it must be set by the host during initialization of the isochronous endpoint.
</p><p>Asynchronous source endpoints imply their data rate by the number of samples produced per (micro)frame.  Asynchronous sink endpoints must provide explicit feedback to the source endpoint.  When the source endpoint is the host, it is the responsibility of the device driver to process the explicit feedback properly.  This feedback allows the host and device to make slight adjustments to the data rate in order to compensate for any clock drift.
</p>
<h5><span class="mw-headline" id="Synchronous_Endpoints">Synchronous Endpoints</span></h5>
<p><b>Synchronous</b> endpoints must synchronize their data transmissions to the SOF packet frequency (1ms periods for full-speed endpoints, 125 microsecond periods for high-speed endpoints).  These endpoints have either a set of one or more fixed data sampling rates, or a continuously programmable data rate.  The device must report the programmability of a synchronous endpoint in some manner (defined by the class of the device rather than by the USB specifications); if the data rate is programmable, then it must be set by the host during initialization of the isochronous endpoint.
</p>
<h5><span class="mw-headline" id="Adaptive_Endpoints">Adaptive Endpoints</span></h5>
<p><b>Adaptive</b> endpoints can source or sink data at any rate within their specified operating range.  These endpoints may have an operating range that centers around a specific data rate, it may have a finite set of data rate ranges, or it may select between several programmable or auto-detecting data rates.  The device must report the programmability of an adaptive endpoint in some manner (defined by the class of the device rather than by the USB specifications); unlike the previous synchronization types, adaptive endpoints may adjust it's instantaneous data rate during operation.
</p><p>Adaptive sink endpoints provide explicit feedback to the source like asynchronous endpoints.
</p>
<h4><span class="mw-headline" id="Handling_Errors">Handling Errors</span></h4>
<p>Handshakes are not performed for isochronous transactions, therewith eliminating the bandwidth overhead of acknowledgment packets.  Unlike other transfer types, the applications of isochronous endpoints are responsible for any error detection and handling.  Although it may be more important to continue delivering streaming data rather than retransmit a missed data packet, applications of isochronous endpoints often still need to know that an error did occur in the stream.
</p><p>The USB protocol highlights the following possible method for the host or a device to detect an error in an isochronous stream:
</p>
<ul><li>High-speed, high-bandwidth isochronous transactions use data PID sequencing (data bit toggling), an isochronous sink can determine that a data packet was missed when it receives an invalid data PID sequence.</li>
<li>The host controller and device can both see SOF packets on the bus.  If the SOF packet is issued for a (micro)frame that is expected to carry the periodic data of an isochronous endpoint, but the data is not transmitted, then the hardware can determine that a packet was missed.</li>
<li>The protocol provides CRC protection to ensure that the data has not been corrupted.</li>
<li>If an endpoint sees the token packet but does not see the associated data packet within a bus transaction timeout period, then the data packet failed to transfer.</li></ul>
<p>Once an application is aware that there is an error in the stream, it is up to the application to determine the next course of action.
</p>
<h2><span class="mw-headline" id="USB_Protocol">USB Protocol</span></h2>
<h3><span class="mw-headline" id="Packets">Packets</span></h3>
<p>The atomic unit of data transfer is a packet.  A packet is a bundle of organized data which typically contains three elements:
</p>
<ul><li>Control information (e.g. source, destination, length of data)</li>
<li>User/Application-specific data</li>
<li>Error detection and correction bits</li></ul>
<h4><span class="mw-headline" id="SYNC_Field">SYNC Field</span></h4>
<p>The SYNC field is omitted from packet diagrams in the USB specifications, and usually in other material on USB meant for programmers.  Here I will briefly describe the semantics of the SYNC field simply because USB sources often reference the SYNC field which may confuse the reader.  However, for clarity, the system programmer (and probably most USB device firmware developers as well) does not need to know about the SYNC field.
</p><p>All USB packets start with a SYNC field which serves, unsurprisingly, as a synchronization mechanism between the receiver and the sender.  The SYNC field consists of 6 or 30 alternating bits for low- and full-speed or high-speed buses, respectively.  The last two bits of the SYNC field are equal (and low).  High-speed hubs may drop up to 4 bits of the SYNC field, so a receiving device may not see the entire field, but the final two bits are all the device needs to identify exactly where the SYNC field ends, and useful data begins.
</p>
<h4><span class="mw-headline" id="Packet_Identifier_Field">Packet Identifier Field</span></h4>
<p>The <b>Packet Identifier</b> (<b>PID</b>) immediately follow the SYNC field.  There are a total of 17 defined PIDs (included the PID of 0000b, which is reserved), therefore a PID requires 4 bits to encode.  If errors on the bus alter the PID field (changing an OUT PID to an IN PID, for example), the result could be anything from unexpected behavior to massive data loss.  Due to the importance of the PID integrity, the PID field is 8 bits wide.  The last 4 bits simply compliment the first four bits, this provides a means to determine if an error on the bus has altered the PID field.  The PID Field is illustrated below.
</p>
<center>
<table border="1" cellpadding="15">
<caption align="bottom" style="font-weight:bold;">Packet Identifier Field Format
</caption>
<tbody><tr>
<td>PID<span style="vertical-align:sub;">0</span>
</td>
<td>PID<span style="vertical-align:sub;">1</span>
</td>
<td>PID<span style="vertical-align:sub;">2</span>
</td>
<td>PID<span style="vertical-align:sub;">3</span>
</td>
<td style="text-decoration:overline;">PID<span style="vertical-align:sub;">0</span>
</td>
<td style="text-decoration:overline;">PID<span style="vertical-align:sub;">1</span>
</td>
<td style="text-decoration:overline;">PID<span style="vertical-align:sub;">2</span>
</td>
<td style="text-decoration:overline;">PID<span style="vertical-align:sub;">3</span>
</td></tr></tbody></table>
</center>
<p>PID codes are categorized into 4 groups which share the same two least-significant bits.  USB 2.0 defines the PIDs in the following table.
</p>
<table border="1" cellpadding="5">
<caption align="bottom" style="font-weight:bold;">PID Types
</caption>
<tbody><tr>
<th style="white-space:nowrap;">PID Type
</th>
<th style="white-space:nowrap;">PID Name
</th>
<th style="white-space:nowrap;">PID [3:0]
</th>
<th style="white-space:nowrap;">Description
</th></tr>
<tr>
<td rowspan="4" align="center">Token
</td>
<td align="center">OUT
</td>
<td align="center">0001b
</td>
<td>The packet describes a host-to-function transaction.
</td></tr>
<tr>
<td align="center">IN
</td>
<td align="center">1001b
</td>
<td>The packet describes a function-to-host transaction.
</td></tr>
<tr>
<td align="center">SOF
</td>
<td align="center">0101b
</td>
<td>The packet marks the start of frame and specifies the frame number.
</td></tr>
<tr>
<td align="center">SETUP
</td>
<td align="center">1101b
</td>
<td>Packet describes a SETUP transaction from the host to the function via a control pipe.
</td></tr>
<tr>
<td rowspan="4" align="center">Data
</td>
<td align="center"><div id="DATAPIDS">DATA0</div>
</td>
<td align="center">0011b
</td>
<td>This packet is an even data packet.
</td></tr>
<tr>
<td align="center">DATA1
</td>
<td align="center">1011b
</td>
<td>This packet is an odd data packet
</td></tr>
<tr>
<td align="center">DATA2
</td>
<td align="center">0111b
</td>
<td>This packet is only used in high-speed, high-bandwidth isochronous transfers.
</td></tr>
<tr>
<td align="center">MDATA
</td>
<td align="center">1111b
</td>
<td>This packet is only used in split transactions, or high-speed, high-bandwidth isochronous transfers.
</td></tr>
<tr>
<td rowspan="4" align="center">Handshake
</td>
<td align="center">ACK
</td>
<td align="center">0010b
</td>
<td>This packet acknowledges the successful receipt of a data packet.
</td></tr>
<tr>
<td align="center">NAK
</td>
<td align="center">1010b
</td>
<td>This packet indicates that data is not ready to be transmitted yet.
</td></tr>
<tr>
<td align="center">STALL
</td>
<td align="center">1110b
</td>
<td>This packet indicates that the endpoint has halted, or a control pipe does not support a certain request.
</td></tr>
<tr>
<td align="center">NYET
</td>
<td align="center">0110b
</td>
<td>The receiver has not yet responded, or the host should begin sending PING packets.
</td></tr>
<tr>
<td rowspan="5" align="center">Special
</td>
<td align="center">PRE
</td>
<td align="center">1100b
</td>
<td>This packet is a host-issued preamble for a split-transaction.
</td></tr>
<tr>
<td align="center">ERR
</td>
<td align="center">1100b
</td>
<td>This packet is a handshake response that a split transaction error occurred.  Note that this PID is identical to the PID for a PRE packet.
</td></tr>
<tr>
<td align="center">SPLIT
</td>
<td align="center">1000b
</td>
<td>This packet supports split transactions between the host and a high-speed hub.
</td></tr>
<tr>
<td align="center">PING
</td>
<td align="center">0100b
</td>
<td>This packet is used for flow-control in high-speed control and bulk transfers.
</td></tr>
<tr>
<td align="center">Reserved
</td>
<td align="center">0000b
</td>
<td>This is a reserved PID and must not be used.
</td></tr></tbody></table>
<h4><span class="mw-headline" id="Address_Fields">Address Fields</span></h4>
<p>Address fields select a specific endpoint on a specific function.  Naturally, two such fields are defined: an address field and an endpoint field.  All devices must fully decode these fields; a mismatch of either field (including an endpoint field which specifies an endpoint that have not been initialized) must be ignored.
</p>
<h5><span class="mw-headline" id="Address_Field">Address Field</span></h5>
<p>The address field is specified for the following PIDs:
</p>
<ul><li>IN</li>
<li>SETUP</li>
<li>OUT</li>
<li>PING</li>
<li>SPLIT</li></ul>
<p>The address field is 7 bits wide and illustrated below.  Each possible value may only indicate a single function.  Address zero is reserved as the <b>default address</b> and cannot be assigned to any function.  All functions must respond to the default address upon reset and power-up until the host assigns the function a specific address.  Therefore, one host controller can support up to 127 devices at one time.
</p>
<center>
<table border="1" cellpadding="15">
<caption align="bottom" style="font-weight:bold;">Address Field
</caption>
<tbody><tr>
<td>Addr<span style="vertical-align:sub;">0</span>
</td>
<td>Addr<span style="vertical-align:sub;">1</span>
</td>
<td>Addr<span style="vertical-align:sub;">2</span>
</td>
<td>Addr<span style="vertical-align:sub;">3</span>
</td>
<td>Addr<span style="vertical-align:sub;">4</span>
</td>
<td>Addr<span style="vertical-align:sub;">5</span>
</td>
<td>Addr<span style="vertical-align:sub;">6</span>
</td></tr></tbody></table>
</center>
<h5><span class="mw-headline" id="Endpoint_Field">Endpoint Field</span></h5>
<p>The endpoint field is specified for the following PIDs:
</p>
<ul><li>IN</li>
<li>SETUP</li>
<li>OUT</li>
<li>PING</li></ul>
<p>The endpoint field is 4 bits wide and illustrated below.  All functions must support at least endpoint number 0 (the default control pipe).  Low-speed functions may only implement 2 additional pipes, while full- and high-speed devices are only limited by the width of the endpoint field.  In other words, the width of the endpoint field is the reason that full- and high-speed devices are limited to implementing up to 15 additional IN endpoints, and 15 additional OUT endpoints, as noted above under <a href="USB#Device_Endpoints_and_Endpoint_Numbers">Device Endpoints and Endpoint Numbers</a>.
</p>
<center>
<table border="1" cellpadding="15">
<caption align="bottom" style="font-weight:bold;">Endpoint Field
</caption>
<tbody><tr>
<td>Endp<span style="vertical-align:sub;">0</span>
</td>
<td>Endp<span style="vertical-align:sub;">1</span>
</td>
<td>Endp<span style="vertical-align:sub;">2</span>
</td>
<td>Endp<span style="vertical-align:sub;">3</span>
</td></tr></tbody></table>
</center>
<h4><span class="mw-headline" id="Data_Field">Data Field</span></h4>
<p>The data field may range from zero to 1,024 bytes and must be an integral number of bytes.  Data bytes are sent least-significant-bit first.
</p>
<h4><span class="mw-headline" id="Cyclic_Redundancy_Checks">Cyclic Redundancy Checks</span></h4>
<p>Cyclic Redundancy Checks (CRC) protect all non-PID fields and provide 100% coverage for all single- and double-bit errors.  CRCs are provided for each token field as well as the data field.  This provides a mechanism for the host or device to recognize and either correct or ignore corrupted fields or, in most cases, an entire corrupted packet.
</p>
<h3><span class="mw-headline" id="Handshakes">Handshakes</span></h3>
<p>Transaction types which support flow control return handshakes to indicate:
</p>
<ul><li>Successful reception of data</li>
<li>Command acceptance or rejection</li>
<li>Flow control</li>
<li>Halt conditions</li></ul>
<p>Handshakes are always returned in the handshake phase of a transaction, but may also be returned in the data phase (in place of an expected data packet).  To best understand a certain handshake response, it is useful to understand what each handshake packet type means, as well as the conditions under which each handshake response may be issued.  This section is divided thusly.
</p>
<h4><span class="mw-headline" id="Handshake_Packets">Handshake Packets</span></h4>
<p>All of the handshake packet types were listed previously and briefly in <a href="USB#Packet_Identifier_Field">Packet Identifier Field</a>.  This section discusses those packet types in greater detail.
</p>
<h5><span class="mw-headline" id="ACK">ACK</span></h5>
<table style="float:right; border: 1px solid #404040; clear:right;" cellspacing="2">
<caption style="font-weight:bold;">ACK Handshake Packet
</caption>
<tbody><tr>
<th style="white-space:no-wrap; border-bottom: 1px solid #404040;">May be issued by...
</th>
<th style="white-space:no-wrap; border-bottom: 1px solid #404040;">For these transactions
</th></tr>
<tr>
<td align="center" style="border-right: 1px solid #000000;">Host
</td>
<td align="center">IN
</td></tr>
<tr>
<td align="center" style="border-right: 1px solid #000000; border-top: 1px solid #000000;" rowspan="3">Function
</td>
<td align="center" style="border-top: 1px solid #000000;">OUT
</td></tr>
<tr>
<td align="center">SETUP
</td></tr>
<tr>
<td align="center">PING
</td></tr></tbody></table>
<p>An ACK handshake is issued to communicate that a data packet was successfully received without any bit stuffing or CRC errors over the data field, and the PID field was not corrupted.
</p><p>ACK packets may be issued when the receiver's sequence bit matches the sequence bit of the received data packet (and the data can be accepted), but the an ACK packet may also be issued when the receiver's sequence bit does not match the sequence bit of the received data packet (and the data cannot be accepted).  This may seem counter intuitive, but the reasoning will become clear in the sections discussing data toggling.
</p>
<h5><span class="mw-headline" id="NAK">NAK</span></h5>
<table style="float:right; border: 1px solid #404040; clear:right;" cellspacing="2">
<caption style="font-weight:bold;">NAK Handshake Packet
</caption>
<tbody><tr>
<th style="white-space:no-wrap; border-bottom: 1px solid #404040;">May be issued by...
</th>
<th style="white-space:no-wrap; border-bottom: 1px solid #404040;">For these transactions
</th></tr>
<tr>
<td align="center" style="border-right: 1px solid #000000;" rowspan="3">Function
</td>
<td align="center">IN
</td></tr>
<tr>
<td align="center">OUT
</td></tr>
<tr>
<td align="center">PING
</td></tr></tbody></table>
<p>The NAK handshake packet is generally used for flow control to indicate that a function is temporarily unable to transmit or receive data.  The host never issues a NAK handshake packet to a device.
</p><p>A function returns a NAK handshake packet to the host after an OUT transaction when the function is unable to receive data (usually because the function's internal buffer is currently full).  This response is not an error, but instead indicates that the host should retry transmission later, allowing the function time to process the data currently in its buffer.
</p><p>A function returns a NAK handshake packet to the host during the data phase of an IN transaction to indicate that the function does not have any data to transfer.
</p>
<h5><span class="mw-headline" id="STALL">STALL</span></h5>
<table style="float:right; border: 1px solid #404040; clear:right;" cellspacing="2">
<caption style="font-weight:bold;">STALL Handshake Packet
</caption>
<tbody><tr>
<th style="white-space:no-wrap; border-bottom: 1px solid #404040;">May be issued by...
</th>
<th style="white-space:no-wrap; border-bottom: 1px solid #404040;">For these transactions
</th></tr>
<tr>
<td align="center" style="border-right: 1px solid #000000;" rowspan="3">Function
</td>
<td align="center">IN
</td></tr>
<tr>
<td align="center">OUT
</td></tr>
<tr>
<td align="center">PING
</td></tr></tbody></table>
<p>A function uses the STALL handshake packet to indicate that it is unable to transmit or receive data.  Besides the default control pipe, all of a function's endpoints are in an undefined state after the device issues a STALL handshake packet.  The host must never issue a STALL handshake packet.
</p><p>Typically, the STALL handshake indicates a functional stall.  A <b>functional stall</b> occurs when the <i>halt feature</i> (which will be covered under "USB Framework") of an endpoint is set.  In this circumstance, host intervention is required via the default control pipe to clear the <i>halt feature</i> of the halted endpoint.
</p><p>Less often, the function returns a STALL handshake during a SETUP or DATA stage of a control transfer.  This is called a <b>protocol stall</b> and is resolved when the host issues the next SETUP transaction.
</p>
<table style="float:right; border: 1px solid #404040; clear:right;" cellspacing="2">
<caption style="font-weight:bold;">NYET Handshake Packet
</caption>
<tbody><tr>
<th style="white-space:no-wrap; border-bottom: 1px solid #404040;">May be issued by...
</th>
<th style="white-space:no-wrap; border-bottom: 1px solid #404040;">For these transactions
</th></tr>
<tr>
<td align="center" style="border-right: 1px solid #000000;">Hub
</td>
<td align="center">SPLIT
</td></tr>
<tr>
<td align="center" style="border-right: 1px solid #000000; border-top: 1px solid #000000;">Function
</td>
<td align="center" style="border-top: 1px solid #000000;">OUT
</td></tr></tbody></table>
<h5><span class="mw-headline" id="NYET">NYET</span></h5>
<p>The NYET packet may be issued by a function as part of the PING protocol.
</p><p>Hubs may issue a NYET handshake packet in response to a split transaction that has not yet completed on the low-/full-speed bus.
</p>
<table style="float:right; border: 1px solid #404040; clear:right;" cellspacing="2">
<caption style="font-weight:bold;">ERR Handshake Packet
</caption>
<tbody><tr>
<th style="white-space:no-wrap; border-bottom: 1px solid #404040;">May be issued by...
</th>
<th style="white-space:no-wrap; border-bottom: 1px solid #404040;">For these transactions
</th></tr>
<tr>
<td align="center" style="border-right: 1px solid #000000;">Hub
</td>
<td align="center">SPLIT
</td></tr></tbody></table>
<h5><span class="mw-headline" id="ERR">ERR</span></h5>
<p>Hubs may issue the special ERR handshake packet to report an error on a low-/full-speed bus as part of the split transaction protocol.
</p>
<h4><span id="Function.2FHost_Response_Circumstances"></span><span class="mw-headline" id="Function/Host_Response_Circumstances">Function/Host Response Circumstances</span></h4>
<p>This section describes the functional circumstances that cause the host or a function to issue an expected response, no response, or certain handshake packet responses.  The tables in this section are taken and slightly modified for clarity from the USB 2.0 specifications, section 8.4.6.  Dashes denote a "don't care."
</p>
<h5><span class="mw-headline" id="Function_Response_to_IN_Transactions">Function Response to IN Transactions</span></h5>
<table border="1" cellpadding="3">
<tbody><tr>
<th>Token received corrupted
</th>
<th>Function Tx endpoint halt feature
</th>
<th>Function can transmit data
</th>
<th>Action taken by function
</th></tr>
<tr>
<td align="center">Yes
</td>
<td align="center">-
</td>
<td align="center">-
</td>
<td>Return no response
</td></tr>
<tr>
<td align="center">No
</td>
<td align="center">Set
</td>
<td align="center">-
</td>
<td>Issue STALL handshake
</td></tr>
<tr>
<td align="center">No
</td>
<td align="center">Not Set
</td>
<td align="center">No
</td>
<td>Issue NAK handshake
</td></tr>
<tr>
<td align="center">No
</td>
<td align="center">Not Set
</td>
<td align="center">Yes
</td>
<td>Issue data packet
</td></tr></tbody></table>
<p><br />
</p>
<h5><span class="mw-headline" id="Host_Response_to_IN_Transactions">Host Response to IN Transactions</span></h5>
<table border="1" cellpadding="3">
<tbody><tr>
<th>Data packet corrupted
</th>
<th>Host can accept data
</th>
<th>Action taken by host
</th>
<th>Handshake returned by host
</th></tr>
<tr>
<td align="center">Yes
</td>
<td align="center">-
</td>
<td>Discard Data
</td>
<td>Return no response
</td></tr>
<tr>
<td align="center">No
</td>
<td align="center">No
</td>
<td>Discard Data
</td>
<td>Return no response
</td></tr>
<tr>
<td align="center">No
</td>
<td align="center">Yes
</td>
<td>Accept Data
</td>
<td>Issue ACK handshake
</td></tr></tbody></table>
<p><br />
</p>
<h5><span class="mw-headline" id="Function_Response_to_OUT_Transactions">Function Response to OUT Transactions</span></h5>
<table border="1" cellpadding="3">
<tbody><tr>
<th>Data packet corrupted
</th>
<th>Receiver halt feature
</th>
<th>Sequence bits match
</th>
<th>Function can accept data
</th>
<th>Action taken by function
</th></tr>
<tr>
<td align="center">Yes
</td>
<td align="center">-
</td>
<td align="center">-
</td>
<td align="center">-
</td>
<td>Return no response
</td></tr>
<tr>
<td align="center">No
</td>
<td align="center">Set
</td>
<td align="center">-
</td>
<td align="center">-
</td>
<td>Issue STALL handshake
</td></tr>
<tr>
<td align="center">No
</td>
<td align="center">Not Set
</td>
<td align="center">No
</td>
<td align="center">-
</td>
<td>Issue ACK handshake
</td></tr>
<tr>
<td align="center">No
</td>
<td align="center">Not Set
</td>
<td align="center">Yes
</td>
<td align="center">Yes
</td>
<td>Issue ACK handshake
</td></tr>
<tr>
<td align="center">No
</td>
<td align="center">Not Set
</td>
<td align="center">Yes
</td>
<td align="center">No
</td>
<td>Issue NAK handshake
</td></tr></tbody></table>
<p><br />
</p>
<h5><span class="mw-headline" id="Function_Response_to_SETUP_Transactions">Function Response to SETUP Transactions</span></h5>
<p>A function must always accept data in a SETUP transaction, and must never issue a STALL or NAK handshake in response.  All non-control endpoints must simply ignore any SETUP transaction addressed to that endpoint.  This allows SETUP transactions to function as a (re)synchronization mechanism between the host and a function's control endpoint.
</p>
<h3><span class="mw-headline" id="PING_Transaction_Protocol">PING Transaction Protocol</span></h3>
<p>Consider a USB mass storage device.  During a transfer from the host to the function, the function's buffer fills up with data that is pending being committed to the physical media.  When the function's buffer is full, the function cannot accept new data until some of the buffer is committed, so if the host continues sending OUT transactions, the function must <a href="USB#NAK">NAK</a> them.
</p><p>The problem with this OUT/NAK model is that a function must wait for the handshake stage of the OUT transaction before responding with a NAK.  Since the handshake stage occurs after the data stage, this can waste a significant amount of bandwidth.  Low- and full-speed buses suffer from this problem, but the USB 2.0 specification introduced the PING transaction protocol for high-speed buses.
</p><p>The PING transaction protocol is very straightforward.  Rather than an OUT transaction, the host issues a PING transaction to the function when the host wishes to send data.  The function responds with either NAK to indicate that it is not ready to receive data (specifically, the function's buffer cannot accommodate the endpoint's maximum data payload amount of data), or ACK to indicate that the host may start sending data.
</p><p>The USB 2.0 framework allows endpoints to specify an interval, in terms of microframes, which is the amount of microframes that the host should wait before issuing another PING packet to the endpoint.  However, the host is not required to wait this interval before issuing the next PING packet.
</p><p>During a high-speed control or bulk transfer from the host to function, when an OUT transactions causes a function's free buffer space to drop below the endpoint's maximum data payload, the function responds with a NYET handshake packet.  This indicates that the host should start issuing PING packets rather than additional OUT transactions.
</p>
<h3><span class="mw-headline" id="Data_Toggle_Synchronization">Data Toggle Synchronization</span></h3>
<p>During a transfer, the host and function must remain synchronized.  The ability to maintain synchronization means that the host or function can detect when synchronization has been lost and, in most cases, resynchronize.
</p><p>Every endpoint maintains, internally (in the function's hardware), a data toggle bit, also called a data sequence bit.  The host also maintains a data toggle bit for every endpoint with which it communicates.  The state of the data toggle bit on the sender is indicated by which <a href="USB#DATAPIDS">DATA PID</a> the sender uses.
</p><p>The receiver toggles its data sequence bit when it is able to accept data and it receives an error-free data packet with the expected <a href="USB#DATAPIDS">DATA PID</a>.  The sender toggles its data sequence bit only upon receiving a valid ACK handshake.  This data toggling scheme requires that the sender and receiver synchronize their data toggle bits at the start of a transaction.
</p><p>Data toggle synchronization works differently depending on the type of transfer used:
</p>
<ul><li>Control transfers initialize the endpoint's data toggle bits to 0 with a SETUP packet.</li>
<li>Interrupt and Bulk endpoints initialize their data toggle bits to 0 upon any configuration event.</li>
<li>Isochronous transfers do not perform a handshake and thus do not support data toggle synchronization.</li>
<li>High-speed, high-bandwidth isochronous transfers do support data sequencing within a microframe.</li></ul>
<p><br />
The remainder of this section illustrates how the sending and receiving devices each manage their data toggle bits during different transmission scenarios.  Black arrows signify the intended data transmission on the USB.  Gray arrows signify that the intended data transmission completed without error.  Red, discontinuous arrows signify that the intended data was corrupted during transmission or entirely failed to transmit.
</p>
<h4><span class="mw-headline" id="Successful_transmissions">Successful transmissions</span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="./File:SuccessfulDataTx.gif" class="image"><img alt="" src="images/thumb/6/68/SuccessfulDataTx.gif/300px-SuccessfulDataTx.gif" decoding="async" width="300" height="257" class="thumbimage" srcset="images/thumb/6/68/SuccessfulDataTx.gif/450px-SuccessfulDataTx.gif 1.5x, images/thumb/6/68/SuccessfulDataTx.gif/600px-SuccessfulDataTx.gif 2x" data-file-width="810" data-file-height="694" /></a>  <div class="thumbcaption"><div class="magnify"><a href="./File:SuccessfulDataTx.gif" class="internal" title="Enlarge"></a></div>Figure 12: Illustration of how the sender and receiver manage their data toggle bits during a successful data transfer</div></div></div>
<p>Figure 12 illustrates a successful data transfer.  Both devices have data toggle bits set to 0 at the beginning of transfer i.  Accordingly, the sending device issues a DATA0 PID followed by the data packet.  The receiving device successful reads the DATA0 PID as well as the data packet.  Since the receiver's data toggle bit matches the DATA0 PID and there were no errors in transmitting the remaining data, the receiver toggles its data toggle bit to 1 and issues an ACK handshake response.  The sender receives the ACK handshake without error, and thus toggles its data toggle bit to 1.
</p><p>Supposing that the next transfer occurs without error as well, the only difference is that the DATA1 PID is used rather than DATA0, and the sending and receiving devices toggle their data toggle bits from 1 to 0 in the same stages that the same bit toggled to a 1 in the previous transfer.
</p>
<div class="thumb tleft"><div class="thumbinner" style="width:302px;"><a href="./File:FailedDataTx.gif" class="image"><img alt="" src="images/thumb/6/6e/FailedDataTx.gif/300px-FailedDataTx.gif" decoding="async" width="300" height="257" class="thumbimage" srcset="images/thumb/6/6e/FailedDataTx.gif/450px-FailedDataTx.gif 1.5x, images/thumb/6/6e/FailedDataTx.gif/600px-FailedDataTx.gif 2x" data-file-width="810" data-file-height="694" /></a>  <div class="thumbcaption"><div class="magnify"><a href="./File:FailedDataTx.gif" class="internal" title="Enlarge"></a></div>Figure 13: Illustration of how the sender and receiver manage their data toggle bits during a failed or corrupt data transfer</div></div></div>
<h4><span class="mw-headline" id="Failed_or_corrupted_data_transmissions">Failed or corrupted data transmissions</span></h4>
<p>Figure 13 illustrates a failed or corrupted data transmission.  Both devices have data toggle bits set to 0 at the beginning of transfer i.  Accordingly, the sending device issues a DATA0 PID followed by the data packet.  The receiving device either does not see the data packet, or reads a corrupted data packet.  The receiver maintains its data toggle bit and issues a NAK handshake.  The sender successfully sees the NAK handshake and thus does not toggle its data toggle bit.
</p><p>At the beginning of the next transfer, both the sending and receiving device have data toggle bits still set to 0.  Supposing this transfer completes successfully, it is carried as as described above, under <a href="USB#Successful_transmissions">successful transmissions</a>.
</p>
<h4><span class="mw-headline" id="Failed_or_corrupted_ACK_handshake">Failed or corrupted ACK handshake</span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="./File:FailedACKTx.gif" class="image"><img alt="" src="images/thumb/7/78/FailedACKTx.gif/300px-FailedACKTx.gif" decoding="async" width="300" height="167" class="thumbimage" srcset="images/thumb/7/78/FailedACKTx.gif/450px-FailedACKTx.gif 1.5x, images/thumb/7/78/FailedACKTx.gif/600px-FailedACKTx.gif 2x" data-file-width="1250" data-file-height="694" /></a>  <div class="thumbcaption"><div class="magnify"><a href="./File:FailedACKTx.gif" class="internal" title="Enlarge"></a></div>Figure 14: Illustration of how the sender and receiver manage their data toggle bits during a failed or corrupt ACK response</div></div></div>
<p>Figure 14 illustrates a failed or corrupted ACK handshake.  Both devices have data toggle bits set to 0 at the beginning of transfer i.  Accordingly, the sending device issues a DATA0 PID followed by the data packet.  The receiving device successfully reads the DATA0 PID as well as the data packet.  Since the receiver's data toggle bit matches the DATA0 PID and there were no errors in transmitting the remaining data, the receiver toggles its data toggle bit to 1 and issues an ACK handshake response.  The sender does not receive, or receives a corrupted ACK response, and thus discards the packet without modifying it's data toggle bit.
</p><p>At this point, the sending device's data toggle bit is still 0, and the receiving device's data toggle bit has been set to 1.  The sender, having not seen a valid ACK response for transfer i, reattempts transfer i.  With a data toggle bit of 0, the sender issues a DATA0 PID followed by the data packet.  The receiving device successfully reads the DATA0 PID as well as the data packet.  Since the receiver's data toggle bit does not match the DATA0 PID, the receiver maintains it's data toggle bit value of 1 and issues an ACK handshake response.  The sender receives the ACK response without error, and thus toggles its data toggle bit to 1.
</p><p>Supposing that the next transfer occurs without error, it begins with both device's data toggle bits set to 1 and ends with them toggling to 0 at the appropriate stage of the transfer.
</p>
<h3><span class="mw-headline" id="USB_Transfers_Revisited">USB Transfers Revisited</span></h3>
<p>A lot of information has been introduced since <a href="USB#Basics_of_USB_Transfers">Basics of USB Transfers</a>, and it is very easy to get lost in the details.  With even a decent understanding of the four types of USB transfers, it is often difficult to extrapolate from the intricacies of the USB protocol to an understanding of just how everything fits together.  For these reasons, this section intends to clarify some potentially confusing concepts both explicitly and implicitly by revisiting the four transfer types in context of all the information covered since first discussing them.
</p><p>An apprehensive reader may have noticed that some terms like SETUP and DATA are used both in referring to <a href="USB#Packet_Identifier_Field">packet identifiers</a>, and in referring to types of transactions.  This wiki entry may very well be the first and only source of USB information that takes a moment to specifically differentiate between the two.
</p><p>Under <a href="USB#Basics_of_USB_Transfers">Basics of USB Transfers</a>, USB transactions were mentioned only briefly as has been reproduced below:
</p>
<pre>Most USB transactions consist of three packets:
* A <b>token packet</b> indicates the type and direction of the transaction, the device address, and an
  endpoint number.
* Depending on the direction of the transaction, either the host or the function sends a <b>data packet</b>
  (which may simply indicate that there is no data to send).
* The receiving device responds with a <b>handshake packet</b> to indicate if the transfer was successful.
</pre>
<p>Then, under <a href="USB#Packets">Packets</a>, a packet was described as "the atomic unit of data transfer."
</p><p>If a packet is an atom, then a transaction would be a molecule.  That is, a transaction is made up of several packets in a specific order, and the packets which make up a transaction cannot be reordered or separated and still yield the same transaction.  Transactions are normally named after their token packet (or their "special" packet, in the case of PING or SPLIT because these special packets play the same role as token packets), with the exception that IN or OUT transactions are often referred to, collectively, as DATA transactions.  In examples, transactions that contain a data stage often indicate the type of DATA PID used by either appending 0, 1, 2, or M to the name, or adding it in parenthesis (e.g, SETUP(0) or SETUP0, OUT1 or OUT(1)).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:454px;"><a href="./File:SETUPTransaction.gif" class="image"><img alt="" src="images/4/49/SETUPTransaction.gif" decoding="async" width="452" height="118" class="thumbimage" data-file-width="452" data-file-height="118" /></a>  <div class="thumbcaption">Figure 15: Illustrates a SETUP transaction, which consists of a SETUP packet, a DATA0 packet, and a handshake packet (in this case, an ACK handshake).</div></div></div></div>
<p>An example of a single SETUP transaction is depicted in figure 15.  This transaction contains the typical three packets.  The token packet has a SETUP PID, the data packet has a DATA0 PID (recall that a SETUP packet initializes both the function's and the host's data toggle bits to 0), and the handshake response has an ACK PID.
</p><p>Transfers are made up of transactions.  Transactions may not be reordered within a transfer but, as discussed in <a href="USB#Frames_and_Microframes">Frames and Microframes</a>, the transactions of a particular transfer may or may not be sent over the bus in a continuous fashion.  The rest of this section looks at the transactions involved in the four transfer types.
</p>
<h4><span class="mw-headline" id="Control_Transfers_2">Control Transfers</span></h4>
<p>Control transfers are the only transfers that use the SETUP transaction.  Control transfers take place in up to three stages:
</p>
<ul><li>The SETUP stage consists simply of a SETUP transaction</li>
<li>The DATA stage is optional.  If used, it may contain either one or more IN transactions, or one or more OUT transactions.  The first of these IN or OUT transactions uses the DATA1 PID.  The second, if present, uses the DATA0 PID, the third DATA1, and so on.</li>
<li>The STATUS stage consists of a single IN or a single OUT transaction, which must use the DATA1 PID.  If the DATA stage is present, then the STATUS stage uses the opposite type of transaction as the DATA stage (i.e, if the DATA stage consists of one or more OUT transactions, the STATUS stage consists of a single IN transaction, and vice versa).  When the DATA stage is omitted, the STATUS stage uses a single IN transaction.</li></ul>
<p>Figure 16 is taken from Figure 8-37 of the USB 2.0 specification and illustrates the transaction order, data sequence bit value, and DATA PID type for control read and write sequences.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:766px;"><a href="./File:ControlTx.gif" class="image"><img alt="" src="images/8/8f/ControlTx.gif" decoding="async" width="764" height="310" class="thumbimage" data-file-width="764" data-file-height="310" /></a>  <div class="thumbcaption">Figure 16: Control read and write sequences</div></div></div></div>
<h4><span class="mw-headline" id="Bulk_and_Interrupt_Transfers">Bulk and Interrupt Transfers</span></h4>
<p>In the context of the USB protocol, the only difference between bulk and interrupt transfers is that bulk transfers, when operating at high-speed, support the <a href="USB#PING_Transaction_Protocol">PING Transaction Protocol</a>.  Note that in a general context, these two transfer types are also different in that they are scheduled differently by the host (refer to <a href="USB#Bus_Time_Rationing">Bus Time Rationing</a>).
</p><p>All bulk and interrupt endpoints transfer in one direction.  The data toggle bits for these endpoints are initialized to zero after any configuration event.  Figure 17 is taken from Figure 8-35 of the USB 2.0 specification and illustrates the bulk and interrupt transactions for both IN and OUT endpoints.  Note that, even though the figure only mentions bulk reads and bulk writes, the USB 2.0 specification references the same figure from section 8.5.4, on Interrupt Transactions.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:509px;"><a href="./File:BulkInterruptTx.gif" class="image"><img alt="" src="images/e/e8/BulkInterruptTx.gif" decoding="async" width="507" height="126" class="thumbimage" data-file-width="507" data-file-height="126" /></a>  <div class="thumbcaption">Figure 17: Bulk and interrupt transactions</div></div></div></div>
<h4><span class="mw-headline" id="Isochronous_Transfers">Isochronous Transfers</span></h4>
<p>Isochronous transfers are the only type of transfers whose transactions do not have a handshake phase.  Isochronous transfers should only use DATA0 PIDs, however the host controller must support DATA1 PIDs as well, even though isochronous transfers do not use a data synchronization bit mechanism.
</p>
<h4><span id="High-Speed.2C_High-Bandwidth_Isochronous_Transfers"></span><span class="mw-headline" id="High-Speed,_High-Bandwidth_Isochronous_Transfers">High-Speed, High-Bandwidth Isochronous Transfers</span></h4>
<p>High-speed, high-bandwidth isochronous transfers are a special case of isochronous transfers, where up to 3 transactions may occur in one microframe.  As a specific type of isochronous transfer, high-speed, high-bandwidth isochronous transfers omit the handshake phase of their transactions.  Since up to 3 transactions may occur in one microframe, high-speed, high-bandwidth isochronous transfers, it is necessary to use a data sequencing mechanism like the other transfer types.
</p><p>USB 2.0 does implement a data sequencing mechanism for high-speed, high-bandwidth isochronous transfers, but it works a little differently than as in other transfer types.  In fact, data sequencing works differently depending on whether an endpoint is an IN, or an OUT high-speed, high-bandwidth isochronous endpoint.
</p><p>For IN high-speed, high-bandwidth isochronous endpoints, the data sequencing is depicted in figure 18, which has been taken from figure 5-11 of the USB 2.0 specifications.  The last transaction in a microframe always uses the DATA0 PID.  The second-to-last transaction in a microframe uses the DATA1 PID, and the third-to-last transaction in a microframe always uses the DATA2 PID.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:805px;"><a href="./File:HSHBIsoIN.gif" class="image"><img alt="" src="images/4/42/HSHBIsoIN.gif" decoding="async" width="803" height="170" class="thumbimage" data-file-width="803" data-file-height="170" /></a>  <div class="thumbcaption">Figure 18: Data Phase Sequence for Isochronous IN High Bandwidth Endpoints</div></div></div></div>
<p>For OUT high-speed, high-bandwidth isochronous endpoints, the data sequencing is depicted in figure 19, which has been taken from figure 5-12 of the USB 2.0 specifications.  All transactions but the last transaction use the MDATA PID.  The last transaction uses either the DATA0, DATA1, or DATA2 PID, depending on how many transactions were intended to take place during the microframe.  If one transaction was meant to take place, it is also the last transaction and uses a DATA0 PID.  If two transactions were meant to take place, the last transaction uses a DATA1 PID.  If three transactions were meant to take place, the last transaction uses a DATA2 PID.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:799px;"><a href="./File:HSHBIsoOUT.gif" class="image"><img alt="" src="images/e/e7/HSHBIsoOUT.gif" decoding="async" width="797" height="167" class="thumbimage" data-file-width="797" data-file-height="167" /></a>  <div class="thumbcaption">Figure 19: Data Phase Sequence for Isochronous OUT High Bandwidth Endpoints</div></div></div></div>
<h2><span class="mw-headline" id="USB_Device_Framework">USB Device Framework</span></h2>
<p>The USB device framework is the thing that makes USB support so appealing.  The transfer types and USB protocol are well-designed, of course, but the USB device framework defines standard device states that all devices must support, as well as standard requests and responses that allow the host to retrieve more than enough information about a device to determine the correct device driver and report information about the device even if the correct device driver isn't available (e.g, the manufacturer's name, the product's name, etc).
</p>
<h3><span id="Functions.2C_Configurations.2C_Interfaces.2C_and_Endpoints"></span><span class="mw-headline" id="Functions,_Configurations,_Interfaces,_and_Endpoints">Functions, Configurations, Interfaces, and Endpoints</span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:346px;"><a href="./File:FunctionConfigsIFacesEPs.gif" class="image"><img alt="" src="images/a/af/FunctionConfigsIFacesEPs.gif" decoding="async" width="344" height="382" class="thumbimage" data-file-width="344" data-file-height="382" /></a>  <div class="thumbcaption">Figure 20: Illustration of the relationship between functions, configurations, interfaces, and endpoints.</div></div></div>
<p>All USB devices, or functions, have at least one configuration, and every configuration has at least one interface.  An interface may define zero or more endpoints.  This relationship is illustrated in figure 20.
</p><p>Although configurations descriptors are addressed sequentially starting with configuration descriptor zero, each configuration specifies a unique (within the scope of the function), none-zero configuration value.  The <b>configuration value</b> is what the host needs to know in order to apply a certain configuration to a device.  When asking for the current configuration of a device, a returned value of zero indicates that the device is not configured and is thus in the address state.
</p><p>An <b>interface</b> defines the functional use of a set of endpoints and may imply that certain class-specific requests can be executed via the default control pipe.  Thus, an interface need not necessarily define any additional endpoints.  No interface may define the functional use of endpoint zero.
</p><p>Each interface describes a unique set of endpoints within the scope of the configuration.  However, an interface may provide one or more <b>alternate settings</b>, which may have different definitions for the same set of endpoints.  When the host selects an alternate setting for an interface, the alternate setting's definitions are used instead of the default settings of the same interface.
</p>
<h3><span class="mw-headline" id="USB_Device_States">USB Device States</span></h3>
<p>A USB device may define states that are internal to the device, however the USB device framework defines a set of states that are visible to both the host and the device.  Those visible states are the following:
</p>
<ul><li><b>Attached</b> - Immediately after the USB device is attached to the USB system, it is in this state.  The USB specifications do not define the state of a USB device that is detached from a USB system.</li>
<li><b>Powered</b> - A device is in this state after it has both been attached to the bus, and the V<span style="vertical-align:sub;">BUS</span> line is applied to the device (the host controller drives the V<span style="vertical-align:sub;">BUS</span> at +5V, however this is only particularly important for hardware developers).  In this state, the device must not respond to any bus transactions.  The USB specification recognizes three potential scenarios with respect to how a device draws power:
<ul><li><i>Self-Powered Devices</i> draw power from an external power source (e.g, a USB printer plugs into the wall as well as a USB port).  Although the device may be considered technically "powered" even before attachment to the USB, it is still only considered powered after the V<span style="vertical-align:sub;">BUS</span> line is applied to the device.</li>
<li><i>Bus-Powered Devices</i> draw power solely from the USB up to 100mA.</li>
<li><i>Self- or Bus-Powered Devices</i> may draw power from either the bus or an external power source, depending on the configuration.  These devices may change power source at any time.  If a device is currently self-powered and requires more than 100mA of power, but switches to being bus-powered, then the device must return to the Address state.</li></ul></li>
<li><b>Default</b> - A device in the powered state enters the default state after receiving a bus reset.  In this state, the device is addressable at the default, reserved address of 0.  At this point, the device is operating at the correct speed.  The host is expected to allow 10 milliseconds before expecting the device to respond to data transfers after reset.</li>
<li><b>Address</b> - A device enters this state after the host assigns it an address via the default control pipe, which is always accessible whether the device's address has been set or not.</li>
<li><b>Configured</b> - A device is in this state after the host examines its possible configurations and selects one.  All endpoint's data toggle bits are initialized to zero when a device enters this state.</li>
<li><b>Suspended</b> - When no traffic is observed on the bus for a period of 1 millisecond, a USB device enters this state, characterized by its low power consumption.  The device's address and configuration settings are maintained while suspended.  A device exits the suspended state as soon as it begins seeing bus activity again.  The host is expected to allow 10 milliseconds before expecting the device to respond to data transfers after resume.</li></ul>
<h3><span class="mw-headline" id="Remote_Wakeup_Capability">Remote Wakeup Capability</span></h3>
<p>One of the reasons a USB device may stop seeing USB traffic and thus enter a suspended state is because the host may have entered a suspended state as well.  Some devices, typically keyboards and mice, support the ability to issue a remote wakeup signal to the host.  In case the host software does not support remote wakeup, this capability must be disabled when a USB device is reset.  If the host does support remote wakeup, then it may selectively enable the remote wakeup capability for specific devices (typically as chosen by the user).  Then, these devices may issue a remote wakeup signal while in a suspended state to request that the host exits its own suspended state.
</p>
<h3><span class="mw-headline" id="USB_Device_Enumeration">USB Device Enumeration</span></h3>
<p>The following describes the process of bus enumeration, which occurs after a device is connected to a powered port:
</p>
<ol><li>The hub to which the device has been attached notifies the host via its status change pipe.  The newly attached device is in the powered state at this point, and the port to which it has been attached is disabled.</li>
<li>The host queries more information from the hub to determine that a device has been attached, and to which port.</li>
<li>The host must wait at least 100 millisecond to allow a device to complete its insertion process, and for power to stabilize at the device.  After the delay, the host enables the port and issues a reset signal to the device for at least 50 milliseconds.</li>
<li>The hub performs any required reset processing.  After the reset signal has been released, the port is enabled and the device enters the default state.</li>
<li>The host assigns the device a unique address, thereby transitioning the device into the address state.</li>
<li>The host requests the device descriptor from the device via the default control pipe in order to determine the actual maximum data payload size of the default control pipe for the device.  This step may occur before or after the host assigns the device an address.</li>
<li>The host reads all the possible device configuration information.</li>
<li>The host selects a certain configuration from the list of configurations supported by the device and sets the device to use that configuration.  Optionally, the host may also select alternate interface settings within a configuration.  All endpoints are initialized as described by the selected configuration, and the device is ready to use.</li></ol>
<h3><span class="mw-headline" id="USB_Device_Requests">USB Device Requests</span></h3>
<p>Standard, class-specific, and vendor-specific requests are made to the USB device over the default control pipe.  The SETUP transaction always has a data payload size of 8 bytes, as noted in the <a href="USB#Maximum_Data_Payload_Size">Maximum Data Payload Size</a> section of <a href="USB#Control_Transfers">Control Transfers</a>.  The format of the setup data is as follows:
</p>
<table border="1" cellpadding="5">
<tbody><tr>
<th>Offset
</th>
<th>Field
</th>
<th>Size
</th>
<th>Type
</th>
<th>Description
</th></tr>
<tr valign="top" align="center">
<td>0
</td>
<td>bmRequestType
</td>
<td>1
</td>
<td>Bitmap
</td>
<td align="center">
<table border="1" cellpadding="15">
<tbody><tr>
<td>D<span style="vertical-align:sub;">7</span>
</td>
<td>D<span style="vertical-align:sub;">6</span>
</td>
<td>D<span style="vertical-align:sub;">5</span>
</td>
<td>D<span style="vertical-align:sub;">4</span>
</td>
<td>D<span style="vertical-align:sub;">3</span>
</td>
<td>D<span style="vertical-align:sub;">2</span>
</td>
<td>D<span style="vertical-align:sub;">1</span>
</td>
<td>D<span style="vertical-align:sub;">0</span>
</td></tr></tbody></table>
<table border="0" cellpadding="0">
<tbody><tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">7</span></b>
</td>
<td><b>Data transfer direction</b> <i>* The value of this bit is ignored when wLength is zero</i>
<ul><li>0b = Host-to-device</li>
<li>1b = Device-to-host</li></ul>
</td></tr>
<tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">6...5</span></b>
</td>
<td><b>Type of request</b>
<ul><li>00b = Standard</li>
<li>01b = Class</li>
<li>10b = Vendor</li>
<li>11b = Reserved</li></ul>
</td></tr>
<tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">4...0</span></b>
</td>
<td><b>Recipient</b>
<ul><li>00000b = Device</li>
<li>00001b = Interface</li>
<li>00010b = Endpoint</li>
<li>00011b = Other</li>
<li>00100b to 11111b = Reserved</li></ul>
</td></tr></tbody></table>
</td></tr>
<tr valign="top" align="center">
<td>1
</td>
<td>bRequest
</td>
<td>1
</td>
<td>Value
</td>
<td align="left">Specific request
</td></tr>
<tr valign="top" align="center">
<td>2
</td>
<td>wValue
</td>
<td>2
</td>
<td>Value
</td>
<td align="left">Word-sized field the may (or may not) serve as a parameter to the request, depending on the specific request.
</td></tr>
<tr valign="top" align="center">
<td>4
</td>
<td>wIndex
</td>
<td>2
</td>
<td>Index or offset
</td>
<td align="left">Word-sized field that may (or may not) serve as a parameter to the request, depending on the specific request.  Typically this field holds an index or an offset value.<br /><br />
<p>When bmRequestType specifies an endpoint as the recipient, the format of this field is as follows:
</p>
<table border="1" align="center">

<tbody><tr align="center">
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">7</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">6</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">5</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">4</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">3</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">2</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">1</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">0</span></b>
</td></tr>
<tr align="center">
<td>Direction
</td>
<td colspan="3">Reserved (reset to zero)
</td>
<td colspan="4">Endpoint Number
</td></tr>
<tr align="center">
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">15</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">14</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">13</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">12</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">11</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">10</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">9</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">8</span></b>
</td></tr>
<tr align="center">
<td colspan="8">Reserved (reset to zero)
</td></tr></tbody></table>
<p>The direction bit (bit <b>D<span style="vertical-align:sub;">7</span></b>) is set to zero to indicate the OUT endpoint with the specified endpoint number, or it is set to one to indicate the IN endpoint with the specified endpoint number.  The host should always set the direction bit to zero (but the device should accept either value) when the endpoint is part of a control pipe.
</p><p>When bmRequestType specifies an interface as the recipient, the format of this field is as follows:
</p>
<table border="1" align="center">

<tbody><tr align="center">
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">7</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">6</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">5</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">4</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">3</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">2</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">1</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">0</span></b>
</td></tr>
<tr align="center">
<td colspan="8">Interface Number
</td></tr>
<tr align="center">
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">15</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">14</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">13</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">12</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">11</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">10</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">9</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">8</span></b>
</td></tr>
<tr align="center">
<td colspan="8">Reserved (reset to zero)
</td></tr></tbody></table>
</td></tr>
<tr valign="top" align="center">
<td>6
</td>
<td>wLength
</td>
<td>2
</td>
<td>Count
</td>
<td align="left">Number of bytes to transfer if there is a DATA stage.<br /><br />
<ul><li>If this field is non-zero, and bmRequestType indicates a transfer from device-to-host, then the device must never return more than <i>wLength</i> bytes of data.  However, a device may return less.</li>
<li>If this field is non-zero, and the bmRequestType indicates a transfer from host-to-device, then the host must send exactly <i>wLength</i> bytes of data.  If the host sends more than <i>wLength</i> bytes, the behavior of the device is undefined.</li></ul>
</td></tr></tbody></table>
<p>When a device receives a request that is undefined, is inappropriate given the current setting or state of the device, or uses values that are inappropriate for the particular request, then a <b>Request Error</b> exists.  The device handles a Request Error by returning a STALL PID to the next DATA or STATUS stage, preferably at the next DATA stage transaction.
</p>
<h3><span class="mw-headline" id="Standard_Requests">Standard Requests</span></h3>
<table border="1" cellpadding="2" style="float:right;margin-left:20px;">
<caption align="bottom"><b>Standard USB Request Codes</b>
</caption>
<tbody><tr>
<th>bRequest
</th>
<th>Value
</th></tr>
<tr>
<td><a href="USB#GET_STATUS">GET_STATUS</a>
</td>
<td align="center">0
</td></tr>
<tr>
<td><a href="USB#CLEAR_FEATURE">CLEAR_FEATURE</a>
</td>
<td align="center">1
</td></tr>
<tr>
<td><i>Reserved</i>
</td>
<td align="center">2
</td></tr>
<tr>
<td><a href="USB#SET_FEATURE">SET_FEATURE</a>
</td>
<td align="center">3
</td></tr>
<tr>
<td><i>Reserved</i>
</td>
<td align="center">4
</td></tr>
<tr>
<td><a href="USB#SET_ADDRESS">SET_ADDRESS</a>
</td>
<td align="center">5
</td></tr>
<tr>
<td><a href="USB#GET_DESCRIPTOR">GET_DESCRIPTOR</a>
</td>
<td align="center">6
</td></tr>
<tr>
<td><a href="USB#SET_DESCRIPTOR">SET_DESCRIPTOR</a>
</td>
<td align="center">7
</td></tr>
<tr>
<td><a href="USB#GET_CONFIGURATION">GET_CONFIGURATION</a>
</td>
<td align="center">8
</td></tr>
<tr>
<td><a href="USB#SET_CONFIGURATION">SET_CONFIGURATION</a>
</td>
<td align="center">9
</td></tr>
<tr>
<td><a href="USB#GET_INTERFACE">GET_INTERFACE</a>
</td>
<td align="center">10
</td></tr>
<tr>
<td><a href="USB#SET_INTERFACE">SET_INTERFACE</a>
</td>
<td align="center">11
</td></tr>
<tr>
<td><a href="USB#SYNC_FRAME">SYNC_FRAME</a>
</td>
<td align="center">12
</td></tr></tbody></table>
<p>The standard requests are defined for all USB devices, and all USB devices must respond to these standard requests even if the device hasn't been assigned an address, or the device hasn't been configured.  To issue a certain request, the software creates the SETUP stage's DATA packet using the appropriate <b>request code</b>, a valid bmRequestType, the appropriate parameter values (or zero, if not applicable) for wValue and wIndex, and the amount of data bytes to be transfered for wLength.  To the right are the standard USB device request codes, and the remainder of this section discusses each request.
</p>
<h4><span class="mw-headline" id="SET_ADDRESS">SET_ADDRESS</span></h4>
<p>The SET_ADDRESS request has the following SETUP DATA packet format:
</p>
<table align="center" border="1" cellpadding="5">
<caption align="bottom"><b>SET_ADDRESS SETUP DATA Packet Format</b>
</caption>
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th>wValue
</th>
<th>wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>00000000b
</td>
<td>SET_ADDRESS<br />5
</td>
<td>Device Address
</td>
<td>Zero
</td>
<td>Zero
</td></tr></tbody></table>
<p>This request does not have a DATA stage, only a SETUP and STATUS stage.
</p><p><i>wValue</i> specifies the address to be assigned to the device.  The behavior of a device is undefined when <i>wValue</i> specifies an address greater than 127.
</p><p>The exact behavior of the device after the SET_ADDRESS requests depends on the current state of the device:
</p>
<ul><li>When a device is in the default state, a non-zero <i>wValue</i> causes the device to transition into the address state.  When a device is in the default state, a <i>wValue</i> of zero has no effect.</li>
<li>When a device is in the address state, a non-zero <i>wValue</i> keeps a device in the Address state, but the device responds to the newly set address.  When a device is in the address state, a <i>wValue</i> of zero transitions the device into the default state.</li>
<li>When a device is in the configurd state, device behavior is not defined for the SET_ADDRESS request.</li></ul>
<p>This is the only request that is complete after the STATUS stage completes successfully.  After the reset/resume recovery interval (10 milliseconds), a device is expected to be able to complete the STATUS stage of this request within 50 milliseconds.  After the STATUS stage is complete, the device is allowed a 2 millisecond recovery interval before it must be able to accept farther SETUP packets for additional requests.
</p>
<h4><span class="mw-headline" id="GET_DESCRIPTOR">GET_DESCRIPTOR</span></h4>
<table border="1" cellpadding="2" style="float:right;clear:right;margin-left:20px;">
<caption align="bottom"><b>Standard USB Descriptor Types</b>
</caption>
<tbody><tr>
<th>Descriptor Type
</th>
<th>Value
</th></tr>
<tr>
<td><a href="USB#DEVICE">DEVICE</a>
</td>
<td align="center">1
</td></tr>
<tr>
<td><a href="USB#CONFIGURATION">CONFIGURATION</a>
</td>
<td align="center">2
</td></tr>
<tr>
<td><a href="USB#STRING">STRING</a>
</td>
<td align="center">3
</td></tr>
<tr>
<td><a href="USB#INTERFACE">INTERFACE</a>
</td>
<td align="center">4
</td></tr>
<tr>
<td><a href="USB#ENDPOINT">ENDPOINT</a>
</td>
<td align="center">5
</td></tr>
<tr>
<td><a href="USB#DEVICE_QUALIFIER">DEVICE_QUALIFIER</a>
</td>
<td align="center">6
</td></tr>
<tr>
<td><a href="USB#OTHER_SPEED_CONFIGURATION">OTHER_SPEED_CONFIGURATION</a>
</td>
<td align="center">7
</td></tr>
<tr>
<td>INTERFACE_POWER
</td>
<td align="center">8
</td></tr></tbody></table>
<p>The GET_DESCRIPTOR request has the following SETUP DATA packet format:
</p>
<table align="center" border="1" cellpadding="5">
<caption align="bottom"><b>GET_DESCRIPTOR SETUP DATA Packet Format</b>
</caption>
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th colspan="2">wValue
</th>
<th>wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>10000000b
</td>
<td>GET_DESCRIPTOR<br />6
</td>
<td>Descriptor Type
</td>
<td>Descriptor Index
</td>
<td>Zero or<br />Language ID
</td>
<td>Descriptor<br />Length
</td></tr></tbody></table>
<p>The high-order byte of <i>wValue</i> specifies the descriptor type (see table of usb standard descriptor types, to the right).  The low-order byte of <i>wValue</i> is only used for selecting a specific STRING or CONFIGURATION descriptor, and should be reset to zero otherwise.
</p><p>The <i>wIndex</i> field is only used for STRING descriptors to specify the desired language and should be reset to zero for other descriptor types.
</p><p>Different descriptor types have different lengths which will be discussed soon.  If <i>wLength</i> is less than the size of the descriptor being returned, then the device only returns the first <i>wLength</i> bytes of the descriptor data.  If <i>wLength</i> is larger than the size of the descriptor being returned, than the full descriptor is returned, followed by a short packet (a packet shorter than the maximum data payload size, including a length of 0 bytes).
</p><p>All USB devices must support requests for DEVICE, CONFIGURATION, and STRING descriptors.  All high-speed devices must support basic operations at full-speed; such devices also support DEVICE_QUALIFIER and OTHER_SPEED_CONFIGURATION descriptors which return the same data that the device would return for DEVICE and CONFIGURATION descriptor requests, respectively, if the device were operating at the speed at which it is not currently operating.
</p><p>A request for a CONFIGURATION descriptor also returns all the INTERFACE descriptors for the specified configuration descriptor index (i.e, the low-order byte of <i>wValue</i>), as well as all of the ENDPOINT descriptors associated with all of the returned INTERFACE descriptors, all in a single request.
</p><p>GET_DESCRIPTOR is a valid request for a device in the default, address, or configured state.
</p>
<h4><span class="mw-headline" id="SET_DESCRIPTOR">SET_DESCRIPTOR</span></h4>
<p>The SET_DESCRIPTOR request is optional; when it is supported, it may be used to update descriptors or add new ones.
</p><p>The SET_DESCRIPTOR request has the following SETUP DATA packet format:
</p>
<table align="center" border="1" cellpadding="5">
<caption align="bottom"><b>SET_DESCRIPTOR SETUP DATA Packet Format</b>
</caption>
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th colspan="2">wValue
</th>
<th>wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>00000000b
</td>
<td>SET_DESCRIPTOR<br />7
</td>
<td>Descriptor Type
</td>
<td>Descriptor Index
</td>
<td>Zero or<br />Language ID
</td>
<td>Descriptor<br />Length
</td></tr></tbody></table>
<p>The high-order byte of <i>wValue</i> specifies the descriptor type.  The low-order byte of <i>wValue</i> is only used for selecting a specific STRING or CONFIGURATION descriptor, and should be reset to zero otherwise.
</p><p>The <i>wIndex</i> field is only used for STRING descriptors to specify the desired language and should be reset to zero for other descriptor types.
</p><p>The <i>wLength</i> field specifies how many bytes will be transfered from the host to the device.
</p><p>This request only supports DEVICE, CONFIGURATIOn, and STRING descriptor types.
</p><p>If this request is not supported, the device responds with a Reuqest Error.
</p><p>If this request is supported, it is only valid when the device is in the address or configured state; the behavior of the device is undefined if this request is made while the device is in the default state.
</p>
<h4><span class="mw-headline" id="GET_CONFIGURATION">GET_CONFIGURATION</span></h4>
<p>The GET_CONFIGURATION request has the following SETUP DATA packet format:
</p>
<table align="center" border="1" cellpadding="5">
<caption align="bottom"><b>GET_CONFIGURATION SETUP DATA Packet Format</b>
</caption>
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th>wValue
</th>
<th>wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>10000000b
</td>
<td>GET_CONFIGURATION<br />8
</td>
<td>Zero
</td>
<td>Zero
</td>
<td>One
</td></tr></tbody></table>
<p>The device sends a one-byte DATA packet during the DATA phase of the control transfer.  This byte is the value of the current configuration of the device.  A value of zero indicates that the device has not yet been configured (it is in the address state).  Behavior of a device is undefined if this request is issued while the device is in the default state.
</p>
<h4><span class="mw-headline" id="SET_CONFIGURATION">SET_CONFIGURATION</span></h4>
<p>The SET_CONFIGURATION request has the following SETUP DATA packet format:
</p>
<table align="center" border="1" cellpadding="5">
<caption align="bottom"><b>SET_CONFIGURATION SETUP DATA Packet Format</b>
</caption>
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th colspan="2">wValue
</th>
<th>wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>00000000b
</td>
<td>SET_CONFIGURATION<br />9
</td>
<td><i>Reserved</i>
</td>
<td>Configuration Value
</td>
<td>Zero
</td>
<td>Zero
</td></tr></tbody></table>
<p>The low-order byte of <i>wValue</i> specifies the desired configuration value.  The low-order byte of <i>wValue</i> must either be zero, or it must match the configuration value field of a configuration descriptor returned by the device.  Specifying a configuration value of zero sets the device into the address state.
</p><p>If the device is in the default state, or if the high-order byte of <i>wValue</i> is not zero, <i>wIndex</i> is not zero, or <i>wLength</i> is not zero, then the behavior after issuing this request is undefined.
</p><p>If the specified configuration value is neither zero nor a valid configuration value specified by a configuration descriptor of the device, the device responds with a Request Error.
</p>
<h4><span class="mw-headline" id="GET_INTERFACE">GET_INTERFACE</span></h4>
<p>The GET_INTERFACE request has the following SETUP DATA packet format:
</p>
<table align="center" border="1" cellpadding="5">
<caption align="bottom"><b>GET_INTERFACE SETUP DATA Packet Format</b>
</caption>
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th>wValue
</th>
<th>wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>10000001b
</td>
<td>GET_INTERFACE<br />10
</td>
<td>Zero
</td>
<td>Interface
</td>
<td>One
</td></tr></tbody></table>
<p>The host uses this request to determine which alternate setting (as described in <a href="USB#Functions.2C_Configurations.2C_Interfaces.2C_and_Endpoints">Functions, Configurations, Interfaces, and Endpoints</a>) is used for a particular interface of the current configuration.  The device responds with a one-byte long DATA packet during the data phase, the transfered byte being the alternate setting value for the interface specified in this request.
</p><p>If <i>wValue</i> is not zero, <i>wLength</i> is not one, <i>wIndex</i> specifies an invalid interface, or the device is in the address state, then the device responds with a Request Error.
</p><p>The behavior of a device in the default state after receiving this request is undefined.
</p><p>This request is valid for a device in the configured state.
</p>
<h4><span class="mw-headline" id="SET_INTERFACE">SET_INTERFACE</span></h4>
<p>The SET_INTERFACE request has the following SETUP DATA packet format:
</p>
<table align="center" border="1" cellpadding="5">
<caption align="bottom"><b>SET_INTERFACE SETUP DATA Packet Format</b>
</caption>
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th>wValue
</th>
<th>wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>00000001b
</td>
<td>SET_INTERFACE<br />11
</td>
<td>Alternate Setting
</td>
<td>Interface
</td>
<td>Zero
</td></tr></tbody></table>
<p>The host uses this request to select an alternate setting (as described in <a href="USB#Functions.2C_Configurations.2C_Interfaces.2C_and_Endpoints">Functions, Configurations, Interfaces, and Endpoints</a>) to be used for a particular interface of the current configuration.  If the interface specified only supports a default setting, then the device may return a STALL handshake during the STATUS stage of the request.
</p><p>If the interface or alternate setting do not exist, or if the device is in the address state, then the device responds with a Request Error.  The behavior of the device is undefined if <i>wLength</i> is not zero, or the device is in the default state.
</p><p>This is a valid request when the device is in the configured state.
</p>
<h4><span class="mw-headline" id="CLEAR_FEATURE">CLEAR_FEATURE</span></h4>
<table style="clear:right;float:right;margin-left:20px;" border="1" cellpadding="2">
<caption align="bottom"><b>Standard USB Feature Selectors</b>
</caption>
<tbody><tr>
<th>Feature Selector
</th>
<th>Recipient
</th>
<th>Value
</th></tr>
<tr>
<td>DEVICE_REMOTE_WAKEUP
</td>
<td align="center">Device
</td>
<td align="center">1
</td></tr>
<tr>
<td>ENDPOINT_HALT
</td>
<td align="center">Endpoint
</td>
<td align="center">0
</td></tr>
<tr>
<td>TEST_MODE
</td>
<td align="center">Device
</td>
<td align="center">2
</td></tr></tbody></table>
<p>The CLEAR_FEATURE request has the following SETUP DATA packet format:
</p>
<table align="center" border="1" cellpadding="5">
<caption align="bottom"><b>CLEAR_FEATURE SETUP DATA Packet Format</b>
</caption>
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th>wValue
</th>
<th>wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>00000000b<br />00000001b<br />00000010b
</td>
<td>CLEAR_FEATURE<br />1
</td>
<td>Feature Selector
</td>
<td>Zero or<br />Interface or<br />Endpoint
</td>
<td>Zero
</td></tr></tbody></table>
<p>The host uses this request to clear or disable a specific feature.
</p><p><i>wValue</i> must contain a feature selector (see table of Standard USB Feature Selectors, to the right) which corresponds with the recipient as specified in the <i>bmRequestType</i> value.
</p><p>Issuing this request while referencing a feature that cannot be cleared or does not exist, or referencing an interface or endpoint that does not exist will cause the device to respond with a Request Error.
</p><p>If the device is in the default state, or <i>wLength</i> is non-zero, then the behavior of the device is undefined.
</p><p>This request is valid when the device is in the configured state.  When the device is in the address state, this request is only valid when referencing endpoint zero, otherwise the device responds with a Request Error.
</p><p>The TEST_MODE feature cannot be cleared by this request.
</p>
<h4><span class="mw-headline" id="SET_FEATURE">SET_FEATURE</span></h4>
<table style="clear:right;float:right;margin-left:20px;" border="1" cellpadding="2">
<caption align="bottom"><b>Standard USB Test Selectors</b>
</caption>
<tbody><tr>
<th>Value
</th>
<th>Description
</th></tr>
<tr>
<td align="center">00h
</td>
<td><i>Reserved</i>
</td></tr>
<tr>
<td align="center">01h
</td>
<td>Test_J
</td></tr>
<tr>
<td align="center">02h
</td>
<td>Test_K
</td></tr>
<tr>
<td align="center">03h
</td>
<td>Test_SE0_NAK
</td></tr>
<tr>
<td align="center">04h
</td>
<td>Test_Packet
</td></tr>
<tr>
<td align="center">05h
</td>
<td>Test_Force_Enable
</td></tr>
<tr>
<td align="center">06h-3Fh
</td>
<td><i>Reserved for standard test selectors</i>
</td></tr>
<tr>
<td align="center">3Fh-BFh
</td>
<td><i>Reserved</i>
</td></tr>
<tr>
<td align="center">C0h-FFh
</td>
<td><i>Reserved for vendor-specific test modes</i>
</td></tr></tbody></table>
<p>The SET_FEATURE request has the following SETUP DATA packet format:
</p>
<table align="center" border="1" cellpadding="5">
<caption align="bottom"><b>SET_FEATURE SETUP DATA Packet Format</b>
</caption>
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th>wValue
</th>
<th colspan="2">wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>00000000b<br />00000001b<br />00000010b
</td>
<td>SET_FEATURE<br />3
</td>
<td>Feature Selector
</td>
<td>Test selector
</td>
<td>Zero or<br />Interface or<br />Endpoint
</td>
<td>Zero
</td></tr></tbody></table>
<p>The host uses this request to set or enable a specific feature.
</p><p><i>wValue</i> must contain a feature selector which corresponds with the recipient as specified in the <i>bmRequestType</i> value.
</p><p>When <i>wValue</i> selects the TEST_MODE feature, <i>bmRequestType</i> and the low-order byte of <i>wIndex</i> must both be reset to zero.  The high-order byte of <i>wIndex</i> must be a valid test selector (see table of Standard USB Test Selectors, to the right), or the device respond with Request Error.  The device must set its upstream-facing port into test mode no longer than 3milliseconds after completing the STATUS stage of this request.  In order to exit test mode, the power to the device must be cycled.  A device must support the TEST_MODE feature in the default, address, and configured high-speed device states.
</p><p>If this request references a feature that does not exist or cannot be set, then the devices responds with a STALL handshake during the STATUS stage.
</p><p>If an endpoint or interface is specified that does not exist, or if the device is in the address state and an endpoint other than endpoint zero is specified, the device responds with a Request Error.
</p><p>Besides requests which select the TEST_MODE feature, issuing this request to a device in the default state results in undefined behavior.  A non-zero value for <i>wLength</i> also results in undefined behavior.
</p><p>This request is valid when a device is in the configured state, or when the device is in the address state and only endpoint zero is referenced.
</p>
<h4><span class="mw-headline" id="GET_STATUS">GET_STATUS</span></h4>
<p>The GET_STATUS request has the following SETUP DATA packet format:
</p>
<table align="center" border="1" cellpadding="5">
<caption align="bottom"><b>GET_STATUS SETUP DATA Packet Format</b>
</caption>
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th>wValue
</th>
<th>wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>10000000b<br />10000001b<br />10000010b
</td>
<td>GET_STATUS<br />0
</td>
<td>Zero
</td>
<td>Zero or<br />Interface or<br />Endpoint
</td>
<td>Two
</td></tr></tbody></table>
<p>The host uses this request to learn the status of the recipient, as specified by the <i>bmRequestType</i> field and, in the case of an interface or endpoint recipient, the <i>wIndex</i> field.
</p><p>If <i>wValue</i> is not zero, <i>wLength</i> is not two, or <i>wIndex</i> is non-zero when <i>bmRequestType</i> specifies a device recipient, or the device is in the default state, then the behavior of the device is undefined.
</p><p>If this request references an endpoint or interface that does not exist (including any endpoint other than endpoint zero when the device is in the address state), then the device responds with a Request Error.
</p><p>In response to this request, the device issues a 2 byte long data transfer during the DATA stage to the host.  These two bytes represent the requested status and the meaning depends on the recipient type.
</p>
<h5><span class="mw-headline" id="Device_Recipient">Device Recipient</span></h5>
<p>When the recipient was a device, the two bytes describe the status as follows:
</p>
<table align="center" border="1">

<tbody><tr align="center">
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">7</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">6</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">5</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">4</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">3</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">2</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">1</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">0</span></b>
</td></tr>
<tr align="center">
<td colspan="6"><i>Reserved (reset to zero)</i>
</td>
<td>Remote<br />Wakeup
</td>
<td>Self<br />Powered
</td></tr>
<tr align="center">
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">15</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">14</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">13</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">12</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">11</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">10</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">9</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">8</span></b>
</td></tr>
<tr align="center">
<td colspan="8"><i>Reserved (reset to zero)</i>
</td></tr></tbody></table>
<p>The <i>Self Powered</i> field is set to 1 to indicate that the device is currently powered by an external power source, or 0 to indicate that the device is currently running on power supplied by the bus.
</p><p>The <i>Remote Wakeup</i> field is set to 0 when the device is reset and indicates whether or not the device is currently enabled to perform remote wakeup signaling (see <a href="USB#Remote_Wakeup_Capability">Remote Wakeup Capability</a>).  The host may modify the value of the <i>Remote Wakeup</i> field by issuing either a CLEAR_FEATURE or SET_FEATURE request using the DEVICE_REMOTE_WAKEUP feature selector.
</p>
<h5><span class="mw-headline" id="Interface_Recipient">Interface Recipient</span></h5>
<p>When the recipient was an interface, the two bytes describe the status as follows:
</p>
<table align="center" border="1">

<tbody><tr align="center">
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">7</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">6</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">5</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">4</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">3</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">2</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">1</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">0</span></b>
</td></tr>
<tr align="center">
<td colspan="8"><i>Reserved (reset to zero)</i>
</td></tr>
<tr align="center">
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">15</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">14</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">13</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">12</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">11</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">10</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">9</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">8</span></b>
</td></tr>
<tr align="center">
<td colspan="8"><i>Reserved (reset to zero)</i>
</td></tr></tbody></table>
<h5><span class="mw-headline" id="Endpoint_Recipient">Endpoint Recipient</span></h5>
<p>When the recipient was an endpoint, the two bytes describe the status as follows:
</p>
<table align="center" border="1">

<tbody><tr align="center">
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">7</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">6</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">5</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">4</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">3</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">2</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">1</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">0</span></b>
</td></tr>
<tr align="center">
<td colspan="7"><i>Reserved (reset to zero)</i>
</td>
<td>Halt
</td></tr>
<tr align="center">
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">15</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">14</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">13</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">12</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">11</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">10</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">9</span></b>
</td>
<td style="padding:15px 15px 15px 15px;"><b>D<span style="vertical-align:sub;">8</span></b>
</td></tr>
<tr align="center">
<td colspan="8"><i>Reserved (reset to zero)</i>
</td></tr></tbody></table>
<p>All interrupt and bulk endpoint types must implement the halt feature, otherwise it is optional.  The <i>Halt</i> field reflects the status of the halt feature of the endpoint.  A value of 0 in the <i>Halt</i> field indicates that the endpoint is not halted, and a value of 1 in the <i>Halt</i> field indicates that the endpoint is halted.
</p><p>The host may set the halt feature of an endpoint with the SET_FEATURE request using the ENDPOINT_HALT feature selector, or the host may clear the halt feature of an endpoint with the CLEAR_FEATURE request using the ENDPOINT_HALT feature selector.  When the CLEAR_FEATURE request is used in this manner, and the endpoint uses a data toggle bit, the data toggle bit is reset to zero.
</p><p>The default control pipe is not required nor recommended to implement the halt feature, but some devices may choose to use the halt feature on the default control pipe to reflect a functional error condition.  When the halt feature is set on the default control pipe, the device responds with a STALL handshake during the DATA or STATUS stage of all transfers with the exception of the GET_STATUS, CLEAR_FEATURE, and SET_FEATURE standard requests.  Additionally, the device is not required to stall vendor- or class-specific requests when the halt feature is set.
</p>
<h4><span class="mw-headline" id="SYNCH_FRAME">SYNCH_FRAME</span></h4>
<p>The SYNCH_FRAME request has the following SETUP DATA packet format:
</p>
<table align="center" border="1" cellpadding="5">
<caption align="bottom"><b>SYNCH_FRAME SETUP DATA Packet Format</b>
</caption>
<tbody><tr>
<th>bmRequestType
</th>
<th>bRequest
</th>
<th>wValue
</th>
<th>wIndex
</th>
<th>wLength
</th></tr>
<tr align="center">
<td>10000010b
</td>
<td>SYNCH_FRAME<br />12
</td>
<td>Zero
</td>
<td>Endpoint
</td>
<td>Two
</td></tr></tbody></table>
<p>This request is only used for isochronous endpoints that use implicit pattern synchronization.  That is, some isochronous endpoints require per-frame transfers to vary in size according to a specific pattern (in order to attain an application-specific bit rate, for example).  This call causes the device to send the host a 2 byte value that is the number of the frame where the pattern began.
</p><p>High-speed isochronous endpoints that support this request must synchronize to the zeroth microframe, as well as have a time notion of classic frames (1 millisecond as opposed to 125 microsecond intervals).
</p><p>If <i>wValue</i> is not zero, <i>wLength</i> is not two, or the device is in the default state, then the behavior of the device is undefined.
</p><p>If the specified endpoint does not support this request, or the device is in the address state, then the device responds with a Request Error.
</p><p>This request is valid when the device is in the configured state.
</p>
<h3><span class="mw-headline" id="Standard_USB_Descriptors">Standard USB Descriptors</span></h3>
<p>A <b>descriptor</b> is a data structure with a defined format.  All standard descriptors begin with two bytes.  The first byte specifies the total length of the descriptor in bytes, including the first two mandatory bytes.  The second byte identifies the type of the descriptor.
</p><p>Some descriptors contain fields which specify an index of a STRING descriptor, but it is optional for a device to support STRING descriptors.  If a device does not support STRING descriptors, then all fields which reference an index of a STRING descriptor should be reset to zero.  Thus, a value of zero in any field that is meant to supply an index of a STRING descriptor indicates that no such STRING descriptor is available.
</p><p>If the second byte of a descriptor identifies that descriptor as one of the standard USB descriptors, but the first byte of that descriptor specifies a length less than the lengths defined in the USB 2.0 specifications (and, transitively, here), then the descriptor should be rejected by the host.  If the length field reports that the descriptor is longer than expected, then the extra data should be ignored, but still considered part of the descriptor (this is important when the device is returning multiple descriptors, as is the case when the host requests a CONFIGURATION descriptor).
</p><p>If class- or vendor-specific descriptors use the same format as standard descriptors (i.e, the two mandatory bytes at the beginning of the descriptor), then the class- or vendor-specific descriptors are interleaved within the results when the host requests a CONFIGURATION descriptor.  Otherwise, the class- or vendor-specific descriptors are accessed by passing a class- or vendor-specific descriptor type in a GET_DESCRIPTOR request.
</p><p>The remainder of this section serves to catalog the standard USB device descriptors and very closely mirrors section 9.6 of the USB 2.0 specifications.  These descriptor definitions supplement the <a href="USB#GET_DESCRIPTOR">GET_DESCRIPTOR</a> request.
</p>
<h4><span class="mw-headline" id="DEVICE">DEVICE</span></h4>
<p>Every USB device has exactly one DEVICE descriptor.  This descriptor provides general information about the device, as well as information that applies globally to the device and all of its configurations.
</p>
<table align="center" border="1">
<tbody><tr>
<th>Offset
</th>
<th>Field
</th>
<th>Size
</th>
<th>Type
</th>
<th>Description
</th></tr>
<tr valign="top">
<td align="center">0
</td>
<td>bLength
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Size of this descriptor in bytes
</td></tr>
<tr valign="top">
<td align="center">1
</td>
<td>bDescriptorType
</td>
<td align="center">1
</td>
<td align="center">Constant
</td>
<td>DEVICE Descriptor Type
</td></tr>
<tr valign="top">
<td align="center">2
</td>
<td>bcdUSB
</td>
<td align="center">2
</td>
<td align="center">BCD
</td>
<td>USB Specification Release Number in Binary-Coded Decimal (i.e, 2.10 is expressed as 210h).  Identifies the release of the USB Specification with with the device and its descriptors are compliant.
</td></tr>
<tr valign="top">
<td align="center">4
</td>
<td>bDeviceClass
</td>
<td align="center">1
</td>
<td align="center">Class
</td>
<td>Class code (assigned by the USB-IF)
<ul><li>This field is reset to zero if each interface within a configuration specifies its own class information and the various interfaces operate independently.</li>
<li>A value of FFh in this field indicates the device class is vendor-specific.</li></ul>
</td></tr>
<tr valign="top">
<td align="center">5
</td>
<td>bDeviceSubClass
</td>
<td align="center">1
</td>
<td align="center">SubClass
</td>
<td>Subclass Code (assigned by the USB-IF)
<ul><li>The subclass code of a device is qualified by the class code of that device.</li>
<li>If <i>bDeviceClass</i> is reset to zero, then this field must also be reset to zero.</li>
<li>When <i>bDeviceClass</i> is not set to FFh, then all values for this field are reserved for assignment by the USB-IF.</li></ul>
</td></tr>
<tr valign="top">
<td align="center">6
</td>
<td>bDeviceProtocol
</td>
<td align="center">1
</td>
<td align="center">Protocol
</td>
<td>Protocol code (assigned by the USB-IF)
<ul><li>The protocol code of a device is qualified by both the class and subclass codes of that device.</li>
<li>A value of 00h in this field means that the device may specify class-specific protocols on an interface basis, though this is not a requirement.</li>
<li>If this field is set to FFh, then the device uses a vendor-specific protocol.</li></ul>
</td></tr>
<tr valign="top">
<td align="center">7
</td>
<td>bMaxPacketSize0
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Maximum packet size for endpoint zero (8, 16, 32, or 64 are the only valid options)
</td></tr>
<tr valign="top">
<td align="center">8
</td>
<td>idVendor
</td>
<td align="center">2
</td>
<td align="center">ID
</td>
<td>Vendor ID (assigned by the USB-IF)
</td></tr>
<tr valign="top">
<td align="center">10
</td>
<td>idProduct
</td>
<td align="center">2
</td>
<td align="center">ID
</td>
<td>Product ID (assigned by the USB-IF)
</td></tr>
<tr valign="top">
<td align="center">12
</td>
<td>bcdDevice
</td>
<td align="center">2
</td>
<td align="center">BCD
</td>
<td>Device release number in binary-coded decimal
</td></tr>
<tr valign="top">
<td align="center">14
</td>
<td>iManufacturer
</td>
<td align="center">1
</td>
<td align="center">Index
</td>
<td>Index of STRING descriptor describing manufacturer
</td></tr>
<tr valign="top">
<td align="center">15
</td>
<td>iProduct
</td>
<td align="center">1
</td>
<td align="center">Index
</td>
<td>Index of STRING descriptor describing product
</td></tr>
<tr valign="top">
<td align="center">16
</td>
<td>iSerialNumber
</td>
<td align="center">1
</td>
<td align="center">Index
</td>
<td>Index of STRING descriptor describing the device's serial number
</td></tr>
<tr valign="top">
<td align="center">17
</td>
<td>bNumConfigurations
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Number of possible configurations
</td></tr></tbody></table>
<h4><span class="mw-headline" id="DEVICE_QUALIFIER">DEVICE_QUALIFIER</span></h4>
<p>A high-speed capable device that has different device information depending on the speed in which the device operating, then that device must also have a DEVICE_QUALIFIER descriptor.  This descriptor provides information about the device that would change if the device were operating at the alternate speed (i.e, when the device is operating at high-speed, this descriptor provides the differences if the device were operating a full-speed, and vice versa).  This descriptor leaves out fields from the DEVICE descriptor that would not reasonably depend on the speed of the device (e.g, index of the STRING descriptor describing the product).
</p><p>If a full-speed only device with a <i>bcdUSB</i> field of at least 0200h in its DEVICE descriptor receives a request for a DEVICE_QUALIFIER descriptor, it must respond with a Request Error.
</p>
<table align="center" border="1">
<tbody><tr>
<th>Offset
</th>
<th>Field
</th>
<th>Size
</th>
<th>Type
</th>
<th>Description
</th></tr>
<tr valign="top">
<td align="center">0
</td>
<td>bLength
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Size of this descriptor in bytes
</td></tr>
<tr valign="top">
<td align="center">1
</td>
<td>bDescriptorType
</td>
<td align="center">1
</td>
<td align="center">Constant
</td>
<td>DEVICE_QUALIFIER Descriptor Type
</td></tr>
<tr valign="top">
<td align="center">2
</td>
<td>bcdUSB
</td>
<td align="center">2
</td>
<td align="center">BCD
</td>
<td>USB Specification Release Number in Binary-Coded Decimal (i.e, 2.00 is expressed as 200h).  Identifies the release of the USB Specification with with the device and its descriptors are compliant.<br /><br />
<p>This field must be at least 0200h.
</p>
</td></tr>
<tr valign="top">
<td align="center">4
</td>
<td>bDeviceClass
</td>
<td align="center">1
</td>
<td align="center">Class
</td>
<td>Class code (assigned by the USB-IF)
</td></tr>
<tr valign="top">
<td align="center">5
</td>
<td>bDeviceSubClass
</td>
<td align="center">1
</td>
<td align="center">SubClass
</td>
<td>Subclass Code (assigned by the USB-IF)
</td></tr>
<tr valign="top">
<td align="center">6
</td>
<td>bDeviceProtocol
</td>
<td align="center">1
</td>
<td align="center">Protocol
</td>
<td>Protocol code (assigned by the USB-IF)
</td></tr>
<tr valign="top">
<td align="center">7
</td>
<td>bMaxPacketSize0
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Maximum packet size for endpoint zero (8, 16, 32, or 64 are the only valid options)
</td></tr>
<tr valign="top">
<td align="center">8
</td>
<td>bNumConfigurations
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Number of possible configurations
</td></tr>
<tr valign="top">
<td align="center">9
</td>
<td>bReserved
</td>
<td align="center">1
</td>
<td align="center">-
</td>
<td>Reserved for future uses, must be zero.
</td></tr></tbody></table>
<h4><span class="mw-headline" id="CONFIGURATION">CONFIGURATION</span></h4>
<p>All USB devices have at least one CONFIGURATION descriptor.  The host may request a specific CONFIGURATION descriptor by its descriptor indexx, which is zero based and has <i>bNumConfigurations</i> (as returned in the DEVICE descriptor) used indices.  That is, the valid values to be used as a descriptor index when requesting a CONFIGURATION descriptor are any integer in the range of 0 to <i>bNumConfigurations</i>-1, inclusive.
</p><p>Each CONFIGURATION descriptor has at least one INTERFACE descriptor, and each INTERFACE descriptor may have up to 15 ENDPOINT descriptors.  When the host requests a certain CONFIGURATION descriptor, the device returns the CONFIGURATION descriptor followed immediately by the first INTERFACE descriptor, followed immediately by all of the ENDPOINT descriptors for endpoints that the interface defines (which may be none).  This is followed immediately by the next INTERFACE descriptor if one exists, and then by its ENDPOINT descriptors if applicable.  This pattern continues until all the information within the scope of the specific configuration is transfered.
</p><p>When a device has vendor- or class-specific descriptors that conform to the standard USB descriptor format (that is, the first byte of the descriptor determines the length of the descriptor, and the second byte identifies the type of descriptor), those descriptors are also returned interleaved among the CONFIGURATION, INTERFACE, and ENDPOINT descriptors when the host requests a specific CONFIGURATION descriptor.  Therefore, the system software cannot assume continuous standard descriptors as implied by the previous paragraph; instead, the system software should check the descriptor type and skip that descriptor if it is not a standard descriptor.  The software should also check that standard descriptors report at least the expected length.
</p><p>Note that the CONFIGURATION descriptor index is not the same as the value <i>bConfigurationValue</i> in the CONFIGURATION descriptor.  <i>bConfigurationValue</i> is the value that the host passes as a parameter with the SET_CONFIGURATION request in order to select a particular configuration, whereas this cannot be done using the CONFIGURATION descriptor index.
</p>
<table align="center" border="1">
<tbody><tr>
<th>Offset
</th>
<th>Field
</th>
<th>Size
</th>
<th>Type
</th>
<th>Description
</th></tr>
<tr valign="top">
<td align="center">0
</td>
<td>bLength
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Size of this descriptor in bytes
</td></tr>
<tr valign="top">
<td align="center">1
</td>
<td>bDescriptorType
</td>
<td align="center">1
</td>
<td align="center">Constant
</td>
<td>CONFIGURATION Descriptor Type
</td></tr>
<tr valign="top">
<td align="center">2
</td>
<td>wTotalLength
</td>
<td align="center">2
</td>
<td align="center">Number
</td>
<td>The total combined length in bytes of all the descriptors returned with the request for this CONFIGURATION descriptor (including CONFIGURATION, INTERFACE, ENDPOINT, class- and vendor-specific descriptors).
</td></tr>
<tr valign="top">
<td align="center">4
</td>
<td>bNumInterfaces
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Number of interfaces supported by this configuration
</td></tr>
<tr valign="top">
<td align="center">5
</td>
<td>bConfigurationValue
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Value which when used as an argument in the SET_CONFIGURATION request, causes the device to assume the configuration described by this descriptor.
</td></tr>
<tr valign="top">
<td align="center">6
</td>
<td>iConfiguration
</td>
<td align="center">1
</td>
<td align="center">Index
</td>
<td>Index of STRING descriptor describing this configuration.
</td></tr>
<tr valign="top">
<td align="center">7
</td>
<td>bmAttributes
</td>
<td align="center">1
</td>
<td align="center">Bitmap
</td>
<td>Configuration Characteristics
<table border="1" cellpadding="15" align="center">
<tbody><tr>
<td>D<span style="vertical-align:sub;">7</span>
</td>
<td>D<span style="vertical-align:sub;">6</span>
</td>
<td>D<span style="vertical-align:sub;">5</span>
</td>
<td>D<span style="vertical-align:sub;">4</span>
</td>
<td>D<span style="vertical-align:sub;">3</span>
</td>
<td>D<span style="vertical-align:sub;">2</span>
</td>
<td>D<span style="vertical-align:sub;">1</span>
</td>
<td>D<span style="vertical-align:sub;">0</span>
</td></tr></tbody></table>
<table border="0" cellpadding="0" align="center" style="max-width:500px;">
<tbody><tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">7</span></b>
</td>
<td><i>Reserved, must be set to one for historical reasons</i>
</td></tr>
<tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">6</span></b>
</td>
<td><b>Self-Powered</b>
<ul><li>0 = Device runs on power supplied by the bus</li>
<li>1 = Device provides a local power source, if <i>bMaxPower</i> is non-zero, the device also may use bus power.</li></ul>
</td></tr>
<tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">5</span></b>
</td>
<td><b>Remote Wakeup</b>
<ul><li>0 = Remote Wakeup not supported</li>
<li>1 = Remote Wakeup supported</li></ul>
</td></tr>
<tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">4...0</span></b>
</td>
<td><i>Reserved, reset to zero</i>
</td></tr></tbody></table>
</td></tr>
<tr valign="top">
<td align="center">8
</td>
<td>bMaxPower
</td>
<td align="center">1
</td>
<td align="center">mA
</td>
<td>Maximum power consumption of this device from the bus when fully operational and using this configuration.
<ul><li>Expressed in units of 2mA (i.e., a value of 50 in this field indicates 100mA).</li>
<li>A device reports with the <i>bmAttributes</i> field whether the configuration is bus- or self-powered, but the device status (retrieved with a GET_STATUS request) reports whether the device is currently self-powered.</li>
<li>If a device is disconnected from an external power source, it may not draw more power from the bus than specified in this field.</li>
<li>Some devices may be able to operate solely on bus power.  A device that cannot and has lost its external power source will fail the operations it can no longer support.  It is up to the software on the host to determine when this is the case, which may be accomplished with a GET_STATUS request.</li></ul>
</td></tr></tbody></table>
<p><br />
</p>
<h4><span class="mw-headline" id="OTHER_SPEED_CONFIGURATION">OTHER_SPEED_CONFIGURATION</span></h4>
<p>This descriptor describes the configuration of a high-speed device if it were operating at it's alternative speed.  The host should not request this descriptor unless it already successfully received a DEVICE_QUALIFIER descriptor from the device.  The structure of the OTHER_SPEED_CONFIGURATION is identical to that of the CONFIGURATION descriptor shown above.  The only difference is that the <i>bDescriptorType</i> field reflects that the descriptor is an OTHER_SPEED_CONFIGURATION descriptor rather than a CONFIGURATION descriptor.
</p>
<h4><span class="mw-headline" id="INTERFACE">INTERFACE</span></h4>
<p>INTERFACE descriptors are only returned following a CONFIGURATION descriptor when the host requests a specific CONFIGURATION descriptor; it is not possible to directly request a specific INTERFACE descriptor.  An interface may provide alternate settings within a configuration that allow the endpoints and/or their characteristics to be varied.  A default interface has the <i>bAlternateSetting</i> field in its INTERFACE descriptor reset to zero.
</p>
<table align="center" border="1">
<tbody><tr>
<th>Offset
</th>
<th>Field
</th>
<th>Size
</th>
<th>Type
</th>
<th>Description
</th></tr>
<tr valign="top">
<td align="center">0
</td>
<td>bLength
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Size of this descriptor in bytes
</td></tr>
<tr valign="top">
<td align="center">1
</td>
<td>bDescriptorType
</td>
<td align="center">1
</td>
<td align="center">Constant
</td>
<td>INTERFACE Descriptor Type
</td></tr>
<tr valign="top">
<td align="center">2
</td>
<td>bInterfaceNumber
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Number of this interface.  Zero-based value which identifies the index of this interface in the array of interfaces supported within a configuration.
</td></tr>
<tr valign="top">
<td align="center">3
</td>
<td>bAlternateSetting
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Value used to select the alternate settings described by this INTERFACE descriptor for the interface with the <i>bInterfaceNumber</i> in the previous field.  This value is zero if this descriptor describes the default settings for a particular interface.
</td></tr>
<tr valign="top">
<td align="center">4
</td>
<td>bNumEndpoints
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Number of endpoints used by this interface, not including endpoint zero.
</td></tr>
<tr valign="top">
<td align="center">5
</td>
<td>bInterfaceClass
</td>
<td align="center">1
</td>
<td align="center">Class
</td>
<td>Class code (assigned by the USB-IF)
<ul><li>A value of zero here is reserved for future standardization.</li>
<li>If this value is FFh, the interface class is vendor-specific.</li>
<li>All other values are reserved for assignment by the USB-IF.</li></ul>
</td></tr>
<tr valign="top">
<td align="center">6
</td>
<td>bInterfaceSubClass
</td>
<td align="center">1
</td>
<td align="center">SubClass
</td>
<td>Subclass code (assigned by the USB-IF)
<ul><li>The subclass code in this field is qualified by the value of the <i>bInterfaceClass</i> field.</li>
<li>If <i>bInterfaceClass</i> is reset to zero, then this field must also be reset to zero.</li>
<li>If <i>bInterfaceClass</i> is not set to the value of FFh, then all values of this field are reserved for assignment by the USB-IF.</li></ul>
</td></tr>
<tr valign="top">
<td align="center">7
</td>
<td>bInterfaceProtocol
</td>
<td align="center">1
</td>
<td align="center">Protocol
</td>
<td>Protocol code (assigned by the USB-IF)
<ul><li>The protocol code in this field is qualified by the values of the <i>bInterfaceClass</i> and <i>bInterfaceSubClass</i> fields.</li>
<li>If an interface supports class-specific requests, then this field identifies the protocols that the device uses as defined by the specifications of the device class.</li>
<li>If this field is reset to zero, then the device does not use a class-specific protocol on this interface.</li>
<li>If this field is set to FFh, then the devices uses a vendor-specific protocol on this interface.</li></ul>
</td></tr>
<tr valign="top">
<td align="center">8
</td>
<td>iInterface
</td>
<td align="center">1
</td>
<td align="center">Index
</td>
<td>Index of STRING descriptor describing this interface
</td></tr></tbody></table>
<p><br />
</p>
<h4><span class="mw-headline" id="ENDPOINT">ENDPOINT</span></h4>
<p>Each endpoint used for a particular interface has a descriptor which follows after that particular interface's descriptor when the host requests a specific CONFIGURATION descriptor; the host cannot request a specific ENDPOINT descriptor explicitly.  And ENDPOINT descriptor never describes endpoint zero.
</p>
<table align="center" border="1">
<tbody><tr>
<th>Offset
</th>
<th>Field
</th>
<th>Size
</th>
<th>Type
</th>
<th>Description
</th></tr>
<tr valign="top">
<td align="center">0
</td>
<td>bLength
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Size of this descriptor in bytes
</td></tr>
<tr valign="top">
<td align="center">1
</td>
<td>bDescriptorType
</td>
<td align="center">1
</td>
<td align="center">Constant
</td>
<td>ENDPOINT Descriptor Type
</td></tr>
<tr valign="top">
<td align="center">2
</td>
<td>bEndpointAddress
</td>
<td align="center">1
</td>
<td align="center">Endpoint
</td>
<td>The address of the endpoint on the USB device described by this descriptor.  This field has the following format:
<table border="1" cellpadding="15" align="center">
<tbody><tr>
<td>D<span style="vertical-align:sub;">7</span>
</td>
<td>D<span style="vertical-align:sub;">6</span>
</td>
<td>D<span style="vertical-align:sub;">5</span>
</td>
<td>D<span style="vertical-align:sub;">4</span>
</td>
<td>D<span style="vertical-align:sub;">3</span>
</td>
<td>D<span style="vertical-align:sub;">2</span>
</td>
<td>D<span style="vertical-align:sub;">1</span>
</td>
<td>D<span style="vertical-align:sub;">0</span>
</td></tr></tbody></table>
<table border="0" cellpadding="0" align="center" style="max-width:500px;">
<tbody><tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">7</span></b>
</td>
<td><b>Direction</b> (ignored for control endpoints)
<ul><li>0 = OUT endpoint</li>
<li>1 = IN endpoint</li></ul>
</td></tr>
<tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">6...4</span></b>
</td>
<td><i>Reserved, reset to zero</i>
</td></tr>
<tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">3...0</span></b>
</td>
<td><b>Endpoint Number</b>
</td></tr></tbody></table>
</td></tr>
<tr valign="top">
<td align="center">3
</td>
<td>bmAttributes
</td>
<td align="center">1
</td>
<td align="center">Bitmap
</td>
<td>This field describes the endpoint's attributes as follows:
<table border="1" cellpadding="15" align="center">
<tbody><tr>
<td>D<span style="vertical-align:sub;">7</span>
</td>
<td>D<span style="vertical-align:sub;">6</span>
</td>
<td>D<span style="vertical-align:sub;">5</span>
</td>
<td>D<span style="vertical-align:sub;">4</span>
</td>
<td>D<span style="vertical-align:sub;">3</span>
</td>
<td>D<span style="vertical-align:sub;">2</span>
</td>
<td>D<span style="vertical-align:sub;">1</span>
</td>
<td>D<span style="vertical-align:sub;">0</span>
</td></tr></tbody></table>
<table border="0" cellpadding="0" align="center" style="max-width:500px;">
<tbody><tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">7...6</span></b>
</td>
<td><i>Reserved, reset to zero</i>
</td></tr>
<tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">5...4</span></b>
</td>
<td><b>Usage Type</b> (Isochronous endpoints only; reserved and reset to zero for other endpoints)
<ul><li>00 = Data endpoint</li>
<li>01 = Feedback endpoint</li>
<li>10 = Implicit feedback data endpoint</li>
<li>11 = Reserved</li></ul>
</td></tr>
<tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">3...2</span></b>
</td>
<td><b>Synchronization Type</b> (Isochronous endpoints only; reserved and reset to zero for other endpoint types)
<ul><li>00 = No synchronization</li>
<li>01 = Asynchronous</li>
<li>10 = Adaptive</li>
<li>11 = Synchronous</li></ul>
</td></tr>
<tr>
<td valign="top" style="min-width:80px;"><b>D<span style="vertical-align:sub;">1...0</span></b>
</td>
<td><b>Transfer Type</b>
<ul><li>00 = Control</li>
<li>01 = Isochronous</li>
<li>10 = Bulk</li>
<li>11 = Interrupt</li></ul>
</td></tr></tbody></table>
</td></tr>
<tr valign="top">
<td align="center">4
</td>
<td>wMaxPacketSize
</td>
<td align="center">2
</td>
<td align="center">Number
</td>
<td>Maximum packet size that this endpoint is capable of sending or receiving.
<ul><li>For isochronous endpoints, this value is used to reserve bus time; the pipe, however, may not always use all of the reserved bus time.</li>
<li>Bits 10...0 specify the maximum packet size in bytes.</li>
<li>For high-speed isochronous and interrupt endpoints, bits 12...11 specify the number of additional transaction opportunities per microframe (see <a href="USB#High-Speed.2C_High-Bandwidth_Endpoints">High-Speed, High-Bandwidth Endpoints</a>).  The format is as follows:
<ul><li>00 = None (1 transaction per microframe)</li>
<li>01 = 1 additional (2 transactions per microframe)</li>
<li>10 = 2 additional (3 transactions per microframe)</li>
<li>11 = Reserved</li></ul></li>
<li>Bits 15...13 are reserved and must be reset to zero.</li></ul>
</td></tr>
<tr valign="top">
<td align="center">6
</td>
<td>bInterval
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Interval for polling a device during a data transfer, expressed in units of microframes for high-speed devices, and frames for low- and full-speed devices.  The exact meaning of the value in this field depends on the endpoint type and the operating speed of the device:
<ul><li>Full- and High-speed isochronous endpoints, and high-speed interrupt endpoints:
<ul><li>This field must be in the range from 1 to 16.</li>
<li>This field is used to calculate the period as 2<span style="vertical-align:super;"><i>bInterval</i> - 1</span>.  That is, a value of 4 calculates to 2<span style="vertical-align:super;">4 - 1</span> = 2<span style="vertical-align:super;">3</span> = 8.</li></ul></li>
<li>Full- and Low-speed interrupt endpoints:
<ul><li>This field must be in the range from 1 to 255.</li></ul></li>
<li>High-speed bulk and control OUT endpoints:
<ul><li>This field must be in the range from 0 to 255.</li>
<li>This field specifies the maximum NAK rate of the endpoint.</li>
<li>A value of zero indicates that the endpoint never NAKs</li>
<li>Other values indicate at most 1 NAK each <i>bInterval</i> number of microframes.</li>
<li>See <a href="USB#PING_Transaction_Protocol">PING Transaction Protocol</a></li></ul></li></ul>
</td></tr></tbody></table>
<h4><span class="mw-headline" id="STRING">STRING</span></h4>
<p>Devices may optionally support STRING descriptors.  If a device does not support STRING descriptors, any field which references the index of a STRING descriptor must be reset to zero.  STRING descriptors use unicode encodings and may support multiple languages.  The host requests a STRING descriptor with the <a href="USB#GET_DESCRIPTOR">GET_DECRIPTOR</a> request and must pass the 16-bit LANGID (as defined by the USB-IF) of the desired language in the <i>wIndex</i> field.  The list of currently accepted LANGIDs is located <a rel="nofollow" class="external text" href="http://www.usb.org/developers/docs/USB_LANGIDs.pdf">here</a>.
</p><p>String index 0 for all languages returns a STRING descriptor that contains an array of all the two-byte LANGID codes that the device supports.
</p><p>Whether requesting a string or an array of LANGIDs, the data is not NULL-terminated.  Instead, the host determines the length of the data by subtracting 2 from the <i>bLength</i> field of the descriptor.
</p><p>When the host requests string index 0, the following descriptor is returned:
</p>
<table align="center" border="1">
<tbody><tr>
<th>Offset
</th>
<th>Field
</th>
<th>Size
</th>
<th>Type
</th>
<th>Description
</th></tr>
<tr valign="top">
<td align="center">0
</td>
<td>bLength
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Size of this descriptor in bytes
</td></tr>
<tr valign="top">
<td align="center">1
</td>
<td>bDescriptorType
</td>
<td align="center">1
</td>
<td align="center">Constant
</td>
<td>STRING Descriptor Type
</td></tr>
<tr valign="top">
<td align="center">2
</td>
<td>wLangID[0]
</td>
<td align="center">2
</td>
<td align="center">Number
</td>
<td>LANGID code zero
</td></tr>
<tr valign="top">
<td align="center">...
</td>
<td align="center">...
</td>
<td align="center">...
</td>
<td align="center">...
</td>
<td align="center">...
</td></tr>
<tr valign="top">
<td align="center">N
</td>
<td>wLangID[x]
</td>
<td align="center">2
</td>
<td align="center">Number
</td>
<td>LANGID code x
</td></tr></tbody></table>
<p>When the host requests a valid string index other than string index 0 for a supported LANGID, the following descriptor is returned:
</p>
<table align="center" border="1">
<tbody><tr>
<th>Offset
</th>
<th>Field
</th>
<th>Size
</th>
<th>Type
</th>
<th>Description
</th></tr>
<tr valign="top">
<td align="center">0
</td>
<td>bLength
</td>
<td align="center">1
</td>
<td align="center">Number
</td>
<td>Size of this descriptor in bytes
</td></tr>
<tr valign="top">
<td align="center">1
</td>
<td>bDescriptorType
</td>
<td align="center">1
</td>
<td align="center">Constant
</td>
<td>STRING Descriptor Type
</td></tr>
<tr valign="top">
<td align="center">2
</td>
<td>bString
</td>
<td align="center">N
</td>
<td align="center">Number
</td>
<td>Unicode string
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Typical_organization_of_system_software">Typical organization of system software</span></h2>
<p>This section discusses how system software is typically, reasonably organized.  This section also serves as an index to the wiki entries which provide, or will provide, farther information and perhaps programming examples.
</p>
<h3><span class="mw-headline" id="USB_Device_Drivers">USB Device Drivers</span></h3>
<p>As with any device driver, a USB device driver abstracts away from the low-level details on just how a specific device is being accessed, and provides the rest of the system and applications with a common interface (e.g, a file manager shouldn't have to know whether it is dealing with an external versus internal hard drive).
</p><p>USB device drivers typically implement a certain class of device as per the appropriate specifications.  Such classes of USB devices include, but are not limited to:
</p>
<ul><li><a href="USB_Mass_Storage_Class_Devices" title="USB Mass Storage Class Devices">USB Mass Storage Class Devices</a></li>
<li><a href="USB_Human_Input_Devices" class="mw-redirect" title="USB Human Input Devices">USB Human Input Devices</a></li></ul>
<h3><span class="mw-headline" id="USB_Driver">USB Driver</span></h3>
<p>Even a USB device driver need not be concerned with some of the lower-level details.  For instance, it shouldn't matter to the device driver if a device is connected directly to the root hub, or if it lies behind 3 hubs.  The device driver shouldn't worry about how much power the device needs from the bus.  This is where the USB driver comes in.
</p><p>The USB driver essentially provides the USB framework interface to device drivers.  The USB driver also handles connect and disconnect events on the USB, as well as determining which device driver is needed (according to the Class, Subclass, and Protocol codes), and if that device driver even exists.
</p>
<h3><span class="mw-headline" id="USB_Hub_Driver">USB Hub Driver</span></h3>
<p>Although the USB Driver knows some details about the USB topography, the responsibility of hub-specific communication (including split-transactions) is often separated from the USB Driver into another module called the USB Hub Driver.
</p><p>Depending on the design of the system, the USB Driver might bypass the USB Hub Driver when communicating with devices on the root hub, or the system may use the reserved address of 0 to indicate the root hub to the USB Hub Driver (it appears that Linux does this).
</p><p>Details on USB Hubs will eventually be discussed in the <a href="USB_Hubs" title="USB Hubs">USB Hubs</a> wiki entry.
</p>
<h3><span class="mw-headline" id="Host_Controller_Driver">Host Controller Driver</span></h3>
<p>As a request for a data transfer moves from the device driver, through the USB Driver, and through the USB Hub Driver, the request gains all the information needed for the host controller to generate the appropriate transactions on the bus.  However, depending on the host controller, this information needs to be formatted in a certain way and added for scheduling by the host controller.
</p><p>This task if given to the host controller driver.  Requests reach the host controller driver in a system-defined format, often called a USB Request Block (URB), or an I/O Request Packet (IRP).
</p><p>Additionally, host controller drivers are loaded by the PCI subsystem when a corresponding host controller is discovered during PCI enumeration.  The host controller driver is thus also responsible for initializing the host controller and perhaps loading the USB Hub Driver and the USB driver.  Combined, the USB driver, USB hub driver, and the host controller driver make up a USB subsystem.
</p>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="http://www.usb.org/home">USB.org</a></li>
<li><a rel="nofollow" class="external text" href="https://usb.org/document-library/usb-20-specification">USB Universal Serial Bus Revision 2.0 Specification</a></li>
<li><a rel="nofollow" class="external text" href="https://usb.org/document-library/usb-32-specification-released-september-22-2017-and-ecns">Universal Serial Bus Revision 3.2 Specification</a></li>
<li><a rel="nofollow" class="external text" href="http://www.usb.org/developers/wusb/wusb1_1_20100910.zip">Wireless USB Specification Revision 1.1</a></li>
<li><a rel="nofollow" class="external text" href="http://www.kernel.org/">The Linux kernel</a> (things tend to be confusing there, plus you have to be careful with educating yourself from Linux sources if your project isn't GPL'ed).</li>
<li><a rel="nofollow" class="external text" href="http://www.beyondlogic.org/usbnutshell/usb1.shtml">USB in a NutShell</a> may also interest you. It looks like a really good tutorial giving all the required knowledge to understand any other USB documentation/source code in a couple of HTML pages</li>
<li><a rel="nofollow" class="external text" href="http://www.usb.org/developers/docs/USB_LANGIDs.pdf">Currently accepted LANGIDs</a></li>
<li><a rel="nofollow" class="external text" href="http://www.usbmadesimple.co.uk/index.html">USB Made Simple</a></li>
<li><a rel="nofollow" class="external text" href="https://www.fysnet.net/the_universal_serial_bus.htm">USB: The Universal Serial Bus</a> is a book on writing device/system drivers for UHCI, OHCI, EHCI, and xHCI with various example devices and available source code.</li></ul>
<!-- 
NewPP limit report
Cached time: 20250211125019
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.139 seconds
Real time usage: 0.140 seconds
Preprocessor visited node count: 633/1000000
Post‐expand include size: 227/2097152 bytes
Template argument size: 135/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 4593/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.877      1 -total
 73.77%    0.647      4 Template:Main
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1725-0!canonical and timestamp 20250211125019 and revision id 27651.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Universal_Serial_Bus&amp;oldid=27651">https://wiki.osdev.org/index.php?title=Universal_Serial_Bus&amp;oldid=27651</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="./Category:USB" title="Category:USB">USB</a></li><li><a href="./Category:Buses" title="Category:Buses">Buses</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Universal+Serial+Bus" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="USB#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Universal_Serial_Bus" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:Universal_Serial_Bus" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Universal_Serial_Bus"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Universal_Serial_Bus&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Universal_Serial_Bus&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Universal_Serial_Bus" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/Universal_Serial_Bus" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Universal_Serial_Bus&amp;oldid=27651" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Universal_Serial_Bus&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/Universal_Serial_Bus" title="Universal Serial Bus – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 3 March 2023, at 15:07.</li>
	<li id="footer-info-0">This page has been accessed 26,070 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Universal_Serial_Bus&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.139","walltime":"0.140","ppvisitednodes":{"value":633,"limit":1000000},"postexpandincludesize":{"value":227,"limit":2097152},"templateargumentsize":{"value":135,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":4593,"limit":5000000},"timingprofile":["100.00%    0.877      1 -total"," 73.77%    0.647      4 Template:Main"]},"cachereport":{"timestamp":"20250211125019","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":250});});</script>
</body>
</html>