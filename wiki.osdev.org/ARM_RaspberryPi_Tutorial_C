<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Raspberry Pi Bare Bones - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"907c002a2040485d17e58deb","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Raspberry_Pi_Bare_Bones","wgTitle":"Raspberry Pi Bare Bones","wgCurRevisionId":29196,"wgRevisionId":29196,"wgArticleId":3316,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using duplicate arguments in template calls","Pages using deprecated source tags","Level 3 Tutorials","ARM","Raspberry Pi","Bare bones tutorials","C","C++"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Raspberry_Pi_Bare_Bones","wgRelevantArticleId":3316,
"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":"ARM_RaspberryPi_Tutorial_C","wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgInternalRedirectTargetUrl":"/Raspberry_Pi_Bare_Bones","wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","mmv.head",
"mmv.bootstrap.autostart","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="Raspberry_Pi_Bare_Bones"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Raspberry_Pi_Bare_Bones rootpage-Raspberry_Pi_Bare_Bones skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Raspberry Pi Bare Bones</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"><span class="mw-redirectedfrom">(Redirected from <a href="https://wiki.osdev.org/index.php?title=ARM_RaspberryPi_Tutorial_C&amp;redirect=no" class="mw-redirect" title="ARM RaspberryPi Tutorial C">ARM RaspberryPi Tutorial C</a>)</span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="ARM_RaspberryPi_Tutorial_C#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="ARM_RaspberryPi_Tutorial_C#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><center>
<table style="border: 1px solid #cfcfbf; margin-top: 25px; margin-bottom: 25px; background-color: #f0f0ff; text-align: center;">
<tbody><tr>
<td>
<p><big><b>WAIT! Have you read <a href="Getting_Started" title="Getting Started">Getting Started</a>, <a href="Beginner_Mistakes" title="Beginner Mistakes">Beginner Mistakes</a>, and some of the related <a href="./Category:OS_theory" title="Category:OS theory">OS theory</a>?</b></big>
</p>
</td></tr></tbody></table>
</center><table style="font-size:95%; line-height:1.5em; padding:0.25em; float:right; margin: 0 0 8px 15px; clear:right; border:1px solid #aaaaaa; background:#eee; text-align:center;;"><tbody><tr><th>Difficulty level</th></tr><tr><td><a href="./File:Difficulty_3.png" class="image"><img alt="Difficulty 3.png" src="images/c/c1/Difficulty_3.png" decoding="async" width="46" height="14" data-file-width="46" data-file-height="14" /></a><br />Advanced</td></tr></tbody></table>
<table style="font-size:95%; line-height:1.5em; padding:0.25em; float:right; margin: 0 0 8px 15px; clear: right; border:1px solid #aaaaaa; background:#eee; text-align:center; width:200px; ;"><tbody><tr><th style="background:#ffce7b; padding:0.3em; font-size:1.1em;"><a href="Kernels" class="mw-redirect" title="Kernels">Kernel Designs</a></th></tr><tr><th>Models</th></tr><tr><td><div>
<p><a href="Monolithic_Kernel" title="Monolithic Kernel">Monolithic Kernel</a><br />
<a href="Microkernel" title="Microkernel">Microkernel</a><br />
<a href="Hybrid_Kernel" title="Hybrid Kernel">Hybrid Kernel</a><br />
<a href="Exokernel" title="Exokernel">Exokernel</a><br />
<a href="Nanokernel" class="mw-redirect" title="Nanokernel">Nano/Picokernel</a><br />
<a href="Exokernel#Cache_Kernel" title="Exokernel">Cache Kernel</a><br />
<a href="Exokernel#Virtualizing_Kernel" title="Exokernel">Virtualizing Kernel</a><br />
<a href="Megalithic_Kernel" title="Megalithic Kernel">Megalithic Kernel</a><br />
</p>
</div></td></tr><tr><th>Other Concepts</th></tr><tr><td><div>
<p><a href="Modular_Kernel" title="Modular Kernel">Modular Kernel</a><br />
<a href="Higher_Half_Kernel" title="Higher Half Kernel">Higher Half Kernel</a><br />
<a href="Creating_a_64-bit_kernel" title="Creating a 64-bit kernel">64-bit Kernel</a><br />
</p>
</div></td></tr></tbody></table>
<p>This is a tutorial on operating systems development on the <a href="Raspberry_Pi" title="Raspberry Pi">Raspberry Pi</a>. This will serve as an example of how to create a minimal system, but not as an example of how to properly structure your project.
</p><p>There's a similar tutorial <a href="Raspberry_Pi_Bare_Bones_Rust" title="Raspberry Pi Bare Bones Rust">Raspberry Pi Bare Bones Rust</a> which uses Rust instead of C.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="ARM_RaspberryPi_Tutorial_C#Prepare"><span class="tocnumber">1</span> <span class="toctext">Prepare</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="ARM_RaspberryPi_Tutorial_C#Building_a_Cross-Compiler"><span class="tocnumber">2</span> <span class="toctext">Building a Cross-Compiler</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="ARM_RaspberryPi_Tutorial_C#Overview"><span class="tocnumber">3</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="ARM_RaspberryPi_Tutorial_C#Booting_the_Operating_System"><span class="tocnumber">4</span> <span class="toctext">Booting the Operating System</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="ARM_RaspberryPi_Tutorial_C#Pi_Model_A,_B,_A+,_B+,_and_Zero"><span class="tocnumber">4.1</span> <span class="toctext">Pi Model A, B, A+, B+, and Zero</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="ARM_RaspberryPi_Tutorial_C#Pi_2"><span class="tocnumber">4.2</span> <span class="toctext">Pi 2</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="ARM_RaspberryPi_Tutorial_C#Pi_3,_4"><span class="tocnumber">4.3</span> <span class="toctext">Pi 3, 4</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="ARM_RaspberryPi_Tutorial_C#Implementing_the_Kernel"><span class="tocnumber">5</span> <span class="toctext">Implementing the Kernel</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="ARM_RaspberryPi_Tutorial_C#Freestanding_and_Hosted_Environments"><span class="tocnumber">5.1</span> <span class="toctext">Freestanding and Hosted Environments</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="ARM_RaspberryPi_Tutorial_C#Writing_a_kernel_in_C"><span class="tocnumber">5.2</span> <span class="toctext">Writing a kernel in C</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="ARM_RaspberryPi_Tutorial_C#Linking_the_Kernel"><span class="tocnumber">6</span> <span class="toctext">Linking the Kernel</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="ARM_RaspberryPi_Tutorial_C#Booting_the_Kernel"><span class="tocnumber">7</span> <span class="toctext">Booting the Kernel</span></a>
<ul>
<li class="toclevel-2 tocsection-13"><a href="ARM_RaspberryPi_Tutorial_C#Testing_your_operating_system_(Real_Hardware)"><span class="tocnumber">7.1</span> <span class="toctext">Testing your operating system (Real Hardware)</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="ARM_RaspberryPi_Tutorial_C#Testing_your_operating_system_(QEMU)"><span class="tocnumber">7.2</span> <span class="toctext">Testing your operating system (QEMU)</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="ARM_RaspberryPi_Tutorial_C#Updated_Support_for_AArch64_(raspi2,_raspi3,_raspi4)"><span class="tocnumber">7.2.1</span> <span class="toctext">Updated Support for AArch64 (raspi2, raspi3, raspi4)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="ARM_RaspberryPi_Tutorial_C#See_Also"><span class="tocnumber">8</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="ARM_RaspberryPi_Tutorial_C#Articles"><span class="tocnumber">8.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="ARM_RaspberryPi_Tutorial_C#External_Links"><span class="tocnumber">8.2</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Prepare">Prepare</span></h2>
<p>You are about to begin development of a new operating system. Perhaps one day, your new operating system can be developed under itself. This is a process known as bootstrapping or going self-hosted. However, that is way into the future. Today, we simply need to set up a system that can compile your operating system from an existing operating system. This is a process known as cross-compiling and this makes the first step in operating systems development.
</p><p>This article assumes you are using a Unix-like operating system such as Linux which supports operating systems development well. Windows users should be able to complete it from a MinGW or Cygwin environment. 
</p>
<h2><span class="mw-headline" id="Building_a_Cross-Compiler">Building a Cross-Compiler</span></h2>
<dl><dd><i>Main article: <a href="GCC_Cross-Compiler" title="GCC Cross-Compiler">GCC Cross-Compiler</a>, <a href="Why_do_I_need_a_Cross_Compiler?" title="Why do I need a Cross Compiler?">Why do I need a Cross Compiler?</a></i></dd></dl>
<p>The first thing you should do is set up a <a href="GCC_Cross-Compiler" title="GCC Cross-Compiler">GCC Cross-Compiler</a> for <b>arm-none-eabi</b>. You have not yet modified your compiler to know about the existence of your operating system, so we use a generic target called arm-none-eabi, which provides you with a toolchain targeting the <a href="System_V_ABI" title="System V ABI">System V ABI</a>.
You will <i>not</i> be able to correctly compile your operating system without a cross-compiler.
</p><p>If you want a 64 bit kernel, you should set up <b>aarch64-elf</b> target instead. This provides the same System V ABI interface, but for 64 bit. Using elf is not mandatory, but simplifies things.
</p>
<h2><span class="mw-headline" id="Overview">Overview</span></h2>
<p>By now, you should have set up your <a href="GCC_Cross-Compiler" title="GCC Cross-Compiler">cross-compiler</a> for the proper ABI (as described above). This tutorial provides a minimal solution for creating an operating system. It doesn't serve as a recommend skeleton for project structure, but rather as an example of a minimal kernel. In this simple case, we just need three input files:
</p>
<ul><li>boot.S - kernel entry point that sets up the processor environment</li>
<li>kernel.c - your actual kernel routines</li>
<li>linker.ld - for linking the above files</li></ul>
<h2><span class="mw-headline" id="Booting_the_Operating_System">Booting the Operating System</span></h2>
<p>We will now create a file called boot.S and discuss its contents. In this example, we are using the GNU assembler, which is part of the cross-compiler toolchain you built earlier. This assembler integrates very well with the rest of the GNU toolchain. 
</p><p>Each Pi Model requires different set up. In general, you must distinguish AArch32 and AArch64 mode, as they are booted differently. The latter only accessible from Pi 3 and upwards. Within a mode, you can <a href="Detecting_Raspberry_Pi_Board" title="Detecting Raspberry Pi Board">detect the board</a> in run-time, and set up mmio base address accordingly.
</p>
<h3><span id="Pi_Model_A.2C_B.2C_A.2B.2C_B.2B.2C_and_Zero"></span><span class="mw-headline" id="Pi_Model_A,_B,_A+,_B+,_and_Zero">Pi Model A, B, A+, B+, and Zero</span></h3>
<p>The environment is set up and execution to _start transferred from <a rel="nofollow" class="external text" href="https://github.com/raspberrypi/tools/blob/master/armstubs/armstub.S#L35">armstub.s</a>.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>// AArch32 mode

// To keep this in the first portion of the binary.
.section &quot;.text.boot&quot;

// Make _start global.
.globl _start

        .org 0x8000
// Entry point for the kernel.
// r15 -&gt; should begin execution at 0x8000.
// r0 -&gt; 0x00000000
// r1 -&gt; 0x00000C42 - machine id
// r2 -&gt; 0x00000100 - start of ATAGS
// preserve these registers as argument for kernel_main
_start:
	// Setup the stack.
	mov sp, #0x8000

	// Clear out bss.
	ldr r4, =__bss_start
	ldr r9, =__bss_end
	mov r5, #0
	mov r6, #0
	mov r7, #0
	mov r8, #0
	b       2f

1:
	// store multiple at r4.
	stmia r4!, {r5-r8}

	// If we are still below bss_end, loop.
2:
	cmp r4, r9
	blo 1b

	// Call kernel_main
	ldr r3, =kernel_main
	blx r3

	// halt
halt:
	wfe
	b halt
</pre></div>
<p>The section ".text.boot" will be used in the linker script to place the boot.S as the very first thing in our kernel image. The code initializes a minimum C environment, which means having a stack and zeroing the BSS segment, before calling the kernel_main function. Note that the code avoids using r0-r2 so the remain valid for the kernel_main call.
</p><p>You can then assemble boot.S using:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>arm-none-eabi-gcc -mcpu<span class="o">=</span>arm1176jzf-s -fpic -ffreestanding -c boot.S -o boot.o
</pre></div>
<h3><span class="mw-headline" id="Pi_2">Pi 2</span></h3>
<p>With newer versions of the Pi, there's a bit more to be done. Raspberry Pis 2 and 3 (the first model that supports 64 bit) have 4 cores. On boot, all cores are running and executing the same boot code. Therefore you have to distinguish cores, and only allow one of them to run, putting the others in an infinite loop.
</p><p>The environment is set up and execution to _start transferred from <a rel="nofollow" class="external text" href="https://github.com/raspberrypi/tools/blob/master/armstubs/armstub7.S#L167">armstub7.s</a>.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>// AArch32 mode

// To keep this in the first portion of the binary.
.section &quot;.text.boot&quot;

// Make _start global.
.globl _start

        .org 0x8000
// Entry point for the kernel.
// r15 -&gt; should begin execution at 0x8000.
// r0 -&gt; 0x00000000
// r1 -&gt; 0x00000C42 - machine id
// r2 -&gt; 0x00000100 - start of ATAGS
// preserve these registers as argument for kernel_main
_start:
	// Shut off extra cores
	mrc p15, 0, r5, c0, c0, 5
	and r5, r5, #3
	cmp r5, #0
	bne halt

	// Setup the stack.
	ldr r5, =_start
	mov sp, r5

	// Clear out bss.
	ldr r4, =__bss_start
	ldr r9, =__bss_end
	mov r5, #0
	mov r6, #0
	mov r7, #0
	mov r8, #0
	b       2f

1:
	// store multiple at r4.
	stmia r4!, {r5-r8}

	// If we are still below bss_end, loop.
2:
	cmp r4, r9
	blo 1b

	// Call kernel_main
	ldr r3, =kernel_main
	blx r3

	// halt
halt:
	wfe
	b halt
</pre></div>
<p>You can assemble boot.S using:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>arm-none-eabi-gcc -mcpu<span class="o">=</span>cortex-a7 -fpic -ffreestanding -c boot.S -o boot.o
</pre></div>
<h3><span id="Pi_3.2C_4"></span><span class="mw-headline" id="Pi_3,_4">Pi 3, 4</span></h3>
<p>It worth mentioning that Pi 3 and 4 normally boots kernel8.img into 64 bit mode, but you can still use AArch32 with kernel7.img for backward compatibility. Note that in 64 bit mode, the boot code is loaded at 0x80000 and not 0x8000. The boot code in AArch64 is exactly the same for Pi 3 and 4, however Pi 4 has a different peripheral base address (see below the C example code).
</p><p>With the latest firmware, only the primary core runs (core 0), and the secondary cores are awaiting in a spin loop. To wake them up, write a function's address at 0xE0 (core 1), 0xE8 (core 2) or 0xF0 (core 3) and they will start to execute that function.
</p><p>The environment is set up and execution to _start transferred from <a rel="nofollow" class="external text" href="https://github.com/raspberrypi/tools/blob/master/armstubs/armstub8.S#L154">armstub8.s</a>.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>// AArch64 mode

// To keep this in the first portion of the binary.
.section &quot;.text.boot&quot;

// Make _start global.
.globl _start

    .org 0x80000
// Entry point for the kernel. Registers:
// x0 -&gt; 32 bit pointer to DTB in memory (primary core only) / 0 (secondary cores)
// x1 -&gt; 0
// x2 -&gt; 0
// x3 -&gt; 0
// x4 -&gt; 32 bit kernel entry point, _start location
_start:
    // set stack before our code
    ldr     x5, =_start
    mov     sp, x5

    // clear bss
    ldr     x5, =__bss_start
    ldr     w6, =__bss_size
1:  cbz     w6, 2f
    str     xzr, [x5], #8
    sub     w6, w6, #1
    cbnz    w6, 1b

    // jump to C code, should not return
2:  bl      kernel_main
    // for failsafe, halt this core
halt:
    wfe
    b halt
</pre></div>
<p>Compile your code with:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>aarch64-elf-as -c boot.S -o boot.o
</pre></div>
<h2><span class="mw-headline" id="Implementing_the_Kernel">Implementing the Kernel</span></h2>
<p>So far we have written the bootstrap assembly stub that sets up the processor such that high level languages such as C can be used. It is also possible to use other languages such as C++.
</p>
<h3><span class="mw-headline" id="Freestanding_and_Hosted_Environments">Freestanding and Hosted Environments</span></h3>
<p>If you have done C or C++ programming in user-space, you have used a so-called Hosted Environment. Hosted means that there is a C standard library and other useful runtime features. Alternatively, there is the Freestanding version, which is what we are using here. Freestanding means that there is no C standard library, only what we provide ourselves. However, some header files are actually not part of the C standard library, but rather the compiler. These remain available even in freestanding C source code. In this case we use &lt;stddef.h&gt; to get size_t &amp; NULL and &lt;stdint.h&gt; to get the intx_t and uintx_t datatypes which are invaluable for operating systems development, where you need to make sure that the variable is of an exact size (if we used a short instead of uint16_t and the size of short changed, our code would break!). Additionally you can access the &lt;float.h&gt;, &lt;iso646.h&gt;, &lt;limits.h&gt;, and &lt;stdarg.h&gt; headers, as they are also freestanding. GCC actually ships a few more headers, but these are special purpose.
</p>
<h3><span class="mw-headline" id="Writing_a_kernel_in_C">Writing a kernel in C</span></h3>
<p>The following shows how to create a simple kernel in C. Please take a few moments to understand the code. To set the value for "int raspi" in run-time, see <a href="Detecting_Raspberry_Pi_Board" title="Detecting Raspberry Pi Board">detecting the board type</a>.
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stddef.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">MMIO_BASE</span><span class="p">;</span><span class="w"></span>

<span class="c1">// The MMIO area base address, depends on board type</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mmio_init</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">raspi</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">raspi</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w">  </span><span class="n">MMIO_BASE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3F000000</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// for raspi2 &amp; 3</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">4</span><span class="o">:</span><span class="w">  </span><span class="n">MMIO_BASE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFE000000</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// for raspi4</span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">MMIO_BASE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x20000000</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// for raspi1, raspi zero etc.</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Memory-Mapped I/O output</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mmio_write</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="o">*</span><span class="p">(</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">MMIO_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Memory-Mapped I/O input</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">mmio_read</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">reg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">MMIO_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Loop &lt;delay&gt; times in a way that the compiler won&#39;t optimize away</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">delay</span><span class="p">(</span><span class="kt">int32_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;__delay_%=: subs&#160;%[count],&#160;%[count], #1; bne __delay_%=</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">		 </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="s">&quot;0&quot;</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;cc&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">enum</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The offsets for reach register.</span>
<span class="w">    </span><span class="n">GPIO_BASE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x200000</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Controls actuation of pull up/down to ALL GPIO pins.</span>
<span class="w">    </span><span class="n">GPPUD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">GPIO_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x94</span><span class="p">),</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Controls actuation of pull up/down for specific GPIO pin.</span>
<span class="w">    </span><span class="n">GPPUDCLK0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">GPIO_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x98</span><span class="p">),</span><span class="w"></span>

<span class="w">    </span><span class="c1">// The base address for UART.</span>
<span class="w">    </span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">GPIO_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">),</span><span class="w"> </span><span class="c1">// for raspi4 0xFE201000, raspi2 &amp; 3 0x3F201000, and 0x20201000 for raspi1</span>

<span class="w">    </span><span class="c1">// The offsets for reach register for the UART.</span>
<span class="w">    </span><span class="n">UART0_DR</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x00</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_RSRECR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x04</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_FR</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x18</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_ILPR</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x20</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_IBRD</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x24</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_FBRD</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x28</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_LCRH</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x2C</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_CR</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x30</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_IFLS</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x34</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_IMSC</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x38</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_RIS</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x3C</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_MIS</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x40</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_ICR</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x44</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_DMACR</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x48</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_ITCR</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x80</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_ITIP</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x84</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_ITOP</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x88</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">UART0_TDR</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART0_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x8C</span><span class="p">),</span><span class="w"></span>

<span class="w">    </span><span class="c1">// The offsets for Mailbox registers</span>
<span class="w">    </span><span class="n">MBOX_BASE</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mh">0xB880</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">MBOX_READ</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">MBOX_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x00</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">MBOX_STATUS</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">MBOX_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x18</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">MBOX_WRITE</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">MBOX_BASE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x20</span><span class="p">)</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// A Mailbox message with set clock rate of PL011 to 3MHz tag</span>
<span class="k">volatile</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)))</span><span class="w"> </span><span class="n">mbox</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="mi">9</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x38002</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3000000</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">,</span><span class="mi">0</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">uart_init</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">raspi</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">mmio_init</span><span class="p">(</span><span class="n">raspi</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Disable UART0.</span>
<span class="w">	</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">UART0_CR</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Setup the GPIO pin 14 &amp;&amp; 15.</span>

<span class="w">	</span><span class="c1">// Disable pull up/down for all GPIO pins &amp; delay for 150 cycles.</span>
<span class="w">	</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">GPPUD</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">delay</span><span class="p">(</span><span class="mi">150</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Disable pull up/down for pin 14,15 &amp; delay for 150 cycles.</span>
<span class="w">	</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">GPPUDCLK0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">14</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">15</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="n">delay</span><span class="p">(</span><span class="mi">150</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Write 0 to GPPUDCLK0 to make it take effect.</span>
<span class="w">	</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">GPPUDCLK0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Clear pending interrupts.</span>
<span class="w">	</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">UART0_ICR</span><span class="p">,</span><span class="w"> </span><span class="mh">0x7FF</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Set integer &amp; fractional part of baud rate.</span>
<span class="w">	</span><span class="c1">// Divider = UART_CLOCK/(16 * Baud)</span>
<span class="w">	</span><span class="c1">// Fraction part register = (Fractional part * 64) + 0.5</span>
<span class="w">	</span><span class="c1">// Baud = 115200.</span>

<span class="w">	</span><span class="c1">// For Raspi3 and 4 the UART_CLOCK is system-clock dependent by default.</span>
<span class="w">	</span><span class="c1">// Set it to 3Mhz so that we can consistently set the baud rate</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">raspi</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="c1">// UART_CLOCK = 30000000;</span>
<span class="w">		</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">mbox</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mh">0xF</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="c1">// wait until we can talk to the VC</span>
<span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">mmio_read</span><span class="p">(</span><span class="n">MBOX_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x80000000</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="c1">// send our message to property channel and wait for the response</span>
<span class="w">		</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">MBOX_WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">mmio_read</span><span class="p">(</span><span class="n">MBOX_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x40000000</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">mmio_read</span><span class="p">(</span><span class="n">MBOX_READ</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Divider = 3000000 / (16 * 115200) = 1.627 = ~1.</span>
<span class="w">	</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">UART0_IBRD</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Fractional part register = (.627 * 64) + 0.5 = 40.6 = ~40.</span>
<span class="w">	</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">UART0_FBRD</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Enable FIFO &amp; 8 bit data transmission (1 stop bit, no parity).</span>
<span class="w">	</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">UART0_LCRH</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">));</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Mask all interrupts.</span>
<span class="w">	</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">UART0_IMSC</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">	                       </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">));</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Enable UART0, receive &amp; transfer part of UART.</span>
<span class="w">	</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">UART0_CR</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">9</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">uart_putc</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Wait for UART to become ready to transmit.</span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">mmio_read</span><span class="p">(</span><span class="n">UART0_FR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">mmio_write</span><span class="p">(</span><span class="n">UART0_DR</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">uart_getc</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Wait for UART to have received something.</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">mmio_read</span><span class="p">(</span><span class="n">UART0_FR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mmio_read</span><span class="p">(</span><span class="n">UART0_DR</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">uart_puts</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">uart_putc</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">)</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#if defined(__cplusplus)</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="cm">/* Use C linkage for kernel_main. */</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="cp">#ifdef AARCH64</span>
<span class="c1">// arguments for AArch64</span>
<span class="kt">void</span><span class="w"> </span><span class="n">kernel_main</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">dtb_ptr32</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">x2</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">x3</span><span class="p">)</span><span class="w"></span>
<span class="cp">#else</span>
<span class="c1">// arguments for AArch32</span>
<span class="kt">void</span><span class="w"> </span><span class="n">kernel_main</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">r0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">atags</span><span class="p">)</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// initialize UART for Raspi2</span>
<span class="w">	</span><span class="n">uart_init</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">uart_puts</span><span class="p">(</span><span class="s">&quot;Hello, kernel World!</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">uart_putc</span><span class="p">(</span><span class="n">uart_getc</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The GPU bootloader passes arguments to the AArch32 kernel via r0-r2 and the boot.S makes sure to preserve those 3 registers. They are the first 3 arguments in a C function call. The argument r0 contains a code for the device the RPi was booted from.  This is generally 0 but its actual value depends on the firmware of the board.  r1 contains the 'ARM Linux Machine Type' which for the RPi is 3138 (0xc42) identifying the BCM2708 CPU. A full list of ARM Machine Types is available from <a rel="nofollow" class="external text" href="http://www.arm.linux.org.uk/developer/machines/">here</a>.  r2 contains the address of the ATAGs.
</p><p>For AArch64, the registers are a little bit different, but also passed as arguments to the C function. The first, x0 is the 32 bit address of the DTB (that is, <a rel="nofollow" class="external text" href="https://elinux.org/Device_Tree_Reference">Device Tree Blob</a> in memory). Watch out, it is a 32 bit address, the upper bits may not be cleared. The other arguments, x1-x3 are cleared to zero for now, but reserved for future use. Your boot.S should preserve them.
</p><p>Notice how we wish to use the common C function strlen, but this function is part of the C standard library that we don't have available. Instead, we rely on the freestanding header &lt;stddef.h&gt; to provide size_t and we simply declare our own implementation of strlen. You will have to do this for every function you wish to use (as the freestanding headers only provide macros and data types). 
</p><p>The addresses for the GPIO and UART are offsets from the peripheral base address, which is 0x20000000 for Raspberry Pi 1 and 0x3F000000 for Raspberry Pi 2 and Raspberry Pi 3. For <a href="Raspberry_Pi_4" title="Raspberry Pi 4">Raspberry Pi 4</a> the base address is 0xFE000000. You can find the addresses of registers and how to use them in the BCM2835 manual. It is possible to detect the base address in run time by <a href="Detecting_Raspberry_Pi_Board" title="Detecting Raspberry Pi Board">reading the board id</a>.
</p><p>Compile using:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>arm-none-eabi-gcc -mcpu<span class="o">=</span>arm1176jzf-s -fpic -ffreestanding -std<span class="o">=</span>gnu99 -c kernel.c -o kernel.o -O2 -Wall -Wextra
</pre></div>
<p>or for 64 bit:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>aarch64-elf-gcc -ffreestanding -c kernel.c -o kernel.o -O2 -Wall -Wextra
</pre></div>
<p>Note that the above code uses a few extensions and hence we build as the GNU version of C99.
</p>
<h2><span class="mw-headline" id="Linking_the_Kernel">Linking the Kernel</span></h2>
<p>To create the full and final kernel we will have to link these object files into the final kernel program. When developing user-space programs, your toolchain ships with default scripts for linking such programs. However, these are unsuitable for kernel development and we need to provide our own customized linker script.
</p><p>The linker script for 64 bit mode looks exactly the same, except for the starting address.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>ENTRY(_start)

SECTIONS
{
    /* Starts at LOADER_ADDR. */
    . = 0x8000;
    /* For AArch64, use . = 0x80000; */
    __start = .;
    __text_start = .;
    .text&#160;:
    {
        KEEP(*(.text.boot))
        *(.text)
    }
    . = ALIGN(4096); /* align to page size */
    __text_end = .;

    __rodata_start = .;
    .rodata&#160;:
    {
        *(.rodata)
    }
    . = ALIGN(4096); /* align to page size */
    __rodata_end = .;

    __data_start = .;
    .data&#160;:
    {
        *(.data)
    }
    . = ALIGN(4096); /* align to page size */
    __data_end = .;

    __bss_start = .;
    .bss&#160;:
    {
        bss = .;
        *(.bss)
    }
    . = ALIGN(4096); /* align to page size */
    __bss_end = .;
    __bss_size = __bss_end - __bss_start;
    __end = .;
}
</pre></div>
<p>There is a lot of text here but don't despair. The script is rather simple if you look at it bit by bit.
</p><p>ENTRY(_start) declares the entry point for the kernel image. That symbol was declared in the boot.S file. Since we are actually booting a binary image, the entry is completely irrelevant, but it has to be there in the elf file we build as intermediate file.
</p><p>SECTIONS declares sections. It decides where the bits and pieces of our code and data go and also sets a few symbols that help us track the size of each section.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>    . = 0x8000;
    __start = .;
</pre></div>
<p>The "." denotes the current address so the first line tells the linker to set the current address to 0x8000 (or 0x80000), where the kernel starts. The current address is automatically incremented when the linker adds data. The second line then creates a symbol "__start" and sets it to the current address.
</p><p>After that sections are defined for text (code), read-only data, read-write data and BSS (0 initialized memory). Other than the name the sections are identical so lets just look at one of them:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>    __text_start = .;
    .text&#160;: {
        KEEP(*(.text.boot))
        *(.text)
    }
    . = ALIGN(4096); /* align to page size */
    __text_end = .;
</pre></div>
<p>The first line creates a __text_start symbol for the section. The second line opens a .text section for the output file which gets closed in the fifth line. Lines 3 and 4 declare what sections from the input files will be placed inside the output .text section. In our case ".text.boot" is to be placed first followed by the more general ".text". ".text.boot" is only used in boot.S and ensures that it ends up at the beginning of the kernel image. ".text" then contains all the remaining code. Any data added by the linker automatically increments the current address ("."). In line 6 we explicitly increment it so that it is aligned to a 4096 byte boundary (which is the page size for the RPi). And last line 7 creates a __text_end symbol so we know where the section ends.
</p><p>What are the __text_start and __text_end for and why use page alignment? The 2 symbols can be used in the kernel source and the linker will then place the correct addresses into the binary. As an example the __bss_start and __bss_end are used in boot.S. But you can also use the symbols from C by declaring them extern first. While not required I made all sections aligned to page size. This later allows mapping them in the page tables with executable, read-only and read-write permissions without having to handle overlaps (2 sections in one page).
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>    __end = .;
</pre></div>
<p>After all sections are declared the __end symbol is created. If you ever want to know how large your kernel is at runtime you can use __start and __end to find out.
</p><p>With these components you can now actually build the final kernel. We use the compiler as the linker as it allows it greater control over the link process. Note that if your kernel is written in C++, you should use the C++ compiler instead.
</p><p>You can then link your kernel using:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>arm-none-eabi-gcc -T linker.ld -o myos.elf -ffreestanding -O2 -nostdlib boot.o kernel.o -lgcc
arm-none-eabi-objcopy myos.elf -O binary kernel7.img
</pre></div>
<p>or for 64 bit:
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>aarch64-elf-gcc -T linker.ld -o myos.elf -ffreestanding -O2 -nostdlib boot.o kernel.o -lgcc 
aarch64-elf-objcopy myos.elf -O binary kernel8.img
</pre></div>
<h2><span class="mw-headline" id="Booting_the_Kernel">Booting the Kernel</span></h2>
<p>In a few moments, you will see your kernel in action. 
</p>
<h3><span id="Testing_your_operating_system_.28Real_Hardware.29"></span><span class="mw-headline" id="Testing_your_operating_system_(Real_Hardware)">Testing your operating system (Real Hardware)</span></h3>
<p>Do you still have the SD card with the original Raspbian image on it from when you where testing the hardware above? Great. So you already have a SD card with a boot partition and the required files. If not then download one of the original Raspberry boot images and copy them to the SD card.
</p><p>Now mount the first partition from the SD card and look at it:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>bootcode.bin  fixup.dat     kernel.img            start.elf
cmdline.txt   fixup_cd.dat  kernel_cutdown.img    start_cd.elf
config.txt    issue.txt     kernel_emergency.img
</pre></div>
<p>If you don't have a raspbian image, you can create a FAT32 partition, and <a rel="nofollow" class="external text" href="https://github.com/raspberrypi/firmware/tree/master/boot">download the firmware files</a> from the official repository. You'll need only three files:
</p>
<ul><li>bootcode.bin: this is the one that's loaded first, executed on the GPU (not needed on RPi4 as that model has bootcode.bin in a ROM)</li>
<li>fixup.dat: this data file contains important hardware-related information, a must have</li>
<li>start.elf: this is the RPi firmware (same as BIOS on IBM PC). This also runs on the GPU.</li></ul>
<p>Simplified when the RPi powers up the ARM CPU is halted and the GPU runs. The GPU loads the bootloader from ROM and executes it. That then finds the SD card and loads the bootcode.bin (except RPi4 which has a big enough ROM to include bootcode.bin as well). The bootcode loads the firmware, start.elf which handles the config.txt and cmdline.txt. The start.elf loads the kernel*.img and at last the ARM CPU is started running that kernel image.
</p><p>To switch among ARM modes, you have to rename your kernel.img file. If you rename it to <b>kernel7.img</b>, that will be executed in AArch32 mode (ARMv7). For AArch64 mode (ARMv8) you'll have to rename it to <b>kernel8.img</b>.
</p><p>So now we replace the original kernel.img with our own, umount, sync, stick the SD card into RPi and turn the power on.
Your Minicom should then show the following:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>Hello, kernel World!
</pre></div>
<h3><span id="Testing_your_operating_system_.28QEMU.29"></span><span class="mw-headline" id="Testing_your_operating_system_(QEMU)">Testing your operating system (QEMU)</span></h3>
<p>QEMU supports emulating Raspberry Pi 2 with the machine type "raspi2". At the time of writing this feature is not available in most package managers but can be found in the latest QEMU source found here: <a rel="nofollow" class="external free" href="https://github.com/qemu/qemu">https://github.com/qemu/qemu</a>
</p><p>Check that your QEMU install has qemu-system-arm and that it supports the option "-M raspi2". When testing in QEMU, be sure to use the raspi2 base addresses noted in the source code.
</p><p>With QEMU you do not need to objcopy the kernel into a plain binary; QEMU also supports ELF kernels:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>$YOURINSTALLLOCATION/bin/qemu-system-arm -m 256 -M raspi2 -serial stdio -kernel kernel.elf
</pre></div>
<h4><span id="Updated_Support_for_AArch64_.28raspi2.2C_raspi3.2C_raspi4.29"></span><span class="mw-headline" id="Updated_Support_for_AArch64_(raspi2,_raspi3,_raspi4)">Updated Support for AArch64 (raspi2, raspi3, raspi4)</span></h4>
<p>As of QEMU 2.12 (April 2018), emulation for 64-bit ARM, <i>qemu-system-aarch64</i>, now supports direct emulation of both Raspberry Pi 2 and 3 using the machine types <b>raspi2</b> and <b>raspi3</b>, respectively. This should allow for testing of 64-bit system code.
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>qemu-system-aarch64 -M raspi3 -serial stdio -kernel kernel8.img
</pre></div>
<p>As of QEMU 9.0 (April 2024), emulation for 64-bit ARM, <i>qemu-system-aarch64</i>, now supports emulation of the Rasberry Pi 4 using the machine type <b>raspi4b</b>. 
</p>
<div class="mw-highlight mw-highlight-lang-bash mw-content-ltr" dir="ltr"><pre><span></span>qemu-system-aarch64 -M raspi4b -serial stdio -kernel kernel8.img
</pre></div>
<p>Note that in most cases, there will be few if any differences between 32-bit ARM code and 64-bit ARM, but there can be difference in the way the code behaves, in particular regarding kernel memory management. Also, some AArch64 implementations may support features not found on any of their 32-bit counterparts (e.g., cryptographic extensions, enhanced NEON SIMD support).
</p><p>Another very important note: starting from Raspberry Pi 3, the SoC is changed to <a rel="nofollow" class="external text" href="https://github.com/raspberrypi/documentation/files/1888662/">BCM2837</a> and PL011 clock (UART0) is not fixed any more, but derived from the system clock. Therefore to properly set up baud rate, first you have to set clock frequency. This can be done with a <a rel="nofollow" class="external text" href="https://github.com/raspberrypi/firmware/wiki/Mailboxes">Mailbox call</a>. Or you can use AUX miniUART (UART1) chip, which is easier to program. The links below includes tutorials on how to do both.
</p>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Articles">Articles</span></h3>
<ul><li><a href="Raspberry_Pi_Bare_Bones_Rust" title="Raspberry Pi Bare Bones Rust">Raspberry Pi Bare Bones Rust</a></li>
<li><a href="ARMv7-A_Bare_Bones" title="ARMv7-A Bare Bones">ARMv7-A Bare Bones</a></li></ul>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf">BCM2835 ARM Peripherals</a> (original Raspberry Pi)</li>
<li><a rel="nofollow" class="external text" href="https://github.com/raspberrypi/documentation/files/1888662/">BCM2837 ARM Peripherals</a> (latest Raspberry Pi 3)</li>
<li><a rel="nofollow" class="external text" href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0183g/DDI0183G_uart_pl011_r1p5_trm.pdf">PrimeCell UART (PL011) Technical Reference Manual</a></li>
<li><a rel="nofollow" class="external text" href="https://github.com/s-matyukevich/raspberry-pi-os">Raspberry-Pi-OS a hobby OS tutorial for the Raspberry Pi</a> (details Linux drivers too, great source)</li>
<li><a rel="nofollow" class="external text" href="https://github.com/bztsrc/raspi3-tutorial">Bare metal tutorial for AArch64</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250212025210
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.136 seconds
Real time usage: 2.645 seconds
Preprocessor visited node count: 586/1000000
Post‐expand include size: 3158/2097152 bytes
Template argument size: 2422/2097152 bytes
Highest expansion depth: 23/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 42563/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%   13.300      1 -total
 63.13%    8.396      1 Template:Kernel_designs
 54.68%    7.273     24 Template:If
 44.51%    5.920      1 Template:SmallNavBox
 43.34%    5.764     24 Template:Show1
 29.03%    3.861      1 Template:Rating
  7.86%    1.045      4 Template:Eq
  7.04%    0.936      1 Template:BeginnersWarning
  4.19%    0.558      4 Template:Eq1
  2.48%    0.330      1 Template:NoteBox
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:3316-0!canonical and timestamp 20250212025208 and revision id 29196.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=Raspberry_Pi_Bare_Bones&amp;oldid=29196">https://wiki.osdev.org/index.php?title=Raspberry_Pi_Bare_Bones&amp;oldid=29196</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_duplicate_arguments_in_template_calls&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using duplicate arguments in template calls (page does not exist)">Pages using duplicate arguments in template calls</a></li><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Level_3_Tutorials" title="Category:Level 3 Tutorials">Level 3 Tutorials</a></li><li><a href="./Category:ARM" title="Category:ARM">ARM</a></li><li><a href="./Category:Raspberry_Pi" title="Category:Raspberry Pi">Raspberry Pi</a></li><li><a href="./Category:Bare_bones_tutorials" title="Category:Bare bones tutorials">Bare bones tutorials</a></li><li><a href="./Category:C" title="Category:C">C</a></li><li><a href="./Category:C++" title="Category:C++">C++</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Raspberry+Pi+Bare+Bones" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="ARM_RaspberryPi_Tutorial_C#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Raspberry_Pi_Bare_Bones" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:Raspberry_Pi_Bare_Bones" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Raspberry_Pi_Bare_Bones"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Raspberry_Pi_Bare_Bones&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Raspberry_Pi_Bare_Bones&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/Raspberry_Pi_Bare_Bones" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="./Special:RecentChangesLinked/Raspberry_Pi_Bare_Bones" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Raspberry_Pi_Bare_Bones&amp;oldid=29196" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Raspberry_Pi_Bare_Bones&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 22 July 2024, at 16:04.</li>
	<li id="footer-info-0">This page has been accessed 21,122 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=Raspberry_Pi_Bare_Bones&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.136","walltime":"2.645","ppvisitednodes":{"value":586,"limit":1000000},"postexpandincludesize":{"value":3158,"limit":2097152},"templateargumentsize":{"value":2422,"limit":2097152},"expansiondepth":{"value":23,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":42563,"limit":5000000},"timingprofile":["100.00%   13.300      1 -total"," 63.13%    8.396      1 Template:Kernel_designs"," 54.68%    7.273     24 Template:If"," 44.51%    5.920      1 Template:SmallNavBox"," 43.34%    5.764     24 Template:Show1"," 29.03%    3.861      1 Template:Rating","  7.86%    1.045      4 Template:Eq","  7.04%    0.936      1 Template:BeginnersWarning","  4.19%    0.558      4 Template:Eq1","  2.48%    0.330      1 Template:NoteBox"]},"cachereport":{"timestamp":"20250212025210","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":2744});});</script>
</body>
</html>