<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>PCI IDE Controller - OSDev Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"3473e59f00368c6000f97d11","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"PCI_IDE_Controller","wgTitle":"PCI IDE Controller","wgCurRevisionId":28314,"wgRevisionId":28314,"wgArticleId":2716,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using deprecated source tags","Disputed Pages","ATA","Storage"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"PCI_IDE_Controller","wgRelevantArticleId":2716,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],
"wgRestrictionMove":[],"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false},"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgVector2022PreviewPages":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgEditSubmitButtonLabelPublish":false};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","skins.vector.styles.legacy":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.DarkMode.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.DarkMode","ext.moderation.notify","ext.moderation.ve","ext.moderation.ajaxhook","ext.moderation.notify.desktop"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=ext.DarkMode.styles%7Cext.pygments%7Cext.visualEditor.desktopArticleTarget.noscript%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://wiki.osdev.org/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://wiki.osdev.org/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.7"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="OSDev Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-PCI_IDE_Controller rootpage-PCI_IDE_Controller skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">PCI IDE Controller</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From OSDev Wiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="PCI_IDE_Controller#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="PCI_IDE_Controller#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><center>
<table style="border: 1px solid #cfcfbf; padding: .0em .25em .0em; background-color: #f0f0ff; text-align: center;">
<tbody><tr>
<td>
<p><font color="black">The factual accuracy of this article or section is <a href="./Category:Disputed_Pages" title="Category:Disputed Pages">disputed</a>.</font><br /><small><font color="red">Please see the relevant discussion on the <a href="./Talk:PCI_IDE_Controller" title="Talk:PCI IDE Controller">talk page</a>.</font></small>
</p>
</td>
<td>
</td></tr></tbody></table>
</center>
<p>IDE is a keyword which refers to the electrical specification of the cables which connect ATA drives (like hard drives) to another device. The drives use the ATA (Advanced Technology Attachment) interface. An IDE cable also can terminate at an IDE card connected to PCI.
</p><p><a href="ATAPI" title="ATAPI">ATAPI</a> is an extension to ATA (recently renamed to PATA) which adds support for the SCSI command set.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="PCI_IDE_Controller#Parallel/Serial_ATA/ATAPI"><span class="tocnumber">1</span> <span class="toctext">Parallel/Serial ATA/ATAPI</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="PCI_IDE_Controller#IDE_Interface"><span class="tocnumber">2</span> <span class="toctext">IDE Interface</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="PCI_IDE_Controller#Serial_IDE"><span class="tocnumber">3</span> <span class="toctext">Serial IDE</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="PCI_IDE_Controller#Detecting_a_PCI_IDE_Controller"><span class="tocnumber">4</span> <span class="toctext">Detecting a PCI IDE Controller</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="PCI_IDE_Controller#Detecting_IDE_Drives"><span class="tocnumber">5</span> <span class="toctext">Detecting IDE Drives</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="PCI_IDE_Controller#Status"><span class="tocnumber">5.1</span> <span class="toctext">Status</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="PCI_IDE_Controller#Errors"><span class="tocnumber">5.2</span> <span class="toctext">Errors</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="PCI_IDE_Controller#Commands"><span class="tocnumber">5.3</span> <span class="toctext">Commands</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="PCI_IDE_Controller#Read/Write_From_ATA_Drive"><span class="tocnumber">6</span> <span class="toctext">Read/Write From ATA Drive</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="PCI_IDE_Controller#Reading_from_an_ATAPI_Drive"><span class="tocnumber">7</span> <span class="toctext">Reading from an ATAPI Drive</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="PCI_IDE_Controller#Reading_from_an_ATA/ATAPI_Drive"><span class="tocnumber">8</span> <span class="toctext">Reading from an ATA/ATAPI Drive</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="PCI_IDE_Controller#Writing_to_an_ATA_drive"><span class="tocnumber">9</span> <span class="toctext">Writing to an ATA drive</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="PCI_IDE_Controller#Ejecting_an_ATAPI_Drive"><span class="tocnumber">10</span> <span class="toctext">Ejecting an ATAPI Drive</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="PCI_IDE_Controller#See_Also"><span class="tocnumber">11</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="PCI_IDE_Controller#Wiki_Pages"><span class="tocnumber">11.1</span> <span class="toctext">Wiki Pages</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="PCI_IDE_Controller#Threads"><span class="tocnumber">11.2</span> <span class="toctext">Threads</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="PCI_IDE_Controller#External_Links"><span class="tocnumber">11.3</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span id="Parallel.2FSerial_ATA.2FATAPI"></span><span class="mw-headline" id="Parallel/Serial_ATA/ATAPI">Parallel/Serial ATA/ATAPI</span></h2>
<p>IDE can connect up to 4 drives. Each drive can be one of the following:
</p>
<ul><li>ATA (Serial): Used for most modern hard drives.</li>
<li>ATA (Parallel): Commonly used for hard drives.</li>
<li>ATAPI (Serial): Used for most modern optical drives.</li>
<li>ATAPI (Parallel): Commonly used for optical drives.</li></ul>
<p>Accessing an ATA/PATA drive works the same way as accessing a SATA drive. This also implicitly states that accessing a PATAPI ODD is the same as accessing a SATAPI ODD. An IDE driver does not need to know whether a drive is parallel or serial, it only has to know whether it's using ATA or ATAPI.
</p>
<h2><span class="mw-headline" id="IDE_Interface">IDE Interface</span></h2>
<p>If you open your case up and take a look at your motherboard, you will most likely see one or two (or possibly more) of the slots.
</p><p>The white and green ports are IDE ports, also known as <i>channels</i>. In this example there are both primary and secondary IDE channels which only PATA can be connected to; this means that it only supports PATA/PATAPI drives.
</p><p>Each port can have a PATA cable connected to it. One master drive, or two drives (master and slave), can be connected to one PATA cable. So that leaves us with the following possibilities:
</p>
<ul><li>Primary Master Drive.</li>
<li>Primary Slave Drive.</li>
<li>Secondary Master Drive.</li>
<li>Secondary Slave Drive.</li></ul>
<p>Each drive can be either PATA or PATAPI.
</p>
<h2><span class="mw-headline" id="Serial_IDE">Serial IDE</span></h2>
<p>Almost every modern (this article is probably written in early 2010 so it assumes motherboards still have ide/ahci modes) motherboard has a Serial IDE channel which allows <a href="SATA" title="SATA">SATA</a> and SATAPI Drives to be connected to it. There are 4 Serial IDE Ports. Each port is connected to a drive with a SATA Cable. Basically you can only have one drive connected to the Serial IDE port. Each pair of ports (every 2 ports) form one channel.
</p><p>Serial IDE also has a few possibilities:
</p>
<ul><li>Primary Master, also called SATA1.</li>
<li>Primary Slave, also called SATA2.</li>
<li>Secondary Master, also called SATA3.</li>
<li>Secondary Slave, also called SATA4.</li></ul>
<h2><span class="mw-headline" id="Detecting_a_PCI_IDE_Controller">Detecting a PCI IDE Controller</span></h2>
<p>Each IDE controller appears as a device on the <a href="PCI" title="PCI">PCI</a> bus and can be identified by reading the configuration space. If the class code is 0x01 (Mass Storage Controller) and the subclass code is 0x01 (IDE), the device is an IDE controller. The programming interface byte(Prog If) determines how you'll access it.
</p>
<ul><li>Bit 0: When set, the primary channel is in PCI native mode. When clear, the primary channel is in compatibility mode (ports 0x1F0-0x1F7, 0x3F6, IRQ14).</li>
<li>Bit 1: When set, you can modify bit 0 to switch between PCI native and compatibility mode. When clear, you cannot modify bit 0.</li>
<li>Bit 2: When set, the secondary channel is in PCI native mode. When clear, the secondary channel is in compatibility mode (ports 0x170-0x177, 0x376, IRQ15).</li>
<li>Bit 3: When set, you can modify bit 2 to switch between PCI native and compatibility mode. When clear, you cannot modify bit 2.</li>
<li>Bit 7: When set, this is a bus master IDE controller. When clear, this controller doesn't support DMA.</li></ul>
<p>If you want to access an IDE channel in PCI native mode or use the bus master function, you must additionally read the BARs to find which I/O ports to use.
</p>
<ul><li>BAR0: Base address of primary channel in PCI native mode (8 ports)</li>
<li>BAR1: Base address of primary channel control port in PCI native mode (4 ports)</li>
<li>BAR2: Base address of secondary channel in PCI native mode (8 ports)</li>
<li>BAR3: Base address of secondary channel control port in PCI native mode (4 ports)</li>
<li>BAR4: Bus master IDE (16 ports, 8 for each channel)</li></ul>
<p>Note that BAR1 and BAR3 specify 4 ports, but only the port at offset 2 is used. Offsets 0, 1, and 3 should not be accessed.
</p><p>If either IDE channel is in PCI native mode, you must also read the interrupt line or interrupt pin register to determine which interrupt to use. If both channels are in PCI native mode, they'll both share the same interrupt. The interrupt line field is only valid when using the <a href="8259_PIC" title="8259 PIC">PIC</a>.
</p>
<h2><span class="mw-headline" id="Detecting_IDE_Drives">Detecting IDE Drives</span></h2>
<p>To initialise the IDE driver, we call ide_initialise:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ide_initialize</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BAR0</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BAR1</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BAR2</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BAR3</span><span class="p">,</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BAR4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</pre></div>
<p>If you only want to support the parallel IDE, you can use these parameters:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">ide_initialize</span><span class="p">(</span><span class="mh">0x1F0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x3F6</span><span class="p">,</span><span class="w"> </span><span class="mh">0x170</span><span class="p">,</span><span class="w"> </span><span class="mh">0x376</span><span class="p">,</span><span class="w"> </span><span class="mh">0x000</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>We can assume that BAR4 is 0x0 because we are not going to use it yet.
We will return to ide_initialize, which searches for drives connected to the IDE. Before we go into this function, we should write some support functions and definitions which will help us a lot.
</p>
<h3><span class="mw-headline" id="Status">Status</span></h3>
<p>The Command/Status Port returns a bit mask referring to the status of a channel when read.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define ATA_SR_BSY     0x80    </span><span class="c1">// Busy</span>
<span class="cp">#define ATA_SR_DRDY    0x40    </span><span class="c1">// Drive ready</span>
<span class="cp">#define ATA_SR_DF      0x20    </span><span class="c1">// Drive write fault</span>
<span class="cp">#define ATA_SR_DSC     0x10    </span><span class="c1">// Drive seek complete</span>
<span class="cp">#define ATA_SR_DRQ     0x08    </span><span class="c1">// Data request ready</span>
<span class="cp">#define ATA_SR_CORR    0x04    </span><span class="c1">// Corrected data</span>
<span class="cp">#define ATA_SR_IDX     0x02    </span><span class="c1">// Index</span>
<span class="cp">#define ATA_SR_ERR     0x01    </span><span class="c1">// Error</span>
</pre></div>
<h3><span class="mw-headline" id="Errors">Errors</span></h3>
<p>The Features/Error Port, which returns the most recent error upon read, has these possible bit masks
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define ATA_ER_BBK      0x80    </span><span class="c1">// Bad block</span>
<span class="cp">#define ATA_ER_UNC      0x40    </span><span class="c1">// Uncorrectable data</span>
<span class="cp">#define ATA_ER_MC       0x20    </span><span class="c1">// Media changed</span>
<span class="cp">#define ATA_ER_IDNF     0x10    </span><span class="c1">// ID mark not found</span>
<span class="cp">#define ATA_ER_MCR      0x08    </span><span class="c1">// Media change request</span>
<span class="cp">#define ATA_ER_ABRT     0x04    </span><span class="c1">// Command aborted</span>
<span class="cp">#define ATA_ER_TK0NF    0x02    </span><span class="c1">// Track 0 not found</span>
<span class="cp">#define ATA_ER_AMNF     0x01    </span><span class="c1">// No address mark</span>
</pre></div>
<h3><span class="mw-headline" id="Commands">Commands</span></h3>
<p>When you write to the Command/Status port, you are executing one of the commands below.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define ATA_CMD_READ_PIO          0x20</span>
<span class="cp">#define ATA_CMD_READ_PIO_EXT      0x24</span>
<span class="cp">#define ATA_CMD_READ_DMA          0xC8</span>
<span class="cp">#define ATA_CMD_READ_DMA_EXT      0x25</span>
<span class="cp">#define ATA_CMD_WRITE_PIO         0x30</span>
<span class="cp">#define ATA_CMD_WRITE_PIO_EXT     0x34</span>
<span class="cp">#define ATA_CMD_WRITE_DMA         0xCA</span>
<span class="cp">#define ATA_CMD_WRITE_DMA_EXT     0x35</span>
<span class="cp">#define ATA_CMD_CACHE_FLUSH       0xE7</span>
<span class="cp">#define ATA_CMD_CACHE_FLUSH_EXT   0xEA</span>
<span class="cp">#define ATA_CMD_PACKET            0xA0</span>
<span class="cp">#define ATA_CMD_IDENTIFY_PACKET   0xA1</span>
<span class="cp">#define ATA_CMD_IDENTIFY          0xEC</span>
</pre></div>
<p>The commands below are for ATAPI devices, which will be understood soon.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define      ATAPI_CMD_READ       0xA8</span>
<span class="cp">#define      ATAPI_CMD_EJECT      0x1B</span>
</pre></div>
<p>ATA_CMD_IDENTIFY_PACKET and ATA_CMD_IDENTIFY return a buffer of 512 bytes called the identification space; the following definitions are used to read information from the identification space.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define ATA_IDENT_DEVICETYPE   0</span>
<span class="cp">#define ATA_IDENT_CYLINDERS    2</span>
<span class="cp">#define ATA_IDENT_HEADS        6</span>
<span class="cp">#define ATA_IDENT_SECTORS      12</span>
<span class="cp">#define ATA_IDENT_SERIAL       20</span>
<span class="cp">#define ATA_IDENT_MODEL        54</span>
<span class="cp">#define ATA_IDENT_CAPABILITIES 98</span>
<span class="cp">#define ATA_IDENT_FIELDVALID   106</span>
<span class="cp">#define ATA_IDENT_MAX_LBA      120</span>
<span class="cp">#define ATA_IDENT_COMMANDSETS  164</span>
<span class="cp">#define ATA_IDENT_MAX_LBA_EXT  200</span>
</pre></div>
<p>When you select a drive, you should specify the interface type and whether it is the master or slave:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define IDE_ATA        0x00</span>
<span class="cp">#define IDE_ATAPI      0x01</span>

<span class="cp">#define ATA_MASTER     0x00</span>
<span class="cp">#define ATA_SLAVE      0x01</span>
</pre></div>
<p>Task File is a range of 8 ports which are offsets from BAR0 (primary channel) and/or BAR2 (secondary channel). To exemplify:
</p>
<ul><li>BAR0 + 0 is first port.</li>
<li>BAR0 + 1 is second port.</li>
<li>BAR0 + 2 is the third</li></ul>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define ATA_REG_DATA       0x00</span>
<span class="cp">#define ATA_REG_ERROR      0x01</span>
<span class="cp">#define ATA_REG_FEATURES   0x01</span>
<span class="cp">#define ATA_REG_SECCOUNT0  0x02</span>
<span class="cp">#define ATA_REG_LBA0       0x03</span>
<span class="cp">#define ATA_REG_LBA1       0x04</span>
<span class="cp">#define ATA_REG_LBA2       0x05</span>
<span class="cp">#define ATA_REG_HDDEVSEL   0x06</span>
<span class="cp">#define ATA_REG_COMMAND    0x07</span>
<span class="cp">#define ATA_REG_STATUS     0x07</span>
<span class="cp">#define ATA_REG_SECCOUNT1  0x08</span>
<span class="cp">#define ATA_REG_LBA3       0x09</span>
<span class="cp">#define ATA_REG_LBA4       0x0A</span>
<span class="cp">#define ATA_REG_LBA5       0x0B</span>
<span class="cp">#define ATA_REG_CONTROL    0x0C</span>
<span class="cp">#define ATA_REG_ALTSTATUS  0x0C</span>
<span class="cp">#define ATA_REG_DEVADDRESS 0x0D</span>
</pre></div>
<p>The ALTSTATUS/CONTROL port returns the alternate status when read and controls a channel when written to.
</p>
<ul><li>For the primary channel, ALTSTATUS/CONTROL port is BAR1 + 2.</li>
<li>For the secondary channel, ALTSTATUS/CONTROL port is BAR3 + 2.</li></ul>
<p>We can now say that each channel has 13 registers. For the primary channel, we use these values:
</p>
<ul><li>Data Register: BAR0 + 0; // Read-Write</li>
<li>Error Register: BAR0 + 1; // Read Only</li>
<li>Features Register: BAR0 + 1; // Write Only</li>
<li>SECCOUNT0: BAR0 + 2; // Read-Write</li>
<li>LBA0: BAR0 + 3; // Read-Write</li>
<li>LBA1: BAR0 + 4; // Read-Write</li>
<li>LBA2: BAR0 + 5; // Read-Write</li>
<li>HDDEVSEL: BAR0 + 6; // Read-Write, used to select a drive in the channel.</li>
<li>Command Register: BAR0 + 7; // Write Only.</li>
<li>Status Register: BAR0 + 7; // Read Only.</li>
<li>Alternate Status Register: BAR1 + 2; // Read Only.</li>
<li>Control Register: BAR1 + 2; // Write Only.</li>
<li>DEVADDRESS: BAR1 + 3; // I don't know what is the benefit from this register.</li></ul>
<p>The map above is the same with the secondary channel, but it uses BAR2 and BAR3 instead of BAR0 and BAR1.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Channels:</span>
<span class="cp">#define      ATA_PRIMARY      0x00</span>
<span class="cp">#define      ATA_SECONDARY    0x01</span>

<span class="c1">// Directions:</span>
<span class="cp">#define      ATA_READ      0x00</span>
<span class="cp">#define      ATA_WRITE     0x01</span>
</pre></div>
<p>We have defined everything needed by the driver, now lets move to an important part. We said that
</p>
<ul><li>BAR0 is the start of the I/O ports used by the primary channel.</li>
<li>BAR1 is the start of the I/O ports which control the primary channel.</li>
<li>BAR2 is the start of the I/O ports used by secondary channel.</li>
<li>BAR3 is the start of the I/O ports which control secondary channel.</li>
<li>BAR4 is the start of 8 I/O ports controls the primary channel's Bus Master IDE.</li>
<li>BAR4 + 8 is the Base of 8 I/O ports controls secondary channel's Bus Master IDE.</li></ul>
<p>So we can make this global structure:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">IDEChannelRegisters</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">base</span><span class="p">;</span><span class="w">  </span><span class="c1">// I/O Base.</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">ctrl</span><span class="p">;</span><span class="w">  </span><span class="c1">// Control Base</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">bmide</span><span class="p">;</span><span class="w"> </span><span class="c1">// Bus Master IDE</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="n">nIEN</span><span class="p">;</span><span class="w">  </span><span class="c1">// nIEN (No Interrupt);</span>
<span class="p">}</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
</pre></div>
<p>We also need a buffer to read the identification space into, we need a variable that indicates if an irq is invoked or not, and finally we need an array of 6 words [12 bytes] for ATAPI Drives:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ide_buf</span><span class="p">[</span><span class="mi">2048</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="k">volatile</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ide_irq_invoked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">atapi_packet</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0xA8</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
</pre></div>
<p>We said the the IDE can contain up to 4 drives:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">ide_device</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="n">Reserved</span><span class="p">;</span><span class="w">    </span><span class="c1">// 0 (Empty) or 1 (This Drive really exists).</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="n">Channel</span><span class="p">;</span><span class="w">     </span><span class="c1">// 0 (Primary Channel) or 1 (Secondary Channel).</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="n">Drive</span><span class="p">;</span><span class="w">       </span><span class="c1">// 0 (Master Drive) or 1 (Slave Drive).</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">Type</span><span class="p">;</span><span class="w">        </span><span class="c1">// 0: ATA, 1:ATAPI.</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">Signature</span><span class="p">;</span><span class="w">   </span><span class="c1">// Drive Signature</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">Capabilities</span><span class="p">;</span><span class="c1">// Features.</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">CommandSets</span><span class="p">;</span><span class="w"> </span><span class="c1">// Command Sets Supported.</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">Size</span><span class="p">;</span><span class="w">        </span><span class="c1">// Size in Sectors.</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="n">Model</span><span class="p">[</span><span class="mi">41</span><span class="p">];</span><span class="w">   </span><span class="c1">// Model in string.</span>
<span class="p">}</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
</pre></div>
<p>When we read a register in a channel, like STATUS Register, it is easy to execute:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">ide_read</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_STATUS</span><span class="p">);</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">ide_read</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mh">0x07</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0C</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_CONTROL</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">nIEN</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x08</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x00</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0C</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">base</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x06</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0E</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">ctrl</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x0A</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x16</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">bmide</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x0E</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mh">0x07</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0C</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_CONTROL</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">nIEN</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>We also need a function for writing to registers:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ide_write</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mh">0x07</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0C</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_CONTROL</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">nIEN</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x08</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">outb</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">base</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0C</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">outb</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">base</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x06</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0E</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">outb</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">ctrl</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x0A</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x16</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">outb</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">bmide</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x0E</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mh">0x07</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0C</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_CONTROL</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">nIEN</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>To read the identification space, we should read the Data Register as a double word 128 times. We can then copy them to our buffer.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ide_read_buffer</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quads</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="cm">/* WARNING: This code contains a serious bug. The inline assembly trashes ES and</span>
<span class="cm">    *           ESP for all of the code the compiler generates between the inline</span>
<span class="cm">    *           assembly blocks.</span>
<span class="cm">    */</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mh">0x07</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0C</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_CONTROL</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">nIEN</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;pushw %es; movw %ds, %ax; movw %ax, %es&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x08</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">insl</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">base</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">quads</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0C</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">insl</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">base</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x06</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">quads</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0E</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">insl</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">ctrl</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x0A</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">quads</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x16</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">insl</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">bmide</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x0E</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">quads</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;popw %es;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mh">0x07</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x0C</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_CONTROL</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">nIEN</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>When we send a command, we should wait for 400 nanosecond, then read the Status port. If the Busy bit is on, we should read the status port again until the Busy bit is 0; then we can read the results of the command. This operation is called "Polling". We can also use IRQs instead of polling.
</p><p>After many commands, if the Device Fault bit is set, there is a failure; if DRQ is not set, there is an error. If the ERR bit is set, there is an error which is described in Error port.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">ide_polling</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">advanced_check</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">   </span><span class="c1">// (I) Delay 400 nanosecond for BSY to be set:</span>
<span class="w">   </span><span class="c1">// -------------------------------------------------</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_read</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_ALTSTATUS</span><span class="p">);</span><span class="w"> </span><span class="c1">// Reading the Alternate Status port wastes 100ns; loop four times.</span>

<span class="w">   </span><span class="c1">// (II) Wait for BSY to be cleared:</span>
<span class="w">   </span><span class="c1">// -------------------------------------------------</span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ide_read</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_SR_BSY</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="c1">// Wait for BSY to be zero.</span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">advanced_check</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_read</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_STATUS</span><span class="p">);</span><span class="w"> </span><span class="c1">// Read Status Register.</span>

<span class="w">      </span><span class="c1">// (III) Check For Errors:</span>
<span class="w">      </span><span class="c1">// -------------------------------------------------</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_SR_ERR</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Error.</span>

<span class="w">      </span><span class="c1">// (IV) Check If Device fault:</span>
<span class="w">      </span><span class="c1">// -------------------------------------------------</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_SR_DF</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Device Fault.</span>

<span class="w">      </span><span class="c1">// (V) Check DRQ:</span>
<span class="w">      </span><span class="c1">// -------------------------------------------------</span>
<span class="w">      </span><span class="c1">// BSY = 0; DF = 0; ERR = 0 so we should check for DRQ now.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_SR_DRQ</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// DRQ should be set</span>

<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// No Error.</span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>If there is an error, we have a function which prints errors on screen:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">ide_print_error</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">drive</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;IDE:&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- Device Fault</span><span class="se">\n</span><span class="s">     &quot;</span><span class="p">);</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">19</span><span class="p">;}</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_read</span><span class="p">(</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_ERROR</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_ER_AMNF</span><span class="p">)</span><span class="w">   </span><span class="p">{</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- No Address Mark Found</span><span class="se">\n</span><span class="s">     &quot;</span><span class="p">);</span><span class="w">   </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_ER_TK0NF</span><span class="p">)</span><span class="w">   </span><span class="p">{</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- No Media or Media Error</span><span class="se">\n</span><span class="s">     &quot;</span><span class="p">);</span><span class="w">   </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_ER_ABRT</span><span class="p">)</span><span class="w">   </span><span class="p">{</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- Command Aborted</span><span class="se">\n</span><span class="s">     &quot;</span><span class="p">);</span><span class="w">      </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_ER_MCR</span><span class="p">)</span><span class="w">   </span><span class="p">{</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- No Media or Media Error</span><span class="se">\n</span><span class="s">     &quot;</span><span class="p">);</span><span class="w">   </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_ER_IDNF</span><span class="p">)</span><span class="w">   </span><span class="p">{</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- ID mark not Found</span><span class="se">\n</span><span class="s">     &quot;</span><span class="p">);</span><span class="w">      </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">21</span><span class="p">;}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_ER_MC</span><span class="p">)</span><span class="w">   </span><span class="p">{</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- No Media or Media Error</span><span class="se">\n</span><span class="s">     &quot;</span><span class="p">);</span><span class="w">   </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_ER_UNC</span><span class="p">)</span><span class="w">   </span><span class="p">{</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- Uncorrectable Data Error</span><span class="se">\n</span><span class="s">     &quot;</span><span class="p">);</span><span class="w">   </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">22</span><span class="p">;}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_ER_BBK</span><span class="p">)</span><span class="w">   </span><span class="p">{</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- Bad Sectors</span><span class="se">\n</span><span class="s">     &quot;</span><span class="p">);</span><span class="w">       </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">;}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">           </span><span class="p">{</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- Reads Nothing</span><span class="se">\n</span><span class="s">     &quot;</span><span class="p">);</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">;}</span><span class="w"></span>
<span class="w">     </span><span class="k">else</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- Write Protected</span><span class="se">\n</span><span class="s">     &quot;</span><span class="p">);</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;}</span><span class="w"></span>
<span class="w">   </span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;- [%s %s] %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">[]){</span><span class="s">&quot;Primary&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Secondary&quot;</span><span class="p">}[</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">channel</span><span class="p">],</span><span class="w"> </span><span class="c1">// Use the channel as an index into the array</span>
<span class="w">      </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">[]){</span><span class="s">&quot;Master&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Slave&quot;</span><span class="p">}[</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">drive</span><span class="p">],</span><span class="w"> </span><span class="c1">// Same as above, using the drive</span>
<span class="w">      </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">model</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Now let's return to the initialization function:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ide_initialize</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BAR0</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BAR1</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BAR2</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BAR3</span><span class="p">,</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BAR4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// 1- Detect I/O Ports which interface IDE Controller:</span>
<span class="w">   </span><span class="n">channels</span><span class="p">[</span><span class="n">ATA_PRIMARY</span><span class="w">  </span><span class="p">].</span><span class="n">base</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BAR0</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFFFFFC</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x1F0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">BAR0</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">channels</span><span class="p">[</span><span class="n">ATA_PRIMARY</span><span class="w">  </span><span class="p">].</span><span class="n">ctrl</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BAR1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFFFFFC</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x3F6</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">BAR1</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">channels</span><span class="p">[</span><span class="n">ATA_SECONDARY</span><span class="p">].</span><span class="n">base</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BAR2</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFFFFFC</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x170</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">BAR2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">channels</span><span class="p">[</span><span class="n">ATA_SECONDARY</span><span class="p">].</span><span class="n">ctrl</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BAR3</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFFFFFC</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x376</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">BAR3</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">channels</span><span class="p">[</span><span class="n">ATA_PRIMARY</span><span class="w">  </span><span class="p">].</span><span class="n">bmide</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BAR4</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFFFFFC</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Bus Master IDE</span>
<span class="w">   </span><span class="n">channels</span><span class="p">[</span><span class="n">ATA_SECONDARY</span><span class="p">].</span><span class="n">bmide</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BAR4</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFFFFFC</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="c1">// Bus Master IDE</span>
</pre></div>
<p>Then we should disable IRQs in both channels by setting bit 1 (nIEN) in the Control port:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// 2- Disable IRQs:</span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">ATA_PRIMARY</span><span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_CONTROL</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">ATA_SECONDARY</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_CONTROL</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Now we need to check for drives which could be connected to each channel. We will select the master drive of each channel, and send the ATA_IDENTIFY command (which is supported by ATA Drives). If there's no error, there are values returned in registers which determine the type of Drive; if no drive is present, there will be strange values.
</p><p>Notice that if bit 4 in HDDEVSEL is set to 1, we are selecting the slave drive, if set to 0, we are selecting the master drive.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// 3- Detect ATA-ATAPI Devices:</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDE_ATA</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Reserved</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Assuming that no drive here.</span>

<span class="w">         </span><span class="c1">// (I) Select Drive:</span>
<span class="w">         </span><span class="n">ide_write</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_HDDEVSEL</span><span class="p">,</span><span class="w"> </span><span class="mh">0xA0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">));</span><span class="w"> </span><span class="c1">// Select Drive.</span>
<span class="w">         </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Wait 1ms for drive select to work.</span>

<span class="w">         </span><span class="c1">// (II) Send ATA Identify Command:</span>
<span class="w">         </span><span class="n">ide_write</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_COMMAND</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_CMD_IDENTIFY</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// This function should be implemented in your OS. which waits for 1 ms.</span>
<span class="w">                   </span><span class="c1">// it is based on System Timer Device Driver.</span>

<span class="w">         </span><span class="c1">// (III) Polling:</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ide_read</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"> </span><span class="c1">// If Status = 0, No Device.</span>

<span class="w">         </span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_read</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_STATUS</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_SR_ERR</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;}</span><span class="w"> </span><span class="c1">// If Err, Device is not ATA.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_SR_BSY</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_SR_DRQ</span><span class="p">))</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// Everything is right.</span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>

<span class="w">         </span><span class="c1">// (IV) Probe for ATAPI Devices:</span>

<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">cl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_read</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_LBA1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_read</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_LBA2</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x14</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xEB</span><span class="p">)</span><span class="w"></span>
<span class="w">               </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDE_ATAPI</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x69</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x96</span><span class="p">)</span><span class="w"></span>
<span class="w">               </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDE_ATAPI</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">else</span><span class="w"></span>
<span class="w">               </span><span class="k">continue</span><span class="p">;</span><span class="w"> </span><span class="c1">// Unknown Type (may not be a device).</span>

<span class="w">            </span><span class="n">ide_write</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_COMMAND</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_CMD_IDENTIFY_PACKET</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>

<span class="w">         </span><span class="c1">// (V) Read Identification Space of the Device:</span>
<span class="w">         </span><span class="n">ide_read_buffer</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_DATA</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">ide_buf</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">);</span><span class="w"></span>

<span class="w">         </span><span class="c1">// (VI) Read Device Parameters:</span>
<span class="w">         </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Reserved</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Type</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Channel</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Drive</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Signature</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">ide_buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ATA_IDENT_DEVICETYPE</span><span class="p">));</span><span class="w"></span>
<span class="w">         </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Capabilities</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">ide_buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ATA_IDENT_CAPABILITIES</span><span class="p">));</span><span class="w"></span>
<span class="w">         </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">CommandSets</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">ide_buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ATA_IDENT_COMMANDSETS</span><span class="p">));</span><span class="w"></span>

<span class="w">         </span><span class="c1">// (VII) Get Size:</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">CommandSets</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">26</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Device uses 48-Bit Addressing:</span>
<span class="w">            </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Size</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">ide_buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ATA_IDENT_MAX_LBA_EXT</span><span class="p">));</span><span class="w"></span>
<span class="w">         </span><span class="k">else</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Device uses CHS or 28-bit Addressing:</span>
<span class="w">            </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Size</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">ide_buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ATA_IDENT_MAX_LBA</span><span class="p">));</span><span class="w"></span>

<span class="w">         </span><span class="c1">// (VIII) String indicates model of device (like Western Digital HDD and SONY DVD-RW...):</span>
<span class="w">         </span><span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">40</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Model</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_buf</span><span class="p">[</span><span class="n">ATA_IDENT_MODEL</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Model</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_buf</span><span class="p">[</span><span class="n">ATA_IDENT_MODEL</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="p">];}</span><span class="w"></span>
<span class="w">         </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">Model</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Terminate String.</span>

<span class="w">         </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">// 4- Print Summary:</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Reserved</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">printk</span><span class="p">(</span><span class="s">&quot; Found %s Drive %dGB - %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">[]){</span><span class="s">&quot;ATA&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ATAPI&quot;</span><span class="p">}[</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Type</span><span class="p">],</span><span class="w">         </span><span class="cm">/* Type */</span><span class="w"></span>
<span class="w">            </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">               </span><span class="cm">/* Size */</span><span class="w"></span>
<span class="w">            </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Model</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span id="Read.2FWrite_From_ATA_Drive"></span><span class="mw-headline" id="Read/Write_From_ATA_Drive">Read/Write From ATA Drive</span></h2>
<p>Now we're moving to a slightly more advanced part, it is to read and write from/to an ATA drive.
There is 3 ways of addressing a sector:
</p>
<ul><li>CHS (Cylinder-Head-Sector): an old way of addressing sectors in ATA drives, all ATA drives should support this way of addressing.</li>
<li>LBA28: Accessing a sector by its 28-bit LBA address. All ATA drives should support this way of addressing, the problem with LBA28 Addressing is that it only allows access 128GB to be accessed, so if the disk is bigger than 128GB, it should support the LBA48 Feature Set.</li>
<li>LBA48: Accessing a sector by its 48-bit LBA address. As we use integers in GCC, our maximum address in this tutorial is 32-bit long, which allows accessing a drive with a size of up to 2TB.</li></ul>
<p>So we can conclude an algorithm to determine which type of Addressing we are going to use:
</p>
<pre>if (No LBA support)
   Use CHS.
else if (the LBA Sector Address &gt; 0x0FFFFFFF)
   Use LBA48.
else
   Use LBA28.
</pre>
<p>Reading the buffer may be done by polling or DMA.
PIO: After sending the command to read or write sectors, we read or write to the Data Port (as words). This is the same way of reading identification space.
DMA: After sending the command, you should wait for an IRQ, while you are waiting, Buffer is written directly to memory automatically.
</p><p>We are going to use PIO as it is less complex.
</p><p>We can conclude also this table:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="cm">/* ATA/ATAPI Read/Write Modes:</span>
<span class="cm">    * ++++++++++++++++++++++++++++++++</span>
<span class="cm">    *  Addressing Modes:</span>
<span class="cm">    *  ================</span>
<span class="cm">    *   - LBA28 Mode.     (+)</span>
<span class="cm">    *   - LBA48 Mode.     (+)</span>
<span class="cm">    *   - CHS.            (+)</span>
<span class="cm">    *  Reading Modes:</span>
<span class="cm">    *  ================</span>
<span class="cm">    *   - PIO Modes (0&#160;: 6)       (+) // Slower than DMA, but not a problem.</span>
<span class="cm">    *   - Single Word DMA Modes (0, 1, 2).</span>
<span class="cm">    *   - Double Word DMA Modes (0, 1, 2).</span>
<span class="cm">    *   - Ultra DMA Modes (0&#160;: 6).</span>
<span class="cm">    *  Polling Modes:</span>
<span class="cm">    *  ================</span>
<span class="cm">    *   - IRQs</span>
<span class="cm">    *   - Polling Status   (+) // Suitable for Singletasking   </span>
<span class="cm">    */</span><span class="w"></span>
</pre></div>
<p>There is something needed to be expressed here, I have told before that Task-File is like that:
</p>
<ul><li>Register 0: [Word] Data Register. (Read-Write).</li>
<li>Register 1: [Byte] Error Register. (Read).</li>
<li>Register 1: [Byte] Features Register. (Write).</li>
<li>Register 2: [Byte] SECCOUNT0 Register. (Read-Write).</li>
<li>Register 3: [Byte] LBA0 Register. (Read-Write).</li>
<li>Register 4: [Byte] LBA1 Register. (Read-Write).</li>
<li>Register 5: [Byte] LBA2 Register. (Read-Write).</li>
<li>Register 6: [Byte] HDDEVSEL Register. (Read-Write).</li>
<li>Register 7: [Byte] Command Register. (Write).</li>
<li>Register 7: [Byte] Status Register. (Read).</li></ul>
<p>So each register between 2 to 5 should be 8-bits long. Really each of them are 16-bits long.
</p>
<ul><li>Register 2: [Bits 0-7] SECCOUNT0, [Bits 8-15] SECOUNT1</li>
<li>Register 3: [Bits 0-7] LBA0, [Bits 8-15] LBA3</li>
<li>Register 4: [Bits 0-7] LBA1, [Bits 8-15] LBA4</li>
<li>Register 5: [Bits 0-7] LBA2, [Bits 8-15] LBA5</li></ul>
<p>The word [(SECCOUNT1 &lt;&lt; 8) | SECCOUNT0] expresses the number of sectors which can be read when you access by LBA48.
When you access in CHS or LBA28, SECCOUNT0 only expresses number of sectors.
</p>
<ul><li>LBA0 makes up bits 0&#160;: 7 of the LBA address when you read in LBA28 or LBA48; it can also be the sector number of CHS.</li>
<li>LBA1 makes up bits 8&#160;: 15 of the LBA address when you read in LBA28 or LBA48; it can also be the low byte of the cylinder number of CHS.</li>
<li>LBA2 makes up bits 16&#160;: 23 of the LBA address when you read in LBA28 or LBA48; it can also be the high byte of the cylinder number of CHS.</li>
<li>LBA3 makes up bits 24&#160;: 31 of the LBA48 address.</li>
<li>LBA4 makes up bits 32&#160;: 39 of the LBA48 address.</li>
<li>LBA5 makes up bits 40&#160;: 47 of LBA48 address.</li></ul>
<p>Notice that the LBA0, 1 and 2 registers are 24 bits long in total, which is not enough for LBA28; the higher 4-bits can be written to the lower 4-bits of the HDDEVSEL register.
</p><p>Also notice that if bit 6 of this register  is set, we are going to use LBA, if not, we are going to use CHS. There is a mode which is called extended CHS.
</p><p>Lets go into the code:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">ide_ata_access</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">drive</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"> </span>
<span class="w">                             </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">numsects</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">selector</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">edi</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</pre></div>
<p>This function reads/writes sectors from ATA-Drive. If direction is 0 we are reading, else we are writing.
</p>
<ul><li>drive is the drive number which can be from 0 to 3.</li>
<li>lba is the LBA address which allows us to access disks up to 2TB.</li>
<li>numsects is the number of sectors to be read, it is a char, as reading more than 256 sector immediately may performance issues. If numsects is 0, the ATA controller will know that we want 256 sectors.</li>
<li>selector is the segment selector to read from, or write to.</li>
<li>edi is the offset in that segment. (the memory address for the data buffer)</li></ul>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">lba_mode</span><span class="w"> </span><span class="cm">/* 0: CHS, 1:LBA28, 2: LBA48 */</span><span class="p">,</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="cm">/* 0: No DMA, 1: DMA */</span><span class="p">,</span><span class="w"> </span><span class="n">cmd</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="n">channel</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Channel</span><span class="p">;</span><span class="w"> </span><span class="c1">// Read the Channel.</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="n">slavebit</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Drive</span><span class="p">;</span><span class="w"> </span><span class="c1">// Read the Drive [Master/Slave]</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="n">bus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">Base</span><span class="p">;</span><span class="w"> </span><span class="c1">// Bus Base, like 0x1F0 which is also data port.</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="n">words</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span><span class="w"> </span><span class="c1">// Almost every ATA drive has a sector-size of 512-byte.</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">cyl</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">sect</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>We don't need IRQs, so we should disable it to prevent problems from happening. We said before that if bit 1 of the Control Register (which is called nIEN bit), is set, no IRQs will be invoked from any drives on this channel, either master or slave.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_CONTROL</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">nIEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ide_irq_invoked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x02</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Now lets read the parameters:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (I) Select one from LBA28, LBA48 or CHS;</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mh">0x10000000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Sure Drive should support LBA in this case, or you are</span>
<span class="w">                            </span><span class="c1">// giving a wrong LBA.</span>
<span class="w">      </span><span class="c1">// LBA48:</span>
<span class="w">      </span><span class="n">lba_mode</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x000000FF</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0000FF00</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x00FF0000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF000000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// LBA28 is integer, so 32-bits are enough to access 2TB.</span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// LBA28 is integer, so 32-bits are enough to access 2TB.</span>
<span class="w">      </span><span class="n">head</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Lower 4-bits of HDDEVSEL are not used here.</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Capabilities</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x200</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="c1">// Drive supports LBA?</span>
<span class="w">      </span><span class="c1">// LBA28:</span>
<span class="w">      </span><span class="n">lba_mode</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x00000FF</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x000FF00</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0FF0000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// These Registers are not used here.</span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// These Registers are not used here.</span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// These Registers are not used here.</span>
<span class="w">      </span><span class="n">head</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xF000000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// CHS:</span>
<span class="w">      </span><span class="n">lba_mode</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">sect</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">63</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">cyl</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">sect</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">63</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sect</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">cyl</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">cyl</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">head</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">sect</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">63</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">63</span><span class="p">);</span><span class="w"> </span><span class="c1">// Head number is written to HDDEVSEL lower 4-bits.</span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>Now we are going to choose the way of reading the buffer [PIO or DMA]:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (II) See if drive supports DMA or not;</span>
<span class="w">   </span><span class="n">dma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// We don&#39;t support DMA</span>
</pre></div>
<p>Lets poll the Status port while the channel is busy:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (III) Wait if the drive is busy;</span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ide_read</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ATA_SR_BSY</span><span class="p">){</span><span class="w">   </span>
<span class="w">   </span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="c1">// Wait if busy.</span>
</pre></div>
<p>The HDDDEVSEL register now looks like this:
</p>
<ul><li>Bits 0&#160;: 3: Head Number for CHS.</li>
<li>Bit 4: Slave Bit. (0: Selecting Master Drive, 1: Selecting Slave Drive).</li>
<li>Bit 5: Obsolete and isn't used, but should be set.</li>
<li>Bit 6: LBA (0: CHS, 1: LBA).</li>
<li>Bit 7: Obsolete and isn't used, but should be set.</li></ul>
<p>Lets write all these information to the register, while the obsolete bits are set (0xA0):
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (IV) Select Drive from the controller;</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_HDDEVSEL</span><span class="p">,</span><span class="w"> </span><span class="mh">0xA0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">slavebit</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">head</span><span class="p">);</span><span class="w"> </span><span class="c1">// Drive &amp; CHS.</span>
<span class="w">   </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_HDDEVSEL</span><span class="p">,</span><span class="w"> </span><span class="mh">0xE0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">slavebit</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">head</span><span class="p">);</span><span class="w"> </span><span class="c1">// Drive &amp; LBA</span>
</pre></div>
<p>Let's write the parameters to registers:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (V) Write Parameters;</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_SECCOUNT1</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_LBA3</span><span class="p">,</span><span class="w">   </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_LBA4</span><span class="p">,</span><span class="w">   </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_LBA5</span><span class="p">,</span><span class="w">   </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_SECCOUNT0</span><span class="p">,</span><span class="w">   </span><span class="n">numsects</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_LBA0</span><span class="p">,</span><span class="w">   </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_LBA1</span><span class="p">,</span><span class="w">   </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_LBA2</span><span class="p">,</span><span class="w">   </span><span class="n">lba_io</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>
</pre></div>
<p>If you are using LBA48 and want to write to the LBA0 and LBA3 registers, you should write LBA3 to Register 3, then write LBA0 to Register 3. ide_write function makes it quite simple, refer to the function and you will fully understand the code.
</p><p>Now, we have a great set of commands described in ATA/ATAPI-8 Specification, we should choose the suitable command to execute:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (VI) Select the command and send it;</span>
<span class="w">   </span><span class="c1">// Routine that is followed:</span>
<span class="w">   </span><span class="c1">// If ( DMA &amp; LBA48)   DO_DMA_EXT;</span>
<span class="w">   </span><span class="c1">// If ( DMA &amp; LBA28)   DO_DMA_LBA;</span>
<span class="w">   </span><span class="c1">// If ( DMA &amp; LBA28)   DO_DMA_CHS;</span>
<span class="w">   </span><span class="c1">// If (!DMA &amp; LBA48)   DO_PIO_EXT;</span>
<span class="w">   </span><span class="c1">// If (!DMA &amp; LBA28)   DO_PIO_LBA;</span>
<span class="w">   </span><span class="c1">// If (!DMA &amp; !LBA#)   DO_PIO_CHS;</span>
</pre></div>
<p>There isn't a command for doing CHS with DMA.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_READ_PIO</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_READ_PIO</span><span class="p">;</span><span class="w">   </span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_READ_PIO_EXT</span><span class="p">;</span><span class="w">   </span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_READ_DMA</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_READ_DMA</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_READ_DMA_EXT</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_WRITE_PIO</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_WRITE_PIO</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_WRITE_PIO_EXT</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_WRITE_DMA</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_WRITE_DMA</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lba_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATA_CMD_WRITE_DMA_EXT</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_COMMAND</span><span class="p">,</span><span class="w"> </span><span class="n">cmd</span><span class="p">);</span><span class="w">               </span><span class="c1">// Send the Command.</span>
</pre></div>
<p>This ATA_CMD_READ_PIO command is used for reading in LBA28 or CHS, and the IDE controller refers to bit 6 of the HDDEVSEL register to find out the mode of reading (LBA or CHS).
</p><p>After sending the command, we should poll, then we read/write a sector, then we should poll, then we read/write a sector, until we read/write all sectors needed, if an error has happened, the function will return a specific error code.
</p><p>Notice that after writing, we should execute the CACHE FLUSH command, and we should poll after it, but without checking for errors.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dma</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="c1">// DMA Read.</span>
<span class="w">      </span><span class="k">else</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="c1">// DMA Write.</span>
<span class="w">   </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="c1">// PIO Read.</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numsects</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_polling</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"> </span><span class="c1">// Polling, set error and exit if there is.</span>
<span class="w">         </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;pushw %es&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;mov&#160;%%ax,&#160;%%es&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">(</span><span class="n">selector</span><span class="p">));</span><span class="w"></span>
<span class="w">         </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;rep insw&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">(</span><span class="n">words</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;d&quot;</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">(</span><span class="n">edi</span><span class="p">));</span><span class="w"> </span><span class="c1">// Receive Data.</span>
<span class="w">         </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;popw %es&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="n">edi</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">words</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// PIO Write.</span>
<span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numsects</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ide_polling</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Polling.</span>
<span class="w">            </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;pushw %ds&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;mov&#160;%%ax,&#160;%%ds&quot;</span><span class="o">::</span><span class="s">&quot;a&quot;</span><span class="p">(</span><span class="n">selector</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;rep outsw&quot;</span><span class="o">::</span><span class="s">&quot;c&quot;</span><span class="p">(</span><span class="n">words</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;d&quot;</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;S&quot;</span><span class="p">(</span><span class="n">edi</span><span class="p">));</span><span class="w"> </span><span class="c1">// Send Data</span>
<span class="w">            </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;popw %ds&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">edi</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">words</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">         </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_COMMAND</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="p">[])</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="n">ATA_CMD_CACHE_FLUSH</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">ATA_CMD_CACHE_FLUSH</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">ATA_CMD_CACHE_FLUSH_EXT</span><span class="p">}[</span><span class="n">lba_mode</span><span class="p">]);</span><span class="w"></span>
<span class="w">         </span><span class="n">ide_polling</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Polling.</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Easy, isn&#39;t it?</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Reading_from_an_ATAPI_Drive">Reading from an ATAPI Drive</span></h2>
<p>Let's move to an easier part - reading from an ATAPI drive. I will not make the function that writes to an ATAPI drive, because writing to it is very complex and is outside of the scope of this tutorial.
</p><p>An ATAPI drive is different from an ATA drive, as it uses the SCSI command set instead of the ATA command set. Parameters are sent as packets, therefore it's called the ATA Packet Interface [ATAPI].
</p><p>Notice also that ATAPI drives always use IRQs and you can't disable them. We should create a function that waits for an IRQ:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ide_wait_irq</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ide_irq_invoked</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">ide_irq_invoked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>When an IRQ happens, the following function should be executed by ISR:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ide_irq</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">ide_irq_invoked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>ide_wait_irq will go into a while loop, which waits for the variable ide_irq_invoked to be set, then clears it.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">ide_atapi_read</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">drive</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">numsects</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">selector</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">edi</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</pre></div>
<ul><li>drive is the drive number, which is from 0 to 3.</li>
<li>lba is the LBA address.</li>
<li>numsects is the number of sectors. It should always be 1, and if you want to read more than one sector, re-execute this function with th updated LBA address.</li>
<li>selector is the Segment Selector.</li>
<li>edi is the offset in the selector.</li></ul>
<p>Let's read the parameters of the drive:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">channel</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Channel</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">slavebit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Drive</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">bus</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">Base</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">words</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"> </span><span class="c1">// Sector Size. ATAPI drives have a sector size of 2048 bytes.</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>We need IRQs:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// Enable IRQs:</span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_CONTROL</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">nIEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_irq_invoked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Let's setup the SCSI Packet, which is 6 words (12 bytes) long:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (I): Setup SCSI Packet:</span>
<span class="w">   </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATAPI_CMD_READ</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numsects</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">atapi_packet</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Now we should select the drive:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (II): Select the drive:</span>
<span class="w">   </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_HDDEVSEL</span><span class="p">,</span><span class="w"> </span><span class="n">slavebit</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>400 nanoseconds delay after this select is a good idea:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (III): Delay 400 nanoseconds for select to complete:</span>
<span class="w">   </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">ide_read</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_ALTSTATUS</span><span class="p">);</span><span class="w"> </span><span class="c1">// Reading the Alternate Status port wastes 100ns.</span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (IV): Inform the Controller that we use PIO mode:</span>
<span class="w">   </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_FEATURES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">         </span><span class="c1">// PIO mode.</span>
</pre></div>
<p>Tell the controller the size of the buffer
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (V): Tell the Controller the size of buffer:</span>
<span class="w">   </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_LBA1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">words</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">);</span><span class="w">   </span><span class="c1">// Lower Byte of Sector Size.</span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_LBA2</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">words</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w">   </span><span class="c1">// Upper Byte of Sector Size.</span>
</pre></div>
<p>Now that we want to send the packet, we should first send the command "Packet":
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (VI): Send the Packet Command:</span>
<span class="w">   </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">   </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_COMMAND</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_CMD_PACKET</span><span class="p">);</span><span class="w">      </span><span class="c1">// Send the Command.</span>

<span class="w">   </span><span class="c1">// (VII): Waiting for the driver to finish or return an error code:</span>
<span class="w">   </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_polling</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w">         </span><span class="c1">// Polling and return if error.</span>

<span class="w">   </span><span class="c1">// (VIII): Sending the packet data:</span>
<span class="w">   </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">   </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;rep   outsw&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;d&quot;</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;S&quot;</span><span class="p">(</span><span class="n">atapi_packet</span><span class="p">));</span><span class="w">   </span><span class="c1">// Send Packet Data</span>
</pre></div>
<p>Here we cannot poll. We should wait for an IRQ, then read the sectors. These two operations should be repeated for each sector.
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (IX): Receiving Data:</span>
<span class="w">   </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numsects</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ide_wait_irq</span><span class="p">();</span><span class="w">                  </span><span class="c1">// Wait for an IRQ.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_polling</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w">      </span><span class="c1">// Polling and return if error.</span>
<span class="w">      </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;pushw %es&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;mov&#160;%%ax,&#160;%%es&quot;</span><span class="o">::</span><span class="s">&quot;a&quot;</span><span class="p">(</span><span class="n">selector</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;rep insw&quot;</span><span class="o">::</span><span class="s">&quot;c&quot;</span><span class="p">(</span><span class="n">words</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;d&quot;</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">(</span><span class="n">edi</span><span class="p">));</span><span class="c1">// Receive Data.</span>
<span class="w">      </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;popw %es&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">edi</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">words</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>Now we should wait for an IRQ and poll until the Busy and DRQ bits are clear:
</p>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="w">   </span><span class="c1">// (X): Waiting for an IRQ:</span>
<span class="w">   </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">   </span><span class="n">ide_wait_irq</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="c1">// (XI): Waiting for BSY &amp; DRQ to clear:</span>
<span class="w">   </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ide_read</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">ATA_SR_BSY</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ATA_SR_DRQ</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Easy, ... Isn&#39;t it?</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span id="Reading_from_an_ATA.2FATAPI_Drive"></span><span class="mw-headline" id="Reading_from_an_ATA/ATAPI_Drive">Reading from an ATA/ATAPI Drive</span></h2>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ide_read_sectors</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">drive</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">numsects</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">es</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">edi</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">   </span><span class="c1">// 1: Check if the drive presents:</span>
<span class="w">   </span><span class="c1">// ==================================</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">drive</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Reserved</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">package</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1</span><span class="p">;</span><span class="w">      </span><span class="c1">// Drive Not Found!</span>

<span class="w">   </span><span class="c1">// 2: Check if inputs are valid:</span>
<span class="w">   </span><span class="c1">// ==================================</span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(((</span><span class="n">lba</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">numsects</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Size</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDE_ATA</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="n">package</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x2</span><span class="p">;</span><span class="w">                     </span><span class="c1">// Seeking to invalid position.</span>

<span class="w">   </span><span class="c1">// 3: Read in PIO Mode through Polling &amp; IRQs:</span>
<span class="w">   </span><span class="c1">// ============================================</span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDE_ATA</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_ata_access</span><span class="p">(</span><span class="n">ATA_READ</span><span class="p">,</span><span class="w"> </span><span class="n">drive</span><span class="p">,</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"> </span><span class="n">numsects</span><span class="p">,</span><span class="w"> </span><span class="n">es</span><span class="p">,</span><span class="w"> </span><span class="n">edi</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDE_ATAPI</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numsects</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_atapi_read</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span><span class="w"> </span><span class="n">lba</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">es</span><span class="p">,</span><span class="w"> </span><span class="n">edi</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2048</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="n">package</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_print_error</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// package[0] is an entry of an array. It contains the Error Code.</span>
</pre></div>
<h2><span class="mw-headline" id="Writing_to_an_ATA_drive">Writing to an ATA drive</span></h2>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ide_write_sectors</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">drive</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">numsects</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">es</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">edi</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">   </span><span class="c1">// 1: Check if the drive presents:</span>
<span class="w">   </span><span class="c1">// ==================================</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">drive</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Reserved</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">package</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1</span><span class="p">;</span><span class="w">      </span><span class="c1">// Drive Not Found!</span>
<span class="w">   </span><span class="c1">// 2: Check if inputs are valid:</span>
<span class="w">   </span><span class="c1">// ==================================</span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(((</span><span class="n">lba</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">numsects</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Size</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDE_ATA</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="n">package</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x2</span><span class="p">;</span><span class="w">                     </span><span class="c1">// Seeking to invalid position.</span>
<span class="w">   </span><span class="c1">// 3: Read in PIO Mode through Polling &amp; IRQs:</span>
<span class="w">   </span><span class="c1">// ============================================</span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDE_ATA</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_ata_access</span><span class="p">(</span><span class="n">ATA_WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">drive</span><span class="p">,</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"> </span><span class="n">numsects</span><span class="p">,</span><span class="w"> </span><span class="n">es</span><span class="p">,</span><span class="w"> </span><span class="n">edi</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDE_ATAPI</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="c1">// Write-Protected.</span>
<span class="w">      </span><span class="n">package</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_print_error</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Ejecting_an_ATAPI_Drive">Ejecting an ATAPI Drive</span></h2>
<div class="mw-highlight mw-highlight-lang-c mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ide_atapi_eject</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">drive</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">channel</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Channel</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">slavebit</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Drive</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">bus</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">Base</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">words</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">2048</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">               </span><span class="c1">// Sector Size in Words.</span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">ide_irq_invoked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// 1: Check if the drive presents:</span>
<span class="w">   </span><span class="c1">// ==================================</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">drive</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Reserved</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">package</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1</span><span class="p">;</span><span class="w">      </span><span class="c1">// Drive Not Found!</span>
<span class="w">   </span><span class="c1">// 2: Check if drive isn&#39;t ATAPI:</span>
<span class="w">   </span><span class="c1">// ==================================</span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ide_devices</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDE_ATA</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">package</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w">         </span><span class="c1">// Command Aborted.</span>
<span class="w">   </span><span class="c1">// 3: Eject ATAPI Driver:</span>
<span class="w">   </span><span class="c1">// ============================================</span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Enable IRQs:</span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_CONTROL</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">nIEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_irq_invoked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// (I): Setup SCSI Packet:</span>
<span class="w">      </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATAPI_CMD_EJECT</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x02</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="w"> </span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">atapi_packet</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// (II): Select the Drive:</span>
<span class="w">      </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_HDDEVSEL</span><span class="p">,</span><span class="w"> </span><span class="n">slavebit</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// (III): Delay 400 nanosecond for select to complete:</span>
<span class="w">      </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">ide_read</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_ALTSTATUS</span><span class="p">);</span><span class="w"> </span><span class="c1">// Reading Alternate Status Port wastes 100ns.</span>

<span class="w">      </span><span class="c1">// (IV): Send the Packet Command:</span>
<span class="w">      </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">      </span><span class="n">ide_write</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_REG_COMMAND</span><span class="p">,</span><span class="w"> </span><span class="n">ATA_CMD_PACKET</span><span class="p">);</span><span class="w">      </span><span class="c1">// Send the Command.</span>

<span class="w">      </span><span class="c1">// (V): Waiting for the driver to finish or invoke an error:</span>
<span class="w">      </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">      </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_polling</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">            </span><span class="c1">// Polling and stop if error.</span>

<span class="w">      </span><span class="c1">// (VI): Sending the packet data:</span>
<span class="w">      </span><span class="c1">// ------------------------------------------------------------------</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;rep   outsw&quot;</span><span class="o">::</span><span class="s">&quot;c&quot;</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;d&quot;</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;S&quot;</span><span class="p">(</span><span class="n">atapi_packet</span><span class="p">));</span><span class="c1">// Send Packet Data</span>
<span class="w">         </span><span class="n">ide_wait_irq</span><span class="p">();</span><span class="w">                  </span><span class="c1">// Wait for an IRQ.</span>
<span class="w">         </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_polling</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">            </span><span class="c1">// Polling and get error code.</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// DRQ is not needed here.</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">package</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_print_error</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"> </span><span class="c1">// Return;</span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>When this method is invoked, the optical device on the given channel is ejected.
</p>
<h2><span class="mw-headline" id="See_Also">See Also</span></h2>
<h3><span class="mw-headline" id="Wiki_Pages">Wiki Pages</span></h3>
<ul><li><a href="MBR_(x86)" title="MBR (x86)">Master Boot Record (x86)</a></li>
<li><a href="Partition_Table" title="Partition Table">Partition Table (x86)</a></li></ul>
<h3><span class="mw-headline" id="Threads">Threads</span></h3>
<ul><li><a rel="nofollow" class="external text" href="http://www.osdev.org/phpBB2/viewtopic.php?t=12268">How to w/r harddisk in pmode? (ASM Code from Dex)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.osdev.org/phpBB2/viewtopic.php?t=15314">ATA PIO code library (ASM code from XCHG)</a></li>
<li><a rel="nofollow" class="external text" href="http://forum.osdev.org/viewtopic.php?f=1&amp;p=167798#p167798">IDE Tutorial (C code from <i>mostafazizo</i>)</a></li></ul>
<h3><span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="http://www.t13.org">T13</a> -- The group that creates the ATA standard</li>
<li><a rel="nofollow" class="external text" href="http://www.ata-atapi.com">ATA-ATAPI</a> -- Public Domain C driver sources (including SATA, Busmatering DMA, ATAPI), fairly good.</li>
<li><a rel="nofollow" class="external text" href="http://hddguru.com/content/en/documentation/">HDD Guru</a> -- The actual ATA specs from the first one that was released in 1994 to the 7th one in 2003.</li>
<li><a rel="nofollow" class="external text" href="http://www.ranish.com/part/primer.htm">Partitioning Primer</a> -- A .HTM file containing some information about partitioning.</li>
<li><a rel="nofollow" class="external text" href="http://www.bswd.com/pciide.pdf">PCI IDE Controller Specification</a> -- Specification containing information on "compatibility mode" and "PCI native mode" (and switching between them)</li>
<li><a rel="nofollow" class="external text" href="http://bswd.com/idems100.pdf">Programming Interface for Bus Master IDE Controller</a> -- Bus Master IDE specification</li></ul>
<!-- 
NewPP limit report
Cached time: 20250212012200
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.290 seconds
Real time usage: 6.590 seconds
Preprocessor visited node count: 318/1000000
Post‐expand include size: 461/2097152 bytes
Template argument size: 9/2097152 bytes
Highest expansion depth: 4/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 181213/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    1.333      1 -total
100.00%    1.333      1 Template:Disputed
 55.52%    0.740      1 Template:DiscussThis
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2716-0!canonical and timestamp 20250212012154 and revision id 28314.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://wiki.osdev.org/index.php?title=PCI_IDE_Controller&amp;oldid=28314">https://wiki.osdev.org/index.php?title=PCI_IDE_Controller&amp;oldid=28314</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/index.php?title=Category:Pages_using_deprecated_source_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using deprecated source tags (page does not exist)">Pages using deprecated source tags</a></li><li><a href="./Category:Disputed_Pages" title="Category:Disputed Pages">Disputed Pages</a></li><li><a href="./Category:ATA" title="Category:ATA">ATA</a></li><li><a href="./Category:Storage" title="Category:Storage">Storage</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=PCI+IDE+Controller" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li><li id="pt-darkmode" class="mw-list-item"><a href="PCI_IDE_Controller#" class="ext-darkmode-link"><span>Dark mode</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="PCI_IDE_Controller" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="mw-list-item"><a href="./Talk:PCI_IDE_Controller" rel="discussion" title="Discussion about the content page [t]" accesskey="t"><span>Discussion</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="PCI_IDE_Controller"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PCI_IDE_Controller&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li><li id="ca-history" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PCI_IDE_Controller&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://wiki.osdev.org/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search OSDev Wiki" aria-label="Search OSDev Wiki" autocapitalize="sentences" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="index.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation vector-menu-portal portal" aria-labelledby="p-navigation-label" role="navigation"  >
	<h3
		id="p-navigation-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Navigation</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-mainpage" class="mw-list-item"><a href="index.html" title="Visit the main page [z]" accesskey="z"><span>Main Page</span></a></li><li id="n-portal" class="mw-list-item"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things"><span>Forums</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="./Category:FAQ"><span>FAQ</span></a></li><li id="n-OS-Projects" class="mw-list-item"><a href="Projects"><span>OS Projects</span></a></li><li id="n-randompage" class="mw-list-item"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x"><span>Random page</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-about" class="vector-menu mw-portlet mw-portlet-about vector-menu-portal portal" aria-labelledby="p-about-label" role="navigation"  >
	<h3
		id="p-about-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">About</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-This-site" class="mw-list-item"><a href="./OSDevWiki:About"><span>This site</span></a></li><li id="n-Joining" class="mw-list-item"><a href="./OSDevWiki:Joining"><span>Joining</span></a></li><li id="n-Editing-help" class="mw-list-item"><a href="./OSDevWiki:Editing"><span>Editing help</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="./Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r"><span>Recent changes</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="./Special:WhatLinksHere/PCI_IDE_Controller" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="./Special:RecentChangesLinked/PCI_IDE_Controller" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="./Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PCI_IDE_Controller&amp;oldid=28314" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://wiki.osdev.org/index.php?title=PCI_IDE_Controller&amp;action=info" title="More information about this page"><span>Page information</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-lang" class="vector-menu mw-portlet mw-portlet-lang vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation"  >
	<h3
		id="p-lang-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">In other languages</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-de mw-list-item"><a href="http://www.lowlevel.eu/wiki/AT_Attachment" title="AT Attachment – Deutsch" lang="de" hreflang="de" class="interlanguage-link-target"><span>Deutsch</span></a></li></ul>
		
	</div>
</nav>

</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 21 September 2023, at 01:33.</li>
	<li id="footer-info-0">This page has been accessed 21,199 times.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="./OSDev_Wiki:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="./OSDev_Wiki:About">About OSDev Wiki</a></li>
	<li id="footer-places-disclaimer"><a href="./OSDev_Wiki:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-mobileview"><a href="https://wiki.osdev.org/index.php?title=PCI_IDE_Controller&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.290","walltime":"6.590","ppvisitednodes":{"value":318,"limit":1000000},"postexpandincludesize":{"value":461,"limit":2097152},"templateargumentsize":{"value":9,"limit":2097152},"expansiondepth":{"value":4,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":181213,"limit":5000000},"timingprofile":["100.00%    1.333      1 -total","100.00%    1.333      1 Template:Disputed"," 55.52%    0.740      1 Template:DiscussThis"]},"cachereport":{"timestamp":"20250212012200","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":118});});</script>
</body>
</html>