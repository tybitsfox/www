<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<?php
//use text=UTF-8
echo "<center><font size=5 color=#00ff00>QT学习总结</font></center><br><br><font color=#0000ff>一、QT profile:<br>";
echo "<pre>
######################################################################
# Automatically generated by qmake (1.07a) Tue Feb 17 21:05:23 2009
######################################################################

TEMPLATE = app
INCLUDEPATH += .
INCLUDEPATH +=/usr/include/kde/
QMAKE_LIBDIR_X11 += /usr/lib
QMAKE_LIBS_X11 += -lkdeui -lkdecore

# Input
INTERFACES += tianyong.ui
SOURCES += main.cpp

######################################################################
# 以上是qt.pro 所应包含的元素
# 使用.ui文件生成.h 和 .cpp文件：
# uic -o filename.h filename.ui
# uic -i filename.h -o filename.cpp filename.ui
# 使用.ui文件生成pro 和 Makefile文件：
# qmake -project
# qmake filename.pro
######################################################################
</pre></font><br>";
echo "<font color=#ff0000>二、Hello QT<br><pre>
本文为Jasmin Blanchette & Mark Summerfield著The C++ GUI Programming with Qt 4, Second Edition的中文翻译连载。原书版权归
原作者，此翻译版版权为CHINSUNG所有，依据GPL（V2+）协议免费发放。如需转载，请注明出处并包含本行文字。
先来看一个最简单的Qt程序。我们会逐行对其进行分析，并介绍其编译、运行方式。
   1.      #include <QApplication>
   2.      #include <QLabel>
   3.      int main(int argc, char *argv[])
        4.                {
   5.      QApplication app(argc, argv);
   6.      QLabel *label = new QLabel(\"Hello Qt!\");
   7.      label->show();
   8.      return app.exec();
        9.                 }

其中第1行和第2行包含了QApplication和QLabel的定义。在Qt中，每一个类均有一个与之同名的头文件，这个头文件中包含了这个类的定义。

第5行创建了一个QApplication对象，用于管理程序资源。由于Qt程序可使用命令行参数，QApplication构造函数需接收argc和argv两个参数。

第6行创建了一个QLabel控件（本文将Widget翻译为控件，其意应为“窗体小部件”）用于显示\"Hello Qt!\"。在Qt和Unix术语中，控件是一种可见的用户界面
元素，源自\"window gadget\"，在Windows术语中与“控制”和 “容器”等价。按纽（Button），菜单（menu），滚动条（scroll bar）以及框架（frame）
等都称作控件。控件还可容纳其他控件，比如程序窗口通常包含有一个菜单栏，若干工具栏，一个状态栏以及若干其他控件。许多程序使用一个QMainWindow或
QDialog作为程序窗口，但事实上Qt高度灵活，任何控件都可作为程序窗口。在本例中，程序窗口是QLabel控件。
第7行将label设为可见。控制被创建后默认为隐藏状态，一般在显示前需对其进行必要修改，以避免发生闪动。
第8行将程序控制权交予Qt，使程序进入事件循环状态，等待恰当的用户行为，如点击鼠标或敲击键盘。用户行为产生程序可响应的事件（也称作“消息”），
通常事件的响应方式就是执行函数。例如，用户点击了一个控件将产生\"mouse press\"和\"mouse release\"两个事件。从这个意义上讲，GUI程序和传统的命令
式程序有着本质的不同，后者通常只是机械的输入和输出，缺少人机交互。
为简便起见，我们在main()程序结束时并没有调用delete命令来清除内存，毕竟这个程序很小，程序终止后操作系统将重新利用其占用的内存，不必担心泄漏问题。
现在可以来运行一下这个程序了，其外观应如图1.1所示。要编译并运行这个小程序，首先得安装Qt4.3.2或以上版本。在附录A中有Qt安装的详细说明。在此我们假定你已
经正确安装了Qt4并将其bin目录添加到了系统环境变量中（在Windows上，这一步由安装程序自动执行）。将上面的程序输入到hello.cpp文件中，或是从随书光盘中拷
贝过去（本书例程可由http://www.informit.com/title/0132354160下载）。我们假定你将hello.cpp文件存放在一个叫hello的文件夹中。
图1.1 Linux上的Hello Qt!
在命令提示符下，更改路径至hello文件夹，然后键入：
$ qmake -project //注意，这里的$ 为linux命令提示符，不必键入，下同
此时hello目录下生成一个平台无关的项目文件hello.pro，然后键入：
$ qmake hello.pro
此时hello目录下生成一个平台相关的Makefile文件（关于qmake的详细说明请参见附录B）。随后键入make构建程序。要运行此程序，Windows下直接输入hello，
UNIX下输入./hello，这里./意为当前目录，类UNIX系统必需指定文件路径。在Mac OS X系统中则需输入open hello.app。要结束这个程序，可点击窗口标题栏的
关闭按纽。当然，在任何操作系统中，均可通过双击程序图标运行程序。
在进入下一节之前，先来玩点有趣的东东：将下面这行
      QLabel *label = new QLabel(\"Hello Qt!\");
换成：
      QLabel *label = new QLabel(\"<h2><i>Hello </i><font color = red>Qt!</font></h2>\");
重新编译运行，可得如图1.2。容易看出，Qt程序可用简单的HTML风格代码来作格式化处理。
</pre></font><br>";
echo "<font color=#0033ff>三、QT Dialog<br><pre>
對話窗 dialog

    * Modal 與 Nonnodal 對話視窗：
         1. Modal 對話視窗：在使用者回應對話視窗之前，擱置其它視窗的輸入。對於立即抓取使用者的回應和顯示重要的錯誤訊息，這類型的對話視窗就很有用。
         2. Nonmodal 對話視窗：非擱置視窗，與一般應用程式視窗相同。對於搜尋視窗或輸入視窗就很有用。
    * QDialog：Qt 的基本對話視窗類別
         1. 實例：一般會產生一個繼承自 QDialog 的對話視窗類別，並加上一些 widget 來構成對話視窗介面。

            #include <qdialog.h>
            MyDialog::MyDialog(QWidget *parent, const char *name) :
            QDialog(parent, name)
            {
              QHBoxLayout *hbox = new QHBoxLayout(this);
              hbox->addWidget(new Qlabel(\"Enter your name\"));
              hbox->addWidget(new QLineEdit());
              hbox->addWidget(ok_pushbutton);
              hbox->addWidget(cancel_pushbutton);
              connect (ok_pushbutton, SIGNAL(clicked()), this, SLOT(accept()));
              connect (cancel_pushbutton, SIGNAL(clicked()), this,
                                         SLOT(reject()));
            }


         2. Modal 對話窗：呼叫 exec()，所有處理都會被擱置。

            MyDialog *dialog = new MyDialog(this, \"mydialog\");
            if (dialog->exec() == QDialog::Accepted)
            {
              // User clicked ‘Ok’
              doSomething();
            }
            else
            {
              // user clicked ‘Cancel’ or dialog killed
              doSomethingElse();
            }
            delete dialog;


         3. signal/slot 連結方式如同 modal 對話視窗。

            MyDialog::MyDialog(QWidget *parent, const char *name) :
            QDialog(parent, name)
            {
              ...
              connect (ok_pushbutton, SIGNAL(clicked()), this, SLOT(OkClicked()));
              connect (cancel_pushbutton, SIGNAL(clicked()), this,
                       SLOT(CancelClicked()));
            }
            MyDialog::OkClicked()
            {
              //Do some processing
            }
            MyDialog::CancelClicked()
            {
              //Do some other processing
            }


         4. NonModal 對話窗：呼叫 show()，顯示對話窗並立刻回覆，繼續主要的處理迴圈。

            MyDialog *dialog = new MyDialog(this, \"mydialog\");
            dialog->show();


    * QMessageBox
         1. QMessageBox 是一個 modal 對話窗，顯示一個簡單的訊息，加上一個小圖示和按鈕。QMessageBox一般的訊息、警告訊息、其它關鍵訊息成員函式：

            #include <qmessagebox.h>
            int information (QWidget *parent, const QString &caption,
                             const QString &text,
                             int button0, int button1=0, int button2=0)
            int warning     (QWidget *parent, const QString &caption,
                             const QString &text,
                             int button0, int button1, int button2=0)
            int critical    (QWidget *parent, const QString &caption,
                             const QString &text,
                             int button0, int button1, int button2=0)


         2. Each of the buttons, button0, button1 and button2 may be set to one of the following values:

            QMessageBox::Ok
            QMessageBox::Cancel
            QMessageBox::Yes
            QMessageBox::No
            QMessageBox::Abort
            QMessageBox::Retry
            QMessageBox::Ignore


         3. 實例：QMessageBox 的使用

            int result = QMessageBox::information(this,
                         \"Engine Room Query\",
                          \"Do you wish to engage the HyperDrive?\",
                         QMessageBox::Yes | QMessageBox::Default,
                         QMessageBox::No | QMessageBox::Escape);
            switch (result) {
              case QMessageBox::Yes:
                 hyperdrive->engage();
                 break;
              case QMessageBox::No:
                // do something else
                break;
            }


         4. 對話視窗的結果。
            \includegraphics[width=2.5in]{hyperdrive.eps}
    * QInputDialog
         1. 類似 QMessageBox，但多一個 QLineEdit 可讓使用者輸入。
            \includegraphics[width=2.5in]{question.eps}
         2. 可輸入文字、布林、整數及浮點數，但分別使用不同的建構函式：

            #include <qinputdialog.h>
            QString getText   (const QString &caption, const QString &label,
                              QLineEdit::EchoMode mode=QLineEdit::Normal,
                              const QString &text=QString::null, bool * ok = 0,
                              QWidget * parent = 0, const char * name = 0)
            QString getItem   (const QString &caption, const QString &label,
                              const QStringList &list, int current=0,
                              bool editable=TRUE,
                              bool * ok=0, QWidget *parent = 0, const char *name=0)
            int getInteger    (const QString &caption, const QString &label,
                              int num=0,
                              int from = -2147483647, int to = 2147483647,
                              int step = 1,
                              bool * ok = 0, QWidget * parent = 0,
                              const char * name = 0)
            double getDouble (const QString &caption, const QString &label,
                              double num = 0,
                              double from = -2147483647, double to = 2147483647,
                              int decimals = 1, bool * ok = 0,
                              QWidget * parent = 0,
                              const char * name = 0 )


         3. 實例：輸入一行的文字：

            bool result;
            QString text = QInputDialog::getText(\"Question\",
                                                    \"What is your Quest?:\",
                                                    QLineEdit::Normal,
                                                    QString::null, &result, this,
                                                    \"input\" );
            if (result) {
               doSomething(text);
            } else {
            // user pressed cancel
            }


               1. getText 利用一個 QLineEdit，可以設定 EchoMode，也可以指定預設文字或清成空白。
               2. 每個 QInputDialog 都有 Ok 和 Cancel 按鈕，必須傳入一個 bool 指標，才能知道哪個按鈕被按下，如果使用者按下 Ok，result 就是 TRUE。
         4. getItem 透過 QComboBox，提供使用者一系列的選項。

            bool result;
            QStringList options;
            options << \"London\" << \"New York\" << \"Paris\";
            QString city = QInputDialog::getItem(\"Holiday\",
                                                  \"Please select a destination:\",
                                                   options, 1, TRUE, &result,
                                                  this, \"combo\");
            if (result)
              selectDestination(city);


         5. 對話窗的結果。
            \includegraphics[width=2.5in]{getitem.eps}
    * 使用 qmake 簡化 makefile 的設計
         1. Qt 提供一個工具稱為 qmake，可以產生 makefile。
         2. qmake 需要一個 .pro 的輸入檔案。這個檔案包含基本的資訊，例如：原始碼、標頭檔案、目的檔案和 KDE/Qt 函式庫位置。一般 KDE 的 .pro 檔案如下：

            TARGET = app
            MOC_DIR = moc
            OBJECTS_DIR = obj
            INCLUDEPATH = /usr/include/kde
            QMAKE_LIBDIR_X11 += /usr/lib
            QMAKE_LIBS_X11 += -lkdeui -lkdecore
            SOURCES = main.cpp window.cpp
            HEADERS = window.h


         3. 產生 makefile。

            \$qmake file.pro -o Makefile
::::::
qmake -project
qmake qt1.pro
make
</pre></font><br>";
echo "<font color=#ff00ff>四、关于QT<pre>
使用Linux纯属为了想了解UNIX下DB2运行和使用情况，而一直喜欢用的FreeBSD上似乎不支持DB2数据库，反正我没有看到这方面资料。假如有谁知道的话
请您告诉我。我的爱机配置较低，在Freebsd上使用GNOME作为X-Windws有点钝，KDE也就一直都没有尝试过。在安装Linux时，突然有想看看KDE 的念头，
于是一古脑全装上了，第一次用时觉得用KDE感觉也不满意，于是将KDE改为UNIX风格，没想到重新启动X-Windws后，速度一下快了起来，终于让我觉得能够顺
利的工作了。最近在学习Python编程，想看看在Linux工作下怎样，而无意发现了QT Designer ,再仔细一看竟然使用的是C 。让我大为兴奋，C＋＋再熟悉但
是了，于是照着英文说明操练了一会，挺顺手的的，于是试着写了一代码，最后就是不会编译。我的英语水平也有限，忙了半天了也有点累了。今天在网上查了一
些资料，终于对QT Designer 有些了解。下面是我在网上看到的一篇文章，先收集以后再说吧。
1. 什麽是 QT.
用 Linux 的人,一定都知道 QT 是什麽.而利用 QT 编译出来的 KDE 桌面系统,
更是让 Linux 有了一次能和 Windows 的 GUI 相媲美的机会.甚至有人说, KDE
的桌面在图像上,还赛过了 Windows95 了.那麽 QT 到底是什麽呢？其实 QT
就是基於 C 语言上的一种专门用来研发 GUI 介面的程式.这里面包括了∶
button; label; frame ... 等等很多的能够直接调用的东西.
2. 为什麽选择 QT
2.1 QT 是基於 C 的一种语言
相信 C/C 现在还是一种很多人都在学习的语言. QT 的好处就在於 QT 本身
能够被称作是一种 C 的延伸. QT 中有数百个 class 都是用 C 写出来的.
这也就是说, QT 本身就具备了 C 的快速、简易、Object-Oriented Programming
（OOP）等等无数的长处.
2.2 QT 具备很好的可移植性（Portable）
QT 不只是能够在 Linux 中运作.也同样能够运行在 Microsoft Windows 中.这也就
意味者,利用 QT 编写出来的程式,在几乎不用修改的情况下,就能够同时在 Linux
中和 Microsoft Windows 中运行. QT 的应用很之广泛,从 Linux 到 Windows 从
x86 到 Embedded 都有 QT 的影子.
3. 什麽是 QT Designer
简单的来说 QT Designer 是个 GUI 的工具. 这个工具能够帮助我们来加快写 QT
程式的速度. 利用 QT Designer 能够用一种所见既所得的方式,来产生 QT 程式的
GUI 介面的程式码. 通过增加一些功能,就能够完成一个程式了.利用 QT Designer
能够很快速的学会 QT, 而我们这里说利用 QT Designer 来学习 QT 而不是利用
QT Designer 来写 QT, 这里的区别就在於, QT Designer 所产生的程式码有些繁琐.
跑起来也比较的慢些.我们这里只是利用 QT Designer 来帮助我们学习.而不是直接
去跑 QT Designer 生成的程式码.
3. 基本需要
因为这篇文章主要是告诉大家如何利用 QT Design 来达到快速学习 QT 的.
所以您最也要做到∶
您需要有一台能够跑 Linux 的电脑或 Microsoft Windows 的电脑
足够的 RAM 和 HardDisk 用以安装、 编译 QT
您的 Linux 中需要安装有 KDE、QT、QT Designer、g 等等程式.
您假如适用 Microsoft Windows, 则您需要 VC 和 QT For Windows
Linux 的使用者最好还能安装一个 Kdevelop（一个很好的用来研发 QT 的 Develop Enverment）
4. QT Designer
简单的介绍--从 PushButton 开始
假设您一切都安装好了.现在我们打开 QT Designer 吧. 打开後,选择 New -> Dialog
这时侯,您的 QT Designer 中就会出现一个 From1 来. 现在我们 click 一下上面的 tools 中
的那个 pushbutton, (标有 OK 的图标）并且用 mouse 选择到一定的大小. 在这个 pushbutton
上面用您的 mouse double click 一下. 我们就能够改变 pushbutton 的 label 了. 这里我们把
pushbutton1 这几个字,换成 Exit, 然後直接按 Enter 或用 mouse 选择 OK 也能够. 现在我们
看到, 那个 button 中的标签已将变成 Exit 了. 我们这时侯还需要给这个 Exit Button 一个
signal（信号）, 这样当您在 Exit 这个 Button 上 click 的时侯. QT 才知道如何去处理这个信
号. 我们按一下 F3（connect singnal slot）然後在那个 Exit Button 上面 Click 一下. 这时
侯我们就看到了 Edit Connection 的 Dialog 了. 在 Signal 中选择 clicked, 在 slot 中,先选
择 setFocus() 就好了. 这时侯选择 OK. 我们就算是完成了. 假如想看看这个小程式长什麽样子.
能够用 CTRL T来看 PreView. (see figure 1)
figure 1
首先在您的 \$HOME 中建立一个 qt_program 的 Directory 出来. 这个 Directory 将会
作为我们存放文档的地方. 现在我们用 File -> Save 把这个文档存为 form1.ui 放在 \$HOME/qt_program
的目录下.现在假如大家打开 form1.ui 来看一看. 会发现那是一堆有很多 的东西.所以我们需要用一个叫做 uic 的程式来把 .ui 文档转换成 QT 能够使用的 .cpp 和 .h 文档.
用下面的指令就能够生成我们需要的 .h 文档了
uic -o form1.h form1.ui
而生成 .cpp 文档则需要用以下的指令∶
uic -i form1.h -o form1.cpp form1.ui
这时侯,form1.h中就会看到一个标准的 QT 需要的 .h 文档
1. #ifndef FORM1_H
2. #define FORM1_H
3. #include
4. #include
5. class QVBoxLayout;
6. class QHBoxLayout;
7. class QGridLayout;
8. class QPushButton;
9. class Form1 : public QDialog
10. {
11. Q_OBJECT
12. public:
13. Form1( QWidget* parent = 0, const char* name = 0, bool modal = FALSE, WFlags fl = 0 );
14. ~Form1();
15. QPushButton* PushButton1;
16. };
17. #endif // FORM1_H
1-2: 定义 FORM1.H 这个文档
3-4: 这里是我们需要用到的两个 .h 文档
5-7: 我们根本用不到, qt designer 自己产生的
8: QPushButton 需要用到这个 class
9-11: 我们的 form1 是 based 在 QDialog 上面的
12: 公开的 （能够在以後的程式中使用.用过 C 的人一定明白）
13: Form1的架构
14: 清除 Form1
15: 产生一个pushbutton （就是那个标有 exit 的 按钮
17: 结束对 FORM1.H 的定义
而 form1.cpp 文档如下:
1. #include \"form1.h\"
2. #include
3. #include
4. #include
5. #include
6. #include
7. /*
8. * Constructs a Form1 which is a child of 'parent', with the
9. * name 'name' and widget flags set to 'f'
10. *
11. * The dialog will by default be modeless, unless you set 'modal' to
12. * TRUE to construct a modal dialog.
13. */
14. Form1::Form1( QWidget* parent, const char* name, bool modal, WFlags fl )
15. : QDialog( parent, name, modal, fl )
16. {
17. if ( !name )
18. setName( \"Form1\" );
19. resize( 596, 480 );
20. setCaption( tr( \"Form1\" ) );
21. PushButton1 = new QPushButton( this, \"PushButton1\" );
22. PushButton1->setGeometry( QRect( 130, 160, 161, 71 ) );
23. PushButton1->setText( tr( \"Exit\" ) );
24. // signals and slots connections
25. connect( PushButton1, SIGNAL( clicked() ), PushButton1, SLOT( setFocus() ) );
26. }
27. /*
28. * Destroys the object and frees any allocated resources
29. */
30. Form1::~Form1()
31. {
32. // no need to delete child widgets, Qt does it all for us
33. }
1: 我们上面的定义文档
2: pushbutton所需要的 .h 文档
3-6: 我们根本用不到, qt designer 自己产生的
7-13: QT Designer 产生的注解
14-15: Form1 的结构
17-18: 假如Form1:Form1中没有 pass 一个名子过来.那麽就命名为 Form1
19: resize
20: 把显示出来的那个 Dialog 的名子定为 Form1, 也就是 window 中左上角的字
21: 做出一个新的button,名子为 PushButton1
22: 这里设定了 pushbutton 在这个 dialog 中的位置. Qrect(130, 160, 161, 71) 这里是说在一
个Dialog中,以左边最上面来算,位置是(0,0), 所以说,这里的130（横向）和 160 （纵向）就是说我
们从 (0,0)开始,往左边跑130,往下跑 160.这样我们就算出了pushbutton这个按钮画在那里了.後面的161,
71则是定义这个pushbutton到底要画多大,设定了长和高
23: 通过呼叫setText指令,我们能够在这个 button上面给入我们需要的文字.这里是 Exit
24: QT Designer 产生的注解
25: 上面就是处理当接收到 clicked 的信号（singal）以後,我们所作的事情（setFocus on PushButton1)
connect 这里是告诉程式连接一个信号,PushButton1, SIGNAL(clicked()),是说信号是由 PushButton1 发出,
发出的信号为 mouse clicked,PushButton1, SLOT(setFocus())表示信号发出以後,目标（Object）为 PushButton,
event 是 setFocus() 动作
26: 主程式结束
27-29: QT Designer 的注解
30-33: 清除 Form1
由於我们要常常用到 QT Designer, 也就是说,需要常常用到 uic 这苹程式. 为了省去每次都要
打一堆东西的麻烦.我们来写一各小 script 来处理 .ui 档案.
不难看出, uic 在处理/生成 .h .cpp 档案的时侯,用到了两个指令∶

uic -o form1.h form1.ui
uic -i form1.h -o form1.cpp form1.ui

所以我们的 script 就写成∶

###############################################################
#!/bin/sh #
# myuic program convert .ui to .cpp .h by calling uic #
#
INPUT_UI=$@ #
#这里读取外面传回来的文档名 #
#
#
if [ ! -f \"\$INPUT_UI\" ] #
then #
echo \"UIC File \$INPUT_UI Not Found\" #
echo #
echo \"Userage myuic input_file.ui\" #
echo #
exit 1 #
fi #
#上面的语句检查我们所输入的.ui文档是否存在 #
#假如很难找到指定的.ui文档,则显示一个简短的 #
#使用说明 #
#
INPUT_H=`echo $@ | cut -d '.' -f1`.h #
#这里我们利用 cut 来处理输入的 .ui 文档. #
#得到一个 .h 的文档名 #
#
INPUT_CPP=`echo $@ | cut -d '.' -f1`.cpp #
#同样的道理,利用 cut 产生一个 .cpp 的文档名 #
#
uic -o \$INPUT_H \$INPUT_UI #
#这里就是利用 .ui 产生 .h 的文档 #
#
uic -i \$INPUT_H -o \$INPUT_CPP \$INPUT_UI #
#利用 .h 和 .ui 产生 .cpp 文档. #
#
###############################################################
我门把这个文档存为 myuic. 并切 chmod x 变成可执行档案.
然後 cp 到 /usr/bin 上面. 假如您在电脑中没有 root 的权限.
能够在自己的 \$HOME 目录中做一个 bin 的 Directory 出来.
然後去编辑您的 .bash_profile （这里假设您用的是 bash）
假如您的 .bash_profile 中本身已有了 PATH 这段文字,那麽
您只要在原本的 PATH 後面加上 :\$HOME/bin就能够了.假如没有
那麽就在您的 .bash_profile 中写入∶

PATH=\$PATH:\$HOME/bin
export PATH
这样您以後就能够直接执行 myuic 这个文档了.现在试试看用 myuic 来处理
刚刚的那个 form1.ui 这个文档吧. 先把旧的 .h .cpp 都删除掉∶
rm -f *.cpp *.h
然後用 myuic 来生成新的 .cpp .h 文档∶
myuic form1.ui
这时候用 ls 就会看到 form1.cpp form1.h form1.ui 这三个文档了
这时侯我们只需要写一个小的main.cpp就能够编译form1.cpp了.
main.cpp很的简单
#include \"form1.h\"
#include
int main(int argc, char **argv)
{
KApplication app(argc, argv, \"Form1\"); //KDE 是建立在QT的基础上得所以KApplication
//所以kapp.h实际上包含了qapplication.h
Form1 *form1=new Form1();
form1->show();
app.setMainWidget(form1);
return(app.exec());
}
基本上来说,很简单.然後当然就是编译啦.我建议写出来的东西都用 Kdevelop 来解决.首先 Kdevelop
介面很的友善.又能省下写 Makefile 的麻烦.打开 Kdevelop 以後,选择 项目->新建, KDE2-Normal,
然後 选择 Next,在这一页中.注意不要在任何选项中打\"x\",因为我们用不到.反而会增加麻烦.最後
一直 next,然後 create , exit. 这时侯我们就已有一个新的项目能够用了.在 menu 中选择:
项目->添加现存文档.然後把 qt_program 中的 form1.cpp form1.h 和 main.cpp 加入. 这时候只要按
一下 F9 , Kdevelop 就会自动帮您把程式 compile 出来.并且执行. 程式执行後,我们不能用 click 那个
Exit Button 退出程式.因为我们并没有给他退出的信号.现在让我们来把程式码作些改变∶
###########################################################
#form1.h
#ifndef FORM1_H
#define FORM1_H
#include
class QPushButton;
class Form1 : public QDialog
{
Q_OBJECT
public:
Form1(QWidget *parent=0, const char *name=0);
QPushButton* PushButton1;
};
#endif // FORM1_H
#################################################################
#form1.cpp
#include \"form1.h\"
#include
#include
Form1::Form1(QWidget* parent, const char* name): QDialog(parent, name)
{
setCaption(tr(\"Form21\"));
PushButton1=new QPushButton(this,\"PushButton1\");
PushButton1->setGeometry(QRect(130,160,161,71));
PushButton1-vsetText(tr(\"Exit\"));
connect(PushButton1, SIGNAL(clicked()), kapp, SLOT(quit()));
}
Form1::~Form1(){}
####################################################################
main.cpp 保持不变.经过一番简化.程式码马上简单很多了.
这里我们除了把一些由 QT Design 做出的不必要的 code 挑除以外.对 form1.cpp
做了两个小改变.
1.增加了 #include 这个 head file.
2.我们把∶
connect(PushButton1, SIGNAL(clicked()), PushButton1, SLOT(setFocus()));
改变为
connect(PushButton1, SIGNAL(clicked()), kapp, SLOT(quit()));
同样的信号传送,但是目标对象有所改变.现在目标将作用在 kapp 上面也就是我们
的主程式（main application）,而 SLOT 则是呼叫 quit(),现在 Kdevelop 中更改
程式码.然後按下 F9 .等待程式运行.这时侯我们的程式,只要在那个 Exit 的 Button
上面用 mouse click 一下. 这个程式就完全关闭了.
现在我们在这个 PushButton 中再增加一些功能.我们来看看 QT Designer 中的 ToolTip
功能. 假如您的 QT Designer 中 Property Edit 并没有自动出现.那麽请在 QT Designer
中选择 Menu 中的 Windows 然後选择 Property Edit. 只要在 PushButton1 那个 Button
上面用 mouse click 一下. 就能够对 Pushbutton1 的 Property 进行编辑. 在 Property
Edit 中的 ToolTip 後面能够进行文字输入的地方,打入下面的文字∶
Click On this Button Will Exit Main Window.
然後 sava 文档. （Form1.ui）在用我们的小 script 呼叫 uic 程式把, Form1.ui 转成
Form1.h 和 Form1.cpp
myuic form1.ui
这时侯我们来观察生成的 form1.cpp 文档,我们会发现现在这里面比一前多了些东西.
现在这里多了一行:
QToolTip::add( PushButton1, tr( \"Clicke On this Button Will Exit Main Window.\" ) );
这里,我们用QToolTip中的add,在 Object (PushButton1) 上面加入\"Clicke On this Button
Will Exit Main window.\"这个字幕.现在我们在前面那个被我们简化的 form1.cpp 中,加入上面那
行程式码,因为我们需要调用到 QToolTip 所以我们也要把 qtooltip.h 给 include 进去.
#################################################################
#form1.cpp
#include \"form1.h\"
#include
#include
#include //因为我们需要用到QToolTip所以,这里要加入qtooltip.h
Form1::Form1(QWidget* parent, const char* name): QDialog(parent, name)
{
setCaption(tr(\"Form21\"));
PushButton1=new QPushButton(this,\"PushButton1\");
PushButton1->setGeometry(QRect(130,160,161,71));
PushButton1->setText(tr(\"Exit\"));
QToolTip::add(PushButton1, tr(\"Click On this Button Will Exit Main Window.\"));
connect(PushButton1, SIGNAL(clicked()), kapp, SLOT(quit()));
}
Form1::~Form1(){}
####################################################################
这时侯,重新编译这个 form1 的程式.您就会看到,当您把 mouse 移动到 Exit 那个按钮的时侯.
停留差不多一两秒钟. \"Click On this Button Will Exit Main Window\"的字样就会出现.
QPushButton 中更有一个常用的功能就是 setEnabled 了.setEnabled 通过 TRUE 和 FALSE 这两
个值.能够决定这个扭是否能够被使用者按下.
我们现在在 QT Designer 中的 Property Edit 中把 Enable 选择成 FALSE, 然後用 myuic 生成
新的程式码.
\$myuic form1.ui
这时候再去观察 form1.cpp 会发现里面多了一行 PushButton1->setEnabled( FALSE ); 这一行就
把 PushButton1 配置为不可使用了. 假如需要 PushButton1 能够正常的被 Click, 那麽只要用
PushButton1->setEnabled(TRUE) 就能够了.
提示∶ 最常用的作法通常是做出一个 SLOT 或一个判断语句,来设定 PushButton 的状态.
QPushButton 更有一各场常被用到的功能就是 Font （字体的设定）在 QT 中,我们通过 QFont 能够
设定字体的大小,种类.
在 QT Designer 中的 Property Edit 中.有一个 Font 的选项.我们在 Font 後面的那个 ... 上面
按一下,就会出现一个能够选择 font 的 window. 这里我们以 Courier(adobe) 24 号字为例子.选择
後, Save, 然後观察重新用 uic 生成的 .cpp 程式码. 我们会发现主程式中多出了下面这些程式码∶
QFont PushButton1_font( PushButton1->font() );
PushButton1_font.setFamily( \"adobe-courier\" );
PushButton1_font.setPointSize( 24 );
PushButton1->setFont( PushButton1_font );
後面还多出一个 bool Form1::event( QEvent* ev ). 这里我们先不要去理会 bool Form1::event( QEvent* ev )
只看下面这四行就好了∶
1. QFont PushButton1_font( PushButton1->font() );
2. PushButton1_font.setFamily( \"adobe-courier\" );
3. PushButton1_font.setPointSize( 24 );
4. PushButton1->setFont( PushButton1_font );
第一行是用 QFont 生成 PushButton1_font. PushButton1_font 是为了给 PushButton1 做字体设定
第二行是告诉 PushButton1_font 使用那种字型. 我们这里使用的是 adobe-courier
第三行用了 setPointSize 设定了我们需要用到多大的字,这里我们用的是 24 号字.
第四行就真正的把这些值给到了 PushButton1 中.也就是说告诉 PushButton1 去改变字体的显示.
加入下面的代码以後,重新编译 form1, 就会看到那个按钮中的 Exit 这几个字明显的变大了.字体也改变了.
提示∶ 通常在设定字体的时侯.都是用 #define 的方式在文档的开头宣告出来.
例如 #define FONT_SIZE 24
然後在设定时用 PushButton1_font.setPointSize(FONT_SIZE)
这样当您要改字体的时侯,只要把 #define FONT_SIZE 後面的值改了
整个程式中任何的字体就都改变了.而省去了在需要改变字体的时侯,
一个个的去改变没一个 setPointSize中的值
√ PushButton 是很之常用的一个东西.能够说是任何程式都不可少的.通常最常见
的用途就是作为 \"退出\" 按钮,对话窗口的选择按钮等等.
QLabel 的使用∶
现在我们再来看看 QLabel 的用法. 在 QT Designer 中, 用 Mouse 选择 Text Label,（就是那个
画了个『A』的图标.）然後用 Mouse 画出一个随便大小的 Text Label. 再用 Mouse 在这个 Label 上面 Double
Click 一下.将跳出的 Window 中的那个 TextLabel1 改成 My Label. 然後按 Save 保存文档. 用 uic 转成
.cpp 和 .h 文档.这使侯,我们发现,在 .h 文档中,多出了
class QLabel; //这里告诉程式,我们下面需要用到 QLabel
QLabel* TextLabel1; // 用 QLabel 生成 *TextLabel1
在 .cpp 中,我们则看到了多出下面这些东西.
#include //这就不用我多说了吧, include 进 qlabel.h 因为我们的 QLabel 需要
TextLabel1 = new QLabel( this, \"TextLabel1\" ); //定义 TextLabel1
TextLabel1->setGeometry( QRect( 130, 120, 171, 91 ) ); //设定 TextLabel 的位置
TextLabel1->setText( tr( \"My Label\" ) ); // 还既得我们输入的 My Label 吧.也就是给 TextLabel1 定的
//显示出来的东西.就是用 setText 在这里设定的.
现在我们把这些加入到我们前面写的那个程式中.将上面的东西加入到 form1.h 和 form1.cpp 中.
但是我们这里需要做一点小小的改变.就是把 TextLabel1 的位置远一下.放造屏幕的最左上角.
我门把:
TextLabel1->setGeometry( QRect( 130, 120, 171, 91 ) );
改换成:
TextLabel1->setGeometry( QRect( 0, 0, 171, 91 ) );
重新编译我们的程式.就会看到在程式窗口的最左上角,有一排文字的出现.文字就是我们的 TextLabel 中
定义的 \"My Label\".
现在回到我们的程式部份.在前面的 PushButton 中,我们给我们的 PushButton 定义了字型及字体.实际
上,字型及字体的定义.在 QT 中是通用的. 我们能够用相同的方法来定义 QLabel 的字体.我们现在在程式
中加入∶
QFont TextLabel1_font( TextLabel1->font() );
TextLabel1_font.setFamily( \"adobe-courier\" );
TextLabel1_font.setPointSize( 24 );
TextLabel1->setFont( TextLabel1_font );
这样我们就把这个 TextLabel改成了跟前面 PushButton 相同的字体 courier (adobe) 24 号字.
大家常常能看到 QT 中的 TextLabel 是用图片来显示的.实际上,这也很简单.我们在 QT Designer 中,
首先在我们刚刚生成的那个 TextLabel 上面用 Mouse Click 一下.把 Property Edit 的 Focus Set 到
我们得 TextLabel 上面. （假如您刚刚没有用 Mouse 在您的 QT Designer 上面乱按的话.那麽您的 Property
Edit 中的 Focus 应该本身就已在 TextLabel 上了）这时侯,我们在 Property Edit 中找一个叫做
pixmap 的东西.在 pixmap 後面的 『...』中按一下,就出现了一个新的让您还则图片的视窗. QT Designer 中
现在能够接受的图片格式为（这篇文章用的是 QT Designer 1.1）bpm, jpeg, pbm, pgm, png 和 ppm. 所以
大家随便找一个上面格式的图片.然後选择 OK.这时侯您就会发现那个 TextLabel 变成您选择的图片了. 也许
您会发现,图片并没有完全显示出来,而是只显示了一部分.（假如您选择的图片大过您的 TextLabel 的话）这
是很常见的.在 pixmap 底下,有一个 scaledContents 的选项.只要把选项後面的值改成 True 就好了.这时侯
您看到的就是个经过平衡收放过大小的图片了. 保存 （Save）起来.让我们来看看程式码这边是如何处理这
些图片的吧.
首先我们看到的是在 .cpp 的文档中,多出了:
#include
#include
这两个文档.这些都是处理图片时需要的.
後面也许大家就头大了.
static const char* const image0_data[] = {
xxxxx
xxxxx
xxxxx
xxxxx
......
...};
好长的一段.这些是什麽呢？看上去满复杂的.不用怀疑,这就是您放进去的那个图片.只但是这里是用
xpm 的格式来处存的.
什麽事 XPM 呢？
其实 XPM 是 XPixMap的简称. XPM 是 Linux 中 X11 的一种图像处存的方法.
在 XPM 中,图像被允许用 ASCII 文字模式来保存起来. 而 XPM 的另一个特性就是能够
直接被 C Compiler 所接受.也就是说您能够直接把 XPM 的图片编译到您的程式中.
把 XPM 直接编译到程式中有两个最大的好处:
第一点是程式本身假如有很多图片,用 XPM 全部编译进程式中.就避免了在发行程式得时侯,需要附带很
多图片的麻烦.
第二点就是「相对」来说,被编译进程式的图片,对於一般的普通使用者来说,要改起来会比较麻烦些.
当然,假如说您不准发行Open Source Code的程式.在没有 Source Code 的情况下.想要改您放放入的
图片,就更家困难了.
但是相对的,也有一些不便性∶
程式码本身会加大很多
图片的更改性不灵活
接下来,我们看到了下面的程式码∶
QPixmap image0( ( const char** ) image0_data ); \image0_data 就是前面那个 XPM 的图片啦
TextLabel1->setPixmap( image0 ); \ 这里是告诉 TextLabel1 去使用并且显示 image0 (image0_date)
TextLabel1->setScaledContents( TRUE ); \打开自动平衡收放图片大小的功能.
QPixmap 本身其实就接受 xpm 档案. 所以我们能够不用把 XPM 的 Source 编译进程式中.而改用
QPixmap pixmap(\"image.xpm\")的形式.当然,我们需要把图片文档转换成 XPM 的格式.这里我们用
到了 Linux 中本身为我们准备好的工具 convert. convert 本身支持很多的图片各式的转换.
</font></pre><br>";




?>
