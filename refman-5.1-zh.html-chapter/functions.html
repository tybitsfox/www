<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Chapter 12. Functions and Operators</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="up" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="prev" href="column-types.html" title="Chapter 11. Column Types"><link rel="next" href="sql-syntax.html" title="Chapter 13. SQL Statement Syntax">
</head><body><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="functions"></a>
	第12章：函数和操作符</h2></div></div></div><div class="toc"><p><b>
	目录</b></p><dl><dt><span class="section"><a href="functions.html#non-typed-operators">
			12.1. 操作符</a></span></dt><dd><dl><dt><span class="section"><a href="functions.html#operator-precedence">
				12.1.1. 操作符优先级</a></span></dt><dt><span class="section"><a href="functions.html#parentheses">
				12.1.2. 圆括号</a></span></dt><dt><span class="section"><a href="functions.html#comparison-operators">
				12.1.3. 比较函数和操作符</a></span></dt><dt><span class="section"><a href="functions.html#logical-operators">
				12.1.4. 逻辑操作符</a></span></dt></dl></dd><dt><span class="section"><a href="functions.html#control-flow-functions">
			12.2. 控制流程函数</a></span></dt><dt><span class="section"><a href="functions.html#string-functions">
			12.3. 字符串函数</a></span></dt><dd><dl><dt><span class="section"><a href="functions.html#string-comparison-functions">
				12.3.1. 字符串比较函数</a></span></dt></dl></dd><dt><span class="section"><a href="functions.html#numeric-functions">
			12.4. 数值函数</a></span></dt><dd><dl><dt><span class="section"><a href="functions.html#arithmetic-functions">
				12.4.1. 算术操作符</a></span></dt><dt><span class="section"><a href="functions.html#mathematical-functions">
				12.4.2. 数学函数</a></span></dt></dl></dd><dt><span class="section"><a href="functions.html#date-and-time-functions">
			12.5. 日期和时间函数</a></span></dt><dt><span class="section"><a href="functions.html#mysql-calendar">
			12.6. MySQL使用什么日历？</a></span></dt><dt><span class="section"><a href="functions.html#fulltext-search">
			12.7. 全文搜索功能</a></span></dt><dd><dl><dt><span class="section"><a href="functions.html#fulltext-boolean">
				12.7.1. 布尔全文搜索</a></span></dt><dt><span class="section"><a href="functions.html#fulltext-query-expansion">
				12.7.2. 全文搜索带查询扩展</a></span></dt><dt><span class="section"><a href="functions.html#fulltext-stopwords">
				12.7.3. 全文停止字</a></span></dt><dt><span class="section"><a href="functions.html#fulltext-restrictions">
				12.7.4. 全文限定条件</a></span></dt><dt><span class="section"><a href="functions.html#fulltext-fine-tuning">
				12.7.5. 微调MySQL全文搜索</a></span></dt></dl></dd><dt><span class="section"><a href="functions.html#cast-functions">
			12.8. Cast函数和操作符</a></span></dt><dt><span class="section"><a href="functions.html#other-functions">
			12.9. 其他函数</a></span></dt><dd><dl><dt><span class="section"><a href="functions.html#bit-functions">
				12.9.1. 位函数</a></span></dt><dt><span class="section"><a href="functions.html#encryption-functions">
				12.9.2. 加密函数</a></span></dt><dt><span class="section"><a href="functions.html#information-functions">
				12.9.3. 信息函数</a></span></dt><dt><span class="section"><a href="functions.html#miscellaneous-functions">
				12.9.4. 其他函数</a></span></dt></dl></dd><dt><span class="section"><a href="functions.html#group-by-functions-and-modifiers">
			12.10. 与GROUP BY子句同时使用的函数和修改程序<code class="literal"></code></a></span></dt><dd><dl><dt><span class="section"><a href="functions.html#group-by-functions">12.10.1. 
				GROUP BY（聚合）函数</a></span></dt><dt><span class="section"><a href="functions.html#group-by-modifiers">12.10.2. 
				GROUP BY修改程序</a></span></dt><dt><span class="section"><a href="functions.html#group-by-hidden-fields">12.10.3. 
				具有隐含字段的GROUP BY</a></span></dt></dl></dd></dl></div><a class="indexterm" name="id2856233"></a><a class="indexterm" name="id2856248"></a><a class="indexterm" name="id2856254"></a>
	<p>
	<span>在<span>SQL
	</span>语句中，表达式可用于一些诸如<span>SELECT</span>语句的<span>ORDER 
	BY </span>或<span>HAVING</span>子句、<span>SELECT</span>、<span> 
	DELETE</span>或<span> UPDATE</span>语句的<span>WHERE </span>
	子句或<span> SET</span>语句之类的地方。使用文本值、<span>column</span>值、<span>NULL</span>值、函数、
	操作符来书写表达式。 
	本章叙述了可用于书写<span>MySQL</span>表达式的函数和操作符。 </span></p>
	<p>
	<span>
	除非在文档编制中对一个函数或操作符另有指定的情况外，一个包含<span>NULL </span>的表达式通常产生一个<span>NULL
	</span>值。</span></p>
	<p><b>
	<span>注释</span></b><span >：</span><span>
	</span><span>在默认状态下<span>,
	</span>在函数和紧随其后的括号之间不得存在空格。这能帮助<span>&nbsp; MySQL </span>
	分析程序区分一些同函数名相同的函数调用以及表或列。不过，函数自变量周围允许有空格出现。 </span></p>
	<p>
	<span>可以通过选择<span>--sql-mode=IGNORE_SPACE</span>来打开<span>MySQL</span>服务器的方法使服务器接受函数名后的空格。 
	个人客户端程序</span><span>可通过选择<span>mysql_real_connect()</span>的<span>CLIENT_IGNORE_SPACE
	</span>实现这一状态。在以上两种情况中， 所有的函数名都成为保留字。请参见</span><a href="database-administration.html#server-sql-mode" title="5.3.2. The Server SQL Mode">5.3.2节，“SQL服务器模式”</a><span >.&nbsp;
	</span></p>
	<p>
	<span>
	为节省时间，本章中对大多数例子使用简写形式展示了 <b><span>mysql</span></b><span>
	</span>程序的输出结果。 对于以下格式的举例展示： </span></p>
	<p>
	<span >
	mysql&gt; <b>SELECT MOD(29,9);</b></span></p>
	<p>
	<span >
	+-----------+</span></p>
	<p>
	<span >| 
	mod(29,9) |</span></p>
	<p>
	<span >
	+-----------+</span></p>
	<p>
	<span >
	|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 |</span></p>
	<p>
	<span >
	+-----------+</span></p>
	<p>
	<span >1 
	rows in set (0.00 </span>
	<span>秒<span>)</span></span></p>
	<p>
	<span>使用如下格式进行代替： 
	</span></p>
	<p>
	<span>
	mysql&gt; <b>SELECT MOD(29,9);</b></span></p>
	<p>
	<span >
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
	<div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="non-typed-operators"></a>
		12.1.&nbsp;操作符</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="functions.html#operator-precedence">
			12.1.1. 操作符优先级</a></span></dt><dt><span class="section"><a href="functions.html#parentheses">
			12.1.2. 圆括号</a></span></dt><dt><span class="section"><a href="functions.html#comparison-operators">
			12.1.3. 比较函数和操作符</a></span></dt><dt><span class="section"><a href="functions.html#logical-operators">
			12.1.4. 逻辑操作符</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="operator-precedence"></a>
			12.1.1.&nbsp;操作符优先级</h3></div></div></div>
			<p>
			<span>
			以下列表显示了操作符优先级的由低到高的顺序。排列在同一行的操作符具有相同的优先级。 </span></p>
			<p>
			<span >
			:=</span></p>
			<p>
			<span >
			||, OR, XOR</span></p>
			<p>
			<span >
			&amp;&amp;, AND</span></p>
			<p>
			<span >NOT</span></p>
			<p>
			<span >BETWEEN, 
			CASE, WHEN, THEN, ELSE</span></p>
			<p>
			<span >=, &lt;=&gt;, 
			&gt;=, &gt;, &lt;=, &lt;, &lt;&gt;, !=, IS, LIKE, REGEXP, IN</span></p>
			<p>
			<span >|</span></p>
			<p>
			<span >&amp;</span></p>
			<p>
			<span >&lt;&lt;, &gt;&gt;</span></p>
			<p>
			<span >-, +</span></p>
			<p>
			<span >*, /, 
			DIV, %, MOD</span></p>
			<p>
			<span >^</span></p>
			<p>
			<span >- (</span><span>一元减号<span>), 
			~ (</span>一元比特反转<span>)</span></span></p>
			<p>
			<span >!</span></p>
			<p>
			<span >BINARY, 
			COLLATE</span></p>
			<p><b>
			<span>注释</span></b><span >：</span><span>假如<span> 
			HIGH_NOT_PRECEDENCE SQL </span>模式被激活，则<span> NOT </span>
			的优先级同<span> the&nbsp; ! </span>操作符相同。请参见</span><a href="database-administration.html#server-sql-mode" title="5.3.2. The Server SQL Mode">5.3.2节，“SQL服务器模式”</a><span>。 
			</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="parentheses"></a>
			12.1.2.&nbsp;圆括号</h3></div></div></div><a class="indexterm" name="id2856476"></a><a class="indexterm" name="id2856485"></a><a class="indexterm" name="id2856494"></a><a class="indexterm" name="id2856504"></a><div class="itemizedlist"><ul type="disc"><li><p>
            ( ... )
          </p><p>
            <span>使用括弧来规定表达式的运算顺序，例如：</span></p><pre class="programlisting">mysql&gt; <strong class="userinput">SELECT 1+2*3;</strong>
        -&gt; 7
mysql&gt; <strong class="userinput">SELECT (1+2)*3;</strong>
        -&gt; 9
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="comparison-operators"></a>
			12.1.3.&nbsp;比较函数和操作符</h3></div></div></div><a class="indexterm" name="id2856556"></a><a class="indexterm" name="id2856573"></a><a class="indexterm" name="id2856579"></a>
			<p>
			<span>比较运算产生的结果为<span>1(TRUE)</span>、<span>0 
			(FALSE)</span>或<span> NULL</span>。这些运算可用于数字和字符串。根据需要，字符串可自动转换为数字，而数字也可自动转换为字符串。 
			</span></p>
			<p>
			<span>本章中的一些函数<span> 
			(</span>如<span>LEAST()</span>和<span>GREATEST())
			</span>的所得值不包括<span> 1 (TRUE)</span>、<span> 0 
			(FALSE)</span>和<span> NULL</span>。然而，其所得值乃是基于按照下述规则运行的比较运算：<span>&nbsp;&nbsp;
			</span></span></p>
			<p>
			<span >MySQL</span><span>按照以下规则进行数值比较： 
			</span></p>
			<ul type="disc">
				<li>
				<span>若有一个或两个<span>参数</span>为<span> 
				NULL</span>，除非<span>NULL-safe &lt;=&gt; </span>等算符，则比较运算的结果为<span>NULL</span>。</span></li>
				<li>
				<span>若同一个比较运算中的两个<span>参数</span>都是字符串，则按照字符串进行比较。 
				</span></li>
				<li>
				<span>若两个<span>参数</span>均为整数，则按照整数进行比较。<span>&nbsp;
				</span></span></li>
				<li>
				<span>
				十六进制值在不需要作为数字进行比较时，则按照二进制字符串进行处理。 </span></li>
				<li>
				<span>假如<span>参数</span>中的一个为<span> 
				TIMESTAMP </span>或<span> DATETIME </span>列，而其它<span>参数</span>均为常数， 
				则在进行比较前将常数转为<span> timestamp</span>。这样做的目的是为了使<span>ODBC</span>的进行更加顺利。<span>
				</span>注意，这不适合<span>IN()</span>中的<span>参数</span><span>!</span>为了更加可靠，在进行对比时通常使用完整的<span> 
				datetime/date/time</span>字符串。</span></li>
				<li>
				<span>在其它情况下，<span>参数</span>作为浮点数进行比较。<span>&nbsp;&nbsp;
				</span></span></li>
			</ul>
			<p>
			<span>
			在默认状态下，字符串比较不区分大小写，并使用现有字符集<span>(</span>默认为<span>cp1252 
			Latin1</span>，同时对英语也适合<span>)</span>。 </span></p>
			<p>
			<span>为了进行比较，可使用<span>CAST()</span>函数将某个值转为另外一种类型。 
			使用<span>CONVERT()</span>将字符串值转为不同的字符集。请参见</span><a href="functions.html#cast-functions" title="12.8. Cast Functions and Operators">12.8节，“Cast函数和操作符”</a><span>。 
			</span></p>
			<p>
			<span>
			以下例子说明了比较运算中将字符串转为数字的过程：</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 &gt; &#39;6x&#39;;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 7 &gt; &#39;6x&#39;;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 0 &gt; &#39;x6&#39;;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 0 = &#39;x6&#39;;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span>
			注意，在将一个字符串列同一个数字进行比较时，<span> MySQL </span>
			不能使用列中的索引进行快速查找。假如<i><span>str_col</span></i><span>
			</span>是一个编入索引的字符串列，则在以下语句中，索引不能执行查找功能：</span></p>
			<p>
			<span >SELECT * 
			FROM <i>tbl_name</i> WHERE <i>str_col</i>=1;</span></p>
			<p>
			<span>
			其原因是许多不同的字符串都可被转换为数值<span> 1: &#39;1&#39;</span>、<span> 
			&#39; 1&#39;</span>、<span> &#39;1a&#39;</span>、 ……</span></p>
			<ul type="disc">
				<li>
				<span >=
				</span></li>
			</ul>
			<p>
			<span>等于：</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 = 0;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT &#39;0&#39; = 0;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT &#39;0.0&#39; = 0;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT &#39;0.01&#39; = 0;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT &#39;.01&#39; = 0.01;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<ul type="disc">
				<li>
				<span >&lt;=&gt;
				</span></li>
			</ul>
			<p>
			<span >NULL-safe 
			equal.</span><span>这个操作符和<span>=</span>操作符执行相同的比较操作，不过在两个操作码均为<span>NULL</span>时，其所得值为<span>1</span>而不为<span>NULL</span>，而当一个操作码为<span>NULL</span>时，其所得值为<span>0</span>而不为<span>NULL</span>。</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 &lt;=&gt; 1, NULL &lt;=&gt; NULL, 1 &lt;=&gt; NULL;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1, 1, 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 = 1, NULL = NULL, 1 = NULL;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1, NULL, NULL</span></p>
			<ul type="disc">
				<li>
				<span >&lt;&gt; !=
				</span></li>
			</ul>
			<p>
			<span>不等于：</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT &#39;.01&#39; &lt;&gt; &#39;0.01&#39;;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT .01 &lt;&gt; &#39;0.01&#39;;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT &#39;zapp&#39; &lt;&gt; &#39;zappp&#39;;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<ul type="disc">
				<li>
				<span >&lt;=
				</span></li>
			</ul>
			<p>
			<span>小于或等于：</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 0.1 &lt;= 2;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<ul type="disc">
				<li>
				<span >&lt;
				</span></li>
			</ul>
			<p>
			<span>小于：</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 2 &lt; 2;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<ul type="disc">
				<li>
				<span >&gt;=
				</span></li>
			</ul>
			<p>
			<span>大于或等于： </span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 2 &gt;= 2;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<ul type="disc">
				<li>
				<span >&gt;
				</span></li>
			</ul>
			<p>
			<span>大于：</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 2 &gt; 2;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<ul type="disc">
				<li>
				<span >IS <i>
				boolean_value</i> IS NOT <i>boolean_value</i> </span></li>
			</ul>
			<p>
			<span>
			根据一个布尔值来检验一个值，在这里，布尔值可以是<span>TRUE</span>、<span>FALSE</span>或<span>UNKNOWN</span>。 
			</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 IS TRUE, 0 IS FALSE, NULL IS UNKNOWN;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1, 1, 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 IS NOT UNKNOWN, 0 IS NOT UNKNOWN, NULL IS NOT UNKNOWN;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1, 1, 0</span></p>
			<ul type="disc">
				<li>
				<span >IS 
				NULL IS NOT NULL </span></li>
			</ul>
			<p>
			<span>检验一个值是否为<span> 
			NULL</span>。</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 IS NULL, 0 IS NULL, NULL IS NULL;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0, 0, 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 IS NOT NULL, 0 IS NOT NULL, NULL IS NOT NULL;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1, 1, 0</span></p>
			<p>
			<span>为了能够顺利的使用<span>ODBC
			</span>程序工作，在使用<span>IS NULL</span>时，<span>MySQL</span>支持一下额外特性：</span></p>
			<ul type="disc">
				<ul type="circle">
					<li>
					<span>
					在一个值产生后，立即运行一个以下格式的语句，从而找到最新<span>AUTO_INCREMENT
					</span>值的所在行：</span></li>
				</ul>
			</ul>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span >SELECT * 
			FROM <i>tbl_name</i> WHERE <i>auto_col</i> IS NULL</span></p>
			<p>
			<span>当设置<span>SQL_AUTO_IS_NULL=0</span>时，这项操作无法运行。请参见</span><a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3节，“SET语法”</a>。</p>
			<ul type="disc">
				<ul type="circle">
					<li>
					<span>对于命名为<span>NOT 
					NULL </span>的<span>DATE </span>和<span>DATETIME</span>列，可通过使用如下的 
					语句找到特定日期<span> &#39;0000-00-00&#39;</span>：</span></li>
				</ul>
			</ul>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span >SELECT * 
			FROM <i>tbl_name</i> WHERE <i>date_column</i> IS NULL</span></p>
			<p>
			<span>运行这一步需要使用一些<span> 
			ODBC </span>应用软件，因为<span> ODBC</span>本身不支持 一个<span> 
			&#39;0000-00-00&#39;</span>的时间值。<span>&nbsp; </span></span></p>
			<ul type="disc">
				<li><i>
				<span >expr</span></i><span > 
				BETWEEN <i>min</i> AND <i>max</i> </span></li>
			</ul>
			<p>
			<span>假如<i><span>expr</span>大于或等于</i>
			<i><span>min</span></i><span> </span>且<i><span>expr</span></i><span>
			</span>小于或等于<i><span>max</span></i><span>,
			</span>则<span>BETWEEN </span>的返回值为<span>1,</span>或是<span>0</span>。若所有<span>参数</span>都是同一类型，则上述关系相当于表达式<span>&nbsp;&nbsp; 
			(<i>min</i> &lt;= <i>expr</i> AND <i>expr</i> &lt;= <i>max</i>)</span>。其它类型的转换根据本章开篇所述规律进行，且适用于<span>3</span>种<span>参数</span>中任意一种。<span>&nbsp;
			</span></span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 BETWEEN 2 AND 3;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT &#39;b&#39; BETWEEN &#39;a&#39; AND &#39;c&#39;;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 2 BETWEEN 2 AND &#39;3&#39;;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 2 BETWEEN 2 AND &#39;x-3&#39;;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<ul type="disc">
				<li><i>
				<span >expr</span></i><span > 
				NOT BETWEEN <i>min</i> AND <i>max</i> </span></li>
			</ul>
			<p>
			<span>这相当于<span>NOT(<i>expr</i> 
			BETWEEN <i>min</i> AND <i>max</i>)</span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			COALESCE(<i>value</i>,...)</span><span> </span></p>
			<p>
			<span>返回值为列表当中的第一个非<span> 
			NULL</span>值，在没有非<span>NULL </span>值得情况下返回值为<span> 
			NULL </span>。</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT COALESCE(NULL,1);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT COALESCE(NULL,NULL,NULL);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; NULL</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>GREATEST</span><span>(<i>value1</i>,<i>value2</i>,...)</span><span>
			</span></p>
			<p>
			<span>当有<span>2</span>或多个<span>参数</span>时，返回值为最大<span>(</span>最大值的<span>)</span><span>参数</span>。比较<span>参数</span>所依据的规律同<span>LEAST()</span>相同。</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT GREATEST(2,0);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 2</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT GREATEST(34.0,3.0,5.0,767.0);</b> </span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 767.0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT GREATEST(&#39;B&#39;,&#39;A&#39;,&#39;C&#39;);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; &#39;C&#39;</span></p>
			<p>
			<span>在没有自变量为<span>NULL</span>的情况下，<span>GREATEST()</span>的返回值为<span>NULL</span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><i><span>expr</span></i><span> IN
			</span><span>(<i>value</i>,...)</span><span>
			</span></p>
			<ul type="disc">
				<li>
				<span>若<i><span>expr</span></i><span>
				</span>为<span>IN</span>列表中的任意一个值，则其返回值为<span> 
				1 , </span>否则返回值为<span>0</span>。假如所有的值都是常数，则其计算和分类根据 
				<i><span>expr</span></i><span> </span>
				的类型进行。这时，使用二分搜索来搜索信息。如<span>IN</span>值列表全部由常数组成，则意味着<span>IN
				</span>的速度非常之快。如<i><span>expr</span></i><span>
				</span>是一个区分大小写的字符串表达式，则字符串比较也按照区分大小写的方式进行。<span>&nbsp;
				</span></span></li>
			</ul>
			<p>
			<span >mysql&gt; <b>
			SELECT 2 IN (0,3,5,&#39;wefwf&#39;);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT &#39;wefwf&#39; IN (0,3,5,&#39;wefwf&#39;);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >IN </span>
			<span>列表中所列值的个数仅受限于<span> 
			max_allowed_packet </span>值。</span></p>
			<p>
			<span>为了同<span>SQL
			</span>标准相一致，在左侧表达式为<span>NULL</span>的情况下，或是表中找不到匹配项或是表中一个表达式为<span>NULL
			</span>的情况下，<span>IN</span>的返回值均为<span>NULL</span>。 
			</span></p>
			<p>
			<span >IN()
			</span><span>
			语构也可用书写某些类型的子查询。请参见</span><a href="sql-syntax.html#any-in-some-subqueries" title="13.2.8.3. Subqueries with ANY, IN, and SOME">13.2.8.3节，“使用ANY、IN和SOME进行子查询”</a><span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><i><span>expr</span></i><span> 
			NOT IN (<i>value</i>,...)</span></span><span> </span></p>
			<p>这与<span><span>NOT 
			(<i>expr</i> IN (<i>value</i>,...))</span>相同。</span> </p>
			<ul type="disc">
				<li>
				<span >
				ISNULL(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>如<i><span>expr</span></i><span>
			</span>为<span>NULL</span>，那么<span>ISNULL()
			</span>的返回值为<span> 1</span>，否则返回值为<span> 0</span>。 
			</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT ISNULL(1+1);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT ISNULL(1/0);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span>使用<span>=
			</span>的<span>NULL </span>值对比通常是错误的。 </span></p>
			<p>
			<span >&nbsp;ISNULL()
			</span><span>函数同<span> 
			IS NULL</span>比较操作符具有一些相同的特性。请参见有关<span>IS NULL </span>的说明。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			INTERVAL(<i>N</i>,<i>N1</i>,<i>N2</i>,<i>N3</i>,...)</span><span>
			</span></p>
			<p>
			<span>假如<i><span>N</span></i><span> 
			&lt; <i>N1</i></span><i>，</i>则返回值为<span>0</span>；假如<i><span>N</span></i><span> 
			&lt; <i>N2</i> </span>等等，则返回值为<span>1</span>；假如<i><span>N</span></i><span>
			</span>为<span>NULL</span>，则返回值为<span> -1 </span>
			。所有的<span>参数</span>均按照整数处理。为了这个函数的正确运行，必须满足 <i>
			<span>N1</span></i><span> &lt; <i>N2</i> &lt; <i>N3</i> 
			&lt; </span>……<span>&lt; <i>Nn</i> </span>。其原因是使用了二分查找<span>(</span>极快速<span>)</span>。</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT INTERVAL(23, 1, 15, 17, 30, 44, 200);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 3</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT INTERVAL(10, 1, 10, 100, 1000);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 2</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT INTERVAL(22, 23, 30, 44, 200);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>LEAST(<i>value1</i>,<i>value2</i>,...)</span><span>
			</span></p>
			<p>
			<span>在有两个或多个<span>参数</span>的情况下， 
			返回值为最小<span> (</span>最小值<span>)<span>
			</span></span><span>参数</span>。用一下规则将自变量进行对比：</span></p>
			<ul type="disc">
				<ul type="circle">
					<li>
					<span>假如返回值被用在一个<span> 
					INTEGER </span>语境中，或是所有<span>参数</span>均为整数值，则将其作为整数值进行比较。</span></li>
					<li>
					<span>假如返回值被用在一个<span> 
					REAL</span>语境中，或所有<span>参数</span>均为实值，则 
					将其作为实值进行比较。</span></li>
					<li>
					<span>假如任意一个<span>参数</span>是一个区分大小写的字符串，则将<span>参数</span>按照区分大小写的字符串进行比较。 
					</span></li>
					<li>
					<span>在其它情况下，将<span>参数</span>作为区分大小写的字符串进行比较。 
					</span></li>
				</ul>
			</ul>
			<p>
			<span>假如任意一个自变量为<span>NULL</span>，则<span> 
			LEAST()</span>的返回值为<span>NULL </span>。</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT LEAST(2,0);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT LEAST(34.0,3.0,5.0,767.0);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 3.0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT LEAST(&#39;B&#39;,&#39;A&#39;,&#39;C&#39;);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; &#39;A&#39;</span></p>
			<p>
			<span>
			注意，上面的转换规则在一些边界情形中会产生一些奇特的结果：<span>&nbsp;&nbsp; </span></span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT CAST(LEAST(3600, 9223372036854775808.0) as SIGNED);</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; -9223372036854775808</span></p>
			<p>
			<span>发生这种情况的原因是<span>MySQL</span>在整数语境中读取</span><span>9223372036854775808.0</span><span>。整数表示法不利于保存数值，因此它包括一个带符号整数。 
			</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="logical-operators"></a>
			12.1.4.&nbsp;逻辑操作符</h3></div></div></div><a class="indexterm" name="id2858800"></a><a class="indexterm" name="id2858809"></a>
			<p>
			<span>在<span>SQL</span>中，所有逻辑
			操作符的求值所得结果均为<span> 
			TRUE</span>、<span>FALSE</span>或<span> NULL 
			(UNKNOWN)</span>。在<span> MySQL</span>中，它们体现为<span>&nbsp; 
			1 (TRUE)</span>、<span> 0 (FALSE)</span>和<span> 
			NULL</span>。其大多数都与不同的数据库<span>SQL</span>通用，然而一些服务器对<span>TRUE</span>的返回值可能是任意一个非零值。</span></p>
			<ul type="disc">
				<li>
				<span >NOT !
				</span></li>
			</ul>
			<p>
			<span>逻辑<span> 
			NOT</span>。当操作数为<span>0 </span>时，所得值为<span> 1
			</span>；当操作数为非零值时，所得值为<span>&nbsp; 0 </span>，而当操作数为<span>NOT 
			NULL</span>时，所得的返回值为<span> NULL</span>。</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT NOT 10;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT NOT 0;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT NOT NULL;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; NULL</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT ! (1+1);</b></span></p>
			<p>
			<span >&nbsp; 
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT ! 1+1;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span>最后一个例子产生的结果为<span> 
			1</span>，原因是表达式的计算方式和<span>(!1)+1</span>相同。</span></p>
			<ul type="disc">
				<li>
				<span >AND 
				&amp;&amp; </span></li>
			</ul>
			<p>
			<span>逻辑<span>AND</span>。当所有操作数均为非零值、并且不为<span>NULL</span>时，计算所得结果为<span>&nbsp; 
			1 </span>，当一个或多个操作数为<span>0 </span>时，所得结果为<span> 
			0 </span>，其余情况返回值为<span> NULL </span>。</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 &amp;&amp; 1;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 &amp;&amp; 0;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 &amp;&amp; NULL;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; NULL</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 0 &amp;&amp; NULL;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT NULL &amp;&amp; 0;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<ul type="disc">
				<li>
				<span >OR ||
				</span></li>
			</ul>
			<p>
			<span>逻辑<span> 
			OR</span>。当两个操作数均为非<span> NULL</span>值时，如有任意一个操作数为非零值，则结果为<span>1</span>，否则结果为<span>0</span>。当有一个操作数为<span>NULL</span>时，如另一个操作数为非零值，则结果为<span>1</span>，否则结果为<span> 
			NULL </span>。假如两个操作数均为<span>&nbsp; NULL</span>，则所得结果为<span> 
			NULL</span>。</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 || 1;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp; 
			&nbsp;&nbsp;&nbsp;&nbsp;-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 || 0;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 0 || 0;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 0 || NULL;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; NULL</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 || NULL;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<ul type="disc">
				<li>
				<span >XOR
				</span></li>
			</ul>
			<p>
			<span>逻辑<span>XOR</span>。当任意一个操作数为<span> 
			NULL</span>时，返回值为<span>NULL</span>。对于非<span>&nbsp;&nbsp; 
			NULL </span>的操作数，假如一个奇数操作数为非零值，则计算所得结果为<span>&nbsp; 1 </span>
			，否则为<span>&nbsp; 0 </span>。</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 XOR 1;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 0</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 XOR 0;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 XOR NULL;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; NULL</span></p>
			<p>
			<span >mysql&gt; <b>
			SELECT 1 XOR 1 XOR 1;</b></span></p>
			<p>
			<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			-&gt; 1</span></p>
			<p>
			<span >a XOR b
			</span><span>的计算等同于<span>&nbsp; 
			(a AND (NOT b)) OR ((NOT a)</span>和<span> b)</span>。 
			</span></p>
			<p>
			<span>同样见 </span> <a href="functions.html#operator-precedence" title="12.1.1. Operator Precedence">
			12.1.1节，“操作符优先级”</a><span>。 
			</span></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="control-flow-functions"></a>
		12.2.&nbsp;控制流程函数</h2>
		<ul type="disc">
			<li>
			<span >CASE <i>
			value</i> WHEN [<i>compare-value</i>] THEN <i>result</i> [WHEN [<i>compare-value</i>] 
			THEN <i>result</i> ...] [ELSE <i>result</i>] END CASE WHEN [<i>condition</i>] 
			THEN <i>result</i> [WHEN [<i>condition</i>] THEN <i>result</i> ...] 
			[ELSE <i>result</i>] END </span></li>
		</ul>
		<p>
		<span>在第一个方案的返回结果中， <i>
		<span>value</span></i><span>=<i>compare-value</i></span>。而第二个方案的返回结果是第一种情况的真实结果。如果没有匹配的结果值，则返回结果为<span>ELSE</span>后的结果，如果没有<span>ELSE
		</span>部分，则返回值为<span> NULL</span>。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT CASE 1 WHEN 1 THEN &#39;one&#39;</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <b>
		WHEN 2 THEN &#39;two&#39; ELSE &#39;more&#39; END;</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;one&#39;</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT CASE WHEN 1&gt;0 THEN &#39;true&#39; ELSE &#39;false&#39; END;</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;true&#39;</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT CASE BINARY &#39;B&#39;</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <b>
		WHEN &#39;a&#39; THEN 1 WHEN &#39;b&#39; THEN 2 END;</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		NULL</span></p>
		<p>
		<span>一个<span>CASE</span>表达式的默认返回值类型是任何返回值的相容集合类型，但具体情况视其所在语境而定。如果用在字符串语境中，则返回结果味字符串。如果用在数字语境中，则返回结果为十进制值、实值或整数值。<span>&nbsp;
		</span></span></p>
		<ul type="disc">
			<li>
			<span >IF(<i>expr1</i>,<i>expr2</i>,<i>expr3</i>)
			</span></li>
		</ul>
		<p>
		<span>如果 <i><span>
		expr1</span></i><span> </span>是<span>TRUE (<i>expr1</i> 
		&lt;&gt; 0 and <i>expr1</i> &lt;&gt; NULL)</span>，则<span> IF()</span>的返回值为<i><span>expr2</span></i><span>;
		</span>否则返回值则为 <i><span>expr3</span></i>。<span>IF()
		</span>的返回值为数字值或字符串值，具体情况视其所在语境而定。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT IF(1&gt;2,2,3);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 3</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT IF(1&lt;2,&#39;yes &#39;,&#39;no&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;-&gt; 
		&#39;yes&#39;</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT IF(STRCMP(&#39;test&#39;,&#39;test1&#39;),&#39;no&#39;,&#39;yes&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;no&#39;</span></p>
		<p>
		<span>如果<i><span>expr2</span></i><span>
		</span>或<i><span>expr3</span></i>中只有一个明确是<span> NULL</span>，则<span>IF()
		</span>函数的结果类型 为非<span>NULL</span>表达式的结果类型。 </span></p>
		<p>
		<i><span >expr1</span></i><span >
		</span><span>
		作为一个整数值进行计算，就是说，假如你正在验证浮点值或字符串值，<span>&nbsp;&nbsp; </span>
		那么应该使用比较运算进行检验。 </span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT IF(0.1,1,0);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT IF(0.1&lt;&gt;0,1,0);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
		<p>
		<span>在所示的第一个例子中，<span>IF(0.1)</span>的返回值为<span>0</span>，原因是<span> 
		0.1 </span>被转化为整数值，从而引起一个对<span> IF(0)</span>的检验。这或许不是你想要的情况。在第二个例子中，比较检验了原始浮点值，目的是为了了解是否其为非零值。比较结果使用整数。 
		</span></p>
		<p>
		<span >IF() (</span><span>这一点在其被储存到临时表时很重要<span> 
		) </span>的默认返回值类型按照以下方式计算： </span></p>
		<table border="1" cellpadding="0" id="table1">
			<tr>
				<td>
				<p><b>
				<span>表达式</span></b></td>
				<td>
				<p><b>
				<span>返回值</span></b></td>
			</tr>
			<tr>
				<td>
				<p><i>
				<span>
				expr2</span></i><span>
				</span><span>或<i><span>expr3</span></i><span>
				</span>返回值为一个字符串。</span></td>
				<td>
				<p>
				<span>字符串</span></td>
			</tr>
			<tr>
				<td>
				<p><i>
				<span>
				expr2</span></i><span>
				</span><span>或<i><span>expr3</span></i><span>
				</span>返回值为一个浮点值。</span></td>
				<td>
				<p>
				<span>浮点</span></td>
			</tr>
			<tr>
				<td>
				<p><i>
				<span>
				expr2</span></i><span>
				</span><span>或 <i>
				<span>expr3</span></i><span> </span>
				返回值为一个整数。<span>&nbsp; </span></span></td>
				<td>
				<p>
				<span>整数</span></td>
			</tr>
		</table>
		<p>
		<span>假如<i><span>expr2</span></i><span>
		</span>和<i><span>expr3</span></i><span> </span>
		都是字符串，且其中任何一个字符串区分大小写，则返回结果是区分大小写。</span></p>
		<ul type="disc">
			<li>
			<span >IFNULL(<i>expr1</i>,<i>expr2</i>)
			</span></li>
		</ul>
		<p>
		<span>假如<i><span>expr1</span></i><span>
		</span>不为<span> NULL</span>，则<span> IFNULL() </span>
		的返回值为 <i><span>expr1</span></i><span>; </span>
		否则其返回值为 <i><span>expr2</span></i>。<span>IFNULL()</span>的返回值是数字或是字符串，具体情况取决于其所使用的语境。 
		</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT IFNULL(1,0);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT IFNULL(NULL,10);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 10</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT IFNULL(1/0,10);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 10</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT IFNULL(1/0,&#39;yes&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;yes&#39;</span></p>
		<p>
		<span >
		IFNULL(<i>expr1</i>,<i>expr2</i>)</span><span>的默认结果值为两个表达式中更加“通用”的一个，顺序为<span>STRING</span>、<span> 
		REAL</span>或<span> INTEGER</span>。假设一个基于表达式的表的情况，<span>&nbsp;
		</span>或<span>MySQL</span>必须在内存储器中储存一个临时表中<span>IFNULL()</span>的返回值：</span></p>
		<p>
		<span >
		CREATE TABLE tmp SELECT IFNULL(1,&#39;test&#39;) AS test</span><span>；</span></p>
		<p>
		<span>
		在这个例子中，测试列的类型为<span> CHAR(4)</span>。</span></p>
		<ul type="disc">
			<li>
			<span >NULLIF(<i>expr1</i>,<i>expr2</i>)
			</span></li>
		</ul>
		<p>
		<span>如果<i><span>expr1</span></i></span><span > 
		= <i>expr2</i>&nbsp; </span>
		<span>成立，那么返回值为<span>NULL</span>，否则返回值为 
		<i><span>expr1</span></i>。这和<span>CASE WHEN <i>expr1</i> 
		= <i>expr2</i> THEN NULL ELSE <i>expr1</i> END</span>相同。 </span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT NULLIF(1,1);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT NULLIF(1,2);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
		<p>
		<span>
		注意，如果参数不相等，则<span> MySQL </span>两次求得的值为<span>&nbsp; expr1
		</span>。</span></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="string-functions"></a>
		12.3.&nbsp;字符串函数</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="functions.html#string-comparison-functions">
			12.3.1. 字符串比较函数</a></span></dt></dl></div><a class="indexterm" name="id2860177"></a><a class="indexterm" name="id2860186"></a>
		<p>
		<span>假如结果的长度大于<span> 
		max_allowed_packet </span>系统变量的最大值时，字符串值函数的返回值为<span>NULL</span>。请参见</span><a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2节，“调节服务器参数”</a><span>。</span></p>
		<p>
		<span>对于在字符串位置操作的函数，第一个位置的编号为<span> 
		1</span>。 </span></p>
		<ul type="disc">
			<li>
			<span >ASCII(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span>返回值为字符串<i><span>str</span></i><span>
		</span>的最左字符的数值。假如<i><span>str</span></i>为空字符串，则返回值为<span> 
		0 </span>。假如<i><span>str</span></i><span> </span>为<span>NULL</span>，则返回值为<span> 
		NULL</span>。<span> ASCII()</span>用于带有从<span> 0</span>到<span>255</span>的数值的字符。 
		</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT ASCII(&#39;2&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 50</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT ASCII(2);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 50</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT ASCII(&#39;dx&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 100</span></p>
		<p>
		<span>见<span> 
		ORD()</span>函数。 </span></p>
		<ul type="disc">
			<li>
			<span >BIN(<i>N</i>)
			</span></li>
		</ul>
		<p>
		<span>返回值为<i><span>N</span></i>的二进制值的字符串表示，其中<span>&nbsp;
		<i>N</i> </span>为一个<span>longlong (BIGINT) </span>数字。这等同于<span> 
		CONV(<i>N</i>,10,2)</span>。假如<i><span>N</span></i><span>
		</span>为<span>NULL</span>，则返回值为<span> NULL</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT BIN(12);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1100&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			BIT_LENGTH(<i>str</i>) </span></li>
		</ul>
		<p>
		<span>
		返回值为二进制的字符串<i><span>str </span></i>长度。 </span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT BIT_LENGTH(&#39;text&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 32</span></p>
		<ul type="disc">
			<li>
			<span >CHAR(<i>N</i>,... 
			[USING <i>charset</i>]) </span></li>
		</ul>
		<p>
		<span >
		CHAR()</span><span>将每个参数<i><span>N</span></i>理解为一个整数，其返回值为一个包含这些整数的代码值所给出的字符的字符串。<span>NULL</span>值被省略。 
		</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CHAR(77,121,83,81,&#39;76&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;MySQL&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CHAR(77,77.3,&#39;77.3&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;MMM&#39;</span></p>
		<p>
		<span>大于<span> 
		255</span>的<span>CHAR()</span>参数被转</span><span>换为多结果字符。<span> 
		例如，<span>CHAR(256) </span>相当于<span> CHAR(1,0),
		</span>而<span>CHAR(256*256) </span>则相当于<span> 
		CHAR(1,0,0)</span>： </span></span></p>
		<p>
		<span>
		mysql&gt; <b>SELECT HEX(CHAR(1,0)), HEX(CHAR(256));</b></span></p>
		<p>
		<span>
		+----------------+----------------+</span></p>
		<p>
		<span>
		| HEX(CHAR(1,0)) | HEX(CHAR(256)) |</span></p>
		<p>
		<span>
		+----------------+----------------+</span></p>
		<p>
		<span>
		| 0100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></p>
		<p>
		<span>
		+----------------+----------------+</span></p>
		<p>
		<span>
		mysql&gt; <b>SELECT HEX(CHAR(1,0,0)), HEX(CHAR(256*256));</b></span></p>
		<p>
		<span>
		+------------------+--------------------+</span></p>
		<p>
		<span>
		| HEX(CHAR(1,0,0)) | HEX(CHAR(256*256)) |</span></p>
		<p>
		<span>
		+------------------+--------------------+</span></p>
		<p>
		<span >
		| 010000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 010000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></p>
		<p>
		<span >
		+------------------+--------------------+</span></p>
		<p>
		<span >
		CHAR()</span><span>的返回值为一个二进制字符串。可选择使用<span>USING</span>语句产生一个给出的字符集中的字符串：</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CHARSET(CHAR(0x65)), CHARSET(CHAR(0x65 USING utf8));</b></span></p>
		<pre><span>mysql&gt; </span><span><b><span>SELECT CHARSET(CHAR(0x65)), CHARSET(CHAR(0x65 USING utf8));</span></b></span></pre>
		<pre><span>+---------------------+--------------------------------+</span></pre>
		<pre><span>| CHARSET(CHAR(0x65)) | CHARSET(CHAR(0x65 USING utf8)) |</span></pre>
		<pre><span>+---------------------+--------------------------------+</span></pre>
		<pre><span>| binary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
		<pre><span>+---------------------+--------------------------------+</span></pre>
		<p>
		<span>如果<span> 
		USING</span>已经产生，而结果字符串不符合给出的字符集，则会发出警告。<span>&nbsp;&nbsp; </span>
		同样，如果严格的<span>SQL</span>模式被激活，则<span>CHAR()</span>的结果会成为<span> 
		NULL</span>。</span></p>
		<ul type="disc">
			<li>
			<span >
			CHAR_LENGTH(<i>str</i>) </span></li>
		</ul>
		<p>
		<span>返回值为字符串</span><span><i><span>str</span></i></span><span >
		</span><span>
		的长度，长度的单位为字符。一个多字节字符算作一个单字符。<i>对于一个</i>包含五个二字节字符集<span>, 
		LENGTH()</span>返回值为<span> 10, </span>而<span>CHAR_LENGTH()</span>的返回值为<span>5</span>。 
		</span></p>
		<ul type="disc">
			<li>
			<span >
			CHARACTER_LENGTH(<i>str</i>) </span></li>
		</ul>
		<p>
		<span >
		CHARACTER_LENGTH()</span><span>是<span>CHAR_LENGTH()</span>的同义词。</span></p>
		<ul type="disc">
			<li>
			<span >COMPRESS(<i>string_to_compress</i>)
			</span></li>
		</ul>
		<p>
		<span>
		压缩一个字符串。这个函数要求<span> MySQL</span>已经用一个诸如<span>zlib</span>的压缩库压缩过。<span>&nbsp;&nbsp;
		</span>否则，返回值始终是<span>NULL</span>。<span>UNCOMPRESS()
		</span>可将压缩过的字符串进行解压缩。 </span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LENGTH(COMPRESS(REPEAT(&#39;a&#39;,1000)));</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;-&gt; 21</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LENGTH(COMPRESS(&#39;&#39;));</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LENGTH(COMPRESS(&#39;a&#39;));</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 13</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LENGTH(COMPRESS(REPEAT(&#39;a&#39;,16)));</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 15</span></p>
		<p>
		<span>
		压缩后的字符串的内容按照以下方式存储：</span></p>
		<ul type="disc">
			<ul type="circle">
				<li>
				<span>空字符串按照空字符串存储。</span></li>
				<li>
				<span>
				非空字符串未压缩字符串的四字节长度进行存储<span>(</span>首先为低字节<span>),</span>后面是压缩字符串。如果字符串以空格结尾，就会在后加一</span><span>个<span>&quot;.&quot;</span>号</span><span>,</span><span>以防止当结果值是存储在</span><span>CHAR</span><span>或<span>VARCHAR</span>类型</span><span>的字段列时</span><span>,</span><span>出现自动把结尾空格去掉的现象。</span><span >(</span><span>不推荐使用<span> 
				CHAR </span>或<span>VARCHAR </span>来存储压缩字符串。最好使用一个<span> 
				BLOB </span>列代替）<span>。 </span></span></li>
			</ul>
			<li>
			<span >CONCAT(<i>str1</i>,<i>str2</i>,...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></li>
		</ul>
		<p>
		<span>
		返回结果为连接参数产生的字符串。如有任何一个参数为<span>NULL </span>，则返回值为<span> 
		NULL</span>。或许有一个或多个参数。 如果所有参数均为非二进制字符串，则结果为非二进制字符串。 
		如果自变量中含有任一二进制字符串，则结果为一个二进制字符串。一个数字参数被转化为与之相等的二进制字符串格式；若要避免这种情况，可使用显式类型<span> 
		cast, </span>例如：<span> SELECT CONCAT(CAST(int_col AS CHAR), 
		char_col) </span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONCAT(&#39;My&#39;, &#39;S&#39;, &#39;QL&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;MySQL&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONCAT(&#39;My&#39;, NULL, &#39;QL&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONCAT(14.3);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;14.3&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			CONCAT_WS(<i>separator</i>,<i>str1</i>,<i>str2</i>,...) </span></li>
		</ul>
		<p>
		<span >
		CONCAT_WS() </span>
		<span>代表<span> 
		CONCAT With Separator </span>，是<span>CONCAT()</span>的特殊形式。<span>&nbsp;&nbsp;
		</span>第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为<span> 
		NULL</span>，则结果为<span> NULL</span>。函数会忽略任何分隔符参数后的<span> 
		NULL </span>值。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONCAT_WS(&#39;,&#39;,&#39;First name&#39;,&#39;Second name&#39;,&#39;Last Name&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;First name,Second name,Last Name&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONCAT_WS(&#39;,&#39;,&#39;First name&#39;,NULL,&#39;Last Name&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;First name,Last Name&#39;</span></p>
		<p>
		<span >
		CONCAT_WS()</span><span>不会忽略任何空字符串。<span> 
		(</span>然而会忽略所有的<span> NULL</span>）<span>。 </span>
		</span></p>
		<ul type="disc">
			<li>
			<span >CONV(<i>N</i>,<i>from_base</i>,<i>to_base</i>)
			</span></li>
		</ul>
		<p>
		<span>
		不同数基间转换数字。返回值为数字的<i><span>N</span></i>字符串表示，由<i><span>from_base</span></i>基转化为 
		<i><span>to_base </span></i>基。如有任意一个参数为<span>NULL</span>，则返回值为<span> 
		NULL</span>。自变量 <i><span>N</span></i><span> </span>
		被理解为一个整数，但是可以被指定为一个整数或字符串。最小基数为<span> 2 </span>，而最大基数则为<span> 
		36</span>。<span> If <i>to_base</i> </span>是一个负数，则 <i>
		<span>N</span></i><span> </span>被看作一个带符号数。否则， <i>
		<span>N</span></i><span> </span>被看作无符号数。<span> 
		CONV() </span>的运行精确度为<span> 64</span>比特。 </span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONV(&#39;a&#39;,16,2);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1010&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONV(&#39;6E&#39;,18,8);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;172&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONV(-17,10,-18);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;-H&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONV(10+&#39;10&#39;+&#39;10&#39;+0xa,10,10);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;40&#39;</span></p>
		<ul type="disc">
			<li>
			<span>ELT(<i>N</i>,<i>str1</i>,<i>str2</i>,<i>str3</i>,...)
			</span></li>
		</ul>
		<p>
		<span>若</span><i><span>N</span></i><span> 
		= 1</span><span>，则返回值为</span><span>&nbsp;
		<i>str1</i> </span>
		<span>，若</span><i><span>N</span></i><span> 
		= 2</span><span>，则返回值为 
		<i><span>str2</span></i><span> </span>，以此类推。<span>&nbsp;&nbsp;
		</span>若<i><span>N</span></i><span> </span>小于</span><span>1</span><span>或大于参数的数目，则返回值为</span><span> 
		NULL </span>
		<span>。 
		<span>ELT() </span>是</span><span>&nbsp; 
		FIELD()</span><span>的补数。</span></p>
		<p>
		<span>
		mysql&gt; <b>SELECT ELT(1, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;);</b></span></p>
		<p>
		<span>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;ej&#39;</span></p>
		<p>
		<span>
		mysql&gt; <b>SELECT ELT(4, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;);</b></span></p>
		<p>
		<span>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
		<span >
		-&gt; &#39;foo&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			EXPORT_SET(<i>bits</i>,<i>on</i>,<i>off</i>[,<i>separator</i>[,<i>number_of_bits</i>]])
			</span></li>
		</ul>
		<p>
		<span>
		返回值为一个字符串，其中对于<i><span>bits</span></i>值中的每个位组，可以得到一个 <i>
		<span>on</span></i><span> </span>
		字符串，而对于每个清零比特位，可以得到一个<i><span>off</span></i><span>
		</span>字符串。<i><span>bits</span></i><span> </span>
		中的比特值按照从右到左的顺序接受检验<span> (</span>由低位比特到高位比特<span>)</span>。字符串被分隔字符串分开<span>(</span>默认为逗号‘<span>,</span>’<span>)</span>，按照从左到右的顺序被添加到结果中。<i><span>number_of_bits</span></i><span>
		</span>会给出被检验的二进制位数<span> (</span>默认为<span> 64)</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT EXPORT_SET(5,&#39;Y&#39;,&#39;N&#39;,&#39;,&#39;,4);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;Y,N,Y,N&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT EXPORT_SET(6,&#39;1&#39;,&#39;0&#39;,&#39;,&#39;,10);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;-&gt; &#39;0,1,1,0,0,0,0,0,0,0&#39;</span></p>
		<ul type="disc">
			<li>
			<span >FIELD(<i>str</i>,<i>str1</i>,<i>str2</i>,<i>str3</i>,...)
			</span></li>
		</ul>
		<p>
		<span>返回值为<i><span>str1</span></i><span>,
		<i>str2</i>, <i>str3</i>,</span>……列表中的<i><span>str</span></i><span>
		</span>指数。在找不到<i><span>str</span></i><span> </span>
		的情况下，返回值为<span> 0 </span>。</span></p>
		<p>
		<span>如果所有对于<span>FIELD()
		</span>的参数均为字符串，则所有参数均按照字符串进行比较。如果所有的参数均为数字，则按照数字进行比较。否则，参数按照双倍进行比较。 
		</span></p>
		<p>
		<span>如果<i><span>str</span></i><span>
		</span>为<span>NULL</span>，则返回值为<span>0 </span>，原因是<span>NULL</span>不能同任何值进行同等比较。<span>FIELD()
		</span>是<span>ELT()</span>的补数。 </span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT FIELD(&#39;ej&#39;, &#39;Hej&#39;, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT FIELD(&#39;fo&#39;, &#39;Hej&#39;, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
		<ul type="disc">
			<li>
			<span >
			FIND_IN_SET(<i>str</i>,<i>strlist</i>) </span></li>
		</ul>
		<p>
		<span>假如字符串<i><span>str</span></i><span>
		</span>在由<i><span>N</span></i><span> </span>
		子链组成的字符串列表<i><span>strlist</span></i><span> </span>
		中， 则返回值的范围在<span> 1 </span>到 <i><span>N</span></i><span>
		</span>之间 。一个字符串列表就是一个由一些被‘<span>,</span>’符号分开的自链组成的字符串。如果第一个参数是一个常数字符串，而第二个是<span>type 
		SET</span>列，则<span>&nbsp;&nbsp; FIND_IN_SET() </span>函数被优化，使用比特计算。如果<i><span>str</span></i>不在<i><span>strlist</span></i><span>
		</span>或<i><span>strlist</span></i><span> </span>
		为空字符串，则返回值为<span> 0 </span>。如任意一个参数为<span>NULL</span>，则返回值为<span> 
		NULL</span>。 这个函数在第一个参数包含一个逗号<span>(</span>‘<span>,</span>’<span>)</span>时将无法正常运行。<span>&nbsp;
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT FIND_IN_SET(&#39;b&#39;,&#39;a,b,c,d&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
		<ul type="disc">
			<li>
			<span >FORMAT(<i>X</i>,<i>D</i>)
			</span></li>
		</ul>
		<p>
		<span>将<span>number
		<i>X</i></span>设置为格式<span> &#39;#,###,###.##&#39;, </span>
		以四舍五入的方式保留到小数点后<i><span>D</span></i>位<span>, </span>
		而返回结果为一个字符串。详见</span><a href="functions.html#miscellaneous-functions" title="12.9.4. Miscellaneous Functions">12.9.4节，“其他函数”</a><span >.
		</span></p>
		<ul type="disc">
			<li>
			<span >HEX(<i>N_or_S</i>)
			</span></li>
		</ul>
		<p>
		<span>如果<i><span>N_OR_S</span></i><span>
		</span>是一个数字，则返回一个 十六进制值 <i><span>N </span>的</i>字符串表示，在这里，<span>&nbsp;&nbsp;
		<i>N</i> </span>是一个<span>longlong (BIGINT)</span>数。这相当于<span> 
		CONV(N,10,16)</span>。</span></p>
		<p>
		<span>如果<i><span>N_OR_S</span></i><span>
		</span>是一个字符串，则返回值为一个<i><span>N_OR_S</span></i>的十六进制字符串表示， 
		其中每个<i><span>N_OR_S</span></i><span> </span>
		里的每个字符被转化为两个十六进制数字。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT HEX(255);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;FF&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT 0x616263;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;abc&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT HEX(&#39;abc&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 616263</span></p>
		<ul type="disc">
			<li>
			<span >INSERT(<i>str</i>,<i>pos</i>,<i>len</i>,<i>newstr</i>)
			</span></li>
		</ul>
		<p>
		<span>返回字符串 <i>
		<span>str</span></i><span>, </span>其子字符串起始于 <i>
		<span>pos</span></i><span> </span>位置和长期被字符串 <i>
		<span>newstr</span></i>取代的<i><span>len</span></i><span>
		</span>字符。<span>&nbsp; </span>如果<i><span>pos</span></i><span>
		</span>超过字符串长度，则返回值为原始字符串。</span><span> 
		假如<i><span>len</span></i>的长度大于其它字符串的长度，则从位置<i><span>pos</span></i>开始替换。若任何一个参数<span>为<span>null</span>，则返回值为<span>NULL</span>。 
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT INSERT(&#39;Quadratic&#39;, 3, 4, &#39;What&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;QuWhattic&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT INSERT(&#39;Quadratic&#39;, -1, 4, &#39;What&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;Quadratic&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT INSERT(&#39;Quadratic&#39;, 3, 100, &#39;What&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;QuWhat&#39;</span></p>
		<p>
		<span>这个函数支持多字节字元</span><span>。</span></p>
		<ul type="disc">
			<li>
			<span >INSTR(<i>str</i>,<i>substr</i>)
			</span></li>
		</ul>
		<p>
		<span>返回字符串 <i>
		<span>str</span></i><span> </span>中子字符串的第一个出现位置。这和<span>LOCATE()</span>的双参数形式相同，除非参数的顺序被颠倒。<span>&nbsp;
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT INSTR(&#39;foobarbar&#39;, &#39;bar&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 4</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT INSTR(&#39;xbar&#39;, &#39;foobar&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
		<p>
		<span>这个函数支持多字节字元，</span><span>并且只有当至少有一个参数是二进制字符串时区分大小写。 
		</span></p>
		<ul type="disc">
			<li>
			<span >LCASE(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span >
		LCASE() </span>
		<span>是<span> 
		LOWER()</span>的同义词。 </span></p>
		<ul type="disc">
			<li>
			<span >LEFT(<i>str</i>,<i>len</i>)
			</span></li>
		</ul>
		<p>
		<span>返回从字符串<i><span>str</span></i><span>
		</span>开始的<i><span>len</span></i><span> </span>最左字符。 
		</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LEFT(&#39;foobarbar&#39;, 5);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;fooba&#39;</span></p>
		<ul type="disc">
			<li>
			<span >LENGTH(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span>返回值为字符串<i><span>str</span></i><span>
		</span>的长度，单位为字节。一个多字节字符算作多字节。这意味着 对于一个包含<span>5</span>个<span>2</span>字节字符的字符串，<span> 
		LENGTH() </span>的返回值为 <span>10, </span>而<span> 
		CHAR_LENGTH()</span>的返回值则为<span>5</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LENGTH(&#39;text&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 4</span></p>
		<ul type="disc">
			<li>
			<span >
			LOAD_FILE(<i>file_name</i>) </span></li>
		</ul>
		<p>
		<span>
		读取文件并将这一文件按照字符串的格式返回。 文件的位置必须在服务器上<span>,</span>你必须为文件制定路径全名，而且你还必须拥有<span>FILE
		</span>特许权。文件必须可读取，文件容量必须小于<span> max_allowed_packet</span>字节。 
		</span></p>
		<p>
		<span>
		若文件不存在，或因不满足上述条件而不能被读取， 则函数返回值为<span> NULL</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>UPDATE <i>tbl_name</i></b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET <i>blob_column</i>=LOAD_FILE(&#39;/tmp/picture&#39;)</span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE id=1;</span></p>
		<ul type="disc">
			<li>
			<span >LOCATE(<i>substr</i>,<i>str</i>) 
			, LOCATE(<i>substr</i>,<i>str</i>,<i>pos</i>) </span></li>
		</ul>
		<p>
		<span>
		第一个语法返回字符串 <i><span>str</span></i>中子字符串<i><span>substr</span></i>的第一个出现位置。第二个语法返回字符串 
		<i><span>str</span></i>中子字符串<i><span>substr</span></i>的第一个出现位置<span>,
		</span>起始位置在<i><span>pos</span></i>。如若<i><span>substr</span></i><span>
		</span>不在<i><span>str</span></i>中，则返回值为<span>0</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 4</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LOCATE(&#39;xbar&#39;, &#39;foobar&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;,5);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 7</span></p>
		<p>
		<span>
		这个函数支持多字节字元，并且只有当至少有一个参数是二进制字符串时区分大小写。<span>&nbsp; </span></span>
		</p>
		<ul type="disc">
			<li>
			<span >LOWER(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span>返回字符串 <i>
		<span>str</span></i><span> </span>
		以及所有根据最新的字符集映射表变为小写字母的字符<span> (</span>默认为<span>&nbsp; 
		cp1252 Latin1)</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LOWER(&#39;QUADRATICALLY&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;quadratically&#39;</span></p>
		<p>
		<span>
		这个函数支持多字节字元。</span></p>
		<ul type="disc">
			<li>
			<span >LPAD(<i>str</i>,<i>len</i>,<i>padstr</i>)
			</span></li>
		</ul>
		<p>
		<span>返回字符串 <i>
		<span>str</span></i><span>, </span>其左边由字符串<i><span>padstr</span></i><span>
		</span>填补到<i><span>len</span></i><span> </span>
		字符长度。假如<i><span>str</span></i><span> </span>的长度大于<i><span>len</span></i><span>,
		</span>则返回值被缩短至 <i><span>len</span></i><span> </span>
		字符。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LPAD(&#39;hi&#39;,4,&#39;??&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;??hi&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LPAD(&#39;hi&#39;,1,&#39;??&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;h&#39;</span></p>
		<ul type="disc">
			<li>
			<span >LTRIM(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span>返回字符串 <i>
		<span>str</span></i><span> </span>，其引导空格字符被删除。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LTRIM(&#39;&nbsp; barbar&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;barbar&#39;</span></p>
		<p>
		<span>
		这个函数支持多字节字元。 </span></p>
		<ul type="disc">
			<li>
			<span >MAKE_SET(<i>bits</i>,<i>str1</i>,<i>str2</i>,...)
			</span></li>
		</ul>
		<p>
		<span>返回一个设定值<span> 
		(</span>一个包含被‘<span>,</span>’号分开的字字符串的字符串<span>)
		</span>，由在<i><span>bits</span></i><span> </span>
		组中具有相应的比特的字符串组成。<i><span>str1</span></i><span>
		</span>对应比特<span> 0, <i>str2</i> </span>对应比特<span>1,</span>以此类推。<i><span>str1</span></i><span>,
		<i>str2</i>, ...</span>中的<span> NULL</span>值不会被添加到结果中。 </span>
		</p>
		<p>
		<span >
		mysql&gt; <b>SELECT MAKE_SET(1,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;a&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT MAKE_SET(1 | 4,&#39;hello&#39;,&#39;nice&#39;,&#39;world&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;hello,world&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT MAKE_SET(1 | 4,&#39;hello&#39;,&#39;nice&#39;,NULL,&#39;world&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;hello&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT MAKE_SET(0,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;&#39;</span></p>
		<ul type="disc">
			<li>
			<span >MID(<i>str</i>,<i>pos</i>,<i>len</i>)
			</span></li>
		</ul>
		<p>
		<span >
		MID(<i>str</i>,<i>pos</i>,<i>len</i>) </span>
		<span>是<span> 
		SUBSTRING(<i>str</i>,<i>pos</i>,<i>len</i>)</span>的同义词。</span></p>
		<ul type="disc">
			<li>
			<span >OCT(<i>N</i>)
			</span></li>
		</ul>
		<p>
		<span>返回一个 <i>
		<span>N</span></i>的八进制值的字符串表示，其中 <i><span>N</span></i><span>
		</span>是一个<span>longlong (BIGINT)</span>数。这等同于<span>CONV(N,10,8)</span>。若<i><span>N</span></i><span>
		</span>为<span> NULL </span>，则返回值为<span>NULL</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT OCT(12);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;14&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			OCTET_LENGTH(<i>str</i>) </span></li>
		</ul>
		<p>
		<span >
		OCTET_LENGTH() </span>
		<span>是<span> 
		LENGTH()</span>的同义词。</span></p>
		<ul type="disc">
			<li>
			<span >ORD(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span>若字符串<i><span>str</span></i><span>
		</span>的最左字符是一个多字节字符，则返回该字符的代码， 代码的计算通过使用以下公式计算其组成字节的数值而得出<span>:
		</span></span></p>
		<pre><span>&nbsp;&nbsp; (1st byte code)</span></pre>
		<pre><span>+ (2nd byte code </span>×<span> 256)</span></pre>
		<pre><span>+ (3rd byte code </span>×<span> 256<sup>2</sup>) ...</span></pre>
		<p>
		<span >
		&nbsp;</span></p>
		<p>
		<span>
		假如最左字符不是一个多字节字符，那么<span> ORD()</span>和函数<span>ASCII()</span>返回相同的值。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT ORD(&#39;2&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 50</span></p>
		<ul type="disc">
			<li>
			<span >POSITION(<i>substr</i> 
			IN <i>str</i>) </span></li>
		</ul>
		<p>
		<span >
		POSITION(<i>substr</i> IN <i>str</i>)</span><span>是<span> 
		LOCATE(<i>substr</i>,<i>str</i>)</span>同义词。 </span></p>
		<ul type="disc">
			<li>
			<span >QUOTE(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span>
		引证一个字符串，由此产生一个在<span>SQL</span>语句中可用作完全转义数据值的结果。<span>&nbsp;
		</span>返回的字符串由单引号标注，每例都带有单引号<span> (</span>‘<span>&#39;</span>’<span>)</span>、 
		反斜线符号<span> (</span>‘<span>\</span>’<span>)</span>、<span> 
		ASCII NUL</span>以及前面有反斜线符号的<span>Control-Z </span>。如果自变量的值为<span>NULL,
		</span>则返回不带单引号的单词 “<span>NULL</span>”。</span></p>
		<p>
		<span>
		mysql&gt; <b>SELECT QUOTE(&#39;Don\&#39;t!&#39;);</b></span></p>
		<p>
		<span>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
		<span >
		-&gt; &#39;Don\&#39;t!&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT QUOTE(NULL);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
		<ul type="disc">
			<li>
			<span >REPEAT(<i>str</i>,<i>count</i>)
			</span></li>
		</ul>
		<p>
		<span>
		返回一个由重复的字符串<i><span>str</span></i><span> </span>
		组成的字符串，字符串<i><span>str</span></i>的数目等于<i><span>count</span></i><span>
		</span>。 若 <i><span>count</span></i><span> &lt;= 0,</span>则返回一个空字符串。若<i><span>str</span></i><span>
		</span>或 <i><span>count</span></i><span> </span>为<span> 
		NULL</span>，则返回<span> NULL </span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT REPEAT(&#39;MySQL&#39;, 3);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;MySQLMySQLMySQL&#39;</span></p>
		<ul type="disc">
			<li>
			<span >REPLACE(<i>str</i>,<i>from_str</i>,<i>to_str</i>)
			</span></li>
		</ul>
		<p>
		<span>返回字符串<i><span>str</span></i><span>
		</span>以及所有被字符串<i><span>to_str</span></i>替代的字符串<i><span>from_str</span></i><span>
		</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT REPLACE(&#39;www.mysql.com&#39;, &#39;w&#39;, &#39;Ww&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;WwWwWw.mysql.com&#39;</span></p>
		<p>
		<span>
		这个函数支持多字节字元。 </span></p>
		<ul type="disc">
			<li>
			<span >REVERSE(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span>返回字符串 <i>
		<span>str</span></i><span> </span>，顺序和字符顺序相反。 </span>
		</p>
		<p>
		<span >
		mysql&gt; <b>SELECT REVERSE(&#39;abc&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;-&gt; &#39;cba&#39;</span></p>
		<p>
		<span>
		这个函数支持多字节字元。 </span></p>
		<ul type="disc">
			<li>
			<span >RIGHT(<i>str</i>,<i>len</i>)
			</span></li>
		</ul>
		<p>
		<span>从字符串<i><span>str</span></i><span>
		</span>开始，返回最右<i><span>len</span></i><span> </span>
		字符。 </span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT RIGHT(&#39;foobarbar&#39;, 4);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;rbar&#39;</span></p>
		<p>
		<span>
		这个函数支持多字节字元。 </span></p>
		<ul type="disc">
			<li>
			<span >RPAD(<i>str</i>,<i>len</i>,<i>padstr</i>)
			</span></li>
		</ul>
		<p>
		<span>返回字符串<i><span>str</span></i><span>,
		</span>其右边被字符串 <i><span>padstr</span></i>填补至<i><span>len</span></i><span>
		</span>字符长度。假如字符串<i><span>str</span></i><span>
		</span>的长度大于 <i><span>len</span></i><span>,</span>则返回值被缩短到与 
		<i><span>len</span></i><span> </span>字符相同长度。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT RPAD(&#39;hi&#39;,5,&#39;?&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;hi???&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT RPAD(&#39;hi&#39;,1,&#39;?&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;h&#39;</span></p>
		<p>
		<span>
		这个函数支持多字节字元。 </span></p>
		<ul type="disc">
			<li>
			<span >RTRIM(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span>返回字符串 <i>
		<span>str</span></i><span> </span>，结尾空格字符被删去。 </span>
		</p>
		<p>
		<span >
		mysql&gt; <b>SELECT RTRIM(&#39;barbar&nbsp;&nbsp; &#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;barbar&#39;</span></p>
		<p>
		<span>
		这个函数支持多字节字元。 </span></p>
		<ul type="disc">
			<li>
			<span >SOUNDEX(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span>从<i><span>str</span></i>返回一个<span>soundex</span>字符串。 
		两个具有几乎同样探测的字符串应该具有同样的<span> soundex </span>字符串。一个标准的<span>soundex
		</span>字符串的长度为<span>4</span>个字符，然而<span>SOUNDEX()
		</span>函数会返回一个人以长度的字符串。 可使用结果中的<span>SUBSTRING() </span>
		来得到一个标准<span> soundex </span>字符串。在<i><span>str</span></i>中<i>，</i>会忽略所有未按照字母顺序排列的字符。 
		所有不在<span>A-Z</span>范围之内的国际字母符号被视为元音字母。 </span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SOUNDEX(&#39;Hello&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;H400&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SOUNDEX(&#39;Quadratically&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;-&gt; &#39;Q36324&#39;</span></p>
		<p>
		<b><span>注意：</span></b><span>这个函数执行原始的<span>Soundex</span>算法，而非更加流行的加强版本<span>(</span>如<span>D. 
		Knuth</span>所述<span>)</span>。其区别在于原始版本首先会删去元音，其次是重复，而加强版则首先删去重复，而后删去元音。 
		</span></p>
		<ul type="disc">
			<li><i>
			<span >expr1</span></i><span > 
			SOUNDS LIKE <i>expr2</i> </span></li>
		</ul>
		<p>
		<span>这相当于<span>SOUNDEX(<i>expr1</i>) 
		= SOUNDEX(<i>expr2</i>)</span>。</span></p>
		<ul type="disc">
			<li>
			<span >SPACE(<i>N</i>)
			</span></li>
		</ul>
		<p>
		<span>返回一个由<i><span>N</span></i><span>
		</span>间隔符号组成的字符串。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SPACE(6);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			SUBSTRING(<i>str</i>,<i>pos</i>) , SUBSTRING(<i>str</i> FROM <i>pos</i>) 
			SUBSTRING(<i>str</i>,<i>pos</i>,<i>len</i>) , SUBSTRING(<i>str</i> 
			FROM <i>pos</i> FOR <i>len</i>) </span></li>
		</ul>
		<p>
		<span>不带有<i><span>len</span></i><span>
		</span>参数的格式从字符串<i><span>str</span></i>返回一个子字符串，起始于位置 <i>
		<span>pos</span></i>。带有<i><span>len</span></i>参数的格式从字符串<i><span>str</span></i>返回一个长度同<i><span>len</span></i>字符相同的子字符串，起始于位置 
		<i><span>pos</span></i>。 使用<span> FROM</span>的格式为标准<span> 
		SQL </span>语法。也可能对<i><span>pos</span></i>使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的<i><span>pos</span></i><span>
		</span>字符，而不是字符串的开头位置。在以下格式的函数中可以对<i><span>pos</span></i><span>
		</span>使用一个负值。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SUBSTRING(&#39;Quadratically&#39;,5);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;ratically&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SUBSTRING(&#39;foobarbar&#39; FROM 4);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;barbar&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SUBSTRING(&#39;Quadratically&#39;,5,6);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;ratica&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SUBSTRING(&#39;Sakila&#39;, -3);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;ila&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SUBSTRING(&#39;Sakila&#39;, -5, 3);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;aki&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SUBSTRING(&#39;Sakila&#39; FROM -4 FOR 2);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;ki&#39;</span></p>
		<p>
		<span>
		这个函数支持多字节字元。</span></p>
		<p>
		<span>注意，如果对<i><span>len</span></i>使用的是一个小于<span>1</span>的值，则结果始终为空字符串。</span></p>
		<p>
		<span >
		SUBSTR()</span><span>是<span> 
		SUBSTRING()</span>的同义词。</span></p>
		<ul type="disc">
			<li>
			<span >
			SUBSTRING_INDEX(<i>str</i>,<i>delim</i>,<i>count</i>) </span></li>
		</ul>
		<p>
		<span>在定界符 <i>
		<span>delim</span></i><span> </span>以及<i><span>count</span></i><span>
		</span>出现前，从字符串<i><span>str</span></i>返回自字符串。若<i><span>count</span></i>为正值<span>,</span>则返回最终定界符<span>(</span>从左边开始<span>)</span>左边的一切内容。若<i><span>count</span></i>为负值，则返回定界符（从右边开始）右边的一切内容。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SUBSTRING_INDEX(&#39;www.mysql.com&#39;, &#39;.&#39;, 2);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;www.mysql&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SUBSTRING_INDEX(&#39;www.mysql.com&#39;, &#39;.&#39;, -2);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;mysql.com&#39;</span></p>
		<p>
		<span>
		这个函数支持多字节字元。 </span></p>
		<ul type="disc">
			<li>
			<span >
			TRIM([{BOTH | LEADING | TRAILING} [<i>remstr</i>] FROM] <i>str</i>) 
			TRIM(<i>remstr</i> FROM] <i>str</i>) </span></li>
		</ul>
		<p>
		<span>返回字符串 <i>
		<span>str</span></i><span> </span>， 其中所有<i><span>remstr</span></i><span>
		</span>前缀和<span>/</span>或后缀都已被删除。若分类符<span>BOTH</span>、<span>LEADIN</span>或<span>TRAILING</span>中没有一个是给定的<span>,</span>则假设为<span>BOTH
		</span>。 <i><span>remstr</span></i><span> </span>
		为可选项，在未指定情况下，可删除空格。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT TRIM(&#39;&nbsp; bar&nbsp;&nbsp; &#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;bar&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT TRIM(LEADING &#39;x&#39; FROM &#39;xxxbarxxx&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;barxxx&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT TRIM(BOTH &#39;x&#39; FROM &#39;xxxbarxxx&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;bar&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT TRIM(TRAILING &#39;xyz&#39; FROM &#39;barxxyz&#39;);</b></span></p>
		<p>
		<span >
		&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; &#39;barx&#39;</span></p>
		<p>
		<span>
		这个函数支持多字节字元。 </span></p>
		<ul type="disc">
			<li>
			<span >UCASE(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span >
		UCASE()</span><span>是<span>UPPER()</span>的同义词。</span></p>
		<ul type="disc">
			<li>
			<span >
			UNCOMPRESS(<i>string_to_uncompress</i>) </span></li>
		</ul>
		<p>
		<span>对经<span>COMPRESS()</span>函数压缩后的字符串进行解压缩。若参数为压缩值，则结果为<span> 
		NULL</span>。这个函数要求<span>&nbsp; MySQL </span>已被诸如<span>zlib
		</span>之类的压缩库编译过。否则<span>, </span>返回值将始终是<span> NULL</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT UNCOMPRESS(COMPRESS(&#39;any string&#39;));</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;any string&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT UNCOMPRESS(&#39;any string&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
		<ul type="disc">
			<li>
			<span >
			UNCOMPRESSED_LENGTH(<i>compressed_string</i>) </span></li>
		</ul>
		<p>
		<span>
		返回压缩字符串压缩前的长度。 </span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT UNCOMPRESSED_LENGTH(COMPRESS(REPEAT(&#39;a&#39;,30)));</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 30</span></p>
		<ul type="disc">
			<li>
			<span >UNHEX(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span>执行从<span>HEX(<i>str</i>)</span>的反向操作。就是说，它将参数中的每一对十六进制数字理解为一个数字，并将其转化为该数字代表的字符。结果字符以二进制字符串的形式返回。 
		</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT UNHEX(&#39;4D7953514C&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;MySQL&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT 0x4D7953514C;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;MySQL&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT UNHEX(HEX(&#39;string&#39;));</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;string&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT HEX(UNHEX(&#39;1267&#39;));</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1267&#39;</span></p>
		<ul type="disc">
			<li>
			<span >UPPER(<i>str</i>)
			</span></li>
		</ul>
		<p>
		<span>返回字符串<i><span>str</span>，</i> 
		以及根据最新字符集映射转化为大写字母的字符<span> (</span>默认为<span>cp1252 
		Latin1). </span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT UPPER(&#39;Hej&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;HEJ&#39;</span></p>
		<p>
		<span>
		该函数支持多字节字元。</span></p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="string-comparison-functions"></a>
			12.3.1.&nbsp;字符串比较函数</h3></div></div></div><a class="indexterm" name="id2865106"></a><a class="indexterm" name="id2865115"></a>
			<p>
			<span>根据，<span>MySQL
			</span>会自动将数字转化为字符串，反之亦然。<span>&nbsp; </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 1+&#39;1&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT CONCAT(2,&#39; test&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;2 test&#39;</span></p>
			<p>
			<span>
			若想要将数字明确地转化为字符串，可使用<span> CAST()</span>或<span> 
			CONCAT()</span>函数：</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 38.8, CAST(38.8 AS CHAR);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 38.8, &#39;38.8&#39;</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 38.8, CONCAT(38.8);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 38.8, &#39;38.8&#39;</span></p>
			<p>
			<span >
			CAST() </span>
			<span>比较可取。<span>.
			</span></span></p>
			<p>
			<span>
			若已经对一个字符串函数给定一个二进制字符串作为参数， 
			则所得到的结果字符串也是一个二进制字符串。一个转化为字符串的数字被作为二进制字符串对待。这仅会对比较结果产生影响。 </span>
			</p>
			<p>
			<span>一般而言<span>,
			</span>若字符串比较中任意一个表达式是区分大小写的，则执行比较时也区分大小写。<span>&nbsp; </span>
			</span></p>
			<ul type="disc">
				<li><i>
				<span >expr</span></i><span > 
				LIKE <i>pat</i> [ESCAPE &#39;<i>escape-char</i>&#39;] </span></li>
			</ul>
			<p>
			<span>
			模式匹配，使用<span>SQL</span>简单正规表达式比较。返回<span>1 
			(TRUE) </span>或<span> 0 (FALSE)</span>。 若 <i>
			<span>expr</span></i><span> </span>或 <i>
			<span>pat</span></i><span> </span>中任何一个为<span> 
			NULL,</span>则结果为<span> NULL</span>。 </span></p>
			<p>
			<span>
			模式不需要为文字字符串。例如，可以被指定为一个字符串表达式或表列。 </span></p>
			<p>
			<span>
			在模式中可以同<span>LIKE</span>一起使用以下两种通配符： </span></p>
			<table border="1" cellpadding="0" id="table2">
				<tr>
					<td>
					<p>
					<b>
					<span>
					字符</span></b></td>
					<td>
					<p>
					<b>
					<span>
					说明</span></b></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>
					%</span></td>
					<td>
					<p>
					<span>
					匹配任何数目的字符，甚至包括零字符<span>&nbsp; </span></span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>
					_</span></td>
					<td>
					<p>
					<span>
					只能匹配一种字符 </span></td>
				</tr>
			</table>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;David!&#39; LIKE &#39;David_&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;David!&#39; LIKE &#39;%D%v%&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span>
			若要对通配符的文字实例进行检验<span>, </span>可将转义字符放在该字符前面。如果没有指定<span> 
			ESCAPE</span>字符<span>, </span>则假设为‘<span>\</span>’。</span></p>
			<table border="1" cellpadding="0" id="table3">
				<tr>
					<td>
					<p>
					<b>
					<span>
					字符串</span></b></td>
					<td width="103">
					<p>
					<b>
					<span>
					说明</span></b></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>
					\%</span></td>
					<td colspan="2">
					<p>
					<span>
					匹配一个<span>&nbsp; </span>‘<span>%</span>’字符</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>
					\_</span></td>
					<td colspan="2">
					<p>
					<span>
					匹配一个 ‘<span>_</span>’ 字符</span></td>
				</tr>
			</table>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;David!&#39; LIKE &#39;David\_&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;David_&#39; LIKE &#39;David\_&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span>
			要指定一个不同的转义字符<span>,</span>可使用<span>ESCAPE</span>语句：</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;David_&#39; LIKE &#39;David|_&#39; ESCAPE &#39;|&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span>
			转义序列可以为空，也可以是一个字符的长度。 从<span> MySQL 5.1.2</span>开始<span>,
			</span>如若 <span>NO_BACKSLASH_ESCAPES SQL</span>模式被激活<span>,
			</span>则该序列不能为空。</span></p>
			<p>
			<span>
			以下两个语句举例说明了字符串比较不区分大小写，除非其中一个操作数为二进制字符串： </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;abc&#39; LIKE &#39;ABC&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;abc&#39; LIKE BINARY &#39;ABC&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
			<p>
			<span>在<span>MySQL</span>中<span>, 
			LIKE </span>允许出现在数字表达式中。<span> (</span>这是标准<span>SQL 
			LIKE </span>的延伸）<span>。 </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 10 LIKE &#39;1%&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<b><span>注释</span></b><span >：
			</span>
			<span>由于<span> 
			MySQL</span>在字符串中使用<span> C</span>转义语法<span>(</span>例如<span>,
			</span>用‘<span>\n</span>’代表一个换行字符<span>)</span>，在<span>LIKE</span>字符串中，必须将用到的‘<span>\</span>’双写。例如， 
			若要查找 ‘<span>\n</span>’<span>, </span>必须将其写成 ‘<span>\\n</span>’。而若要查找 
			‘<span>\</span>’<span>, </span>则必须将其写成<span> 
			it as </span>‘<span>\\\\</span>’<span>;</span>原因是反斜线符号会被语法分析程序剥离一次，在进行模式匹配时，又会被剥离一次，最后会剩下一个反斜线符号接受匹配。 
			</span></p>
			<ul type="disc">
				<li><i>
				<span >expr</span></i><span > 
				NOT LIKE <i>pat</i> [ESCAPE &#39;<i>escape-char</i>&#39;] </span></li>
			</ul>
			<p>
			<span>这相当于<span> 
			NOT (<i>expr</i> LIKE <i>pat</i> [ESCAPE &#39;<i>escape-char</i>&#39;])</span>。</span></p>
			<ul type="disc">
				<li><i>
				<span >expr</span></i><span > 
				NOT REGEXP <i>pat</i> <i>expr</i> NOT RLIKE <i>pat</i> </span>
				</li>
			</ul>
			<p>
			<span>这相当于<span>NOT 
			(<i>expr</i> REGEXP <i>pat</i>)</span>。</span></p>
			<ul type="disc">
				<li><i>
				<span >expr</span></i><span > 
				REGEXP <i>pat</i> <i>expr</i> RLIKE <i>pat</i> </span></li>
			</ul>
			<p>
			<span>
			执行字符串表达式 <i><span>expr</span></i><span> </span>
			和模式<i><span>pat</span></i><span> </span>
			的模式匹配。该模式可以被延伸为正规表达式。正规表达式的语法在</span><a href="regexp.html">附录G：</a><a href="regexp.html" title="Appendix G. MySQL Regular Expressions"><i>MySQL正则表达式</i></a><span>中有详细讨论。若<i><span>expr</span></i><span>
			</span>匹配 <i><span>pat</span>，</i>则返回<span> 1;
			</span>否则返回<span>0</span>。若 <i><span>expr</span></i><span>
			</span>或 <i><span>pat</span></i><span> </span>
			任意一个为<span> NULL, </span>则结果为<span> NULL</span>。<span> 
			RLIKE </span>是<span>REGEXP</span>的同义词<span>,
			</span>作用是为<span>mSQL </span>提供兼容性。 </span></p>
			<p>
			<span>
			模式不需要为文字字符串。例如<span>,</span>可以被指定为一个字符串表达式或表列。 </span></p>
			<p>
			<b><span>注释</span></b><span >：</span><span>由于在字符串中，<span> 
			MySQL</span>使用<span> C </span>转义语法<span> (</span>例如<span>,
			</span>用‘<span>\n</span>’来代表换行字符<span> ),</span>在<span>REGEXP</span>字符串中必须将用到的‘<span>\</span>’ 
			双写。</span></p>
			<p>
			<span >
			REGEXP </span>
			<span>
			不区分大小写<span>, </span>除非将其同二进制字符串同时使用。 </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;Monty!&#39; REGEXP &#39;m%y%%&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;Monty!&#39; REGEXP &#39;.*&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;new*\n*line&#39; REGEXP &#39;new\\*.\\*line&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;a&#39; REGEXP &#39;A&#39;, &#39;a&#39; REGEXP BINARY &#39;A&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1&nbsp; 0</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT &#39;a&#39; REGEXP &#39;^[a-d]&#39;;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span>
			在确定字符类型时，<span>REGEXP </span>和<span> RLIKE
			</span>使用当前字符集<span> (</span>默认为<span>cp1252 
			Latin1 )</span>。 <b>警告：</b>这些操作符不支持多字节字元。</span></p>
			<ul type="disc">
				<li>
				<span >
				STRCMP(<i>expr1</i>,<i>expr2</i>) </span></li>
			</ul>
			<p>
			<span>
			若所有的字符串均相同，则返回<span>STRCMP()</span>，若根据当前分类次序，第一个参数小于第二个，则返回<span>&nbsp; 
			-1</span>，其它情况返回<span> 1 </span>。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT STRCMP(&#39;text&#39;, &#39;text2&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT STRCMP(&#39;text2&#39;, &#39;text&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT STRCMP(&#39;text&#39;, &#39;text&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
			<p>
			<span>
			在执行比较时，<span>STRCMP() </span>
			使用当前字符集。这使得默认的比较区分大小写，当操作数中的一个或两个都是二进制字符串时除外。 </span></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="numeric-functions"></a>
		12.4.&nbsp;数值函数</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="functions.html#arithmetic-functions">
			12.4.1. 算术操作符</a></span></dt><dt><span class="section"><a href="functions.html#mathematical-functions">
			12.4.2. 数学函数</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="arithmetic-functions"></a>
			12.4.1.&nbsp;算术操作符</h3></div></div></div><a class="indexterm" name="id2866125"></a>
			<p>
			<span>
			可使用常见的算术操作符。注意就<span> -</span>、<span> +</span>和<span> 
			*</span>而言<span>, </span>若两个参数均为正数，则其计算结果的精确度为<span> 
			BIGINT (64</span>比特<span>)</span>，若其中一个参数为无符号整数， 而其它参数也是整数<span>,
			</span>则结果为无符号整数。请参见</span><a href="functions.html#cast-functions" title="12.8. Cast Functions and Operators">12.8节，“Cast函数和操作符”</a><span >。 
			</span></p>
			<ul type="disc">
				<li>
				<span >+
				</span></li>
			</ul>
			<p>
			<span>加号<span>:
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 3+5;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 8</span></p>
			<ul type="disc">
				<li>
				<span >-
				</span></li>
			</ul>
			<p>
			<span>减号<span>:
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 3-5;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -2</span></p>
			<ul type="disc">
				<li>
				<span >-
				</span></li>
			</ul>
			<p>
			<span>
			一元减号。更换参数符号。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT - 2;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -2</span></p>
			<p>
			<b><span>注意</span></b><span>：若该
			操作符同一个<span>BIGINT</span>同时使用，则返回值也是一个<span>BIGINT</span>。这意味着你应当尽量避免对可能产生–<span>2<sup>63</sup></span>的整数使用 
			–。</span></p>
			<ul type="disc">
				<li>
				<span >*
				</span></li>
			</ul>
			<p>
			<span>乘号<span>:
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 3*5;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 15</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 18014398509481984*18014398509481984.0;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 324518553658426726783156020576256.0</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 18014398509481984*18014398509481984;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
			<p>
			<span>
			最后一个表达式的结果是不正确的。原因是整数相乘的结果超过了<span>BIGINT </span>计算的<span> 
			64</span>比特范围。<span> (</span>见</span><a href="column-types.html#numeric-types" title="11.2. Numeric Types">11.2节，“数值类型”</a><span >.)
			</span></p>
			<ul type="disc">
				<li>
				<span >/
				</span></li>
			</ul>
			<p>
			<span>除号<span>:
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 3/5;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.60</span></p>
			<p>
			<span>
			被零除的结果为<span> NULL</span>：</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 102/(1-1);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
			<p>
			<span>
			只有当执行的语境中，其结果要被转化为一个整数时 ，除法才会和<span> BIGINT </span>算法一起使用。</span></p>
			<ul type="disc">
				<li>
				<span >DIV
				</span></li>
			</ul>
			<p>
			<span>整数除法。 
			类似于<span> FLOOR()</span>，然而使用<span>BIGINT </span>
			算法也是可靠的。 </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 5 DIV 2;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mathematical-functions"></a>
			12.4.2.&nbsp;数学函数</h3></div></div></div>
			<p>
			<span>
			若发生错误，所有数学函数会返回<span> NULL </span>。</span></p>
			<ul type="disc">
				<li>
				<span >ABS(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i><span>
			</span>的绝对值。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ABS(2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ABS(-32);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 32</span></p>
			<p>
			<span>
			该函数支持使用<span>BIGINT</span>值。</span></p>
			<ul type="disc">
				<li>
				<span >ACOS(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i><span>
			</span>反余弦<span>, </span>即<span>, </span>余弦是<i><span>X</span></i>的值。若<i><span>X</span></i><span>
			</span>不在<span>-1</span>到<span> 1</span>的范围之内，则返回 
			<span>NULL </span>。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ACOS(1);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ACOS(1.0001);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ACOS(0);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1.5707963267949</span></p>
			<ul type="disc">
				<li>
				<span >ASIN(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i><span>
			</span>的反正弦，即，正弦为<i><span>X</span></i><span>
			</span>的值。若<i><span>X</span></i><span>&nbsp; </span>若<i><span>X</span></i><span>
			</span>不在<span>-1</span>到<span> 1</span>的范围之内，则返回<span> 
			NULL </span>。</span></p>
			<p>
			<span >
			&nbsp;</span></p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT ASIN(0.2);</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.20135792079033</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT ASIN(&#39;foo&#39;);</span></b></span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>+-------------+</span></pre>
			<pre><span>| ASIN(&#39;foo&#39;) |</span></pre>
			<pre><span>+-------------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
			<pre><span>+-------------+</span></pre>
			<pre><span>1 row in set, 1 warning (0.00 sec)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SHOW WARNINGS;</span></b></span></pre>
			<pre><span>+---------+------+-----------------------------------------+</span></pre>
			<pre><span>| Level&nbsp;&nbsp; | Code | Message&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
			<pre><span>+---------+------+-----------------------------------------+</span></pre>
			<pre><span>| Warning | 1292 | Truncated incorrect DOUBLE value: &#39;foo&#39; |</span></pre>
			<pre><span>+---------+------+-----------------------------------------+</span></pre>
			<ul type="disc">
				<li>
				<span >ATAN(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i><span>
			</span>的反正切，即，正切为<i><span>X</span></i><span>
			</span>的值。 </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ATAN(2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1.1071487177941</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ATAN(-2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1.1071487177941</span></p>
			<ul type="disc">
				<li>
				<span>ATAN(<i>Y</i>,<i>X</i>) 
				, ATAN2(<i>Y</i>,<i>X</i>) </span></li>
			</ul>
			<p>
			<span>
			返回两个变量<i><span>X</span></i><span> </span>及<i><span>Y</span></i>的反正切。 
			它类似于 <i><span>Y</span></i><span> </span>或 <i>
			<span>X</span></i>的反正切计算<span>,&nbsp; </span>
			除非两个参数的符号均用于确定结果所在象限。 </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ATAN(-2,2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -0.78539816339745</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ATAN2(PI(),0);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;-&gt; 1.5707963267949</span></p>
			<ul type="disc">
				<li>
				<span >
				CEILING(<i>X</i>) CEIL(<i>X</i>) </span></li>
			</ul>
			<p>
			<span>返回不小于<i><span>X</span></i><span>
			</span>的最小整数值。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT CEILING(1.23);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT CEIL(-1.23);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1</span></p>
			<p>
			<span>
			这两个函数的意义相同。注意返回值会被转化为一个<span>BIGINT</span>。</span></p>
			<ul type="disc">
				<li>
				<span >COS(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i><span>
			</span>的余弦，其中<i><span>X</span></i>在弧度上已知。<span>&nbsp;
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT COS(PI());</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1</span></p>
			<ul type="disc">
				<li>
				<span >COT(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i><span>
			</span>的余切。 </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT COT(12);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1.5726734063977</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT COT(0);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
			<ul type="disc">
				<li>
				<span >
				CRC32(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>计算</span><span>循环冗余码校验</span><span>值并返回一个<span> 
			32</span>比特无符号值。若参数为<span>NULL </span>，则结果为<span> 
			NULL</span>。该参数应为一个字符串，而且在不是字符串的情况下会被作为字符串处理（若有可能）。 </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT CRC32(&#39;MySQL&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 3259397556</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT CRC32(&#39;mysql&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2501908538</span></p>
			<ul type="disc">
				<li>
				<span >
				DEGREES(<i>X</i>) </span></li>
			</ul>
			<p>
			<span>返回参数 
			<i><span>X</span></i><span>, </span>该参数由弧度被转化为度。 
			</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT DEGREES(PI());</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 180</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT DEGREES(PI() / 2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 90</span></p>
			<ul type="disc">
				<li>
				<span >EXP(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回<span>e</span>的<i><span>X</span></i>乘方后的值<span>(</span>自然对数的底<span>)</span>。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT EXP(2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 7.3890560989307</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT EXP(-2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.13533528323661</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT EXP(0);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<ul type="disc">
				<li>
				<span >
				FLOOR(<i>X</i>) </span></li>
			</ul>
			<p>
			<span>返回不大于<i><span>X</span></i>的最大整数值 
			。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT FLOOR(1.23);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT FLOOR(-1.23);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -2</span></p>
			<p>
			<span>
			注意，返回值会被转化为一个<span> BIGINT</span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				FORMAT(<i>X</i>,<i>D</i>) </span></li>
			</ul>
			<p>
			<span>将数字<i><span>X</span></i><span>
			</span>的格式写成<span>&#39;#,###,###.##&#39;</span>格式<span>,
			</span>即保留小数点后 <i><span>D</span></i>位，而第<span>D</span>位的保留方式为四舍五入，然后将结果以字符串的形式返回。<span>详见</span></span><a href="functions.html#miscellaneous-functions" title="12.9.4. Miscellaneous Functions">12.9.4节，“其他函数”</a><span>。</span></p>
			<ul type="disc">
				<li>
				<span >LN(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i><span>
			</span>的自然对数<span>,</span>即<span>,<i> X</i>
			</span>相对于基数<span>e </span>的对数。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LN(2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.69314718055995</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LN(-2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
			<p>
			<span>这个函数同<span>LOG(<i>X</i>)</span>具有相同意义。 
			</span></p>
			<ul type="disc">
				<li>
				<span >LOG(<i>X</i>) 
				LOG(<i>B</i>,<i>X</i>) </span></li>
			</ul>
			<p>
			<span>
			若用一个参数调用，这个函数就会返回<i><span>X</span></i><span>
			</span>的自然对数。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LOG(2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.69314718055995</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LOG(-2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
			<p>
			<span>
			若用两个参数进行调用，这个函数会返回<i><span>X</span></i><span>
			</span>对于任意基数<i><span>B</span></i><span> </span>
			的对数。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LOG(2,65536);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 16</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LOG(10,100);</b></span></p>
			<p>
			<span >
			&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; 2</span></p>
			<p>
			<span >
			LOG(<i>B</i>,<i>X</i>) </span>
			<span>就相当于<span> 
			LOG(<i>X</i>) / LOG(<i>B</i>)</span>。</span></p>
			<ul type="disc">
				<li>
				<span >LOG2(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i><span>
			</span>的基数为<span>2</span>的对数。 </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LOG2(65536);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 16</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LOG2(-100);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
			<p>
			<span>
			对于查出存储一个数字需要多少个比特，<span>LOG2()</span>非常有效。这个函数相当于表达式<span> 
			LOG(<i>X</i>) / LOG(2)</span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				LOG10(<i>X</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i>的基数为<span>10</span>的对数。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LOG10(2);</b></span></p>
			<p>
			<span >
			&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; 0.30102999566398</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LOG10(100);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LOG10(-100);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
			<p>
			<span >
			LOG10(<i>X</i>)</span><span>相当于<span>LOG(10,<i>X</i>)</span>。</span></p>
			<ul type="disc">
				<li>
				<span >MOD(<i>N</i>,<i>M</i>) 
				, <i>N</i> % <i>M</i> <i>N</i> MOD <i>M</i> </span></li>
			</ul>
			<p>
			<span>
			模操作。返回<i><span>N</span></i><span> </span>被 <i>
			<span>M</span></i>除后的余数。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT MOD(234, 10);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 4</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 253 % 7;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT MOD(29,9);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 29 MOD 9;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
			<p>
			<span>
			这个函数支持使用<span>BIGINT </span>值。</span></p>
			<p>
			<span >
			MOD() </span>
			<span>
			对于带有小数部分的数值也起作用， 它返回除法运算后的精确余数： </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT MOD(34.5,3);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1.5</span></p>
			<ul type="disc">
				<li>
				<span >PI()
				</span></li>
			</ul>
			<p>
			<span>返回 
			</span>
			<span>
			ϖ</span><span > 
			(pi)</span><span>的值。默认的显示小数位数是<span>7</span>位<span>,</span>然而<span> 
			MySQL</span>内部会使用完全双精度值。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT PI();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 3.141593</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT PI()+0.000000000000000000;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 3.141592653589793116</span></p>
			<ul type="disc">
				<li>
				<span >POW(<i>X</i>,<i>Y</i>) 
				, POWER(<i>X</i>,<i>Y</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i><span>
			</span>的<i><span>Y</span></i>乘方的结果值。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT POW(2,2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 4</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT POW(2,-2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.25</span></p>
			<ul type="disc">
				<li>
				<span >
				RADIANS(<i>X</i>) </span></li>
			</ul>
			<p>
			<span>
			返回由度转化为弧度的参数 <i><span>X</span></i><span>,&nbsp; (</span>注意 
			</span>
			<span>
			ϖ</span><span >
			</span>
			<span>弧度等于<span>180</span>度）<span>。
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT RADIANS(90);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1.5707963267949</span></p>
			<ul type="disc">
				<li>
				<span >
				RAND() RAND(<i>N</i>) </span></li>
			</ul>
			<p>
			<span>
			返回一个随机浮点值 <i><span>v</span></i><span> </span>
			，范围在<span> 0 </span>到<span>1 </span>之间<span> 
			(</span>即<span>, </span>其范围为<span> 0 </span>≤ <i>
			<span>v</span></i><span> </span>≤<span> 
			1.0)</span>。若已指定一个整数参数 <i><span>N</span></i><span>
			</span>，则它被用作种子值，用来产生重复序列。<span>&nbsp; </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT RAND();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.9233482386203</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT RAND(20);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.15888261251047</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT RAND(20);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.15888261251047</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT RAND();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.63553050033332</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT RAND();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.70100469486881</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT RAND(20);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0.15888261251047</span></p>
			<p>
			<span>若要在<i><span>i</span></i><span>
			</span>≤ <i><span>R</span></i><span> </span>≤ <i>
			<span>j</span></i><span> </span>这个范围得到一个随机整数<i><span>R</span></i><span>
			</span>，需要用到表达式<span> FLOOR(<i>i</i> + RAND() * (<i>j</i>
			</span>– <i><span>i</span></i><span> + 1))</span>。例如， 
			若要在<span>7 </span>到<span> 12 </span>的范围（包括<span>7</span>和<span>12</span>）内得到一个随机整数<span>,
			</span>可使用以下语句：</span></p>
			<p>
			<span >
			SELECT FLOOR(7 + (RAND() * 6));</span></p>
			<p>
			<span>在<span>ORDER 
			BY</span>语句中，不能使用一个带有<span>RAND()</span>值的列，原因是<span> 
			ORDER BY </span>会计算列的多重时间。然而，可按照如下的随机顺序检索数据行： </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT * FROM <i>tbl_name</i> ORDER BY RAND();</b></span></p>
			<p>
			<span >
			ORDER BY RAND()</span><span>同<span> 
			LIMIT </span>的结合从一组列中选择随机样本很有用：</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT * FROM table1, table2 WHERE a=b AND c&lt;d</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt; <b>ORDER BY RAND() LIMIT 1000;</b></span></p>
			<p>
			<span>注意，在<span>WHERE</span>语句中，<span>WHERE</span>每执行一次，<span> 
			RAND()</span>就会被再计算一次。</span></p>
			<p>
			<span >
			RAND()</span><span>的作用不是作为一个精确的随机发生器，而是一种用来发生在同样的<span> 
			MySQL</span>版本的平台之间的可移动<i><span>ad hoc</span></i>随机数的快速方式。 
			</span></p>
			<ul type="disc">
				<li>
				<span >
				ROUND(<i>X</i>) ROUND(<i>X</i>,<i>D</i>) </span></li>
			</ul>
			<p>返回参数<i><span>X</span></i><span>,
			</span>其值接近于最近似的整数。在有两个参数的情况下，返回 <i><span>X</span></i><span>
			</span>，其值保留到小数点后<i><span>D</span></i>位，而第<i><span>D</span></i>位的保留方式为四舍五入。若要接保留<i><span>X</span></i>值小数点左边的<i><span>D</span></i><span>
			</span>位，可将 <i><span>D</span></i><span> </span>
			设为负值。 </p>
			<p>
			<span >
			mysql&gt; <b>SELECT ROUND(-1.23);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ROUND(-1.58);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -2</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ROUND(1.58);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ROUND(1.298, 1);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1.3</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ROUND(1.298, 0);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;-&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ROUND(23.298, -1);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 20</span></p>
			<p>
			<span>
			返回值的类型同 第一个自变量相同<span>(</span>假设它是一个整数、双精度数或小数<span>)</span>。这意味着对于一个整数参数<span>,</span>结果也是一个整数<span>(</span>无小数部分<span>)</span>。</span></p>
			<p>
			<span>
			当第一个参数是十进制常数时，对于准确值参数，<span>ROUND() </span>使用精密数学题库：</span></p>
			<ul type="disc">
				<ul type="circle">
					<li>
					<span>对于准确值数字<span>, 
					ROUND() </span>使用“四舍五入” 或“舍入成最接近的数” 的规则<span>:</span>对于一个分数部分为<span> 
					.5</span>或大于<span> .5</span>的值，正数则上舍入到邻近的整数值， 
					负数则下舍入临近的整数值。<span>(</span>换言之<span>,
					</span>其舍入的方向是数轴上远离零的方向）<span>。</span>对于一个分数部分小于<span>.5
					</span>的值，正数则下舍入下一个整数值，负数则下舍入邻近的整数值，而正数则上舍入邻近的整数值。 </span>
					</li>
					<li>
					<span>
					对于近似值数字，其结果根据<span>C </span>库而定。在很多系统中，这意味着<span> 
					ROUND()</span>的使用遵循“舍入成最接近的偶数”的规则： 
					一个带有任何小数部分的值会被舍入成最接近的偶数整数。</span></li>
				</ul>
			</ul>
			<p>
			<span>
			以下举例说明舍入法对于精确值和近似值的不同之处： </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ROUND(2.5), ROUND(25E-1);</b></span></p>
			<p>
			<span >
			+------------+--------------+</span></p>
			<p>
			<span >
			| ROUND(2.5) | ROUND(25E-1) |</span></p>
			<p>
			<span >
			+------------+--------------+</span></p>
			<p>
			<span >
			| 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 |</span></p>
			<p>
			<span >
			+------------+--------------+</span></p>
			<p>
			<span>详见</span><a href="precision-math.html">第24章：</a><a href="precision-math.html" title="Chapter 24. Precision Math"><i>精度数学</i></a><span>。</span></p>
			<ul type="disc">
				<li>
				<span >SIGN(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>
			返回参数作为<span>-1</span>、<span> 0</span>或<span>1</span>的符号，该符号取决于<i><span>X</span></i><span>
			</span>的值为负、零或正。 </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SIGN(-32);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SIGN(0);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SIGN(234);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<ul type="disc">
				<li>
				<span >SIN(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i><span>
			</span>正弦，其中 <i><span>X</span></i><span> </span>
			在弧度中被给定。 </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SIN(PI());</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1.2246063538224e-16</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ROUND(SIN(PI()));</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
			<ul type="disc">
				<li>
				<span >SQRT(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回非负数<i><span>X</span></i><span>
			</span>的二次方根。 </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SQRT(4);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SQRT(20);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 4.4721359549996</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SQRT(-16);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
			<ul type="disc">
				<li>
				<span >TAN(<i>X</i>)
				</span></li>
			</ul>
			<p>
			<span>返回<i><span>X</span></i><span>
			</span>的正切，其中<i><span>X</span></i><span> </span>
			在弧度中被给定。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT TAN(PI());</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1.2246063538224e-16</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT TAN(PI()+1);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1.5574077246549</span></p>
			<ul type="disc">
				<li>
				<span >
				TRUNCATE(<i>X</i>,<i>D</i>) </span></li>
			</ul>
			<p>
			<span>
			返回被舍去至小数点后<i><span>D</span></i>位的数字<i><span>X</span></i>。若<i><span>D</span></i><span>
			</span>的值为<span> 0, </span>则结果不带有小数点或不带有小数部分。</span><span>可以将<span>D</span>设为负数<span>,</span>若要截去<span>(</span>归零<span>) 
			X</span>小数点左起第<span>D</span>位开始后面所有低位的值<span>.</span></span><span>
			<i>&nbsp;</i></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT TRUNCATE(1.223,1);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1.2</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT TRUNCATE(1.999,1);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1.9</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT TRUNCATE(1.999,0);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT TRUNCATE(-1.999,1);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1.9</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT TRUNCATE(122,-2);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 100</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT TRUNCATE(10.28*100,0);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1028</span></p>
			<p>
			<span>
			所有数字的舍入方向都接近于零。</span></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="date-and-time-functions"></a>
		12.5.&nbsp;日期和时间函数</h2></div></div></div><a class="indexterm" name="id2869542"></a><a class="indexterm" name="id2869551"></a>
		<p>
		<span>
		本章论述了一些可用于操作时间值的函数。关于每个时间和日期类型具有的值域及指定值的有效格式，请参见</span><a href="column-types.html#date-and-time-types" title="11.3. Date and Time Types">11.3节，“日期和时间类型”</a><span>。</span></p>
		<p>
		<span>
		下面的例子使用了时间函数。以下询问选择了最近的<span> 30</span>天内所有带有<span>date_col
		</span>值的记录：<span> </span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT <i>something</i> FROM <i>tbl_name</i></b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp; -&gt; <b>WHERE DATE_SUB(CURDATE(),INTERVAL 30 DAY) &lt;= <i>date_col</i>;</b></span></p>
		<p>
		<span>
		注意，这个询问也能选择将来的日期记录。<span>&nbsp; </span></span></p>
		<p>
		<span>
		用于日期值的函数通常会接受时间日期值而忽略时间部分。而用于时间值的函数通常接受时间日期值而忽略日期部分。</span></p>
		<p>
		<span>
		返回各自当前日期或时间的函数在每次询问执行开始时计算一次。这意味着在一个单一询问中，对诸如<span>NOW()
		</span>的函数多次访问总是会得到同样的结果<span>(</span>未达到我们的目的，单一询问也包括对存储程序或触发器和被该程序<span>/</span>触发器调用的所有子程序的调用<span> 
		)</span>。这项原则也适用于<span> CURDATE()</span>、<span> 
		CURTIME()</span>、<span> UTC_DATE()</span>、<span> 
		UTC_TIME()</span>、<span>UTC_TIMESTAMP()</span>，以及所有和它们意义相同的函数。</span></p>
		<p>
		<span >
		CURRENT_TIMESTAMP()</span><span>、<span> 
		CURRENT_TIME()</span>、<span> CURRENT_DATE()</span>以及<span>FROM_UNIXTIME()</span>函数返回连接当前时区内的值，这个值可用作<span>time_zone</span>系统变量的值。此外，<span> 
		UNIX_TIMESTAMP() </span>假设其参数为一个当前时区的时间日期值。请参见</span><a href="database-administration.html#time-zone-support" title="5.10.8. MySQL Server Time Zone Support">5.10.8节，“MySQL服务器时区支持”</a><span >。 
		</span></p>
		<p>
		<span>
		以下函数的论述中返回值的范围会请求完全日期。 若一个日期为“零” 值，或者是一个诸如<span>&#39;2001-11-00&#39;</span>之类的不完全日期， 
		提取部分日期值的函数可能会返回<span> 0</span>。 例如，<span> DAYOFMONTH(&#39;2001-11-00&#39;)
		</span>会返回<span>0</span>。<span> </span></span></p>
		<ul type="disc">
			<li>
			<span >ADDDATE(<i>date</i>,INTERVAL
			<i>expr</i> <i>type</i>) ADDDATE(<i>expr</i>,<i>days</i>) </span>
			</li>
		</ul>
		<p>
		<span>当被第二个参数的<span>INTERVAL</span>格式激活后，<span> 
		ADDDATE()</span>就是<span>DATE_ADD()</span>的同义词。相关函数<span>SUBDATE()
		</span>则是<span>DATE_SUB()</span>的同义词。对于<span>INTERVAL</span>参数上的信息
		，请参见关于<span>DATE_ADD()</span>的论述。<span>
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_ADD(&#39;1998-01-02&#39;, INTERVAL 31 DAY);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1998-02-02&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT ADDDATE(&#39;1998-01-02&#39;, INTERVAL 31 DAY);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1998-02-02&#39;</span></p>
		<p>
		<span>若 <i>
		<span>days</span></i><span> </span>参数只是整数值，则<span> 
		MySQL 5.1</span>将其作为天数值添加至 <i><span>expr</span></i>。<span>
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT ADDDATE(&#39;1998-01-02&#39;, 31);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1998-02-02&#39;</span></p>
		<ul type="disc">
			<li>
			<span >ADDTIME(<i>expr</i>,<i>expr2</i>)
			</span></li>
		</ul>
		<p>
		<span >
		ADDTIME()</span><span>将 
		<i><span>expr2</span></i>添加至<i><span>expr</span></i><span>
		</span>然后返回结果。 <i><span>expr</span></i><span> </span>
		是一个时间或时间日期表达式，而<i><span>expr2</span></i><span>
		</span>是一个时间表达式。<span> </span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT ADDTIME(&#39;1997-12-31 23:59:59.999999&#39;,</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>&#39;1 1:1:1.000002&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1998-01-02 01:01:01.000001&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT ADDTIME(&#39;01:00:00.999999&#39;, &#39;02:00:00.999998&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;03:00:01.999997&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			CONVERT_TZ(<i>dt</i>,<i>from_tz</i>,<i>to_tz</i>) </span></li>
		</ul>
		<p>
		<span >
		CONVERT_TZ() </span>
		<span>将时间日期值<i><span>dt</span></i><span>
		</span>从<i><span>from_tz</span></i><span> </span>
		给出的时区转到<i><span>to_tz</span></i>给出的时区，然后返回结果值。关于可能指定的时区的详细论述，请参见</span><a href="database-administration.html#time-zone-support" title="5.10.8. MySQL Server Time Zone Support">5.10.8节，“MySQL服务器时区支持”</a><span>。若自变量无效，则这个函数会返回<span> 
		NULL</span>。</span></p>
		<p>
		<span>在从若<i><span>from_tz</span></i><span>
		</span>到<span>UTC</span>的转化过程中，该值超出<span> TIMESTAMP
		</span>类型的被支持范围，那么转化不会发生。关于<span> TIMESTAMP </span>范围的论述，请参见</span><a href="column-types.html#date-and-time-type-overview" title="11.1.2. Overview of Date and Time Types">11.1.2节，“日期和时间类型概述”</a><span>。<span>
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONVERT_TZ(&#39;2004-01-01 12:00:00&#39;,&#39;GMT&#39;,&#39;MET&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;2004-01-01 13:00:00&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONVERT_TZ(&#39;2004-01-01 12:00:00&#39;,&#39;+00:00&#39;,&#39;+10:00&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;2004-01-01 22:00:00&#39;</span></p>
		<p>
		<b><span>注释</span></b><span >：</span><span>若要使用诸如<span> 
		&#39;MET&#39;</span>或<span> &#39;Europe/Moscow&#39;</span>之类的指定时间区，首先要设置正确的时区表。详细说明见</span><a href="database-administration.html#time-zone-support" title="5.10.8. MySQL Server Time Zone Support">5.10.8节，“MySQL服务器时区支持”</a><span >。&nbsp;
		</span></p>
		<ul type="disc">
			<li>
			<span >CURDATE()
			</span></li>
		</ul>
		<p>
		<span>将当前日期按照<span>&#39;YYYY-MM-DD&#39;
		</span>或<span>YYYYMMDD </span>格式的值返回，具体格式根据函数用在字符串或是数字语境中而定。<span>
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CURDATE();</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1997-12-15&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CURDATE() + 0;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 19971215</span></p>
		<ul type="disc">
			<li>
			<span >
			CURRENT_DATE CURRENT_DATE() </span></li>
		</ul>
		<p>
		<span >
		CURRENT_DATE</span><span>和<span>CURRENT_DATE()</span>是的同义词<span>.
		</span></span></p>
		<ul type="disc">
			<li>
			<span >CURTIME()
			</span></li>
		</ul>
		<p>
		<span>将当前时间以<span>&#39;HH:MM:SS&#39;</span>或<span> 
		HHMMSS </span>的格式返回， 具体格式根据函数用在字符串或是数字语境中而定。<span>&nbsp; </span>
		</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CURTIME();</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;23:50:26&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CURTIME() + 0;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 235026</span></p>
		<ul type="disc">
			<li>
			<span >
			CURRENT_TIME, CURRENT_TIME() </span></li>
		</ul>
		<p>
		<span >
		CURRENT_TIME </span>
		<span>和<span>CURRENT_TIME()
		</span>是<span>CURTIME()</span>的同义词。</span></p>
		<ul type="disc">
			<li>
			<span >
			CURRENT_TIMESTAMP, CURRENT_TIMESTAMP() </span></li>
		</ul>
		<p>
		<span >
		CURRENT_TIMESTAMP</span><span>和<span> 
		CURRENT_TIMESTAMP()</span>是<span>NOW()</span>的同义词。</span></p>
		<ul type="disc">
			<li>
			<span >DATE(<i>expr</i>)
			</span></li>
		</ul>
		<p>
		<span>
		提取日期或时间日期表达式<i><span>expr</span></i>中的日期部分。<span>
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE(&#39;2003-12-31 01:02:03&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;2003-12-31&#39;</span></p>
		<ul type="disc">
			<li>
			<span >DATEDIFF(<i>expr</i>,<i>expr2</i>)
			</span></li>
		</ul>
		<p>
		<span >
		DATEDIFF() </span>
		<span>返回起始时间 <i>
		<span>expr</span></i>和结束时间<i><span>expr2</span></i>之间的天数。<i><span>Expr</span></i>和<i><span>expr2</span></i><span>
		</span>为日期或<span> date-and-time </span>表达式。计算中只用到这些值的日期部分。<span>
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATEDIFF(&#39;1997-12-31 23:59:59&#39;,&#39;1997-12-30&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATEDIFF(&#39;1997-11-30 23:59:59&#39;,&#39;1997-12-31&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -31</span></p>
		<ul type="disc">
			<li>
			<span >DATE_ADD(<i>date</i>,INTERVAL
			<i>expr</i> <i>type</i>) DATE_SUB(<i>date</i>,INTERVAL <i>expr</i>
			<i>type</i>) </span></li>
		</ul>
		<p>
		<span>
		这些函数执行日期运算。 <i><span>date</span></i><span> </span>
		是一个<span> DATETIME </span>或<span>DATE</span>值，用来指定起始时间。 
		<i><span>expr</span></i><span> </span>
		是一个表达式，用来指定从起始日期添加或减去的时间间隔值。<span>&nbsp; <i>Expr</i></span>是一个字符串<span>;</span>对于负值的时间间隔，它可以以一个 
		‘<span>-</span>’开头。 <i><span>type</span></i><span>
		</span>为关键词，它指示了表达式被解释的方式。<span>&nbsp; </span></span></p>
		<p>
		<span>关键词<span>INTERVA</span>及 
		<i><span>type</span></i><span> </span>分类符均不区分大小写。<span>
		</span></span></p>
		<p>
		<span>以下表显示了<i><span>type</span></i><span>
		</span>和<i><span>expr</span></i><span> </span>参数的关系：<span>
		</span></span></p>
		<table border="1" cellpadding="0" id="table4">
			<tr>
				<td>
				<p><i>
				<span>
				type</span></i><span>
				</span><b>
				<span>值</span></b></td>
				<td>
				<p><b>
				<span>
				预期的</span></b><span>
				<i><span>expr</span></i><span> </span>
				<b>格式</b></span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				MICROSECOND</span></td>
				<td>
				<p>
				<span>
				MICROSECONDS</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				SECOND</span></td>
				<td>
				<p>
				<span>
				SECONDS</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				MINUTE</span></td>
				<td>
				<p>
				<span>
				MINUTES</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				HOUR</span></td>
				<td>
				<p>
				<span>
				HOURS</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				DAY</span></td>
				<td>
				<p>
				<span>
				DAYS</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				WEEK</span></td>
				<td>
				<p>
				<span>
				WEEKS</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				MONTH</span></td>
				<td>
				<p>
				<span>
				MONTHS</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				QUARTER</span></td>
				<td>
				<p>
				<span>
				QUARTERS</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				YEAR</span></td>
				<td>
				<p>
				<span>
				YEARS</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				SECOND_MICROSECOND</span></td>
				<td>
				<p>
				<span>
				&#39;SECONDS.MICROSECONDS&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				MINUTE_MICROSECOND</span></td>
				<td>
				<p>
				<span>
				&#39;MINUTES.MICROSECONDS&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				MINUTE_SECOND</span></td>
				<td>
				<p>
				<span>
				&#39;MINUTES:SECONDS&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				HOUR_MICROSECOND</span></td>
				<td>
				<p>
				<span>
				&#39;HOURS.MICROSECONDS&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				HOUR_SECOND</span></td>
				<td>
				<p>
				<span>
				&#39;HOURS:MINUTES:SECONDS&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				HOUR_MINUTE</span></td>
				<td>
				<p>
				<span>
				&#39;HOURS:MINUTES&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				DAY_MICROSECOND</span></td>
				<td>
				<p>
				<span>
				&#39;DAYS.MICROSECONDS&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				DAY_SECOND</span></td>
				<td>
				<p>
				<span>
				&#39;DAYS HOURS:MINUTES:SECONDS&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				DAY_MINUTE</span></td>
				<td>
				<p>
				<span>
				&#39;DAYS HOURS:MINUTES&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				DAY_HOUR</span></td>
				<td>
				<p>
				<span>
				&#39;DAYS HOURS&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				YEAR_MONTH</span></td>
				<td>
				<p>
				<span>
				&#39;YEARS-MONTHS&#39;</span></td>
			</tr>
		</table>
		<p>
		<span >
		MySQL </span>
		<span>允许任何<i><span>expr</span></i><span>
		</span>格式中的标点分隔符。表中所显示的是建议的 分隔符。若 <i><span>date</span></i><span>
		</span>参数是一个<span> DATE </span>值，而你的计算只会包括<span> 
		YEAR</span>、<span>MONTH</span>和<span>DAY</span>部分<span>(</span>即<span>,
		</span>没有时间部分<span>), </span>其结果是一个<span>DATE </span>
		值。否则，结果将是一个<span> DATETIME</span>值。</span></p>
		<p>
		<span>
		若位于另一端的表达式是一个日期或日期时间值 ， 则<span>INTERVAL <i>expr</i> <i>type</i></span>只允许在<span> 
		+ </span>操作符的两端。对于 –操作符，<span>&nbsp; INTERVAL <i>expr</i> <i>type</i>
		</span>只允许在其右端，原因是从一个时间间隔中提取一个日期或日期时间值是毫无意义的。<span> (</span>见下面的例子）<span>。
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT &#39;1997-12-31 23:59:59&#39; + INTERVAL 1 SECOND;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1998-01-01 00:00:00&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT INTERVAL 1 DAY + &#39;1997-12-31&#39;;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1998-01-01&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT &#39;1998-01-01&#39; - INTERVAL 1 SECOND;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1997-12-31 23:59:59&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_ADD(&#39;1997-12-31 23:59:59&#39;,</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>INTERVAL 1 SECOND);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1998-01-01 00:00:00&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_ADD(&#39;1997-12-31 23:59:59&#39;,</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>INTERVAL 1 DAY);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1998-01-01 23:59:59&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_ADD(&#39;1997-12-31 23:59:59&#39;,</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>INTERVAL &#39;1:1&#39; MINUTE_SECOND);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1998-01-01 00:01:00&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_SUB(&#39;1998-01-01 00:00:00&#39;,</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>INTERVAL &#39;1 1:1:1&#39; DAY_SECOND);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1997-12-30 22:58:59&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_ADD(&#39;1998-01-01 00:00:00&#39;,</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>INTERVAL &#39;-1 10&#39; DAY_HOUR);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1997-12-30 14:00:00&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_SUB(&#39;1998-01-02&#39;, INTERVAL 31 DAY);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1997-12-02&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_ADD(&#39;1992-12-31 23:59:59.000002&#39;,</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>INTERVAL &#39;1.999999&#39; SECOND_MICROSECOND);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1993-01-01 00:00:01.000001&#39;</span></p>
		<p>
		<span>
		若你指定了一个过于短的时间间隔值<span> (</span>不包括<i><span>type</span></i><span>
		</span>关键词所预期的所有时间间隔部分<span>), MySQL </span>
		假定你已经省去了时间间隔值的最左部分。 例如，你指定了一种类型的<span>DAY_SECOND,<i> expr</i>
		</span>的值预期应当具有天、 小时、分钟和秒部分。若你指定了一个类似<span> &#39;1:10&#39;</span>的值<span>, 
		MySQL </span>假定天和小时部分不存在，那么这个值代表分和秒。换言之<span>, &#39;1:10&#39; 
		DAY_SECOND </span>被解释为相当于<span> &#39;1:10&#39; MINUTE_SECOND</span>。这相当于<span> 
		MySQL</span>将<span>TIME </span>值解释为所耗费的时间而不是日时的解释方式。<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span></p>
		<p>
		<span>
		假如你对一个日期值添加或减去一些含有时间部分的内容，则结果自动转化为一个日期时间值：</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_ADD(&#39;1999-01-01&#39;, INTERVAL 1 DAY);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1999-01-02&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_ADD(&#39;1999-01-01&#39;, INTERVAL 1 HOUR);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1999-01-01 01:00:00&#39;</span></p>
		<p>
		<span>
		假如你使用了格式严重错误的日期<span>,</span>则结果为<span> NULL</span>。假如你添加了<span>&nbsp; 
		MONTH</span>、<span>YEAR_MONTH</span>或<span>YEAR
		</span>，而结果日期中有一天的日期大于添加的月份的日期最大限度，则这个日期自动被调整为添加月份的最大日期：<span>
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_ADD(&#39;1998-01-30&#39;, INTERVAL 1 MONTH);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1998-02-28&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			DATE_FORMAT(<i>date</i>,<i>format</i>) </span></li>
		</ul>
		<p>
		<span>根据<i><span>format</span></i><span>
		</span>字符串安排<i><span>date</span></i><span> </span>
		值的格式。<span> </span></span></p>
		<p>
		<span>以下说明符可用在 
		<i><span>format</span></i><span> </span>字符串中：</span></p>
		<table border="1" cellpadding="0" width="531">
			<tr>
				<td width="59">
				<p><b>
				<span>
				说明符</span></b></td>
				<td>
				<p><strong>
				<span>说明</span></strong></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%a</span></td>
				<td>
				<p>
				工作日的缩写名称&nbsp; 
				(Sun..Sat)</td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%b</span></td>
				<td>
				<p>
				<span>月份的缩写名称</span><span>&nbsp; 
				(</span><span>Jan</span><span>..</span><span>Dec</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%c</span></td>
				<td>
				<p>
				<span>月份，数字形式</span><span>(</span><span>0</span><span>..</span><span>12</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%D</span></td>
				<td>
				<p>
				<span>带有英语后缀的该月日期</span><span>&nbsp; 
				(</span><span>0th</span><span>,
				</span>
				<span>1st</span><span>, </span>
				<span>2nd</span><span>,
				</span>
				<span>3rd</span><span>, ...)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%d</span></td>
				<td>
				<p>
				<span>该月日期</span><span>,
				</span><span>数字形式</span><span> 
				(</span><span>00</span><span>..</span><span>31</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%e</span></td>
				<td>
				<p>
				<span>该月日期</span><span>,
				</span><span>数字形式</span><span>(</span><span>0</span><span>..</span><span>31</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%f</span></td>
				<td>
				<p>
				<span>微秒</span><span> 
				(</span><span>000000</span><span>..</span><span>999999</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%H</span></td>
				<td>
				<p>
				<span>小时</span><span>(</span><span>00</span><span>..</span><span>23</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%h</span></td>
				<td>
				<p>
				<span>小时</span><span>(</span><span>01</span><span>..</span><span>12</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%I</span></td>
				<td>
				<p>
				<span>小时</span><span> 
				(</span><span>01</span><span>..</span><span>12</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%i</span></td>
				<td>
				<p>
				<span>分钟</span><span>,</span><span>数字形式</span><span> 
				(</span><span>00</span><span>..</span><span>59</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%j</span></td>
				<td>
				<p>
				<span>一年中的天数</span><span> 
				(</span><span>001</span><span>..</span><span>366</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%k</span></td>
				<td>
				<p>
				<span>小时</span><span> 
				(</span><span>0</span><span>..</span><span>23</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%l</span></td>
				<td>
				<p>
				<span>小时</span><span> 
				(</span><span>1</span><span>..</span><span>12</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%M</span></td>
				<td>
				<p>
				<span>月份名称</span><span> 
				(</span><span>January</span><span>..</span><span>December</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%m</span></td>
				<td>
				<p>
				<span>月份</span><span>,
				</span><span>数字形式</span><span> 
				(</span><span>00</span><span>..</span><span>12</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%p</span></td>
				<td>
				<p>
				<span>上午（<span>AM</span>）或下午（</span><span> </span><span>
				<span>PM</span><span>）</span></span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%r</span></td>
				<td>
				<p>
				<span>时间</span><span> 
				, 12</span><span>小时制</span><span> 
				(</span><span>小时<span>hh:</span>分钟<span>mm:</span>秒数<span>ss</span></span><span>
				</span><span>后加</span><span> </span>
				<span>AM</span><span>或</span><span>PM</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%S</span></td>
				<td>
				<p>
				<span>秒</span><span> 
				(</span><span>00</span><span>..</span><span>59</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%s</span></td>
				<td>
				<p>
				<span>秒</span><span> 
				(</span><span>00</span><span>..</span><span>59</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%T</span></td>
				<td>
				<p>
				<span>时间</span><span> 
				, 24</span><span>小时制</span><span> 
				(</span><span>小时<span>hh:</span>分钟<span>mm:</span>秒数<span>ss</span></span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%U</span></td>
				<td>
				<p>
				<span>周</span><span> 
				(</span><span>00</span><span>..</span><span>53</span><span>),
				</span><span>
				其中周日为每周的第一天</span><span> </span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%u</span></td>
				<td>
				<p>
				<span>周</span><span> 
				(</span><span>00</span><span>..</span><span>53</span><span>),
				</span><span>
				其中周一为每周的第一天</span><span>&nbsp;
				</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%V</span></td>
				<td>
				<p>
				<span>周</span><span> 
				(</span><span>01</span><span>..</span><span>53</span><span>),
				</span><span>
				其中周日为每周的第一天</span><span> ;
				</span><span>和</span><span>
				</span><span>
				<span>%X</span><span>同时使用</span></span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%v</span></td>
				<td>
				<p>
				<span>周</span><span> 
				(</span><span>01</span><span>..</span><span>53</span><span>),
				</span><span>
				其中周一为每周的第一天</span><span> ;
				</span><span>和</span><span>
				</span><span>
				<span>%x</span><span>同时使用</span></span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%W</span></td>
				<td>
				<p>
				<span>工作日名称</span><span> 
				(</span><span>周日</span><span>..</span><span>周六</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%w</span></td>
				<td>
				<p>
				<span>一周中的每日</span><span> 
				(</span><span>0</span><span>=</span><span>周日</span><span>..</span><span>6</span><span>=</span><span>周六</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%X</span></td>
				<td>
				<p>
				<span>
				该周的年份，其中周日为每周的第一天</span><span>,
				</span><span>数字形式</span><span>,4</span><span>位数</span><span>;</span><span>和</span><span><span>%V</span><span>同时使用</span></span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%x</span></td>
				<td>
				<p>
				<span>
				该周的年份，其中周一为每周的第一天</span><span>,
				</span><span>数字形式</span><span>,4</span><span>位数</span><span>;</span><span>和</span><span><span>%v</span><span>同时使用</span></span><span>
				</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%Y</span></td>
				<td>
				<p>
				<span>年份</span><span>,
				</span><span>数字形式</span><span>,4</span><span>位数</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%y</span></td>
				<td>
				<p>
				<span>年份</span><span>,
				</span><span>数字形式</span><span> 
				(2</span><span>位数</span><span>)</span></td>
			</tr>
			<tr>
				<td width="59">
				<p>
				<span>%%</span></td>
				<td>
				<p>
				<span>‘</span><span>%</span><span>’文字字符</span></td>
			</tr>
		</table>
		<p>
		<span>
		所有其它字符都被复制到结果中，</span><span>无需作出解释。</span></p>
		<p>
		<span>注意， ‘<span>%</span>’字符要求在格式指定符之前。</span></p>
		<p>
		<span>
		月份和日期说明符的范围从零开始，原因是<span> MySQL</span>允许存储诸如<span> 
		&#39;2004-00-00&#39;</span>的不完全日期<span>. </span></span></p>
		<pre><span>mysql&gt; </span><span><b><span>SELECT DATE_FORMAT(&#39;1997-10-04 22:23:00&#39;, &#39;%W %M %Y&#39;);</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;Saturday October 1997&#39;</span></pre>
		<pre><span>mysql&gt; </span><span><b><span>SELECT DATE_FORMAT(&#39;1997-10-04 22:23:00&#39;, &#39;%H:%i:%s&#39;);</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;22:23:00&#39;</span></pre>
		<pre><span>mysql&gt; </span><span><b><span>SELECT DATE_FORMAT(&#39;1997-10-04 22:23:00&#39;,</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;%D %y %a %d %m %b %j&#39;);</span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;4th 97 Sat 04 10 Oct 277&#39;</span></pre>
		<pre><span>mysql&gt; </span><span><b><span>SELECT DATE_FORMAT(&#39;1997-10-04 22:23:00&#39;,</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;%H %k %I %r %T %S %w&#39;);</span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;22 22 10 10:23:00 PM 22:23:00 00 6&#39;</span></pre>
		<pre><span>mysql&gt; </span><span><b><span>SELECT DATE_FORMAT(&#39;1999-01-01&#39;, &#39;%X %V&#39;);</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1998 52&#39;</span></pre>
		<ul type="disc">
			<li>
			<span >DAY(<i>date</i>)
			</span></li>
		</ul>
		<p>
		<span >
		DAY() </span>
		<span>和<span>DAYOFMONTH()</span>的意义相同。</span></p>
		<ul type="disc">
			<li>
			<span >DAYNAME(<i>date</i>)
			</span></li>
		</ul>
		<p>
		<span>返回<i><span>date</span></i><span>
		</span>对应的工作日名称。<span> </span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DAYNAME(&#39;1998-02-05&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;</span><span>周四<span>&#39;</span></span></p>
		<ul type="disc">
			<li>
			<span >
			DAYOFMONTH(<i>date</i>) </span></li>
		</ul>
		<p>
		<span>返回<i><span>date</span></i><span>
		</span>对应的该月日期，范围是从<span> 1</span>到<span>31</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DAYOFMONTH(&#39;1998-02-03&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 3</span></p>
		<ul type="disc">
			<li>
			<span >
			DAYOFWEEK(<i>date</i>) </span></li>
		</ul>
		<p>
		<span>返回<i><span>date</span></i><span> 
		(1 = </span>周日<span>, 2 = </span>周一<span>, ..., 7 =
		</span>周六<span>)</span>对应的工作日索引。这些索引值符合<span> ODBC</span>标准。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DAYOFWEEK(&#39;1998-02-03&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 3</span></p>
		<ul type="disc">
			<li>
			<span >
			DAYOFYEAR(<i>date</i>) </span></li>
		</ul>
		<p>
		<span>返回<i><span>date</span></i><span>
		</span>对应的一年中的天数，范围是从<span> 1</span>到<span>366</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DAYOFYEAR(&#39;1998-02-03&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 34</span></p>
		<ul type="disc">
			<li>
			<span >EXTRACT(<i>type</i> 
			FROM <i>date</i>) </span></li>
		</ul>
		<p>
		<span >
		EXTRACT()</span><span>函数所使用的时间间隔类型说明符同<span> 
		DATE_ADD()</span>或<span>DATE_SUB()</span>的相同<span>,</span>但它从日期中提取其部分，而不是执行日期运算。<span>&nbsp;
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT EXTRACT(YEAR FROM &#39;1999-07-02&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1999</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT EXTRACT(YEAR_MONTH FROM &#39;1999-07-02 01:02:03&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 199907</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT EXTRACT(DAY_MINUTE FROM &#39;1999-07-02 01:02:03&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 20102</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT EXTRACT(MICROSECOND</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>FROM &#39;2003-01-02 10:30:00.00123&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 123</span></p>
		<ul type="disc">
			<li>
			<span >
			FROM_DAYS(<i>N</i>) </span></li>
		</ul>
		<p>
		<span>给定一个天数<span>&nbsp;
		<i>N</i>, </span>返回一个<span>DATE</span>值。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT FROM_DAYS(729669);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1997-10-07&#39;</span></p>
		<p>
		<span>使用<span> 
		FROM_DAYS()</span>处理古老日期时，务必谨慎。他不用于处理阳历出现前的日期<span>(1582)</span>。请参见</span><a href="functions.html#mysql-calendar" title="12.6. What Calendar Is Used By MySQL?">12.6节，“MySQL使用什么日历？”</a><span>。</span></p>
		<ul type="disc">
			<li>
			<span >
			FROM_UNIXTIME(<i>unix_timestamp</i>) , FROM_UNIXTIME(<i>unix_timestamp</i>,<i>format</i>)
			</span></li>
		</ul>
		<p>
		<span>返回<span>&#39;YYYY-MM-DD 
		HH:MM:SS&#39;</span>或<span>YYYYMMDDHHMMSS </span>格式值的<i><span>unix_timestamp</span></i>参数表示，具体格式取决于该函数是否用在字符串中或是数字语境中。<span>
		</span></span></p>
		<p>
		<span>若<i><span>format</span></i><span>
		</span>已经给出，则结果的格式是根据<i><span>format</span></i><span>
		</span>字符串而定。 <i><span>format</span></i><span>
		</span>可以包含同<span>DATE_FORMAT() </span>函数输入项列表中相同的说明符。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT FROM_UNIXTIME(875996580);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1997-10-04 22:23:00&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT FROM_UNIXTIME(875996580) + 0;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 19971004222300</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(),</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>&#39;%Y %D %M %h:%i:%s %x&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;2003 6th August 06:22:58 2003&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			GET_FORMAT(DATE|TIME|DATETIME, &#39;EUR&#39;|&#39;USA&#39;|&#39;JIS&#39;|&#39;ISO&#39;|&#39;INTERNAL&#39;)
			</span></li>
		</ul>
		<p>
		<span>
		返回一个格式字符串。这个函数在同<span>DATE_FORMAT() </span>及<span>STR_TO_DATE()</span>函数结合时很有用。<span>
		</span></span></p>
		<p>
		<span>第一个参数的<span>3</span>个可能值和第二个参数的<span>5</span>个可能值产生<span> 
		15 </span>个可能格式字符串<span> (</span>对于使用的说明符，请参见<span>DATE_FORMAT()</span>函数说明表<span> 
		)</span>。</span></p>
		<table border="1" cellpadding="0" id="table6">
			<tr>
				<td>
				<p><b>
				<span>
				函数调用</span></b></td>
				<td>
				<p><b>
				<span>
				结果</span></b></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(DATE,&#39;USA&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%m.%d.%Y&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(DATE,&#39;JIS&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%Y-%m-%d&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(DATE,&#39;ISO&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%Y-%m-%d&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(DATE,&#39;EUR&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%d.%m.%Y&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(DATE,&#39;INTERNAL&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%Y%m%d&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(DATETIME,&#39;USA&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%Y-%m-%d-%H.%i.%s&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(DATETIME,&#39;JIS&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%Y-%m-%d %H:%i:%s&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(DATETIME,&#39;ISO&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%Y-%m-%d %H:%i:%s&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(DATETIME,&#39;EUR&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%Y-%m-%d-%H.%i.%s&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(DATETIME,&#39;INTERNAL&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%Y%m%d%H%i%s&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(TIME,&#39;USA&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%h:%i:%s %p&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(TIME,&#39;JIS&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%H:%i:%s&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(TIME,&#39;ISO&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%H:%i:%s&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(TIME,&#39;EUR&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%H.%i.%S&#39;</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>
				GET_FORMAT(TIME,&#39;INTERNAL&#39;)</span></td>
				<td>
				<p>
				<span>
				&#39;%H%i%s&#39;</span></td>
			</tr>
		</table>
		<p>
		<span >
		ISO </span>
		<span>格式为<span>ISO 
		9075, </span>而非<span>ISO 8601. </span></span></p>
		<p>
		<span>也可以使用<span>TIMESTAMP,
		</span>这时<span>GET_FORMAT()</span>的返回值和<span>DATETIME</span>相同。<span>
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT DATE_FORMAT(&#39;2003-10-03&#39;,GET_FORMAT(DATE,&#39;EUR&#39;));</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;03.10.2003&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT STR_TO_DATE(&#39;10.31.2003&#39;,GET_FORMAT(DATE,&#39;USA&#39;));</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;2003-10-31&#39;</span></p>
		<p>
		<span>或见</span><a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3节，“SET语法”</a><span>。</span><span >
		</span></p>
		<ul type="disc">
			<li>
			<span >HOUR(<i>time</i>)
			</span></li>
		</ul>
		<p>
		<span>返回<i><span>time</span></i><span>
		</span>对应的小时数。对于日时值的返回值范围是从<span> 0 </span>到<span> 
		23 </span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT HOUR(&#39;10:05:03&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 10</span></p>
		<p>
		<span>然而<span>,&nbsp; 
		TIME </span>值的范围实际上非常大<span>, </span>所以<span>HOUR</span>可以返回大于<span>23</span>的值。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT HOUR(&#39;272:59:59&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 272</span></p>
		<ul type="disc">
			<li>
			<span >LAST_DAY(<i>date</i>)
			</span></li>
		</ul>
		<p>
		<span>
		获取一个日期或日期时间值，返回该月最后一天对应的值。若参数无效，则返回<span>NULL</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LAST_DAY(&#39;2003-02-05&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;2003-02-28&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LAST_DAY(&#39;2004-02-05&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;2004-02-29&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LAST_DAY(&#39;2004-01-01 01:01:01&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;2004-01-31&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT LAST_DAY(&#39;2003-03-32&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
		<ul type="disc">
			<li>
			<span >LOCALTIME, 
			LOCALTIME() </span></li>
		</ul>
		<p>
		<span >
		LOCALTIME </span>
		<span>及<span> 
		LOCALTIME()</span>和<span>NOW()</span>具有相同意义。</span></p>
		<ul type="disc">
			<li>
			<span >
			LOCALTIMESTAMP, LOCALTIMESTAMP() </span></li>
		</ul>
		<p>
		<span >
		LOCALTIMESTAMP</span><span>和<span>LOCALTIMESTAMP()</span>和<span>NOW()</span>具有相同意义。</span></p>
		<ul type="disc">
			<li>
			<span >MAKEDATE(<i>year</i>,<i>dayofyear</i>)
			</span></li>
		</ul>
		<p>
		<span>给出年份值和</span><span>一年中的天数</span><span>值，返回一个日期。<i><span>dayofyear</span></i><span>
		</span>必须大于<span> 0 </span>，否则结果为<span> NULL</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT MAKEDATE(2001,31), MAKEDATE(2001,32);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;2001-01-31&#39;, &#39;2001-02-01&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT MAKEDATE(2001,365), MAKEDATE(2004,365);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;2001-12-31&#39;, &#39;2004-12-30&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT MAKEDATE(2001,0);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
		<ul type="disc">
			<li>
			<span >MAKETIME(<i>hour</i>,<i>minute</i>,<i>second</i>)
			</span></li>
		</ul>
		<p>
		<span>返回由<i><span>hour</span></i>、 
		<i><span>minute</span></i>和<i><span>second</span></i><span>
		</span>参数计算得出的时间值。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT MAKETIME(12,15,30);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;12:15:30&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			MICROSECOND(<i>expr</i>) </span></li>
		</ul>
		<p>
		<span>
		从时间或日期时间表达式<i><span>expr</span></i>返回微秒值，其数字范围从<span> 
		0</span>到<span> 999999</span>。<span> </span></span>
		</p>
		<p>
		<span >
		mysql&gt; <b>SELECT MICROSECOND(&#39;12:00:00.123456&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 123456</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT MICROSECOND(&#39;1997-12-31 23:59:59.000010&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 10</span></p>
		<ul type="disc">
			<li>
			<span >MINUTE(<i>time</i>)
			</span></li>
		</ul>
		<p>
		<span>返回<i><span> 
		time</span></i><span> </span>对应的分钟数<span>,</span>范围是从<span> 
		0 </span>到<span> 59</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT MINUTE(&#39;98-02-03 10:05:03&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 5</span></p>
		<ul type="disc">
			<li>
			<span >MONTH(<i>date</i>)
			</span></li>
		</ul>
		<p>
		<span>返回<i><span>date</span></i><span>
		</span>对应的月份，范围时从<span> 1 </span>到<span> 12</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT MONTH(&#39;1998-02-03&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
		<ul type="disc">
			<li>
			<span >
			MONTHNAME(<i>date</i>) </span></li>
		</ul>
		<p>
		<span>返回<i><span>date</span></i><span>
		</span>对应月份的全名。<span> </span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT MONTHNAME(&#39;1998-02-05&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;February &#39;</span></p>
		<ul type="disc">
			<li>
			<span >NOW()
			</span></li>
		</ul>
		<p>
		<span>
		返回当前日期和时间值，其格式为<span> &#39;YYYY-MM-DD HH:MM:SS&#39; </span>或<span>YYYYMMDDHHMMSS
		</span>， 具体格式取决于该函数是否用在字符串中或数字语境中。<span> </span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT NOW();</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;1997-12-15 23:50:26&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT NOW() + 0;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 19971215235026</span></p>
		<p>
		<span>
		在一个存储程序或触发器内<span>, NOW() </span>
		返回一个常数时间，该常数指示了该程序或触发语句开始执行的时间。这同<span>SYSDATE()</span>的运行有所不同。</span></p>
		<ul type="disc">
			<li>
			<span >
			PERIOD_ADD(<i>P</i>,<i>N</i>) </span></li>
		</ul>
		<p>
		<span>添加 <i>
		<span>N</span></i><span> </span>个月至周期<i><span>P</span></i><span> 
		(</span>格式为<span>YYMM </span>或<span>YYYYMM)</span>，返回值的格式为<span> 
		YYYYMM</span>。注意周期参数 <i><span>P</span></i><span>
		</span><i>不是</i>日期值。<span>&nbsp; </span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT PERIOD_ADD(9801,2);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 199803</span></p>
		<ul type="disc">
			<li>
			<span >
			PERIOD_DIFF(<i>P1</i>,<i>P2</i>)&nbsp; </span></li>
		</ul>
		<p>
		<span>返回周期<i><span>P1</span></i>和 
		<i><span>P2</span></i><span> </span>之间的月份数。<i><span>P1</span></i><span>
		</span>和<i><span>P2</span></i><span> </span>的格式应该为<span>YYMM</span>或<span>YYYYMM</span>。注意周期参数 
		<i><span>P1</span></i>和<i><span>P2</span></i><span>
		</span><i>不是</i>日期值。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT PERIOD_DIFF(9802,199703);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 11</span></p>
		<ul type="disc">
			<li>
			<span >QUARTER(<i>date</i>)
			</span></li>
		</ul>
		<p>
		<span>返回<i><span>date</span></i><span>
		</span>对应的一年中的季度值，范围是从<span> 1</span>到<span> 4</span>。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT QUARTER(&#39;98-04-01&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
		<ul type="disc">
			<li>
			<span >SECOND(<i>time</i>)
			</span></li>
		</ul>
		<p>
		<span>返回<i><span>time</span></i><span>
		</span>对应的秒数<span>, </span>范围是从<span> 0</span>到<span>59</span>。<span>
		</span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SECOND(&#39;10:05:03&#39;);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 3</span></p>
		<ul type="disc">
			<li>
			<span >
			SEC_TO_TIME(<i>seconds</i>) </span></li>
		</ul>
		<p>
		<span>返回被转化为小时、 
		分钟和秒数的<i><span>seconds</span></i>参数值<span>, </span>
		其格式为<span> &#39;HH:MM:SS&#39; </span>或<span>HHMMSS</span>，具体格式根据该函数是否用在字符串或数字语境中而定。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SEC_TO_TIME(2378);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;00:39:38&#39;</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT SEC_TO_TIME(2378) + 0;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 3938</span></p>
		<ul type="disc">
			<li>
			<span >
			STR_TO_DATE(<i>str</i>,<i>format</i>) </span></li>
		</ul>
		<p>
		<span>这是<span>DATE_FORMAT()
		</span>函数的倒转。它获取一个字符串 <i><span>str</span></i><span>
		</span>和一个格式字符串<i><span>format</span></i>。若格式字符串包含日期和时间部分，则<span> 
		STR_TO_DATE()</span>返回一个<span> DATETIME </span>值， 
		若该字符串只包含日期部分或时间部分，则返回一个<span> DATE </span>或<span>TIME</span>值。</span></p>
		<p>
		<i>
		<span >
		str</span></i><span>所包含的日期、时间或日期时间值应该在<i><span>format</span></i>指示的格式中被给定。对于可用在<i><span>format</span></i>中的说明符，请参见<span>DATE_FORMAT()
		</span>函数说明表。 所有其它的字符被逐字获取，因此不会被解释。若 <i><span>str</span></i><span>
		</span>包含一个非法日期、时间或日期时间值，则<span> STR_TO_DATE()</span>返回<span>NULL</span>。同时，一个非法值会引起警告。<span>
		</span></span></p>
		<p>
		<span>
		对日期值部分的范围检查在</span><a href="column-types.html#datetime" title="11.3.1. The DATETIME, DATE, and TIMESTAMP Types">11.3.1节，“DATETIME、DATE和TIMESTAMP类型”</a><span>有详细说</span><span>明。其意义是<span>,</span>例如<span>,
		</span>只要具体日期部分的范围时从<span> 1</span>到<span> 31</span>之间，则允许一个日期中的具体日期部分大于一个月中天数值。并且，允许“零”日期或带有<span>0</span>值部分的日期。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT STR_TO_DATE(&#39;00/00/0000&#39;, &#39;%m/%d/%Y&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;0000-00-00&#39;</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT STR_TO_DATE(&#39;04/31/2004&#39;, &#39;%m/%d/%Y&#39;)<span>;</span></b></span></p>
		<p>
		<span>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
		<span >-&gt; 
		&#39;2004-04-31&#39;</span></p>
		<ul type="disc">
			<li>
			<span >SUBDATE(<i>date</i>,INTERVAL
			<i>expr</i> <i>type</i>) SUBDATE(<i>expr</i>,<i>days</i>) </span>
			</li>
		</ul>
		<p>
		<span>当被第二个参数的<span> 
		INTERVAL</span>型式调用时<span>, SUBDATE()</span>和<span>DATE_SUB()</span>的意义相同。对于有关<span>INTERVAL</span>参数的信息， 
		见有关<span> DATE_ADD()</span>的讨论。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT DATE_SUB(&#39;1998-01-02&#39;, INTERVAL 31 DAY);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;1997-12-02&#39;</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT SUBDATE(&#39;1998-01-02&#39;, INTERVAL 31 DAY);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;1997-12-02&#39;</span></p>
		<p>
		<span>第二个形式允许对<i><span>days</span></i>使用整数值。在这些情况下，它被算作由日期或日期时间表达式 
		<i><span>expr</span></i>中提取的天数。<span> </span></span>
		</p>
		<p>
		<span >mysql&gt; <b>
		SELECT SUBDATE(&#39;1998-01-02 12:00:00&#39;, 31);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;1997-12-02 12:00:00&#39;</span></p>
		<p>
		<b><span>注意</span></b><span>不能使用格式<span> 
		&quot;%X%V&quot; </span>来将一个<span> year-week </span>
		字符串转化为一个日期，原因是当一个星期跨越一个月份界限时，一个年和星期的组合不能标示一个唯一的年和月份。若要将<span>year-week</span>转化为一个日期，则也应指定具体工作日：</span></p>
		<p>
		<span >mysql&gt; <b>
		select str_to_date(&#39;200442 Monday&#39;, &#39;%X%V %W&#39;);</b></span></p>
		<p>
		<span >-&gt; 2004-10-18</span></p>
		<ul type="disc">
			<li>
			<span >SUBTIME(<i>expr</i>,<i>expr2</i>)
			</span></li>
		</ul>
		<p>
		<span >SUBTIME()</span><span>从<i><span>expr</span></i><span>
		</span>中提取<i><span>expr2</span></i><span> </span>
		，然后返回结果。<i><span>expr</span></i><span> </span>
		是一个时间或日期时间表达式，而<i><span>xpr2</span></i><span> </span>
		是一个时间表达式。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT SUBTIME(&#39;1997-12-31 23:59:59.999999&#39;,&#39;1 1:1:1.000002&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;1997-12-30 22:58:58.999997&#39;</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT SUBTIME(&#39;01:00:00.999999&#39;, &#39;02:00:00.999998&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;-00:59:59.999999&#39;</span></p>
		<ul type="disc">
			<li>
			<span >SYSDATE()
			</span></li>
		</ul>
		<p>
		<span>返回当前日期和时间值，格式为<span>&#39;YYYY-MM-DD 
		HH:MM:SS&#39; </span>或<span>YYYYMMDDHHMMSS</span>， 
		具体格式根据函数是否用在字符串或数字语境而定。 </span></p>
		<p>
		<span>在一个存储程序或触发器中<span>, 
		SYSDATE()</span>返回其执行的时间<span>, </span>而非存储成都或触发语句开始执行的时间。这个<span>NOW()</span>的运作有所不同。</span></p>
		<ul type="disc">
			<li>
			<span >TIME(<i>expr</i>)
			</span></li>
		</ul>
		<p>
		<span>
		提取一个时间或日期时间表达式的时间部分，并将其以字符串形式返回。<span> </span></span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIME(&#39;2003-12-31 01:02:03&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;01:02:03&#39;</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIME(&#39;2003-12-31 01<span>:02:03.000123&#39;);</span></b></span></p>
		<p>
		<span>
		&nbsp;&nbsp;&nbsp;&nbsp; </span><span >
		&nbsp;&nbsp;&nbsp;-&gt; &#39;01:02:03.000123&#39;</span></p>
		<ul type="disc">
			<li>
			<span >TIMEDIFF(<i>expr</i>,<i>expr2</i>)
			</span></li>
		</ul>
		<p>
		<span >TIMEDIFF()
		</span><span>返回起始时间 <i>
		<span>expr</span></i><span> </span>和结束时间<i><span>expr2</span></i><span>
		</span>之间的时间。 <i><span>expr</span></i><span> </span>
		和<i><span>expr2</span></i><span> </span>为时间或<span> 
		date-and-time </span>表达式<span>,</span>两个的类型必须一样。<span>&nbsp;
		</span></span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIMEDIFF(&#39;2000:01:01 00:00:00&#39;,</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp; 
		-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>&#39;2000:01:01 00:00:00.000001&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;-00:00:00.000001&#39;</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIMEDIFF(&#39;1997-12-31 23:59:59.000001&#39;,</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp; 
		-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>&#39;1997-12-30 01:01:01.000002&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;46:58:57.999999&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			TIMESTAMP(<i>expr</i>) , TIMESTAMP(<i>expr</i>,<i>expr2</i>) </span>
			</li>
		</ul>
		<p>
		<span>对于一个单参数<span>,</span>该函数将日期或日期时间表达式 
		<i><span>expr</span></i><span> </span>作为日期时间值返回<span>.</span>对于两个参数<span>,
		</span>它将时间表达式 <i><span>expr2</span></i><span>
		</span>添加到日期或日期时间表达式 <i><span>expr</span></i><span>
		</span>中，将<span>theresult</span>作为日期时间值返回。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIMESTAMP(&#39;2003-12-31&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;2003-12-31 00:00:00&#39;</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIMESTAMP(&#39;2003-12-31 12:00:00&#39;,&#39;12:00:00&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;2004-01-01 00:00:00&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			TIMESTAMPADD(<i>interval</i>,<i>int_expr</i>,<i>datetime_expr</i>)
			</span></li>
		</ul>
		<p>
		<span>将整型表达式<i><span>int_expr</span></i><span>
		</span>添加到日期或日期时间表达式 <i><span>datetime_expr</span></i>中。 <i>
		<span>int_expr</span></i><span> </span>
		的单位被时间间隔参数给定，该参数必须是以下值的其中一个：<span> FRAC_SECOND</span>、<span>SECOND</span>、<span> 
		MINUTE</span>、<span> HOUR</span>、<span> DAY</span>、<span> 
		WEEK</span>、<span> MONTH</span>、<span> QUARTER</span>或<span> 
		YEAR</span>。</span></p>
		<p>
		<span>可使用所显示的关键词指定<i><span>Interval</span></i>值，或使用<span>SQL_TSI_</span>前缀。例如<span>, 
		DAY</span>或<span>SQL_TSI_DAY </span>都是正确的。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIMESTAMPADD(MINUTE,1,&#39;2003-01-02&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;2003-01-02 00:01:00&#39;</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIMESTAMPADD(WEEK,1,&#39;2003-01-02&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;2003-01-09&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			TIMESTAMPDIFF(<i>interval</i>,<i>datetime_expr1</i>,<i>datetime_expr2</i>)
			</span></li>
		</ul>
		<p>
		<span>返回日期或日期时间表达式<i><span>datetime_expr1</span></i><span>
		</span>和<i><span>datetime_expr2</span></i><span>the
		</span>之间的整数差。其结果的单位由<i><span>interval</span></i><span>
		</span>参数给出。<i><span>interval</span></i><span>
		</span>的法定值同<span>TIMESTAMPADD()</span>函数说明中所列出的相同。<span>
		</span></span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIMESTAMPDIFF(MONTH,&#39;2003-02-01&#39;,&#39;2003-05-01&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 3</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIMESTAMPDIFF(YEAR,&#39;2002-05-01&#39;,&#39;2001-01-01&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1</span></p>
		<ul type="disc">
			<li>
			<span >
			TIME_FORMAT(<i>time</i>,<i>format</i>) </span></li>
		</ul>
		<p>
		<span>其使用和<span> 
		DATE_FORMAT()</span>函数相同<span>, </span>然而<i><span>format</span></i><span>
		</span>字符串可能仅会包含处理小时、分钟和秒的格式说明符。其它说明符产生一个<span>NULL</span>值或<span>0</span>。<span>
		</span></span></p>
		<p>
		<span>若<i><span>time</span></i><span> 
		value</span>包含一个大于<span>23</span>的小时部分，则<span> %H
		</span>和<span> %k </span>小时格式说明符会产生一个大于<span>0..23</span>的通常范围的值。另一个小时格式说明符产生小时值模数<span>12</span>。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIME_FORMAT(&#39;100:00:00&#39;, &#39;%H %k %h %I %l&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;100 100 04 04 4&#39;</span></p>
		<ul type="disc">
			<li>
			<span >
			TIME_TO_SEC(<i>time</i>) </span></li>
		</ul>
		<p>
		<span>返回已转化为秒的<i><span>time</span></i>参数。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIME_TO_SEC(&#39;22:23:00&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		80580</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TIME_TO_SEC(&#39;00:39:38&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		2378</span></p>
		<ul type="disc">
			<li>
			<span >TO_DAYS(<i>date</i>)
			</span></li>
		</ul>
		<p>
		<span>给定一个日期<i><span>date</span></i><span>,
		</span>返回一个天数 <span>(</span>从年份<span>0</span>开始的天数<span> 
		)</span>。<span> </span></span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TO_DAYS(950501);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		728779</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TO_DAYS(&#39;1997-10-07&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		729669</span></p>
		<p>
		<span >TO_DAYS()
		</span><span>不用于阳历出现<span>(1582)</span>前的值，原因是当日历改变时，遗失的日期不会被考虑在内。请参见</span><a href="functions.html#mysql-calendar" title="12.6. What Calendar Is Used By MySQL?">12.6节，“MySQL使用什么日历？”</a><span >。 
		</span></p>
		<p>
		<span>请记住，<span> 
		MySQL</span>使用</span><a href="column-types.html#date-and-time-types" title="11.3. Date and Time Types">11.3节，“日期和时间类型”</a><span>中的规则将日期中的二位数年份值转化为四位。例如，<span>&nbsp; 
		&#39;1997-10-07&#39;</span>和<span> &#39;97-10-07&#39; </span>被视为同样的日期<span>:
		</span></span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT TO_DAYS(&#39;1997-10-07&#39;), TO_DAYS(&#39;97-10-07&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		729669, 729669</span></p>
		<p>
		<span>对于<span>1582
		</span>年之前的日期<span>(</span>或许在其它地区为下一年<span> ),
		</span>该函数的结果实不可靠的。详见</span><a href="functions.html#mysql-calendar" title="12.6. What Calendar Is Used By MySQL?">12.6节，“MySQL使用什么日历？”</a><span><span>&nbsp;</span>。</span></p>
		<ul type="disc">
			<li>
			<span >
			UNIX_TIMESTAMP(), UNIX_TIMESTAMP(<i>date</i>) </span></li>
		</ul>
		<p>
		<span>若无参数调用，则返回一个<span>Unix 
		timestamp (&#39;1970-01-01 00:00:00&#39; GMT </span>之后的秒数<span>)
		</span>作为无符号整数。若用<i><span>date</span></i><span>
		</span>来调用<span>UNIX_TIMESTAMP()</span>，它会将参数值以<span>&#39;1970-01-01 
		00:00:00&#39; GMT</span>后的秒数的形式返回。<i><span>date</span></i><span>
		</span>可以是一个<span>DATE </span>字符串、一个<span> DATETIME</span>字符串、一个<span> 
		TIMESTAMP</span>或一个当地时间的<span>YYMMDD </span>或<span>YYYMMDD</span>格式的数字。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT UNIX_TIMESTAMP();</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		882226357</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT UNIX_TIMESTAMP(&#39;1997-10-04 22:23:00&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		875996580</span></p>
		<p>
		<span>当<span> 
		UNIX_TIMESTAMP</span>被用在<span> TIMESTAMP</span>列时<span>,
		</span>函数直接返回内部时戳值，<span>&nbsp; </span>而不进行任何隐含的 “<span>string-to-Unix-timestamp</span>”转化。假如你向<span>UNIX_TIMESTAMP()</span>传递一个溢出日期，它会返回<span> 
		0,</span>但请注意只有基本范围检查会被履行<span> (</span>年份从<span>1970
		</span>到<span> 2037</span>， 月份从<span>01</span>到<span>12,</span>日期从<span>&nbsp; 
		01 </span>到<span>31)</span>。</span></p>
		<p>
		<span>假如你想要减去<span> 
		UNIX_TIMESTAMP() </span>列<span>, </span>你或许希望删去带符号整数的结果。请参见</span><a href="functions.html#cast-functions" title="12.8. Cast Functions and Operators">12.8节，“Cast函数和操作符”</a><span>。<span>
		</span></span></p>
		<ul type="disc">
			<li>
			<span >UTC_DATE, 
			UTC_DATE() </span></li>
		</ul>
		<p>
		<span>返回当前<span> 
		UTC</span>日期值，其格式为<span> &#39;YYYY-MM-DD&#39; </span>或<span> 
		YYYYMMDD</span>，具体格式取决于函数是否用在字符串或数字语境中。<span>&nbsp; </span></span>
		</p>
		<p>
		<span >mysql&gt; <b>
		SELECT UTC_DATE(), UTC_DATE() + 0;</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;-&gt; 
		&#39;2003-08-14&#39;, 20030814</span></p>
		<ul type="disc">
			<li>
			<span >UTC_TIME, 
			UTC_TIME() </span></li>
		</ul>
		<p>
		<span>返回当前<span> 
		UTC </span>值，其格式为<span>&nbsp; &#39;HH:MM:SS&#39; </span>或<span>HHMMSS</span>，具体格式根据该函数是否用在字符串或数字语境而定。<span>
		</span></span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT UTC_TIME(), UTC_TIME() + 0;</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;18:07:53&#39;, 180753</span></p>
		<ul type="disc">
			<li>
			<span >
			UTC_TIMESTAMP, UTC_TIMESTAMP() </span></li>
		</ul>
		<p>
		<span>返回当前<span>UTC</span>日期及时间值，格式为<span> 
		&#39;YYYY-MM-DD HH:MM:SS&#39; </span>或<span>YYYYMMDDHHMMSS</span>，具体格式根据该函数是否用在字符串或数字语境而定。<span>
		</span></span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT UTC_TIMESTAMP(), UTC_TIMESTAMP() + 0;</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;2003-08-14 18:08:04&#39;, 20030814180804</span></p>
		<ul type="disc">
			<li>
			<span >WEEK(<i>date</i>[,<i>mode</i>])
			</span></li>
		</ul>
		<p>
		<span>该函数返回<i><span>date</span></i><span>
		</span>对应的星期数。<span>WEEK() </span>的双参数形式允许你指定该星期是否起始于周日或周一， 
		以及返回值的范围是否为从<span>0 </span>到<span>53 </span>或从<span>1
		</span>到<span>53</span>。若 <i><span>mode</span></i>参数被省略，则使用<span>default_week_format</span>系统自变量的值。请参见</span><a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a><span >。 
		</span></p>
		<p>
		<span>以下表说明了<i><span>mode</span></i><span>
		</span>参数的工作过程：<span>d </span></span></p>
		<table border="1" cellpadding="0" id="table7">
			<tr>
				<td>
				<p>
				<span>&nbsp;</span></td>
				<td>
				<p><b>
				<span>第一天 </span></b>
				</td>
				<td>
				<p>
				<span>&nbsp;</span></td>
				<td>
				<p>
				<span>&nbsp;</span></td>
			</tr>
			<tr>
				<td>
				<p><b>
				<span>
				Mode</span></b></td>
				<td>
				<p><b>
				<span>工作日</span></b></td>
				<td>
				<p><b>
				<span>范围</span></b></td>
				<td>
				<p><b>
				<span>
				Week 1 </span><span>
				为第一周<span> ...</span></span></b></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>0</span></td>
				<td>
				<p>
				<span>周日 </span></td>
				<td>
				<p>
				<span>
				0-53</span></td>
				<td>
				<p>
				<span>本年度中有一个周日 
				</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>1</span></td>
				<td>
				<p>
				<span>周一</span></td>
				<td>
				<p>
				<span>
				0-53</span></td>
				<td>
				<p>
				<span>本年度中有<span>3</span>天以上 
				</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>2</span></td>
				<td>
				<p>
				<span>周日</span></td>
				<td>
				<p>
				<span>
				1-53</span></td>
				<td>
				<p>
				<span>本年度中有一个周日</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>3</span></td>
				<td>
				<p>
				<span>周一</span></td>
				<td>
				<p>
				<span>
				1-53</span></td>
				<td>
				<p>
				<span>本年度中有<span>3</span>天以上 
				</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>4</span></td>
				<td>
				<p>
				<span>周日</span></td>
				<td>
				<p>
				<span>
				0-53</span></td>
				<td>
				<p>
				<span>本年度中有<span>3</span>天以上</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>5</span></td>
				<td>
				<p>
				<span>周一</span></td>
				<td>
				<p>
				<span>
				0-53</span></td>
				<td>
				<p>
				<span>本年度中有一个周一 
				</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>6</span></td>
				<td>
				<p>
				<span>周日</span></td>
				<td>
				<p>
				<span>
				1-53</span></td>
				<td>
				<p>
				<span>本年度中有<span>3</span>天以上</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>7</span></td>
				<td>
				<p>
				<span>周一</span></td>
				<td>
				<p>
				<span>
				1-53</span></td>
				<td>
				<p>
				<span>本年度中有一个周一</span></td>
			</tr>
		</table>
		<p>
		<span >mysql&gt; <b>
		SELECT WEEK(&#39;1998-02-20&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 7</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT WEEK(&#39;1998-02-20&#39;,0);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 7</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT WEEK(&#39;1998-02-20&#39;,1);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 8</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT WEEK(&#39;1998-12-31&#39;,1);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 53</span></p>
		<p>
		<span>注意，假如有一个日期位于前一年的最后一周， 
		若你不使用<span>2</span>、<span>3</span>、<span>6</span>或<span>7</span>作为<i><span>mode</span></i><span>
		</span>参数选择，则<span>MySQL</span>返回<span> 0</span>：</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT YEAR(&#39;2000-01-01&#39;), WEEK(&#39;2000-01-01&#39;,0);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		2000, 0</span></p>
		<p>
		<span>有人或许会提出意见，认为<span> 
		MySQL </span>对于<span>WEEK() </span>函数应该返回<span> 52
		</span>，原因是给定的日期实际上发生在<span>1999</span>年的第<span>52</span>周。我们决定返回<span>0</span>作为代替的原因是我们希望该函数能返回“给定年份的星期数”。这使得<span>WEEK()
		</span>函数在同其它从日期中抽取日期部分的函数结合时的使用更加可靠。</span></p>
		<p>
		<span>
		假如你更希望所计算的关于年份的结果包括给定日期所在周的第一天，则应使用<span> 0</span>、<span>2</span>、<span>5</span>或<span> 
		7 </span>作为<i><span>mode</span></i>参数选择。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT WEEK(&#39;2000-01-01&#39;,2);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 52</span></p>
		<p>
		<span>作为选择，可使用<span> 
		YEARWEEK()</span>函数<span>: </span></span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT YEARWEEK(&#39;2000-01-01&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		199952</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT MID(YEARWEEK(&#39;2000-01-01&#39;),5,2);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		&#39;52&#39;</span></p>
		<ul type="disc">
			<li>
			<span >WEEKDAY(<i>date</i>)
			</span></li>
		</ul>
		<p>
		<span>返回<i><span>date</span></i><span> 
		(0 = </span>周一<span>, 1 = </span>周二<span>, ... 6 =
		</span>周日<span>)</span>对应的工作日索引<span>&nbsp; weekday index 
		for </span></span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT WEEKDAY(&#39;1998-02-03 22:23:00&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT WEEKDAY(&#39;1997-11-05&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
		<ul type="disc">
			<li>
			<span >
			WEEKOFYEAR(<i>date</i>) </span></li>
		</ul>
		<p>
		<span>将该日期的阳历周以数字形式返回，范围是从<span>1</span>到<span>53</span>。它是一个兼容度函数，相当于<span>WEEK(<i>date</i>,3)</span>。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT WEEKOFYEAR(&#39;1998-02-20&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 8</span></p>
		<ul type="disc">
			<li>
			<span >YEAR(<i>date</i>)
			</span></li>
		</ul>
		<p>
		<span>返回<i><span>date</span></i><span>
		</span>对应的年份<span>,</span>范围是从<span>1000</span>到<span>9999</span>。</span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT YEAR(&#39;98-02-03&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		1998</span></p>
		<ul type="disc">
			<li>
			<span >YEARWEEK(<i>date</i>), 
			YEARWEEK(<i>date</i>,<i>start</i>) </span></li>
		</ul>
		<p>
		<span>返回一个日期对应的年或周。<i><span>start</span></i>参数的工作同 
		<i><span>start</span></i>参数对<span> WEEK()</span>的工作相同。结果中的年份可以和该年的第一周和最后一周对应的日期参数有所不同。<span>
		</span></span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT YEARWEEK(&#39;1987-01-01&#39;);</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 
		198653</span></p>
		<p>
		<span>注意，周数和<span>WEEK()</span>函数队可选参数<span>0</span>或<span> 
		1</span>可能会返回的<span>(0) w</span>有所不同，原因是此时<span> 
		WEEK() </span>返回给定年份的语境中的周。<span> </span></span></p>
		<div class="itemizedlist">
			<ul type="disc">
				<li>
				<pre class="programlisting">
        -&gt; '1997-10-07'
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="mysql-calendar"></a>
		12.6.&nbsp;MySQL使用什么日历？</h2></div></div></div><a class="indexterm" name="id2877004"></a>
		<p>
		<span >MySQL </span>
		<span>使用通常所说的 <i>
		<span>proleptic </span></i>阳历<i>。</i><span> </span>
		</span></p>
		<p>
		<span>每个将日历由</span><span>朱利安</span><span>改为阳历的国家在改变日历期间都不得不删除至少<span>10</span>天。 
		为了了解其运作，让我们看看<span>1582</span>年<span>10</span>月，这是由</span><span>朱利安</span><span>日历转换为阳历的第一次<span>:
		</span></span></p>
		<table border="1" cellpadding="0" id="table8">
			<tr>
				<td>
				<p>
				<span>周一</span></td>
				<td>
				<p>
				<span>周二</span></td>
				<td>
				<p>
				<span>周三</span></td>
				<td>
				<p>
				<span>周四</span></td>
				<td>
				<p>
				<span>周五</span></td>
				<td>
				<p>
				<span>周六</span></td>
				<td>
				<p>
				<span>周日</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>1</span></td>
				<td>
				<p>
				<span>2</span></td>
				<td>
				<p>
				<span>3</span></td>
				<td>
				<p>
				<span>4</span></td>
				<td>
				<p>
				<span>15</span></td>
				<td>
				<p>
				<span>16</span></td>
				<td>
				<p>
				<span>17</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>18</span></td>
				<td>
				<p>
				<span>19</span></td>
				<td>
				<p>
				<span>20</span></td>
				<td>
				<p>
				<span>21</span></td>
				<td>
				<p>
				<span>22</span></td>
				<td>
				<p>
				<span>23</span></td>
				<td>
				<p>
				<span>24</span></td>
			</tr>
			<tr>
				<td>
				<p>
				<span>25</span></td>
				<td>
				<p>
				<span>26</span></td>
				<td>
				<p>
				<span>27</span></td>
				<td>
				<p>
				<span>28</span></td>
				<td>
				<p>
				<span>29</span></td>
				<td>
				<p>
				<span>30</span></td>
				<td>
				<p>
				<span>31</span></td>
			</tr>
		</table>
		<p>
		<span>在<span>10</span>月<span>4
		</span>日到<span>10</span>月<span>15</span>日之间的日期为空白。这个中断被称为<i>接入</i>。接入前的日期均使用</span><span>朱利安</span><span>日历<span>,
		</span>而接入后的日期均使用阳历。接入期间的日期是不存在的。<span> </span></span></p>
		<p>
		<span>当一个用于日期的日历并为得到实际使用时被称为 
		<i><span>proleptic</span></i>。因此<span>, </span>
		若我们假设从来没有接入期的存在，而阳历历法则始终被使用，我们会有一个预期的阳历 。这就是<span>MySQL </span>
		所使用的，正如标准<span>SQL</span>所要求的。 鉴于这个原因，作为<span>MySQL 
		DATE </span>或<span> DATETIME</span>值而被储存的接入前的日期必须调整这个差异。我们必须明白，接入的发生时间在不同的国家有所不同，而接入的时间越晚，遗失的日期越多。例如，在大不列颠<span>,
		</span>接入发生在<span> 1752</span>年<span>,</span>这时<span>9</span>月<span>2</span>日，周三后的第二天为<span>9</span>月<span>14</span>日，周二； 
		俄罗斯结束使用</span><span>朱利安</span><span>日历的时间为<span>1918</span>年<span>,</span>接入过程中遗失天数为<span> 
		13</span>天<span>, </span>根据阳历，其普遍被称为“<span>10</span>月革命”的发生时间实际上是<span>11</span>月。</span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="fulltext-search"></a>
		12.7.&nbsp;全文搜索功能</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="functions.html#fulltext-boolean">
			12.7.1. 布尔全文搜索</a></span></dt><dt><span class="section"><a href="functions.html#fulltext-query-expansion">
			12.7.2. 全文搜索带查询扩展</a></span></dt><dt><span class="section"><a href="functions.html#fulltext-stopwords">
			12.7.3. 全文停止字</a></span></dt><dt><span class="section"><a href="functions.html#fulltext-restrictions">
			12.7.4. 全文限定条件</a></span></dt><dt><span class="section"><a href="functions.html#fulltext-fine-tuning">
			12.7.5. 微调MySQL全文搜索</a></span></dt>
			<dd>
			<ul type="disc">
				<li>
          <a class="indexterm" name="id2890003"></a>

          		<a class="indexterm">MATCH (col1,col2,...) AGAINST (expr [IN 
				BOOLEAN MODE | WITH QUERY EXPANSION]) </a>

          		</li>
			</ul>
			<p>
			<span >MySQL</span><span>支持全文索引和搜索功能。<span>MySQL</span>中的全文索引类型<span>FULLTEXT</span>的索引。<span>&nbsp; 
			FULLTEXT </span>索引仅可用于<span> MyISAM </span>表；他们可以从<span>CHAR</span>、<span> 
			VARCHAR</span>或<span>TEXT</span>列中作为<span>CREATE 
			TABLE</span>语句的一部分被创建，或是随后使用<span>ALTER TABLE </span>或<span> 
			CREATE INDEX</span>被添加。对于较大的数据集，将你的资料输入一个没有<span>FULLTEXT</span>索引的表中，然后创建索引， 
			其速度比把资料输入现有<span>FULLTEXT</span>索引的速度更为快。</span></p>
			<p>
			<span>关于全文搜索的限制列表，请参见 
			</span>
          <a href="functions.html#fulltext-restrictions" title="12.7.4. Full-Text Restrictions">
			12.7.4节，“全文限定条件”</a><span >.
			</span></p>
			<p>
			<span>全文搜索同<span>MATCH()</span>函数一起执行。<span>&nbsp;
			</span></span></dd>
			</dl></div>
		<pre><span>mysql&gt; </span><span><b><span>CREATE TABLE articles (</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp; </span><span><b><span>id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp; </span><span><b><span>title VARCHAR(200),</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp; </span><span><b><span>body TEXT,</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp; </span><span><b><span>FULLTEXT (title,body)</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>);</span></b></span></pre>
		<pre><span>Query OK, 0 rows affected (0.00 sec)</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>mysql&gt; </span><span><b><span>INSERT INTO articles (title,body) VALUES</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>(&#39;MySQL Tutorial&#39;,&#39;DBMS stands for DataBase ...&#39;),</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>(&#39;How To Use MySQL Well&#39;,&#39;After you went through a ...&#39;),</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>(&#39;Optimizing MySQL&#39;,&#39;In this tutorial we will show ...&#39;),</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>(&#39;1001 MySQL Tricks&#39;,&#39;1. Never run mysqld as root. 2. ...&#39;),</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>(&#39;MySQL vs. YourSQL&#39;,&#39;In the following database comparison ...&#39;),</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>(&#39;MySQL Security&#39;,&#39;When configured properly, MySQL ...&#39;);</span></b></span></pre>
		<pre><span>Query OK, 6 rows affected (0.00 sec)</span></pre>
		<pre><span>Records: 6&nbsp; Duplicates: 0 &nbsp;Warnings: 0</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>mysql&gt; </span><span><b><span>SELECT * FROM articles</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>WHERE MATCH (title,body) AGAINST (&#39;database&#39;);</span></b></span></pre>
		<pre><span>+----+-------------------+------------------------------------------+</span></pre>
		<pre><span>| id | title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | body&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
		<pre><span>+----+-------------------+------------------------------------------+</span></pre>
		<pre><span>|&nbsp; 5 | MySQL vs. YourSQL | In the following database comparison ... |</span></pre>
		<pre><span>|&nbsp; 1 | MySQL Tutorial&nbsp;&nbsp;&nbsp; | DBMS stands for DataBase ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
		<pre><span>+----+-------------------+------------------------------------------+</span></pre>
		<pre><span>2 rows in set (0.00 sec)</span></pre>
		<p>
		<span >MATCH()</span><span>函数对于一个字符串执行资料库内的自然语言搜索。一个资料库就是<span>1</span>套<span>1</span>个或<span>2</span>个包含在<span>FULLTEXT</span>内的列。搜索字符串作为对<span>AGAINST()</span>的参数而被给定。对于表中的每一行<span>, 
		MATCH() </span>返回一个相关值，即<span>, </span>搜索字符串和<span> 
		MATCH()</span>表中指定列中该行文字之间的一个相似性度量。</span></p>
		<p>
		<span>在默认状态下<span>,
		</span>搜索的执行方式为不区分大小写方式。然而<span>,</span>你可以通过对编入索引的列使用二进制排序方式执行区分大小写的全文搜索。</span><span>
		</span><span>例如，可以向一个使用<span>latin1</span>字符集的列给定</span><span>latin1_bin</span><span>
		</span><span>
		的排序方式，对于全文搜索区分大小写。</span></p>
		<p>
		<span>如上述所举例子，当</span><span>MATCH()</span><span>被用在一个</span><span>
		</span>
		<span>WHERE </span><span>
		语句中时，相关值是非负浮点数。零相关的意思是没有相似性。相关性的计算是基于该行中单词的数目<span>, </span>
		该行中独特子的数目，资料库中单词的总数，以及包含特殊词的文件<span>(</span>行<span>)</span>数目。</span></p>
		<p>
		<span>对于自然语言全文搜索，要求<span>MATCH()
		</span>函数中命名的列和你的表中一些<span>FULLTEXT</span>索引中包含的列相同。对于前述问讯， 
		注意，<span>MATCH()</span>函数<span>(</span>题目及全文<span>)</span>中所命名的列和文章表的<span>FULLTEXT</span>索引中的列相同。若要分别搜索题目和全文，应该对每个列创建<span>FULLTEXT</span>索引。<span>
		</span></span></p>
		<p>
		<span>
		或者也可以运行布尔搜索或使用查询扩展进行搜索。关于这些搜索类型的说明见</span><a href="functions.html#fulltext-boolean" title="12.7.1. Boolean Full-Text Searches">12.7.1节，“布尔全文搜索”</a><span>和</span><a href="functions.html#fulltext-query-expansion" title="12.7.2. Full-Text Searches with Query Expansion">12.7.2节，“全文搜索带查询扩展”</a><span>。 
		</span></p>
		<p>
		<span>
		上面的例子基本上展示了怎样使用返回行的相关性顺序渐弱的<span>MATCH()</span>函数。而下面的例子则展示了怎样明确地检索相关值。返回行的顺序是不定的，原因是<span>&nbsp; 
		SELECT </span>语句不包含<span> WHERE</span>或<span>ORDER 
		BY </span>子句：<span> </span></span></p>
		<pre><span>mysql&gt; </span><span><b><span>SELECT id, MATCH (title,body) AGAINST (&#39;Tutorial&#39;)</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>FROM articles;</span></b></span></pre>
		<pre><span>+----+-----------------------------------------+</span></pre>
		<pre><span>| id | MATCH (title,body) AGAINST (&#39;Tutorial&#39;) |</span></pre>
		<pre><span>+----+-----------------------------------------+</span></pre>
		<pre><span>|&nbsp; 1 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.65545833110809 |</span></pre>
		<pre><span>|&nbsp; 2 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
		<pre><span>|&nbsp; 3 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.66266459226608 |</span></pre>
		<pre><span>|&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
		<pre><span>|&nbsp; 5 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
		<pre><span>|&nbsp; 6 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
		<pre><span>+----+-----------------------------------------+</span></pre>
		<pre><span>6 rows in set (0.00 sec)</span></pre>
		<p>
		<span>
		下面的例子则更加复杂。询问返回相关值，同时对行按照相关性渐弱的顺序进行排序。为实现这个结果，你应该两次指定<span> 
		MATCH()</span>： 一次在<span> SELECT </span>列表中而另一次在<span> 
		WHERE</span>子句中。这不会引起额外的内务操作，原因是<span>MySQL </span>优化程序注意到两个<span>MATCH()</span>调用是相同的，从而只会激活一次全文搜索代码。<span>&nbsp;
		</span></span></p>
		<pre><span>mysql&gt; </span><span><b><span>SELECT id, body, MATCH (title,body) AGAINST</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>(&#39;Security implications of running MySQL as root&#39;) AS score</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>FROM articles WHERE MATCH (title,body) AGAINST</span></b></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>(&#39;Security implications of running MySQL as root&#39;);</span></b></span></pre>
		<pre><span>+----+-------------------------------------+-----------------+</span></pre>
		<pre><span>| id | body&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | score&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
		<pre><span>+----+-------------------------------------+-----------------+</span></pre>
		<pre><span>|&nbsp; 4 | 1. Never run mysqld as root. 2. ... | 1.5219271183014 |</span></pre>
		<pre><span>|&nbsp; 6 | When configured properly, MySQL ... | 1.3114095926285 |</span></pre>
		<pre><span>+----+-------------------------------------+-----------------+</span></pre>
		<pre><span>2 rows in set (0.00 sec)</span></pre>
		<p>
		<span>表中有<span>2</span>行<span>(0.00
		</span>秒<span>)</span></span></p>
		<p>
		<span >MySQL 
		FULLTEXT </span><span>
		执行将任何单字字符原形<span> (</span>字母、数字和下划线部分<span>)</span>的序列视为一个单词。这个序列或许也包含单引号<span> 
		(&#39;),</span>但在一行中不会超过一个。 这意味着<span> aaa&#39;bbb </span>会被视为一个单词，而<span> 
		aaa&#39;&#39;bbb</span>则被视为<span>2</span>个单词。位于单词之前或其后的单引号会被<span>FULLTEXT</span>分析程序去掉；<span> 
		&#39;aaa&#39;bbb&#39; </span>会变成<span>&nbsp;&nbsp; aaa&#39;bbb</span>。</span></p>
		<p>
		<span >FULLTEXT</span><span>分析程序会通过寻找某些分隔符来确定单词的起始位置和结束位置，例如<span>&#39; 
		&#39; (</span>间隔符号<span>)</span>、<span> , (</span>逗号<span>)</span>以及<span> 
		. (</span>句号 <span>)</span>。假如单词没有被分隔符分开，<span>(</span>例如在中文里<span> 
		), </span>则<span> FULLTEXT </span>
		分析程序不能确定一个词的起始位置和结束位置。为了能够在这样的语言中向<span>FULLTEXT </span>
		索引添加单词或其它编入索引的术语，你必须对它们进行预处理，使其被一些诸如<span>&quot;</span>之类的任意分隔符分隔开。<span>
		</span></span></p>
		<p>
		<span>一些词在全文搜索中会被忽略：<span>&nbsp;
		</span></span></p>
		<ul type="disc">
			<li>
			<span>任何过于短的词都会被忽略。 
			全文搜索所能找到的词的默认最小长度为<span> 4</span>个字符。<span>
			</span></span></li>
			<li>
			<span>
			停止字中的词会被忽略。禁用词就是一个像“<span>the</span>” 或“<span>some</span>” 
			这样过于平常而被认为是不具语义的词。存在一个内置的停止字， 但它可以通过用户自定义列表被改写。请参见</span><a href="functions.html#fulltext-fine-tuning" title="12.7.5. Fine-Tuning MySQL Full-Text Search">12.7.5节，“微调MySQL全文搜索”</a><span>。</span></li>
		</ul>
		<p>
		<span>默认的停止字在</span><a href="functions.html#fulltext-stopwords" title="12.7.3. Full-Text Stopwords">12.7.3节，“全文停止字”</a><span>中被给出。默认的最小单词长度和
		停止字可以被改变，如</span><a href="functions.html#fulltext-fine-tuning" title="12.7.5. Fine-Tuning MySQL Full-Text Search">12.7.5节，“微调MySQL全文搜索”</a><span>中所述。</span></p>
		<p>
		<span>
		词库和询问中每一个正确的单词根据其在词库和询问中的重要性而被衡量。<span>&nbsp; </span>
		通过这种方式，一个出现在许多文件中的单词具有较低的重要性<span>(</span>而且甚至很多单词的重要性为零<span>),</span>原因是在这个特别词库中其语义价值较低。反之，假如这个单词比较少见，那么它会得到一个较高的重要性。然后单词的重要性被组合，从而用来计算该行的相关性。<span>&nbsp;
		</span></span></p>
		<p>
		<span>这项技术最适合同大型词库一起使用<span> 
		(</span>事实上<span>, </span>此时它经过仔细的调整<span> )</span>。对于很小的表，单词分布并不能充分反映它们的语义价值， 
		而这个模式有时可能会产生奇特的结果。例如<span>, </span>虽然单词 “<span>MySQL</span>” 
		出现在文章表中的每一行，但对这个词的搜索可能得不到任何结果：<span> </span></span></p>
		<p>
		<span >mysql&gt; <b>
		SELECT * FROM articles</b></span></p>
		<p>
		<span >&nbsp;&nbsp;&nbsp; -&gt; <b>
		WHERE MATCH (title,body) AGAINST (&#39;MySQL&#39;);</b></span></p>
		<p>
		<span>找不到搜索的词<span>(0.00
		</span>秒<span>)</span></span></p>
		<p>
		<span>这个搜索的结果为空，原因是单词 “<span>MySQL</span>” 
		出现在至少全文的<span>50%</span>的行中。 因此<span>, </span>
		它被列入停止字。对于大型数据集，使用这个操作最合适不过了<span>----</span>一个自然语言问询不会从一个<span>1GB
		</span>的表每隔一行返回一次。对于小型数据集，它的用处可能比较小。<span> </span></span></p>
		<p>
		<span>
		一个符合表中所有行的内容的一半的单词查找相关文档的可能性较小。事实上<span>, </span>
		它更容易找到很多不相关的内容。我们都知道，当我们在因特网上试图使用搜索引擎寻找资料的时候，这种情况发生的频率颇高。可以推论，包含该单词的行因<i>其所在特别数据集 
		</i>而被赋予较低的语义价值。 一个给定的词有可能在一个数据集中拥有超过其<span>50%</span>的域值，而在另一个数据集却不然。<span>&nbsp;
		</span></span></p>
		<p>
		<span>
		当你第一次尝试使用全文搜索以了解其工作过程时，这个<span>50% </span>
		的域值提供重要的蕴涵操作：若你创建了一个表，并且只将文章的<span>1</span>、<span>2</span>行插入其中， 
		而文中的每个单词在所有行中出现的机率至少为<span>&nbsp; 50% </span>
		。那么结果是你什么也不会搜索到。一定要插入至少<span>3</span>行，并且多多益善。需要绕过该<span>50%
		</span>限制的用户可使用布尔搜索代码；见</span><a href="functions.html#fulltext-boolean" title="12.7.1. Boolean Full-Text Searches">12.7.1节，“布尔全文搜索”</a><span>。</span></p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fulltext-boolean"></a>
			12.7.1.&nbsp;布尔全文搜索</h3></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			<p>
			<span>利用<span>IN 
			BOOLEAN MODE</span>修改程序，<span> MySQL </span>也可以执行布尔全文搜索：</span></p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT * FROM articles WHERE MATCH (title,body)</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>AGAINST (&#39;+MySQL -YourSQL&#39; IN BOOLEAN MODE);</span></b></span></pre>
			<pre><span>+----+-----------------------+-------------------------------------+</span></pre>
			<pre><span>| id | title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | body&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+----+-----------------------+-------------------------------------+</span></pre>
			<pre><span>|&nbsp; 1 | MySQL Tutorial&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | DBMS stands for DataBase ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>|&nbsp; 2 | How To Use MySQL Well | After you went through a ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>|&nbsp; 3 | Optimizing MySQL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | In this tutorial we will show ...&nbsp;&nbsp; |</span></pre>
			<pre><span>|&nbsp; 4 | 1001 MySQL Tricks&nbsp;&nbsp;&nbsp;&nbsp; | 1. Never run mysqld as root. 2. ... |</span></pre>
			<pre><span>|&nbsp; 6 | MySQL Security&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | When configured properly, MySQL ... |</span></pre>
			<pre><span>+----+-----------------------+-------------------------------------+</span></pre>
			<p>
			<span>这个问询检索所有包含单词“<span>MySQL</span>”的行，但<i>不</i>检索包含单词“<span>YourSQL</span>”的行。</span></p>
			<p>
			<span>布尔全文搜索具有以下特点：<span>
			</span></span></p>
			<ul type="disc">
				<li>
				<span>它们不使用<span> 
				50% </span>域值。<span>. </span></span></li>
				<li>
				<span>
				它们不会按照相关性渐弱的顺序将行进行分类。你可以从上述问询结果中看到这一点：相关性最高的行是一个包含两个“<span>MySQL</span>” 
				的行，但它被列在最后的位置，而不是开头位置。<span> </span></span></li>
				<li>
				<span>即使没有<span>FULLTEXT</span>，它们仍然可以工作，尽管这种方式的搜索执行的速度非常之慢。<span>
				</span></span></li>
				<li>
				<span>
				最小单词长度全文参数和最大单词长度全文参数均适用。<span> </span></span></li>
				<li>
				<span>停止字适用。</span></li>
			</ul>
			<p>
			<span>布尔全文搜索的性能支持以下操作符：<span>&nbsp;
			</span></span></p>
			<ul type="disc">
				<li>
				<span >+
				</span></li>
			</ul>
			<p>
			<span>一个前导的加号表示该单词<i>必须</i> 
			出现在返回的每一行的开头位置。<span> </span></span></p>
			<ul type="disc">
				<li>
				<span >-
				</span></li>
			</ul>
			<p>
			<span>一个前导的减号表示该单词<i>一定不能</i>出现在任何返回的行中。<span>
			</span></span></p>
			<ul type="disc">
				<li>
				<span >(</span><span>无操作符<span>)
				</span></span></li>
			</ul>
			<p>
			<span>在默认状态下<span>(</span>当没有指定<span> 
			+ </span>或–的情况下<span>)</span>，该单词可有可无，但含有该单词的行等级较高。这和<span>MATCH() 
			... AGAINST()</span>不使用<span>IN BOOLEAN MODE</span>修改程序时的运作很类似。<span>&nbsp;&nbsp;
			</span></span></p>
			<ul type="disc">
				<li>
				<span >&gt; &lt;
				</span></li>
			</ul>
			<p>
			<span>
			这两个操作符用来改变一个单词对赋予某一行的相关值的影响。<span> &gt; </span>操作符增强其影响，而<span> 
			&lt;</span>操作符则减弱其影响。请参见下面的例子。<span>&nbsp; </span></span></p>
			<ul type="disc">
				<li>
				<span >( )
				</span></li>
			</ul>
			<p>
			<span>
			括号用来将单词分成子表达式。括入括号的部分可以被嵌套。<span> </span></span></p>
			<ul type="disc">
				<li>
				<span >~
				</span></li>
			</ul>
			<p>
			<span>一个前导的代字号用作否定符， 
			用来否定单词对该行相关性的影响。 这对于标记“<span>noise</span>（无用信息）”的单词很有用。包含这类单词的行较其它行等级低，但因其可能会和<span>-</span>号同时使用，因而不会在任何时候都派出所有无用信息行。</span></p>
			<ul type="disc">
				<li>
				<span >*
				</span></li>
			</ul>
			<p>
			<span>
			星号用作截断符。于其它符号不同的是，它应当被<i>追加</i>到要截断的词上。<span> </span>
			</span></p>
			<ul type="disc">
				<li>
				<span >&quot;
				</span></li>
			</ul>
			<p>
			<span>一个被括入双引号的短语<span> 
			(</span>‘<span>&quot;</span>’<span>) </span>只和<i>字面上</i>包含该短语<i>输入格式</i>的行进行匹配。全文引擎将短语拆分成单词，在<span>FULLTEXT</span>索引中搜索该单词。<span>&nbsp;&nbsp;
			</span>非单词字符不需要严密的匹配：短语搜索只要求符合搜索短语包含的单词且单词的排列顺序相同的内容。例如，<span> 
			&quot;test phrase&quot; </span>符合<span> &quot;test, phrase&quot;</span>。<span>
			</span></span></p>
			<p>
			<span>
			若索引中不存在该短语包含的单词，则结果为空。例如，若所有单词都是禁用词，或是长度都小于编入索引单词的最小长度，则结果为空。<span>
			</span></span></p>
			<p>
			<span>
			以下例子展示了一些使用布尔全文符号的搜索字符串：</span></p>
			<ul type="disc">
				<li>
				<span >
				&#39;apple banana&#39; </span></li>
			</ul>
			<p>
			<span>寻找包含至少两个单词中的一个的行。<span>
			</span></span></p>
			<ul type="disc">
				<li>
				<span >
				&#39;+apple +juice&#39; </span></li>
			</ul>
			<p>
			<span>寻找两个单词都包含的行。<span>
			</span></span></p>
			<ul type="disc">
				<li>
				<span >
				&#39;+apple macintosh&#39; </span></li>
			</ul>
			<p>
			<span>寻找包含单词“<span>apple</span>”的行，若这些行也包含单词“<span>macintosh</span>”， 
			则列为更高等级。<span> </span></span></p>
			<ul type="disc">
				<li>
				<span >
				&#39;+apple -macintosh&#39; </span></li>
			</ul>
			<p>
			<span>寻找包含单词“<span>apple</span>” 
			但不包含单词 “<span>macintosh</span>”的行。<span> </span>
			</span></p>
			<ul type="disc">
				<li>
				<span >
				&#39;+apple +(&gt;turnover &lt;strudel)&#39; </span></li>
			</ul>
			<p>
			<span>寻找包含单词“<span>apple</span>”和“<span>turnover</span>” 
			的行，或包含“<span>apple</span>” 和“<span>strudel</span>”的行<span> 
			(</span>无先后顺序<span>),</span>然而包含 “<span>apple 
			turnover</span>”的行较包含“<span>apple strudel</span>”的行排列等级更为高。</span></p>
			<ul type="disc">
				<li>
				<span >
				&#39;apple*&#39; </span></li>
			</ul>
			<p>
			<span>寻找包含“<span>apple</span>”、“<span>apples</span>”、“<span>applesauce</span>”或“<span>applet</span>”的行。</span></p>
			<ul type="disc">
				<li>
				<span >
				&#39;&quot;some words&quot;&#39; </span></li>
			</ul>
			<p>
			<span>寻找包含原短语“<span>some 
			words</span>”的行<span> (</span>例如<span>,</span>包含“<span>some 
			words of wisdom</span>” 的行，而非包含<span>&nbsp; </span>“<span>some 
			noise words</span>”的行<span>)</span>。注意包围词组的‘<span>&quot;</span>’ 
			符号是界定短语的操作符字符。它们不是包围搜索字符串本身的引号。</span></p>
			<h3 class="title"><a name="fulltext-query-expansion"></a>
			12.7.2.&nbsp;全文搜索带查询扩展</h3></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			<p>
			<span>全文搜索支持查询扩展功能<span> 
			(</span>特别是其多变的“盲查询扩展功能”<span> )</span>。若搜索短语的长度过短<span>,
			</span>那么用户则需要依靠全文搜索引擎通常缺乏的</span><span>内隐知识进行查询</span><span>。这时，查询扩展功能通常很有用。例如<span>,
			</span>某位搜索 “<span>database</span>” 一词的用户，可能认为“<span>MySQL</span>”、“<span>Oracle</span>”、“<span>DB2<span>”</span> 
			and </span>“<span>RDBMS</span>”均为符合 “<span>databases</span>”的项，因此都应被返回。这既为内隐知识。 
			</span></p>
			<p>
			<span>在下列搜索短语后添加<span>WITH 
			QUERY EXPANSION</span>，激活盲查询扩展功能<span>(</span>即通常所说的自动相关性反馈<span>)</span>。它将执行两次搜索，其中第二次搜索的搜索短语是同第一次搜索时找到的少数顶层文件连接的原始搜索短语。这样<span>,</span>假如这些文件中的一个 
			含有单词 “<span>databases</span>” 以及单词 “<span>MySQL</span>”<span>,
			</span>则第二次搜索会寻找含有单词“<span>MySQL</span>” 的文件，即使这些文件不包含单词 “<span>database</span>”。下面的例子显示了这个不同之处：</span></p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT * FROM articles</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>WHERE MATCH (title,body) AGAINST (&#39;database&#39;);</span></b></span></pre>
			<pre><span>+----+-------------------+------------------------------------------+</span></pre>
			<pre><span>| id | title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | body&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+----+-------------------+------------------------------------------+</span></pre>
			<pre><span>|&nbsp; 5 | MySQL vs. YourSQL | In the following database comparison ... |</span></pre>
			<pre><span>|&nbsp; 1 | MySQL Tutorial&nbsp;&nbsp;&nbsp; | DBMS stands for DataBase ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+----+-------------------+------------------------------------------+</span></pre>
			<pre><span>2 rows in set (0.00 sec)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT * FROM articles</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>WHERE MATCH (title,body)</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>AGAINST (&#39;database&#39; WITH QUERY EXPANSION);</span></b></span></pre>
			<pre><span>+----+-------------------+------------------------------------------+</span></pre>
			<pre><span>| id | title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | body&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+----+-------------------+------------------------------------------+</span></pre>
			<pre><span>|&nbsp; 1 | MySQL Tutorial&nbsp;&nbsp;&nbsp; | DBMS stands for DataBase ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>|&nbsp; 5 | MySQL vs. YourSQL | In the following database comparison ... |</span></pre>
			<pre><span>|&nbsp; 3 | Optimizing MySQL&nbsp; | In this tutorial we will show ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+----+-------------------+------------------------------------------+</span></pre>
			<pre><span>3 rows in set (0.00 sec)</span></pre>
			<p>
			<span>另一个例子是<span>Georges 
			Simenon </span>搜索关于<span>Maigret</span>的书籍<span>,
			</span>这个用户不确定“<span>Maigret</span>”一词的拼法。若不使用查询扩展而搜索“<span>Megre 
			and the reluctant witnesses</span>” 得到的结果只能是的“<span>Maigret 
			and the Reluctant Witnesses</span>” 。 而带有查询扩展的搜索会在第二遍得到带有“<span>Maigret</span>”一词的所有书名。</span></p>
			<b><span>注释</span></b><span >：&nbsp;
			</span><span>
			盲查询扩展功能很容易返回非相关文件而增加无用信息，因此只有在查询一个长度很短的短语时才有必要使用这项功能。</span><h3 class="title"><a name="fulltext-stopwords"></a>
			12.7.3.&nbsp;全文停止字</h3></div></div></div><div class="informaltable">
				<p>
				<span>
				以下表列出了默认的全文停止字：<span>&nbsp; </span></span></p>
				<table border="1"><colgroup><col><col><col><col><col></colgroup><tbody><tr><td>a's</td><td>able</td><td>about</td><td>above</td><td>according</td></tr><tr><td>accordingly</td><td>across</td><td>actually</td><td>after</td><td>afterwards</td></tr><tr><td>again</td><td>against</td><td>ain't</td><td>all</td><td>allow</td></tr><tr><td>allows</td><td>almost</td><td>alone</td><td>along</td><td>already</td></tr><tr><td>also</td><td>although</td><td>always</td><td>am</td><td>among</td></tr><tr><td>amongst</td><td>an</td><td>and</td><td>another</td><td>any</td></tr><tr><td>anybody</td><td>anyhow</td><td>anyone</td><td>anything</td><td>anyway</td></tr><tr><td>anyways</td><td>anywhere</td><td>apart</td><td>appear</td><td>appreciate</td></tr><tr><td>appropriate</td><td>are</td><td>aren't</td><td>around</td><td>as</td></tr><tr><td>aside</td><td>ask</td><td>asking</td><td>associated</td><td>at</td></tr><tr><td>available</td><td>away</td><td>awfully</td><td>be</td><td>became</td></tr><tr><td>because</td><td>become</td><td>becomes</td><td>becoming</td><td>been</td></tr><tr><td>before</td><td>beforehand</td><td>behind</td><td>being</td><td>believe</td></tr><tr><td>below</td><td>beside</td><td>besides</td><td>best</td><td>better</td></tr><tr><td>between</td><td>beyond</td><td>both</td><td>brief</td><td>but</td></tr><tr><td>by</td><td>c'mon</td><td>c's</td><td>came</td><td>can</td></tr><tr><td>can't</td><td>cannot</td><td>cant</td><td>cause</td><td>causes</td></tr><tr><td>certain</td><td>certainly</td><td>changes</td><td>clearly</td><td>co</td></tr><tr><td>com</td><td>come</td><td>comes</td><td>concerning</td><td>consequently</td></tr><tr><td>consider</td><td>considering</td><td>contain</td><td>containing</td><td>contains</td></tr><tr><td>corresponding</td><td>could</td><td>couldn't</td><td>course</td><td>currently</td></tr><tr><td>definitely</td><td>described</td><td>despite</td><td>did</td><td>didn't</td></tr><tr><td>different</td><td>do</td><td>does</td><td>doesn't</td><td>doing</td></tr><tr><td>don't</td><td>done</td><td>down</td><td>downwards</td><td>during</td></tr><tr><td>each</td><td>edu</td><td>eg</td><td>eight</td><td>either</td></tr><tr><td>else</td><td>elsewhere</td><td>enough</td><td>entirely</td><td>especially</td></tr><tr><td>et</td><td>etc</td><td>even</td><td>ever</td><td>every</td></tr><tr><td>everybody</td><td>everyone</td><td>everything</td><td>everywhere</td><td>ex</td></tr><tr><td>exactly</td><td>example</td><td>except</td><td>far</td><td>few</td></tr><tr><td>fifth</td><td>first</td><td>five</td><td>followed</td><td>following</td></tr><tr><td>follows</td><td>for</td><td>former</td><td>formerly</td><td>forth</td></tr><tr><td>four</td><td>from</td><td>further</td><td>furthermore</td><td>get</td></tr><tr><td>gets</td><td>getting</td><td>given</td><td>gives</td><td>go</td></tr><tr><td>goes</td><td>going</td><td>gone</td><td>got</td><td>gotten</td></tr><tr><td>greetings</td><td>had</td><td>hadn't</td><td>happens</td><td>hardly</td></tr><tr><td>has</td><td>hasn't</td><td>have</td><td>haven't</td><td>having</td></tr><tr><td>he</td><td>he's</td><td>hello</td><td>help</td><td>hence</td></tr><tr><td>her</td><td>here</td><td>here's</td><td>hereafter</td><td>hereby</td></tr><tr><td>herein</td><td>hereupon</td><td>hers</td><td>herself</td><td>hi</td></tr><tr><td>him</td><td>himself</td><td>his</td><td>hither</td><td>hopefully</td></tr><tr><td>how</td><td>howbeit</td><td>however</td><td>i'd</td><td>i'll</td></tr><tr><td>i'm</td><td>i've</td><td>ie</td><td>if</td><td>ignored</td></tr><tr><td>immediate</td><td>in</td><td>inasmuch</td><td>inc</td><td>indeed</td></tr><tr><td>indicate</td><td>indicated</td><td>indicates</td><td>inner</td><td>insofar</td></tr><tr><td>instead</td><td>into</td><td>inward</td><td>is</td><td>isn't</td></tr><tr><td>it</td><td>it'd</td><td>it'll</td><td>it's</td><td>its</td></tr><tr><td>itself</td><td>just</td><td>keep</td><td>keeps</td><td>kept</td></tr><tr><td>know</td><td>knows</td><td>known</td><td>last</td><td>lately</td></tr><tr><td>later</td><td>latter</td><td>latterly</td><td>least</td><td>less</td></tr><tr><td>lest</td><td>let</td><td>let's</td><td>like</td><td>liked</td></tr><tr><td>likely</td><td>little</td><td>look</td><td>looking</td><td>looks</td></tr><tr><td>ltd</td><td>mainly</td><td>many</td><td>may</td><td>maybe</td></tr><tr><td>me</td><td>mean</td><td>meanwhile</td><td>merely</td><td>might</td></tr><tr><td>more</td><td>moreover</td><td>most</td><td>mostly</td><td>much</td></tr><tr><td>must</td><td>my</td><td>myself</td><td>name</td><td>namely</td></tr><tr><td>nd</td><td>near</td><td>nearly</td><td>necessary</td><td>need</td></tr><tr><td>needs</td><td>neither</td><td>never</td><td>nevertheless</td><td>new</td></tr><tr><td>next</td><td>nine</td><td>no</td><td>nobody</td><td>non</td></tr><tr><td>none</td><td>noone</td><td>nor</td><td>normally</td><td>not</td></tr><tr><td>nothing</td><td>novel</td><td>now</td><td>nowhere</td><td>obviously</td></tr><tr><td>of</td><td>off</td><td>often</td><td>oh</td><td>ok</td></tr><tr><td>okay</td><td>old</td><td>on</td><td>once</td><td>one</td></tr><tr><td>ones</td><td>only</td><td>onto</td><td>or</td><td>other</td></tr><tr><td>others</td><td>otherwise</td><td>ought</td><td>our</td><td>ours</td></tr><tr><td>ourselves</td><td>out</td><td>outside</td><td>over</td><td>overall</td></tr><tr><td>own</td><td>particular</td><td>particularly</td><td>per</td><td>perhaps</td></tr><tr><td>placed</td><td>please</td><td>plus</td><td>possible</td><td>presumably</td></tr><tr><td>probably</td><td>provides</td><td>que</td><td>quite</td><td>qv</td></tr><tr><td>rather</td><td>rd</td><td>re</td><td>really</td><td>reasonably</td></tr><tr><td>regarding</td><td>regardless</td><td>regards</td><td>relatively</td><td>respectively</td></tr><tr><td>right</td><td>said</td><td>same</td><td>saw</td><td>say</td></tr><tr><td>saying</td><td>says</td><td>second</td><td>secondly</td><td>see</td></tr><tr><td>seeing</td><td>seem</td><td>seemed</td><td>seeming</td><td>seems</td></tr><tr><td>seen</td><td>self</td><td>selves</td><td>sensible</td><td>sent</td></tr><tr><td>serious</td><td>seriously</td><td>seven</td><td>several</td><td>shall</td></tr><tr><td>she</td><td>should</td><td>shouldn't</td><td>since</td><td>six</td></tr><tr><td>so</td><td>some</td><td>somebody</td><td>somehow</td><td>someone</td></tr><tr><td>something</td><td>sometime</td><td>sometimes</td><td>somewhat</td><td>somewhere</td></tr><tr><td>soon</td><td>sorry</td><td>specified</td><td>specify</td><td>specifying</td></tr><tr><td>still</td><td>sub</td><td>such</td><td>sup</td><td>sure</td></tr><tr><td>t's</td><td>take</td><td>taken</td><td>tell</td><td>tends</td></tr><tr><td>th</td><td>than</td><td>thank</td><td>thanks</td><td>thanx</td></tr><tr><td>that</td><td>that's</td><td>thats</td><td>the</td><td>their</td></tr><tr><td>theirs</td><td>them</td><td>themselves</td><td>then</td><td>thence</td></tr><tr><td>there</td><td>there's</td><td>thereafter</td><td>thereby</td><td>therefore</td></tr><tr><td>therein</td><td>theres</td><td>thereupon</td><td>these</td><td>they</td></tr><tr><td>they'd</td><td>they'll</td><td>they're</td><td>they've</td><td>think</td></tr><tr><td>third</td><td>this</td><td>thorough</td><td>thoroughly</td><td>those</td></tr><tr><td>though</td><td>three</td><td>through</td><td>throughout</td><td>thru</td></tr><tr><td>thus</td><td>to</td><td>together</td><td>too</td><td>took</td></tr><tr><td>toward</td><td>towards</td><td>tried</td><td>tries</td><td>truly</td></tr><tr><td>try</td><td>trying</td><td>twice</td><td>two</td><td>un</td></tr><tr><td>under</td><td>unfortunately</td><td>unless</td><td>unlikely</td><td>until</td></tr><tr><td>unto</td><td>up</td><td>upon</td><td>us</td><td>use</td></tr><tr><td>used</td><td>useful</td><td>uses</td><td>using</td><td>usually</td></tr><tr><td>value</td><td>various</td><td>very</td><td>via</td><td>viz</td></tr><tr><td>vs</td><td>want</td><td>wants</td><td>was</td><td>wasn't</td></tr><tr><td>way</td><td>we</td><td>we'd</td><td>we'll</td><td>we're</td></tr><tr><td>we've</td><td>welcome</td><td>well</td><td>went</td><td>were</td></tr><tr><td>weren't</td><td>what</td><td>what's</td><td>whatever</td><td>when</td></tr><tr><td>whence</td><td>whenever</td><td>where</td><td>where's</td><td>whereafter</td></tr><tr><td>whereas</td><td>whereby</td><td>wherein</td><td>whereupon</td><td>wherever</td></tr><tr><td>whether</td><td>which</td><td>while</td><td>whither</td><td>who</td></tr><tr><td>who's</td><td>whoever</td><td>whole</td><td>whom</td><td>whose</td></tr><tr><td>why</td><td>will</td><td>willing</td><td>wish</td><td>with</td></tr><tr><td>within</td><td>without</td><td>won't</td><td>wonder</td><td>would</td></tr><tr><td>would</td><td>wouldn't</td><td>yes</td><td>yet</td><td>you</td></tr><tr><td>you'd</td><td>you'll</td><td>you're</td><td>you've</td><td>your</td></tr><tr><td>yours</td><td>yourself</td><td>yourselves</td><td>zero</td><td> </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fulltext-restrictions"></a>
		12.7.4.&nbsp;全文限定条件</h3>
		<ul type="disc">
			<li>
			<span>全文搜索只适用于<span> 
			MyISAM </span>表。</span></li>
			<li>
			<span>
			全文搜索可以同大多数多字节字符集一起使用。<span>Unicode</span>属于例外情况<span>;&nbsp;
			</span>可使用<span>utf8 </span>字符集<span> , </span>
			而非<span>ucs2</span>字符集。</span></li>
			<li>
			<span>
			诸如汉语和日语这样的表意语言没有自定界符。因此</span><span>，<span> 
			FULLTEXT</span>分析程序<i>不能确定在这些或其它的这类语言中词的起始和结束的位置。</i>其隐含操作及该问题的一些工作区在</span><a href="functions.html#fulltext-search" title="12.7. Full-Text Search Functions">12.7节，“全文搜索功能”</a><span>有详细论述。<span>
			</span></span></li>
			<li>
			<span>
			若支持在一个单独表中使用多字符集，则所有<span> FULLTEXT</span>索引中的列 
			必须使用同样的字符集和库。<span> </span></span></li>
			<li>
			<span >MATCH()</span><span>列列表必须同该表中一些<span> 
			FULLTEXT</span>索引定义中的列列表完全符合<span>,</span>除非<span>MATCH()</span>在<span>IN 
			BOOLEAN MODE</span>。</span></li>
			<li>
			<span>对<span>AGAINST()
			</span>的参数必须是一个常数字符串。<span>&nbsp; </span></span></li>
		</ul>
		</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fulltext-fine-tuning"></a>
			12.7.5.&nbsp;微调MySQL全文搜索</h3></div></div></div>
			<p>
			<span >MySQL</span><span>的全文搜索容量几乎不具有用户调节参数。假如你拥有一个<span> 
			MySQL</span>源分布，你就能对全文搜索性能行使更多控制，原因是一些变化需要源代码修改。请参见</span><a href="installing.html#installing-source" title="2.8. MySQL Installation Using a Source Distribution">2.8节，“使用源码分发版安装MySQL”</a><span>。</span></p>
			<p>
			<span>
			注意，为了更加有效，需要对全文搜索谨慎调节。实际上，在大多数情况下修改默认性能只能降低其性能。<i> 
			除非你知道自己在做什么，否则不要改变<span> MySQL</span>源。<span>&nbsp;
			</span></i></span></p>
			<p>
			<span>
			下述的大多数全文变量必须在服务器启动时被设置。为了改变它们，还要重新启动服务器；在服务器正在运行期间，他们不会被改变。<span>&nbsp;
			</span></span></p>
			<p>
			<span>一些变量的改变需要你重建表中的<span> 
			FULLTEXT </span>索引。本章结尾部分给出了其有关操作说明。<span> </span></span>
			</p>
			<ul type="disc">
				<li>
				<span >
				ft_min_word_len and ft_max_word_len</span><span>系统自变量规定了被编入索引单词的最小长度和最大长度。<span>(</span>见</span><a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a><span><span>.)
				</span>默认的最小值为四个字符；默认的最大值取决于使用的<span> MySQL </span>
				版本。假如你改变任意一个值，那么你必须重建你的<span> FULLTEXT</span>索引。 
				例如，若你希望一个<span>3</span>字符的单词变为可查找项，则可以通过将以下行移动到一个供选择文件里，从而设置<span> 
				ft_min_word_len </span>变量：</span></li>
			</ul>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span >[mysqld]</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span >
			ft_min_word_len=3</span></p>
			<p>
			<span>然后重新启动服务器，重建你的<span> 
			FULLTEXT</span>索引。同时还要特别注意该表后面的说明中的关于<b><span>myisamchk</span></b>的注释。<span>
			</span></span></p>
			<ul type="disc">
				<li>
				<span>若要覆盖默认停止字，则可设置<span> 
				ft_stopword_file </span>系统变量。<span> (</span>见</span><a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a><span>）<span>。
				</span>变量值应为包含停止字的文件路径名<span>, </span>
				或是用来截止禁用词过滤的空字符串。在改变了这个变量的值或禁用词文件的内容后<span>, </span>
				重建你的<span> FULLTEXT</span>索引。<span> </span>
				</span></li>
			</ul>
			<p>
			<span>
			停止字是自由形态的，换言之，你可使用任何诸如<span>newline</span>、<span> 
			space</span>或<span>comma</span>这样的非字母数字字符来分隔禁用词。 下划线字符<span>(_)
			</span>和被视为单词的一部分的单引号<span> (&#39;)</span>例外。停止字字符集为服务器默认字符集；见</span><a href="charset.html#charset-server" title="10.3.1. Server Character Set and Collation">10.3.1节，“服务器字符集和校对”</a><span >.
			</span></p>
			<ul type="disc">
				<li>
				<span >&nbsp;</span><span>自然语言查询的<span>50%</span>阈值由所选择的特别权衡方案所决定。若要阻止它，<span>myisam/ftdefs.h
				</span>中寻找以下行：<span> </span></span></li>
			</ul>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span >#define 
			GWS_IN_USE GWS_PROB</span></p>
			<p>
			<span>将该行改为：<span>
			</span></span></p>
			<p>
			<span >#define 
			GWS_IN_USE GWS_FREQ</span></p>
			<p>
			<span>然后重新编译<span> 
			MySQL</span>。此时不需要重建索引。注释<span>：</span>这样做你会<i>严重的</i><span>By
			</span>降低<span> MySQL</span>为<span>MATCH()</span>函数提供合适的相关值得能力。假如你争得需要搜索这样的普通词，而使用<span>IN 
			BOOLEAN MODE</span>代替的效果更好，因为它不遵循<span> 50% </span>阈值。<span>
			</span></span></p>
			<ul type="disc">
				<li>
				<span>
				要改变用于布尔全文搜索的操作符，设置<span> ft_boolean_syntax </span>
				系统变量。 这个变量也可以在服务器运行时被改变，但你必须有<span>SUPER </span>
				特权才能这么做。在这种情况下不需要重建索引。 见</span><a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a><span><span>,
				</span>它向我们说明了怎样使用这个变量的规则。<span> </span></span></li>
			</ul>
			<p>
			<span>假如你改变了影响索引的全文变量<span> 
			(ft_min_word_len</span>、<span> ft_max_word_len</span>或<span>ft_stopword_file),</span>或假如你改变了禁用词文件本身，则你必须在改变和重新启动服务器后重建你的<span> 
			FULLTEXT</span>索引。这时，要重建索引， 只需进行一个<span> QUICK </span>
			修理操作：<span>&nbsp; </span></span></p>
			<p>
			<span >mysql&gt; <b>
			REPAIR TABLE <i>tbl_name</i> QUICK;</b></span></p>
			<p>
			<span>注意，假如你使用<span>&nbsp;
			<b>myisamchk</b> </span>来执行一项修改表索引的操作<span> (</span>诸如修理或分析<span> 
			), </span>则使用最小单词长度和最大单词长度以及停止字的默认全文参数值重建<span>FULLTEXT</span>索引，除非你已另外指定。这会导致问询失败。<span>
			</span></span></p>
			<p>
			<span>
			发生这个问题的原因是只有服务器认识这些参数。它们的存储位置不在<span>&nbsp; MyISAM </span>
			索引文件中。若你已经修改了最小单词长度或最大单词长度或服务器中的停止字，为避免这个问题，为你对<b><span>mysqld</span></b>所使用的<b><span>myisamchk</span></b><span>
			</span>指定同样的<span> ft_min_word_len</span>、<span> 
			ft_max_word_len</span>和<span>ft_stopword_file</span>值。例如，假如你已经将最小单词长度设置为<span> 
			3, </span>则你可以这样修改一个带有<b><span>myisamchk</span></b>的表：</span></p>
			<p>
			<span >shell&gt; <b>
			myisamchk --recover --ft_min_word_len=3 <i>tbl_name</i>.MYI</b></span></p>
			<p>
			<span>为保证 <b>
			<span>myisamchk</span></b><span> </span>
			及服务器对全文参数使用相同的值， 可将每一项都放在供选文件中的<span> [mysqld]</span>和<span> 
			[myisamchk] </span>部分：</span></p>
			<p>
			<span >[mysqld]</span></p>
			<p>
			<span >
			ft_min_word_len=3</span></p>
			<p>
			<span >&nbsp;</span></p>
			<p>
			<span >[myisamchk]</span></p>
			<p>
			<span >
			ft_min_word_len=3</span></p>
			<p>
			<span>使用<span> 
			REPAIR TABLE</span>、<span> ANALYZE TABLE</span>、<span>OPTIMIZE 
			TABLE</span>或<span>ALTER TABLE</span>来代替使用 <b>
			<span>myisamchk</span></b><span> </span>
			。这些语句通过服务器来执行，服务器知道使用哪个全文参数值更加合适。<span> </span></span></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="cast-functions"></a>
		12.8.&nbsp;Cast函数和操作符</h2>
		<ul type="disc">
			<li>
			<span >BINARY
			</span></li>
		</ul>
		<p>
		<span >BINARY</span><span>操作符将后面的字符串抛给一个二进制字符串。<span>这是一种简单的方式来促使逐字节而不是逐字符的进行列比较。这使得比较区分大小写，即使该列不被定义为<span> 
		BINARY</span>或<span> BLOB</span>。<span>BINARY</span>也会产生结尾空白，从而更加显眼。<span>
		</span></span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT &#39;a&#39; = &#39;A&#39;;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT BINARY &#39;a&#39; = &#39;A&#39;;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT &#39;a&#39; = &#39;a &#39;;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT BINARY &#39;a&#39; = &#39;a &#39;;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
		<p>
		<span >
		BINARY</span><span>影响整个比较；它可以在任何操作数前被给定，而产生相同的结果。<span>
		</span></span></p>
		<p>
		<span >
		BINARY <i>str</i> </span>
		<span>是<span>CAST(<i>str</i> 
		AS BINARY)</span>的缩略形式。</span></p>
		<p>
		<span>
		注意，在一些语境中，假如你将一个编入索引的列派给<span>BINARY, MySQL </span>
		将不能有效使用这个索引。<span> </span></span></p>
		<p>
		<span>假如你想要将一个<span> 
		BLOB</span>值或其它二进制字符串进行区分大小写的比较，你可利用二进制字符串没有字符集这一事实实现这个目的，这样就不会有文书夹的概念。为执行一个区分大小写的比较，可使用<span>&nbsp; 
		CONVERT()</span>函数将一个字符串值转化为一个不区分大小写的字符集。其结果为一个非二进制字符串，因此<span> 
		LIKE </span>操作也不会区分大小写：<span> </span></span></p>
		<p>
		<span >
		SELECT &#39;A&#39; LIKE CONVERT(<i>blob_col</i> USING latin1) FROM <i>tbl_name</i>;</span></p>
		<p>
		<span>
		若要使用一个不同的字符集<span>, </span>替换其在上述语句中的<span>latin1</span>名。</span></p>
		<p>
		<span >
		CONVERT()</span><span>一般可用于比较出现在不同字符集中的字符串。<span>
		</span></span></p>
		<ul type="disc">
			<li>
			<span >CAST(<i>expr</i> 
			AS <i>type</i>), CONVERT(<i>expr</i>,<i>type</i>) , CONVERT(<i>expr</i> 
			USING <i>transcoding_name</i>) </span></li>
		</ul>
		<p>
		<span >
		CAST() </span>
		<span>和<span>CONVERT()
		</span>函数可用来获取一个类型的值，并产生另一个类型的值。<span> </span></span></p>
		<p>
		<span>这个<i>类型</i> 
		可以是以下值其中的 一个：<span>&nbsp; </span></span></p>
		<ul type="disc">
			<ul type="circle">
				<li>
				<span >
				BINARY[(<i>N</i>)] </span></li>
				<li>
				<span >
				CHAR[(<i>N</i>)] </span></li>
				<li>
				<span >DATE
				</span></li>
				<li>
				<span >
				DATETIME </span></li>
				<li>
				<span >
				DECIMAL </span></li>
				<li>
				<span >
				SIGNED [INTEGER] </span></li>
				<li>
				<span >TIME
				</span></li>
				<li>
				<span >
				UNSIGNED [INTEGER] </span></li>
			</ul>
		</ul>
		<p>
		<span >
		BINARY </span>
		<span>
		产生一个二进制字符串。关于它怎样影响比较结果的说明见本章中<span> BINARY</span>操作符项。</span></p>
		<p>
		<span>假如给定了随意长度<i><span>N</span></i>，则<span> 
		BINARY[<i>N</i>] </span>使<span> cast</span>使用该参数的不多于 <i>
		<span>N</span></i><span> </span>个字节。同样的，<span> 
		CHAR[<i>N</i>]</span>会使<span> cast </span>使用该参数的不多于<i><span>N</span></i><span>
		</span>个字符。<span> </span></span></p>
		<p>
		<span >
		CAST() and CONVERT(... USING ...) </span>
		<span>是标准<span> 
		SQL</span>语法。<span>CONVERT()</span>的非<span>USING
		</span>格式是<span>ofis ODBC</span>语法。</span></p>
		<p>
		<span>带有<span>USING</span>的<span>CONVERT()
		</span>被用来在不同的字符集之间转化数据。在<span> MySQL</span>中<span>,
		</span>自动译码名和相应的字符集名称相同。例如。 这个语句将服务器的默认字符集中的字符串<span> &#39;abc&#39;</span>转化为<span>utf8</span>字符集中相应的字符串：<span>&nbsp;
		</span></span></p>
		<p>
		<span >
		SELECT CONVERT(&#39;abc&#39; USING utf8);</span></p>
		<p>
		<span>当你想要在一个<span>CREATE 
		... SELECT </span>语句中创建一个特殊类型的列，则<span>cast</span>函数会很有用：</span></p>
		<p>
		<span >
		CREATE TABLE new_table SELECT CAST(&#39;2000-01-01&#39; AS DATE);</span></p>
		<p>
		<span>该函数也用于<span>ENUM
		</span>列按词法顺序的排序。通常<span>ENUM</span>列的排序在使用内部数值时发生。将这些值按照词法顺序派给<span> 
		CHAR </span>结果：</span></p>
		<p>
		<span >
		SELECT <i>enum_col</i> FROM <i>tbl_name</i> ORDER BY CAST(<i>enum_col</i> 
		AS CHAR);</span></p>
		<p>
		<span >
		CAST(<i>str</i> AS BINARY)</span><span>和<span>BINARY
		<i>str</i></span>相同<i>。</i><span> CAST(<i>expr</i> AS CHAR)
		</span>将表达式视为一个带有默认字符集的字符串。<span> </span></span></p>
		<p>
		<span>若用于一个诸如<span> 
		CONCAT(&#39;Date: &#39;,CAST(NOW() AS DATE))</span>这样的比较复杂的表达式的一部分，<span>CAST()</span>也会改变结果。</span></p>
		<p>
		<span>
		你不应在不同的格式中使用<span> CAST() </span>来析取数据，但可以使用诸如<span>LEFT()
		</span>或<span> EXTRACT() </span>的样的字符串函数来代替。请参见</span><a href="functions.html#date-and-time-functions" title="12.5. Date and Time Functions">12.5节，“日期和时间函数”</a><span >。 
		</span></p>
		<p>
		<span>
		若要在数值语境中将一个字符串派给一个数值<span>, </span>
		通常情况下，除了将字符串值作为数字使用外，你不需要做任何事：</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT 1+&#39;1&#39;;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></p>
		<p>
		<span>
		若要在一个字符串语境中使用一个数字，该数字会被自动转化为一个<span>BINARY </span>字符串。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CONCAT(&#39;hello you &#39;,2);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;hello you 2&#39;</span></p>
		<p>
		<span >
		MySQL </span>
		<span>
		支持带符号和无符号的<span>64</span>比特值的运算。若你正在使用数字操作符<span>&nbsp; (</span>如<span> 
		+) </span>而其中一个操作数为无符号整数，则结果为无符号。可使用<span>SIGNED </span>和<span>UNSIGNED 
		cast </span>操作符来覆盖它。将运算分别派给带符号或无符号<span>64</span>比特整数。</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CAST(1-2 AS UNSIGNED)</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 18446744073709551615</span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CAST(CAST(1-2 AS UNSIGNED) AS SIGNED);</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1</span></p>
		<p>
		<span>
		注意，假如任意一个操作数为一个浮点值，则结果为一个浮点值， 且不会受到上述规则影响<span> (</span>关于这一点<span>, 
		DECIMAL </span>列值被视为浮点值）<span>。 </span></span></p>
		<p>
		<span >
		mysql&gt; <b>SELECT CAST(1 AS UNSIGNED) - 2.0;</b></span></p>
		<p>
		<span >
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; -1.0</span></p>
		<p>
		<span>
		若你在一个算术运算中使用了一个字符串，它会被转化为一个浮点数。<span>&nbsp; </span></span></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="other-functions"></a>
		12.9.&nbsp;其他函数</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="functions.html#bit-functions">
			12.9.1. 位函数</a></span></dt><dt><span class="section"><a href="functions.html#encryption-functions">
			12.9.2. 加密函数</a></span></dt><dt><span class="section"><a href="functions.html#information-functions">
			12.9.3. 信息函数</a></span></dt><dt><span class="section"><a href="functions.html#miscellaneous-functions">
			12.9.4. 其他函数</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="bit-functions"></a>
			12.9.1.&nbsp;位函数</h3></div></div></div><a class="indexterm" name="id2882196"></a><a class="indexterm" name="id2882205"></a><a class="indexterm" name="id2882218"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			<span>
			对于比特运算，<span>MySQL </span>使用<span> BIGINT (64</span>比特<span>)
			</span>算法，因此这些操作符的最大范围是<span> 64 </span>比特。</span></p>
			<ul type="disc">
				<li>
				<span >|
				</span></li>
			</ul>
			<p>
			<span >
			Bitwise OR: </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 29 | 15;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 31</span></p>
			<p>
			<span>
			其结果为一个<span>64</span>比特无符号整数。</span></p>
			<ul type="disc">
				<li>
				<span >&amp;
				</span></li>
			</ul>
			<p>
			<span >
			Bitwise AND: </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 29 &amp; 15;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 13</span></p>
			<p>
			<span>
			其结果为一个<span>64</span>比特无符号整数。</span></p>
			<ul type="disc">
				<li>
				<span >^
				</span></li>
			</ul>
			<p>
			<span >
			Bitwise XOR: </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 1 ^ 1;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 1 ^ 0;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 11 ^ 3;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 8</span></p>
			<p>
			<span>结果为一个<span>64</span>比特无符号整数。</span></p>
			<ul type="disc">
				<li>
				<span >&lt;&lt;
				</span></li>
			</ul>
			<p>
			<span>把一个<span>longlong 
			(BIGINT)</span>数左移两位。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 1 &lt;&lt; 2;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 4</span></p>
			<p>
			<span>
			其结果为一个<span>64</span>比特无符号整数。</span></p>
			<ul type="disc">
				<li>
				<span >&gt;&gt;
				</span></li>
			</ul>
			<p>
			<span>把一个<span>longlong 
			(BIGINT)</span>数右移两位</span><span>。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 4 &gt;&gt; 2;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span>
			其结果为一个<span>64</span>比特无符号整数。</span></p>
			<ul type="disc">
				<li>
				<span >~
				</span></li>
			</ul>
			<p>
			<span>
			反转所有比特。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT 5 &amp; ~1;</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 4</span></p>
			<p>
			<span>
			其结果为一个<span>64</span>比特无符号整数。</span></p>
			<ul type="disc">
				<li>
				<span >
				BIT_COUNT(<i>N</i>) </span></li>
			</ul>
			<p>
			<span>返回参数<i><span>N</span></i><span>
			</span>中所设置的比特数<span> </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT BIT_COUNT(29);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 4</span></p>
			<h3 class="title"><a name="encryption-functions"></a>
			12.9.2.&nbsp;加密函数</h3></div></div></div><a class="indexterm" name="id2882770"></a><a class="indexterm" name="id2882779"></a>
			<p>
			<span>
			本节介绍了加密和加密值。若你想要储存一些由可能包含任意字节值的加密函数返回的结果，使用<span>BLOB</span>列而不是<span> 
			CHAR </span>或<span>VARCHAR </span>
			列，从而避免由于结尾空格的删除而改变一些数据值的潜在问题。</span></p>
			<ul type="disc">
				<li>
				<span >
				AES_ENCRYPT(<i>str</i>,<i>key_str</i>) , AES_DECRYPT(<i>crypt_str</i>,<i>key_str</i>)
				</span></li>
			</ul>
			<p>
			<span>
			这些函数允许使用官方<span>AES</span>进行加密和数据加密<span> (</span>高级加密标准<span> 
			) </span>算法<span>, </span>即以前人们所熟知的 “<span>Rijndael</span>”。</span><span>
			</span><span>保密关键字的长度</span><span>为<span>128</span>比特，不过你可以通过改变源而将其延长到<span> 
			256 </span>比特。我们选择了<span> 128</span>比特的原因是它的速度要快得多，且对于大多数用途而言这个保密程度已经够用。<span>&nbsp;&nbsp;
			</span></span></p>
			<p>
			<span>
			输入参数可以为任何长度。若任何一个参数为<span>NULL,</span>则函数的结果也是<span>NULL</span>。</span></p>
			<p>
			<span>因为<span> 
			AES </span>是</span><span>块级算法，</span><span>使用填充将不均衡长度字符串编码，这样结果字符串的长度的算法为<span> 
			16 * (trunc(<i>string_length</i> / 16) + 1)</span>。</span></p>
			<p>
			<span>若<span> 
			AES_DECRYPT()</span>检测到无效数据或不正确填充，它会返回<span> NULL</span>。然而，若输入的资料或密码无效时，<span> 
			AES_DECRYPT()</span>有可能返回一个非<span> NULL </span>值<span> 
			(</span>可能为无用信息<span> )</span>。</span></p>
			<p>
			<span>
			你可以通过修改你的问询，从而使用<span>AES</span>函数以加密形式来存储数据：</span></p>
			<p>
			<span >
			INSERT INTO t VALUES (1,AES_ENCRYPT(&#39;text&#39;,&#39;password&#39;));</span></p>
			<p>
			<span >
			AES_ENCRYPT()</span><span>和<span>AES_DECRYPT()
			</span>可以被看作<span>MySQL</span>中普遍通用的密码最安全的加密函数。</span></p>
			<ul type="disc">
				<li>
				<span >
				DECODE(<i>crypt_str</i>,<i>pass_str</i>) </span></li>
			</ul>
			<p>
			<span>使用 <i>
			<span>pass_str</span></i><span> </span>
			作为密码，解密加密字符串 <i><span>crypt_str</span></i>， <i>
			<span>crypt_str</span></i><span> </span>应该是由<span>ENCODE()</span>返回的字符串。<span>
			</span></span></p>
			<ul type="disc">
				<li>
				<span >
				ENCODE(<i>str</i>,<i>pass_str</i>) </span></li>
			</ul>
			<p>
			<span>使用<i><span>pass_str</span></i><span>
			</span>作为密码，解密 <i><span>str</span></i><span>
			</span>。 使用<span>DECODE()</span>解密结果。<span>
			</span></span></p>
			<p>
			<span>
			结果是一个和<i><span>str</span></i>长度相同的二进制字符串。若你想要将其保留在一个列中，可使用<span> 
			BLOB </span>列类型。</span></p>
			<ul type="disc">
				<li>
				<span >
				DES_DECRYPT(<i>crypt_str</i>[,<i>key_str</i>]) </span></li>
			</ul>
			<p>
			<span>使用<span>DES_ENCRYPT()</span>加密一个字符串。若出现错误，这个函数会返回<span> 
			NULL</span>。</span></p>
			<p>
			<span>
			注意，这个函数只有当<span>MySQL</span>在<span>SSL </span>
			的支持下配置完毕时才会运作。请参见</span><a href="database-administration.html#secure-connections" title="5.8.7. Using Secure Connections">5.8.7节，“使用安全连接”</a><span >.
			</span></p>
			<p>
			<span>
			假如没有给定 <i><span>key_str</span></i><span> </span>
			参数，<span>&nbsp; DES_DECRYPT() </span>会首先检查加密字符串的第一个字节， 
			从而确定用来加密原始字符串的<span>DES</span>密码关键字数字，之后从<span>DES</span>关键字文件中读取关键字从而解密信息。为使其运行，用户必须享有<span> 
			SUPER </span>特权。可以选择<span>--des-key-file</span>服务器指定关键字文件。</span></p>
			<p>
			<span>
			假如你向这个函数传递一个<i><span>key_str</span></i><span>
			</span>参数，该字符串被用作解密信息的关键字。</span></p>
			<p>
			<span>若 <i>
			<span>crypt_str</span></i><span> </span>
			参数看起来不是一个加密字符串，<span> MySQL </span>会返回给定的 <i>
			<span>crypt_str</span></i>。<span> </span></span>
			</p>
			<ul type="disc">
				<li>
				<span >
				DES_ENCRYPT(<i>str</i>[,(<i>key_num</i>|<i>key_str</i>)]) </span>
				</li>
			</ul>
			<p>
			<span>用<span>Triple-DES
			</span>算法给出的关键字加密字符串。若出现错误，这个函数会返回<span>NULL</span>。</span></p>
			<p>
			<span>
			注意，这个函数只有当<span>MySQL </span>在<span>SSL</span>的支持下配置完毕后才会运行。请参见</span><a href="database-administration.html#secure-connections" title="5.8.7. Using Secure Connections">5.8.7节，“使用安全连接”</a><span >.
			</span></p>
			<p>
			<span>
			使用的加密关键字的选择基于第二个到<span> DES_ENCRYPT()</span>的参数，假如给定：<span>&nbsp;
			</span></span></p>
			<table border="1" cellpadding="0" id="table9">
				<tr>
					<td>
					<p>
					<b>
					<span>
					参数</span></b></td>
					<td>
					<p>
					<b>
					<span>
					说明</span></b></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>
					无参数</span></td>
					<td>
					<p>
					<span>
					使用来自<span>DES</span>关键字文件的第一个关键字。</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<i>
					<span>
					key_num</span></i></td>
					<td>
					<p>
					<span>
					使用<span>DES </span>关键字文件给出的关键字数字<span>(0-9)</span>。 
					</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<i>
					<span>
					key_str</span></i></td>
					<td>
					<p>
					<span>
					使用给出的关键字字符串为 <i><span>str</span></i><span>
					</span>加密。</span></td>
				</tr>
			</table>
			<p>
			<span>选择<span>--des-key-file</span>服务器指定关键字文件。</span></p>
			<p>
			<span>
			返回字符串是一个二进制字符串，其中第一个字符为<span> CHAR(128 | key_num)</span>。</span></p>
			<p>
			<span>加上<span> 
			128</span>使得识别加密关键字更加容易。若你使用一个字符串关键字，则 <i><span>key_num</span></i><span>
			</span>为<span>127</span>。</span></p>
			<p>
			<span>
			结果的字符串长度为<span>&nbsp; <i>new_len</i> = <i>orig_len</i> + (8-(<i>orig_len</i> 
			% 8))+1</span>。<span> </span></span></p>
			<p>
			<span >
			DES</span><span>关键字文件中的每一行都具有如下格式：</span></p>
			<p>
			<i>
			<span >
			key_num</span></i><span >
			<i>des_key_str</i></span></p>
			<p>
			<span>每个<i><span>key_num</span></i><span>
			</span>必须是一个从<span>0</span>到<span>0</span>范围内的数字。文件中行的排列顺序是任意的。 
			<i><span>des_key_str</span></i><span> </span>
			是用来加密信息的字符串。在数字和关键字之间应该至少有一个空格。若你未指定任何到<span>DES_ENCRYPT()</span>的关键字参数，则第一个关键字为默认的使用关键字。</span></p>
			<p>
			<span>使用<span>FLUSH 
			DES_KEY_FILE</span>语句，你可以让<span> MySQL</span>从关键字文件读取新的关键字值。这要求你享有<span> 
			RELOAD</span>特权。</span></p>
			<p>
			<span>
			拥有一套默认关键字的一个好处就是它向应用程序提供了一个检验加密列值的方式，而无须向最终用户提供解密这些值的权力。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT customer_address FROM customer_table </b></span>
			</p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp; &gt; WHERE crypted_credit_card = DES_ENCRYPT(&#39;credit_card_number&#39;);</span></p>
			<ul type="disc">
				<li>
				<span >
				ENCRYPT(<i>str</i>[,<i>salt</i>]) </span></li>
			</ul>
			<p>
			<span>使用<span>Unix 
			crypt() </span>系统调用加密 <i><span>str</span></i>。 <i>
			<span>salt</span></i><span> </span>参数应为一个至少包含<span>2</span>个字符的字符串。若没有给出 
			<i><span>salt</span></i><span> </span>参数，则使用任意值。<span>
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ENCRYPT(&#39;hello&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;VxuFAJXVARROc&#39;</span></p>
			<p>
			<span>
			至少在一些系统中，<span>ENCRYPT()</span>除了<span>s<i>tr</i></span>的前八位字符之外会忽略所有内容。这个行为由下划线的<span>crypt()
			</span>系统调用的执行所决定。</span></p>
			<p>
			<span>假如<span>crypt()</span>在你的系统中不可用<span>(</span>正如在<span> 
			Windows</span>系统<span>), ENCRYPT() </span>则会始终返回<span>NULL</span>。鉴于这个原因，我们向你推荐使用<span> 
			MD5() </span>或<span>SHA1() </span>来代替<span>,</span>因为这两个函数适合所有的平台。<span>
			</span></span></p>
			<ul type="disc">
				<li>
				<span >MD5(<i>str</i>)
				</span></li>
			</ul>
			<p>
			<span>
			为字符串算出一个<span> MD5 128</span>比特检查和。该值以</span><span>32</span><span>位十六进制数字的二进制字符串</span><span>的形式返回<span>,
			</span>若参数为<span> NULL </span>则会返回<span> NULL</span>。例如，返回值可被用作散列关键字。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT MD5(&#39;testing&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;ae2b1fca515949e5d54fb22b8ed95575&#39;</span></p>
			<p>
			<span>这是<span>&quot;RSA 
			Data Security, Inc. MD5 Message-Digest Algorithm.&quot; </span></span>
			</p>
			<p>
			<span>
			假如你想要将这个值转化为大写字母，参见</span><a href="functions.html#cast-functions" title="12.8. Cast Functions and Operators">12.8节，“Cast函数和操作符”</a><span>中<span>BINARY</span>操作符项中给出的二进制字符串转换。</span></p>
			<ul type="disc">
				<li>
				<span >
				OLD_PASSWORD(<i>str</i>) </span></li>
			</ul>
			<p>
			<span>当<span>PASSWORD()</span>的执行变为改善安全性时，<span>OLD_PASSWORD()</span>会被添加到<span> 
			MySQL</span>。<span>OLD_PASSWORD()</span>返回从前的<span>PASSWORD()</span>执行值<span>( 
			4.1</span>之前<span>)</span>，同时允许你为任何<span>4.1
			</span>之前的需要连接到你的<span>5.1 </span>版本<span>MySQL</span>服务器前客户端设置密码，从而不至于将它们切断。请参见</span><a href="database-administration.html#password-hashing" title="5.7.9. Password Hashing in MySQL 4.1">5.7.9节，“MySQL 4.1中的密码哈希处理”</a><span >。 
			</span></p>
			<ul type="disc">
				<li>
				<span >
				PASSWORD(<i>str</i>) </span></li>
			</ul>
			<p>
			<span>从原文密码<i><span>str</span></i><span>
			</span>计算并返回密码字符串，当参数为<span> NULL </span>时返回<span> 
			NULL</span>。这个函数用于用户授权表的<span>Password</span>列中的加密<span>MySQL</span>密码存储</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT PASSWORD(&#39;badpwd&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;7f84554057dd964b&#39;</span></p>
			<p>
			<span >
			PASSWORD() </span>
			<span>
			加密是单向的<span> (</span>不可逆<span> )</span>。</span></p>
			<p>
			<span >
			PASSWORD() </span>
			<span>
			执行密码加密与<span>Unix </span>密码被加密的方式不同。请参见<span>ENCRYPT()</span>。</span></p>
			<p>
			<b><span>注释</span></b><span >： 
			PASSWORD()</span><span>函数在<span>MySQL</span>服务器中的鉴定系统使用；你<i>不</i>应将它用在你个人的应用程序中。为达到同样目的，可使用<span> 
			MD5()</span>或<span>SHA1() </span>代替。<span>&nbsp;&nbsp;&nbsp;
			</span>更多关于在您的应用程序中处理密码及安全鉴定的信息见<span>RFC 2195&nbsp; </span>
			</span></p>
			<ul type="disc">
				<li>
				<span >SHA1(<i>str</i>) 
				SHA(<i>str</i>) </span></li>
			</ul>
			<p>
			<span>
			为字符串算出一个<span> SHA1 160</span>比特检查和，如<span>RFC 
			3174 (</span>安全散列算法<span> )</span>中所述。该值被作为<span>40</span>位十六进制数字返回，而当参数为<span>NULL
			</span>时则返回<span> NULL</span>。这个函数的一个可能的用处就在于其作为散列关键字。你也可以将其作为存储密码的密码安全函数使用。<span>
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SHA1(&#39;abc&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;a9993e364706816aba3e25717850c26c9cd0d89d&#39;</span></p>
			<p>
			<span >
			SHA1()</span><span>可以被视为一个密码更加安全的函数，相当于<span>&nbsp; 
			MD5()</span>。<span> SHA() </span>和<span>SHA1()</span>具有相同的意义。<span>
			</span></span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="information-functions"></a>
			12.9.3.&nbsp;信息函数</h3>
			<ul type="disc">
				<li>
				<span >
				BENCHMARK(<i>count</i>,<i>expr</i>) </span></li>
			</ul>
			<p>
			<span >
			BENCHMARK() </span>
			<span>函数重复<i><span>count</span></i><span>
			</span>次执行表达式 <i><span>expr</span></i><span>
			</span>。 它可以被用于计算<span>&nbsp; MySQL </span>处理表达式的速度。结果值通常为<span> 
			0</span>。另一种用处来自 <b><span>mysql</span></b>客户端内部<span>,</span>能够报告问询执行的次数：</span></p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT BENCHMARK(1000000,ENCODE(&#39;hello&#39;,&#39;goodbye&#39;));</span></b></span></pre>
			<pre><span>+----------------------------------------------+</span></pre>
			<pre><span>| BENCHMARK(1000000,ENCODE(&#39;hello&#39;,&#39;goodbye&#39;)) |</span></pre>
			<pre><span>+----------------------------------------------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
			<pre><span>+----------------------------------------------+</span></pre>
			<pre><span>1 row in set (4.74 sec)</span></pre>
			<p>此处报告的时间是客户端上的共用时间，而不是服务器端上的<span>CPU</span>时间。建议执行多遍<span>BENCHMARK()</span>，并解释与服务器机器负荷程度有关的结果。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>CHARSET(<i>str</i>)</span><span>
			</span></p>
			<p>返回字符串自变量的字符集。</p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT CHARSET(&#39;abc&#39;);</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;latin1&#39;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT CHARSET(CONVERT(&#39;abc&#39; USING utf8));</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;utf8&#39;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT CHARSET(USER());</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;utf8&#39;</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			COERCIBILITY(<i>str</i>)</span><span> </span></p>
			<p>返回字符串自变量的整序可压缩性值。</p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT COERCIBILITY(&#39;abc&#39; COLLATE latin1_swedish_ci);</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 0</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT COERCIBILITY(USER());</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 3</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT COERCIBILITY(&#39;abc&#39;);</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 4</span></pre>
			<p>
			<span>
			返回值具有如下意义：</span><b><span>
			</span></b></p>
			<table border="1" cellpadding="0" id="table10">
				<tr>
					<td>
					<p><strong>
					<span>可压缩性 </span>
					</strong></td>
					<td>
					<p><strong>
					<span>意义</span></strong></td>
					<td>
					<p><strong>
					<span>举例</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>0</span></td>
					<td>
					<p>
					<span>明确排序</span></td>
					<td>
					<p>
					<span>带有</span><span>COLLATE</span><span>
					</span><span>子句的值</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>1</span></td>
					<td>
					<p>
					<span>无排序</span></td>
					<td>
					<p>
					<span>不同排序的字符串连接 
					</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>2</span></td>
					<td>
					<p>
					<span>明确排序</span></td>
					<td>
					<p>
					<span>列值</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>3</span></td>
					<td>
					<p>
					<span>系统常量</span></td>
					<td>
					<p>
					<span>USER()</span><span>返回值</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>4</span></td>
					<td>
					<p>
					<span>可压缩</span></td>
					<td>
					<p>
					<span>文字字符串</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>5</span></td>
					<td>
					<p>
					<span>可忽略</span></td>
					<td>
					<p><span>
					<span>NULL</span><span>得来的<span>NULL</span></span></span><span>或一个表达式 
					</span></td>
				</tr>
			</table>
			<p>
			<b>
			<span>
			&nbsp;</span></b></p>
			<p>
			<span >
			&nbsp;</span></p>
			<p>
			<span>
			下方值得优先级较高。<span> </span></span></p>
			<ul type="disc">
				<li>
				<span >
				COLLATION(<i>str</i>) </span></li>
			</ul>
			<p>
			<span>
			返回惠字符串参数的排序方式。<span> </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT COLLATION(&#39;abc&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;latin1_swedish_ci&#39;</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT COLLATION(_utf8&#39;abc&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;utf8_general_ci&#39;</span></p>
			<ul type="disc">
				<li>
				<span >
				CONNECTION_ID() </span></li>
			</ul>
			<p>
			<span>
			返回对于连接的连接<span>ID (</span>线程</span><span >ID)</span><span>。每个连接都有各自的唯一<span> 
			ID</span>。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT CONNECTION_ID();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 23786</span></p>
			<ul type="disc">
				<li>
				<span >
				CURRENT_USER, CURRENT_USER() </span></li>
			</ul>
			<p>
			<span>
			返回当前话路被验证的用户名和主机名组合。这个值符合确定你的存取权限的<span>MySQL </span>
			账户。在被指定<span>SQL SECURITY DEFINER</span>特征的存储程序内，<span> 
			CURRENT_USER() </span>返回程序的创建者。</span></p>
			<p>
			<span >
			&nbsp;</span><span>CURRENT_USER()</span><span>的值可以和</span><span>USER()</span><span>的值有所不同。</span><span>
			</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT USER();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;davida@localhost&#39;</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT * FROM mysql.user;</b></span></p>
			<p>
			<span >
			ERROR 1044: Access denied for user &#39;&#39;@&#39;localhost&#39; to</span></p>
			<p>
			<span >
			database &#39;mysql&#39;</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT CURRENT_USER();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;@localhost&#39;</span></p>
			<p>
			<span>
			这个例子解释了虽然客户端指定了一个<span> davida</span>用户名<span> (</span>正如<span>USER()</span>函数的值所指示的<span>),
			</span>服务器却使用一个匿名的用户账户确认该客户端<span> (</span>见<span>CURRENT_USER()</span>值得空用户名部分<span> 
			)</span>。这种情况发生的一个原因是<span> One </span>在向<span> 
			davida</span>的授权列表中没有足够的账户。<span>&nbsp; </span></span></p>
			<p>
			<span >
			&nbsp;CURRENT_USER() </span>
			<span>
			返回的字符串使用<span> utf8</span>字符集。</span></p>
			<ul type="disc">
				<li>
				<span >
				DATABASE() </span></li>
			</ul>
			<p>
			<span>返回使用<span> 
			utf8 </span>字符集的默认<span>(</span>当前<span>)</span>数据库名。在存储程序里，默认数据库是同该程序向关联的数据库，但并不一定与调用语境的默认数据库相同。<span>&nbsp;
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT DATABASE();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;test&#39;</span></p>
			<p>
			<span>
			若没有默认数据库<span>, DATABASE()</span>返回<span> NULL</span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				FOUND_ROWS() </span></li>
			</ul>
			<p>
			<span >
			A SELECT</span><span>语句可能包括一个<span> 
			LIMIT </span>子句，用来限制服务器返回客户端的行数。在有些情况下，需要不用再次运行该语句而得知在没有<span>LIMIT
			</span>时到底该语句返回了多少行。为了知道这个行数<span>, </span>包括在<span>SELECT
			</span>语句中选择<span>&nbsp; SQL_CALC_FOUND_ROWS </span>，随后调用<span> 
			FOUND_ROWS() </span>：</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SQL_CALC_FOUND_ROWS * FROM <i>tbl_name</i></b></span></p>
			<p>
			<span >
			&nbsp; &nbsp;&nbsp;-&gt; <b>WHERE id &gt; 100 LIMIT 10;</b></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT FOUND_ROWS();</b></span></p>
			<p>
			<span>第二个<span> 
			SELECT</span>返回一个数字，指示了在没有<span>LIMIT</span>子句的情况下，第一个<span>SELECT</span>返回了多少行<span> 
			(</span>若上述的<span> SELECT</span>语句不包括<span> 
			SQL_CALC_FOUND_ROWS </span>选项<span>,</span>则使用<span>LIMIT
			</span>和不使用时，<span>FOUND_ROWS() </span>可能会返回不同的结果）<span>。
			</span></span></p>
			<p>
			<span>通过<span> 
			FOUND_ROWS()</span>的有效行数是瞬时的，并且不用于越过<span>SELECT 
			SQL_CALC_FOUND_ROWS</span>语句后面的语句。若你需要稍候参阅这个值，那么将其保存：<span>
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SQL_CALC_FOUND_ROWS * FROM ... ;</b></span></p>
			<p>
			<span >
			mysql&gt; <b>SET @rows = FOUND_ROWS();</b></span></p>
			<p>
			<span>
			假如你正在使用<span> SELECT SQL_CALC_FOUND_ROWS, MySQL </span>
			必须计算出在全部结果集合中有所少行。然而， 这比不用<span>LIMIT</span>而再次运行问询要快，原因是结果集合不需要被送至客户端。<span>
			</span></span></p>
			<p>
			<span >
			SQL_CALC_FOUND_ROWS </span>
			<span>和<span> 
			FOUND_ROWS() </span>
			在当你希望限制一个问询返回的行数时很有用，同时还能不需要再次运行问询而确定全部结果集合中的行数。一个例子就是提供页式显示的<span>Web</span>脚本，该显示包含显示搜索结果其它部分的页的连接。使用<span>FOUND_ROWS()
			</span>使你确定剩下的结果需要多少其它的页。<span>&nbsp; </span></span></p>
			<p>
			<span >
			SQL_CALC_FOUND_ROWS </span>
			<span>和<span> 
			FOUND_ROWS() </span>的应用对于<span>UNION </span>问询比对于简单<span>SELECT
			</span>语句更为复杂，原因是在<span>UNION </span>中，<span>LIMIT
			</span>可能会出现在多个位置。它可能适用于<span>UNION</span>中的个人<span> 
			SELECT</span>语句，或是总体上<span>&nbsp; </span>到<span>UNION
			</span>结果的全程。<span> </span></span></p>
			<p>
			<span >
			SQL_CALC_FOUND_ROWS</span><span>对于<span> 
			UNION</span>的意向是它应该不需要全程<span>LIMIT</span>而返回应返回的行数。<span>SQL_CALC_FOUND_ROWS
			</span>和<span>UNION </span>一同使用的条件是：</span></p>
			<ul type="disc">
				<ul type="circle">
					<li>
					<span >
					&nbsp;SQL_CALC_FOUND_ROWS </span>
					<span>关键词必须出现在<span>UNION</span>的第一个<span> 
					SELECT</span>中。</span></li>
					<li>
					<span >
					&nbsp;FOUND_ROWS()</span><span>的值只有在使用<span> 
					UNION ALL</span>时才是精确的。若使用不带<span>ALL</span>的<span>UNION</span>，则会发生两次删除， 
					而<span>&nbsp; FOUND_ROWS() </span>的指只需近似的。<span>
					</span></span></li>
					<li>
					<span>假若<span>UNION
					</span>中没有出现<span>&nbsp; LIMIT </span>，则<span>SQL_CALC_FOUND_ROWS
					</span>被忽略，返回临时表中的创建的用来处理<span>UNION</span>的行数。</span></li>
				</ul>
				<li>
				<span >
				LAST_INSERT_ID() LAST_INSERT_ID(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>自动返回<i>最后一个</i><span>INSERT</span>或<span> 
			UPDATE </span>问询为<span> AUTO_INCREMENT</span>列设置的<i>第一个 
			</i>发生的值。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT LAST_INSERT_ID();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 195</span></p>
			<p>
			<span>产生的<span>ID
			</span><i>每次连接后</i>保存在服务器中。这意味着函数向一个给定客户端返回的值是该客户端产生对影响<span>AUTO_INCREMENT</span>列的最新语句第一个<span> 
			AUTO_INCREMENT</span>值的。这个值不能被其它客户端影响，即使它们产生它们自己的<span> 
			AUTO_INCREMENT</span>值。这个行为保证了你能够找回自己的<span> ID </span>
			而不用担心其它客户端的活动，而且不需要加锁或处理。<span> </span></span></p>
			<p>
			<span>
			假如你使用一个非“<span>magic</span>”值来更新某一行的<span>AUTO_INCREMENT
			</span>列，则<span>LAST_INSERT_ID() </span>的值不会变化<span>(</span>换言之<span>,
			</span>一个不是<span> NULL</span>也不是<span> 0</span>的值<span>)</span>。</span></p>
			<p>
			<b><span>重点</span></b><span >:
			</span>
			<span>
			假如你使用单<span>INSERT</span>语句插入多个行，<span>&nbsp; 
			LAST_INSERT_ID() </span><i>只</i>返回插入的<i>第一</i>行产生的值。其原因是这使依靠其它服务器复制同样的<span> 
			INSERT</span>语句变得简单。<span> </span></span></p>
			<p>
			<span>例如：<span>
			</span></span></p>
			<pre><span>mysql&gt; </span><span><b><span>USE test;</span></b></span></pre>
			<pre><span>Database changed</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>CREATE TABLE t (</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp; </span><span><b><span>id INT AUTO_INCREMENT NOT NULL PRIMARY KEY,</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp; </span><span><b><span>name VARCHAR(10) NOT NULL</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>);</span></b></span></pre>
			<pre><span>Query OK, 0 rows affected (0.09 sec)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; </span><span>INSERT INTO t VALUES (NULL, &#39;Bob&#39;);</span></pre>
			<pre><span>Query OK, 1 row affected (0.01 sec)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT * FROM t;</span></b></span></pre>
			<pre><span>+----+------+</span></pre>
			<pre><span>| id | name |</span></pre>
			<pre><span>+----+------+</span></pre>
			<pre><span>|&nbsp; 1 | Bob&nbsp; |</span></pre>
			<pre><span>+----+------+</span></pre>
			<pre><span>1 row in set (0.01 sec)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT LAST_INSERT_ID();</span></b></span></pre>
			<pre><span>+------------------+</span></pre>
			<pre><span>| LAST_INSERT_ID() |</span></pre>
			<pre><span>+------------------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</span></pre>
			<pre><span>+------------------+</span></pre>
			<pre><span>1 row in set (0.00 sec)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>INSERT INTO t VALUES</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>(NULL, &#39;Mary&#39;), (NULL, &#39;Jane&#39;), (NULL, &#39;Lisa&#39;);</span></b></span></pre>
			<pre><span>Query OK, 3 rows affected (0.00 sec)</span></pre>
			<pre><span>Records: 3&nbsp; Duplicates: 0&nbsp; Warnings: 0</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; SELECT * FROM t;</span></pre>
			<pre><span>+----+------+</span></pre>
			<pre><span>| id | name |</span></pre>
			<pre><span>+----+------+</span></pre>
			<pre><span>|&nbsp; 1 | Bob&nbsp; |</span></pre>
			<pre><span>|&nbsp; 2 | Mary |</span></pre>
			<pre><span>|&nbsp; 3 | Jane |</span></pre>
			<pre><span>|&nbsp; 4 | Lisa |</span></pre>
			<pre><span>+----+------+</span></pre>
			<pre><span>4 rows in set (0.01 sec)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT LAST_INSERT_ID();</span></b></span></pre>
			<pre><span>+------------------+</span></pre>
			<pre><span>| LAST_INSERT_ID() |</span></pre>
			<pre><span>+------------------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 |</span></pre>
			<pre><span>+------------------+</span></pre>
			<pre><span>1 row in set (0.00 sec)</span></pre>
			<p>
			<span>
			虽然第二个问询将<span>3 </span>个新行插入<span> t, </span>
			对这些行的第一行产生的<span> ID </span>为<span> 2, </span>
			这也是<span> LAST_INSERT_ID()</span>返回的值。</span></p>
			<p>
			<span>假如你使用<span> 
			INSERT IGNORE</span>而记录被忽略，则<span>AUTO_INCREMENT </span>
			计数器不会增量，而<span> LAST_INSERT_ID() </span>返回<span>0,
			</span>这反映出没有插入任何记录。<span> </span></span></p>
			<p>
			<span>
			若给出作为到<span>LAST_INSERT_ID()</span>的参数<i><span>expr</span></i><span>
			</span>，则参数的值被函数返回，并作为被<span>LAST_INSERT_ID()</span>返回的下一个值而被记忆。这可用于模拟序列：</span></p>
			<ul type="disc">
				<ul type="circle">
					<li>
					<span>
					创建一个表，用来控制顺序计数器并使其初始化：</span></li>
				</ul>
			</ul>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span >
			mysql&gt; <b>CREATE TABLE sequence (id INT NOT NULL);</b></span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span >
			mysql&gt; <b>INSERT INTO sequence VALUES (0);</b></span></p>
			<ul type="disc">
				<ul type="circle">
					<li>
					<span>
					使用该表产生这样的序列数 ：</span></li>
				</ul>
			</ul>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span >
			mysql&gt; <b>UPDATE sequence SET id=LAST_INSERT_ID(id+1);</b></span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span >
			mysql&gt; <b>SELECT LAST_INSERT_ID();</b></span></p>
			<p>
			<span >
			UPDATE </span>
			<span>
			语句会增加顺序计数器并引发向<span>LAST_INSERT_ID()&nbsp; </span>
			的下一次调用，用来返回升级后的值。<span> SELECT </span>语句会检索这个值。<span>&nbsp; 
			mysql_insert_id() C API</span>函数也可用于获取这个值。 见</span><a href="apis.html#mysql-insert-id" title="25.2.3.36. mysql_insert_id()">25.2.3.36节，“mysql_insert_id()”</a><span >.
			</span></p>
			<p>
			<span>
			你可以不用调用<span>LAST_INSERT_ID()</span>而产生序列，但这样使用这个函数的效用在于<span> 
			ID</span>值被保存在服务器中，作为自动产生的值。它适用于多个用户，原因是多个用户均可使用<span> 
			UPDATE</span>语句并用<span>SELECT</span>语句<span>(</span>或<span>mysql_insert_id()),</span>得到他们自己的序列值，而不会影响其它产生他们自己的序列值的客户端或被其它产生他们自己的序列值的客户端所影响。<span>
			</span></span></p>
			<p>
			<span>注意，<span> 
			mysql_insert_id() </span>仅会在<span>INSERT </span>和<span>UPDATE</span>语句后面被升级， 
			因此你不能在执行了其它诸如<span>SELECT</span>或<span> SET
			</span>这样的<span>SQL</span>语句后使用<span> C API
			</span>函数来找回<span> LAST_INSERT_ID(<i>expr</i>) </span>
			对应的值。</span></p>
			<ul type="disc">
				<li>
				<span >
				ROW_COUNT() </span></li>
			</ul>
			<p>
			<span >
			ROW_COUNT()</span><span>返回被前面语句升级的、插入的或删除的行数。 
			这个行数和 <b><span>mysql</span></b><span> </span>
			客户端显示的行数及<span> mysql_affected_rows() C API </span>
			函数返回的值相同。</span></p>
			<p>
			<span >
			mysql&gt; <b>INSERT INTO t VALUES(1),(2),(3);</b></span></p>
			<p>
			<span>问询完成<span>,
			</span>表中有<span>3 </span>行<span> (0.00</span>秒<span>)</span></span></p>
			<p>
			<span>记录<span>: 
			3 </span>重复<span>: 0 </span>警告<span>: 0</span></span></p>
			<p>
			<span >
			&nbsp;</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ROW_COUNT();</b></span></p>
			<p>
			<span >
			+-------------+</span></p>
			<p>
			<span >
			| ROW_COUNT() |</span></p>
			<p>
			<span >
			+-------------+</span></p>
			<p>
			<span >
			|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 |</span></p>
			<p>
			<span >
			+-------------+</span></p>
			<p>
			<span>表中有<span>1</span>行<span> 
			(0.00 </span>秒<span>)</span></span></p>
			<p>
			<span >
			&nbsp;</span></p>
			<p>
			<span >
			mysql&gt; <b>DELETE FROM t WHERE i IN(1,2);</b></span></p>
			<p>
			<span>问询完成<span>,
			</span>找到<span>2 </span>行<span> (0.00 </span>秒<span>)</span></span></p>
			<p>
			<span >
			&nbsp;</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT ROW_COUNT();</b></span></p>
			<p>
			<span >
			+-------------+</span></p>
			<p>
			<span >
			| ROW_COUNT() |</span></p>
			<p>
			<span >
			+-------------+</span></p>
			<p>
			<span >
			|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 |</span></p>
			<p>
			<span >
			+-------------+</span></p>
			<p>
			<span>表中有<span>1</span>行<span> 
			(0.00 </span>秒<span>)</span></span></p>
			<ul type="disc">
				<li>
				<span >
				SCHEMA() </span></li>
			</ul>
			<p>
			<span>这个函数和<span> 
			DATABASE()</span>具有相同的意义。</span></p>
			<ul type="disc">
				<li>
				<span >
				SESSION_USER() </span></li>
			</ul>
			<p>
			<span >
			SESSION_USER()</span><span>和<span> 
			USER()</span>具有相同的意义。</span></p>
			<ul type="disc">
				<li>
				<span >
				SYSTEM_USER() </span></li>
			</ul>
			<p>
			<span >
			SYSTEM_USER()</span><span>合<span> 
			USER()</span>具有相同的意义。</span></p>
			<ul type="disc">
				<li>
				<span >
				USER() </span></li>
			</ul>
			<p>
			<span>返回当前<span> 
			MySQL</span>用户名和机主名<span>/</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT USER();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;davida@localhost&#39;</span></p>
			<p>
			<span>
			这个值指示了你指定的连接服务器时的用户名<span>,</span>及你所连接的客户主机。这个值可以和<span>CURRENT_USER()
			</span>的值不同。</span></p>
			<p>
			<span>
			你可以这样提取用户名部分：<span> </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SUBSTRING_INDEX(USER(),&#39;@&#39;,1);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;davida&#39;</span></p>
			<p>
			<span>由于<span> 
			USER() </span>返回一个<span>utf8 </span>字符集中的值，你也应确保<span>&#39;@&#39;
			</span>字符串文字在该字符集中得到解释：</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT SUBSTRING_INDEX(USER(),_utf8&#39;@&#39;,1);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;davida&#39;</span></p>
			<ul type="disc">
				<li>
				<span >
				VERSION() </span></li>
			</ul>
			<p>
			<span>返回指示<span> 
			MySQL </span>服务器版本的字符串。这个字符串使用<span> utf8 </span>字符集。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT VERSION();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;5.1.2-alpha-standard&#39;</span></p>
			<p>
			<span>
			注意，假如你的版本字符串以<span>-log</span>结尾，这说明登录已被激活。<span>&nbsp;
			</span></span></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="miscellaneous-functions"></a>
			12.9.4.&nbsp;其他函数</h3>
			<ul type="disc">
				<li>
				<span >
				DEFAULT(<i>col_name</i>) </span></li>
			</ul>
			<p>
			<span>
			返回一个表列的默认值。若该列没有默认值则会产生错误。<span> </span></span></p>
			<p>
			<span >
			mysql&gt; <b>UPDATE t SET i = DEFAULT(i)+1 WHERE id &lt; 100;</b></span></p>
			<ul type="disc">
				<li>
				<span >
				FORMAT(<i>X</i>,<i>D</i>) </span></li>
			</ul>
			<p>
			<span>将数字<i><span>X</span></i><span>
			</span>的格式写为<span>&#39;#,###,###.##&#39;,</span>以四舍五入的方式保留小数点后 <i>
			<span>D</span></i><span> </span>位， 
			并将结果以字符串的形式返回。若<span>&nbsp; <i>D</i> </span>为<span> 
			0, </span>则返回结果不带有小数点，或不含小数部分。<span> </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT FORMAT(12332.123456, 4);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;12,332.1235&#39;</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT FORMAT(12332.1,4);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;12,332.1000&#39;</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT FORMAT(12332.2,0);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;12,332&#39;</span></p>
			<ul type="disc">
				<li>
				<span >
				GET_LOCK(<i>str</i>,<i>timeout</i>) </span></li>
			</ul>
			<p>
			<span>
			设法使用字符串<i><span>str</span></i><span> </span>
			给定的名字得到一个锁， 超时为<i><span>timeout</span></i><span>
			</span>秒。若成功得到锁，则返回<span> 1</span>，若操作超时则返回<span>0&nbsp; 
			(</span>例如<span>,</span>由于另一个客户端已提前封锁了这个名字<span> 
			),</span>若发生错误则返回<span>NULL (</span>诸如缺乏记忆或线程<b><span>mysqladmin 
			kill</span></b><span> </span>被断开<span> )</span>。假如你有一个用<span>GET_LOCK()</span>得到的锁，当你执行<span>RELEASE_LOCK()</span>或你的连接断开<span>(</span>正常或非正常<span>)</span>时，这个锁就会解除。</span><span>
			</span></p>
			<p>
			<span>
			这个函数可用于执行应用程序锁或模拟记录锁定。名称被锁定在服务器范围内。假如一个名字已经被一个客户端封锁，<span> 
			GET_LOCK() </span>
			会封锁来自另一个客户端申请封锁同一个名字的任何请求。这使对一个封锁名达成协议的客户端使用这个名字合作执行建议锁。然而要知道它也允许不在一组合作客户端中的一个客户端封锁名字，不论是服役的还是非故意的，这样阻止任何合作中的客户端封锁这个名字。一个减少这种情况发生的办法就是使用数据库特定的或应用程序特定的封锁名。例如，<span>&nbsp;
			</span>使用<i><span>db_name.str</span></i>或 <i>
			<span>app_name.str</span></i><span> </span>
			形式的封锁名。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT GET_LOCK(&#39;lock1&#39;,10);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT IS_FREE_LOCK(&#39;lock2&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT GET_LOCK(&#39;lock2&#39;,10);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT RELEASE_LOCK(&#39;lock2&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 1</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT RELEASE_LOCK(&#39;lock1&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; NULL</span></p>
			<p>
			<span>
			注意，第二个<span> RELEASE_LOCK()</span>调用返回<span> 
			NULL </span>，原因是锁<span>&#39;lock1&#39; </span>杯第二个<span>GET_LOCK()</span>调用解开。</span></p>
			<ul type="disc">
				<li>
				<span >
				INET_ATON(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>
			给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数。地址可以是<span>4</span>或<span>8</span>比特地址。<span>
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT INET_ATON(&#39;209.207.224.40&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 3520061480</span></p>
			<p>
			<span>
			产生的数字总是按照网络字节顺序。如上面的例子，数字按照<span> 209</span>×<span>256<sup>3</sup> 
			+ 207</span>×<span>256<sup>2</sup> + 224</span>×<span>256 
			+ 40 </span>进行计算。</span></p>
			<p>
			<span >
			INET_ATON() </span>
			<span>
			也能理解短格式<span> IP </span>地址：</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT INET_ATON(&#39;127.0.0.1&#39;), INET_ATON(&#39;127.1&#39;);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2130706433, 2130706433</span></p>
			<p>
			<b><span>注释</span></b><span >：
			</span>
			<span>在存储由<span>INET_ATON()
			</span>产生的值时，推荐你使用<span> INT UNSIGNED </span>列。假如你使用<span> 
			(</span>带符号<span>) INT</span>列<span>, </span>
			则相应的第一个八位组大于<span>127</span>的<span>IP </span>
			地址值会被截至<span>&nbsp; 2147483647 (</span>即<span>, 
			INET_ATON(&#39;127.255.255.255&#39;) </span>所返回的值<span>)</span>。请参见</span><a href="column-types.html#numeric-types" title="11.2. Numeric Types">11.2节，“数值类型”</a><span >。 
			</span></p>
			<ul type="disc">
				<li>
				<span >
				INET_NTOA(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>
			给定一个数字网络地址<span> (4 </span>或<span> 8 </span>比特<span>),</span>返回作为字符串的该地址的电地址表示。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT INET_NTOA(3520061480);</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;209.207.224.40&#39;</span></p>
			<ul type="disc">
				<li>
				<span >
				IS_FREE_LOCK(<i>str</i>) </span></li>
			</ul>
			<p>
			<span>检查名为<i><span>str</span></i>的锁是否可以使用<span> 
			(</span>换言之<span>,</span>没有被封锁<span>)</span>。若锁可以使用，则返回<span>&nbsp; 
			1&nbsp; (</span>没有人在用这个锁<span>), </span>若这个锁正在被使用，则返回<span>0
			</span>，出现错误则返回<span> NULL&nbsp; (</span>诸如不正确的参数<span> 
			)</span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				IS_USED_LOCK(<i>str</i>) </span></li>
			</ul>
			<p>
			<span>检查名为<i><span>str</span></i>的锁是否正在被使用<span>(</span>换言之<span>,</span>被封锁<span>)</span>。若被封锁，则返回使用该锁的客户端的连接标识符。否则返回<span> 
			NULL</span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				MASTER_POS_WAIT(<i>log_name</i>,<i>log_pos</i>[,<i>timeout</i>])
				</span></li>
			</ul>
			<p>
			<span>
			该函数对于控制主从同步很有用处。它会持续封锁，直到从设备阅读和应用主机记录中所有补充资料到指定的位置。返回值是其为到达指定位置而必须等待的记录事件的数目。若从设备<span>SQL</span>线程没有被启动、从设备主机信息尚未初始化、参数不正确或出现任何错误，则该函数返回<span> 
			NULL</span>。若</span><span>超时时间被</span><span>超过，则返回<span>-1</span>。</span><span>若</span><span>在<span>MASTER_POS_WAIT()
			</span>等待期间，从设备<span>SQL</span>线程中止，则该函数返回<span> 
			NULL</span>。若从设备由指定位置通过，则函数会立即返回结果。<span> </span></span>
			</p>
			<p>
			<span>
			假如已经指定了一个</span><i><span>超时时间</span></i><span>值，当 
			</span><i><span>超时时间</span><span>
			</span></i>
			<span>秒数经过后<span>MASTER_POS_WAIT()</span>会停止等待。</span><i><span>超时时间</span></i><span> 
			必须大于<span> 0</span>；一个为零或为负值的 </span><i>
			<span>超时时间</span></i><span> 
			表示没有超市时间。<span>&nbsp; </span></span></p>
			<ul type="disc">
				<li>
				<span >
				NAME_CONST(<i>name</i>,<i>value</i>) </span></li>
			</ul>
			<p>
			<span>
			返回给定值。 当用来产生一个结果集合列时<span>, NAME_CONST()</span>促使该列使用给定名称。<span>&nbsp;
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT NAME_CONST(&#39;myname&#39;, 14);</b></span></p>
			<p>
			<span >
			+--------+</span></p>
			<p>
			<span >
			| myname |</span></p>
			<p>
			<span >
			+--------+</span></p>
			<p>
			<span >
			|&nbsp;&nbsp;&nbsp;&nbsp; 14 |</span></p>
			<p>
			<span >
			+--------+</span></p>
			<p>
			<span>
			这个函数被添加进<span> MySQL 5.0.12</span>。它只做内部使用。 
			服务器在书写来自包含局部程序变量的存储程序的语句时会用到它，详见</span><a href="stored-procedures.html#stored-procedure-logging" title="20.4. Binary Logging of Stored Routines and Triggers">20.4节，“存储子程序和触发程序的二进制日志功能”</a><span>。你可能会在<b><span>mysqlbinlog</span></b><span>
			</span>的书橱中看到这个函数。<span> </span></span></p>
			<ul type="disc">
				<li>
				<span >
				RELEASE_LOCK(<i>str</i>) </span></li>
			</ul>
			<p>
			<span>解开被<span>GET_LOCK()</span>获取的，用字符串<i><span>str</span></i><span>
			</span>所命名的锁。若锁被解开，则返回<span>&nbsp; 1</span>，若改线程尚未创建锁，则返回<span>0 
			(</span>此时锁没有被解开<span> ), </span>若命名的锁不存在，则返回<span> 
			NULL</span>。若该锁从未被对<span>GET_LOCK()</span>的调用获取，或锁已经被提前解开，则该锁不存在。</span></p>
			<p>
			<span >
			DO </span>
			<span>语句和<span>RELEASE_LOCK()</span>同时使用很方便。请参见</span><a href="sql-syntax.html#do" title="13.2.2. DO Syntax">13.2.2节，“DO语法”</a><span >。 
			</span></p>
			<ul type="disc">
				<li>
				<span >
				SLEEP(<i>duration</i>) </span></li>
			</ul>
			<p>
			<span>睡眠<span>(</span>暂停<span>)
			</span>时间为<i><span>duration</span></i><span>
			</span>参数给定的秒数，然后返回<span> 0</span>。若<span> 
			SLEEP() </span>被中断<span>,</span>它会返回<span> 1</span>。<span> 
			duration </span>或许或包括一个给定的以微秒为单位的分数部分。<span> </span>
			</span></p>
			<ul type="disc">
				<li>
				<span >UUID()
				</span></li>
			</ul>
			<p>
			<span>
			返回一个通用唯一标识符<span>(UUID) </span>，其产生的根据是《<span>DCE 
			1.1: </span></span><span>
			远程过程调用</span><span>》<span> 
			(</span>附录<span>A) CAE (</span>公共应用软件环境</span><span >)
			</span>
			<span>
			的说明，该作品于<span>1997</span>年<span>10</span>月由<span> 
			The Open Group </span>出版<span> (</span>文件编号<span> 
			C706,
			<a target="_top"  href="http://www.opengroup.org/public/pubs/catalog/c706.htm">
			http://www.opengroup.org/public/pubs/catalog/c706.htm</a>). </span>
			</span></p>
			<p>
			<span >
			UUID</span><span>被设计成一个在时间和空间上都独一无二的数字。<span>2</span>个对<span>UUID()
			</span>的调用应产生<span>2</span>个不同的值，即使这些调用的执行是在两个互不相连的单独电脑上进行。<span>
			</span></span></p>
			<p>
			<span >
			UUID </span>
			<span>是一个由<span>5</span>位十六进制数的字符串表示的<span>128</span>比特数字 
			，其格式为<span>&nbsp; aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee </span>：</span></p>
			<ul type="disc">
				<ul type="circle">
					<li>
					<span>前<span>3</span>个数字从一个时间戳产生。<span>&nbsp;
					</span></span></li>
					<li>
					<span>第<span>4
					</span>个数字保持暂时唯一性，以防时间戳值失去单一性<span> (</span>例如<span>,
					</span>由于经济时<span>)</span>。</span></li>
					<li>
					<span>第<span>5</span>个数字是一个<span> 
					IEEE 802 </span>节点号，它提供空间唯一性。若后者不可用，则用一个随机数字替换。<span> 
					(</span>例如<span>, </span>
					由于主机没有以太网卡，或我们不知道怎样在你的操作系统上找到界面的机器地址<span> )</span>。假若这样，空间唯一性就不能得到保证。尽管如此，一个冲突的发生机率还是<i>非常</i>低的。<span>
					</span></span></li>
				</ul>
			</ul>
			<p>
			<span>目前<span>,</span>一个界面的<span> 
			MAC </span>地址尽被<span>FreeBSD </span>和<span> 
			Linux</span>考虑到。在其它操作系统中<span>, MySQL</span>使用随机产生的<span> 
			48</span>比特数字。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT UUID();</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; &#39;6ccd780c-baba-1026-9564-0040f4311e29&#39;</span></p>
			<p>
			<span>注意，<span> 
			UUID() </span>不支持复制功能。<span> </span></span></p>
			<ul type="disc">
				<li>
				<span >
				VALUES(<i>col_name</i>) </span></li>
			</ul>
			<p>
			<span>在一个<span>INSERT
			</span>…<span> ON DUPLICATE KEY UPDATE </span>…语句中，你可以在<span>UPDATE
			</span>子句中使用<span> VALUES(<i>col_name</i>)</span>函数，用来访问来自该语句的<span>INSERT
			</span>部分的列值。换言之，<span>UPDATE </span>子句中的<span> 
			VALUES(<i>col_name</i>) </span>访问需要被插入的<i><span>col_name
			</span></i>的值<span>,</span>并不会发生重复键冲突。这个函数在多行插入中特别有用。<span>&nbsp; 
			VALUES()</span>函数只在<span>INSERT ... UPDATE </span>
			语句中有意义，而在其它情况下只会返回<span> NULL</span>。请参见</span><a href="sql-syntax.html#insert" title="13.2.4. INSERT Syntax">13.2.4节，“INSERT语法”</a><span >.
			</span></p>
			<p>
			<span >
			mysql&gt; <b>INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6)</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt; <b>ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);</b></span></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="group-by-functions-and-modifiers"></a>
		12.10.&nbsp;与GROUP BY子句同时使用的函数和修改程序<code class="literal"></code></h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="functions.html#group-by-functions">12.10.1. 
			GROUP BY（聚合）函数</a></span></dt><dt><span class="section"><a href="functions.html#group-by-modifiers">12.10.2. 
			GROUP BY修改程序</a></span></dt><dt><span class="section"><a href="functions.html#group-by-hidden-fields">12.10.3. 
			具有隐含字段的GROUP BY</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-by-functions"></a>12.10.1. GROUP 
			BY（聚合）函数</h3></div></div></div><a class="indexterm" name="id2887569"></a><a class="indexterm" name="id2887578"></a>
			<p>
			<span>
			本章论述了用于一组数值操作的<span> group (</span>集合<span>)</span>函数。除非另作说明，<span> 
			group </span>函数会忽略<span> NULL </span>值。</span></p>
			<p>
			<span>
			假如你在一个不包含<span> ROUP BY</span>子句的语句中使用一个<span> 
			group</span>函数 ，它相当于对所有行进行分组。<span> </span></span></p>
			<ul type="disc">
				<li>
				<span >
				AVG([DISTINCT] <i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>expr</span></i><span>
			</span>的平均值。<span> DISTINCT </span>选项可用于返回 <i>
			<span>expr</span></i>的不同值的平均值。<span> </span>
			</span></p>
			<p>
			<span>
			若找不到匹配的行，则<span>AVG()</span>返回<span> NULL </span>
			。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT student_name, AVG(test_score)</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>FROM student</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>GROUP BY student_name;</b></span></p>
			<ul type="disc">
				<li>
				<span >
				BIT_AND(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>expr</span></i>中所有比特的<span> 
			bitwise AND </span>。计算执行的精确度为<span>64</span>比特<span>(BIGINT)
			</span>。</span></p>
			<p>
			<span>
			若找不到匹配的行，则这个函数返回<span> 18446744073709551615 </span>。<span>(</span>这是无符号<span> 
			BIGINT </span>值，所有比特被设置为<span> 1</span>）<span>。
			</span></span></p>
			<ul type="disc">
				<li>
				<span >
				BIT_OR(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>expr</span></i><span>
			</span>中所有比特的<span>bitwise OR</span>。计算执行的精确度为<span>64</span>比特<span>(BIGINT)
			</span>。</span></p>
			<p>
			<span>
			若找不到匹配的行，则函数返回<span> 0 </span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				BIT_XOR(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>expr</span></i><span>
			</span>中所有比特的<span>bitwise XOR</span>。计算执行的精确度为<span>64</span>比特<span>(BIGINT)
			</span>。</span></p>
			<p>
			<span>
			若找不到匹配的行，则函数返回<span> 0 </span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				COUNT(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<span>SELECT</span>语句检索到的行中非<span>NULL</span>值的数目。<span>&nbsp;&nbsp;
			</span></span></p>
			<p>
			<span>
			若找不到匹配的行，则<span>COUNT() </span>返回<span> 0 </span>
			。<span> </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT student.student_name,COUNT(*)</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>FROM student,course</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>WHERE student.student_id=course.student_id</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>GROUP BY student_name;</b></span></p>
			<p>
			<span >
			&nbsp;</span></p>
			<p>
			<span >
			COUNT(*) </span>
			<span>
			的稍微不同之处在于，它返回检索行的数目， 不论其是否包含<span> NULL</span>值。</span></p>
			<p>
			<span >
			SELECT </span>
			<span>
			从一个表中检索，而不检索其它的列，并且没有<span> WHERE</span>子句时，<span> 
			COUNT(*)</span>被优化到最快的返回速度。例如：</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT COUNT(*) FROM student;</b></span></p>
			<p>
			<span>
			这个优化仅适用于<span> MyISAM</span>表<span>, </span>
			原因是这些表类型会储存一个函数返回记录的精确数量，而且非常容易访问。</span><span>对于</span><span>事务型的存储引擎</span><span >(InnoDB, 
			BDB), </span>
			<span>
			存储一个精确行数的问题比较多，原因是可能会发生多重事物处理<span>, </span>
			而每个都可能会对行数产生影响。</span></p>
			<ul type="disc">
				<li>
				<span >
				COUNT(DISTINCT <i>expr</i>,[<i>expr</i>...]) </span></li>
			</ul>
			<p>
			<span>
			返回不同的非<span>NULL</span>值数目。</span></p>
			<p>
			<span>
			若找不到匹配的项，则<span>COUNT(DISTINCT)</span>返回<span> 0
			</span>。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT COUNT(DISTINCT results) FROM student;</b></span></p>
			<p>
			<span>在<span>MySQL</span>中<span>,
			</span>你通过给定一个表达式列表而获取不包含<span>NULL </span>不同表达式组合的数目。在标准<span> 
			SQL</span>中<span>,</span>你将必须在<span>COUNT(DISTINCT 
			...)</span>中连接所有表达式。</span></p>
			<ul type="disc">
				<li>
				<span >
				GROUP_CONCAT(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>
			该函数返回带有来自一个组的连接的非<span>NULL</span>值的字符串结果。其完整的语法如下所示：<span>&nbsp;
			</span></span></p>
			<p>
			<span >
			GROUP_CONCAT([DISTINCT] <i>expr</i> [,<i>expr</i> ...]</span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ORDER BY {<i>unsigned_integer</i> | <i>col_name</i> |
			<i>expr</i>}</span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ASC | DESC] [,<i>col_name</i> ...]]</span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [SEPARATOR <i>str_val</i>])</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT student_name,</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <b>GROUP_CONCAT(test_score)</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <b>FROM student</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <b>GROUP BY student_name;</b></span></p>
			<p>
			<span >
			Or: </span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT student_name,</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <b>GROUP_CONCAT(DISTINCT test_score</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>ORDER BY test_score DESC SEPARATOR &#39; &#39;)</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <b>FROM student</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <b>GROUP BY student_name;</b></span></p>
			<p>
			<span>在<span>MySQL</span>中<span>,</span>你可以获取表达式组合的连接值。你可以使用<span>DISTINCT</span>删去重复值。假若你希望多结果值进行排序，则应该使用<span>&nbsp; 
			ORDER BY</span>子句。若要按相反顺序排列，将<span> DESC (</span>递减<span>)
			</span>关键词添加到你要用<span>ORDER BY </span>
			子句进行排序的列名称中。默认顺序为升序；可使用<span>ASC</span>将其明确指定。<span>&nbsp;&nbsp; 
			SEPARATOR </span>后面跟随应该被插入结果的值中间的字符串值。默认为逗号<span> (</span>‘<span>,</span>’<span>)</span>。通过指定<span>SEPARATOR 
			&#39;&#39; </span>，你可以删除所有分隔符。<span> </span></span></p>
			<p>
			<span>使用<span>group_concat_max_len</span>系统变量，你可以设置允许的最大长度。<span>&nbsp;
			</span>程序中进行这项操作的语法如下，其中<span> val </span>是一个无符号整数：</span></p>
			<p>
			<span >
			SET [SESSION | GLOBAL] group_concat_max_len = val;</span></p>
			<p>
			<span>
			若已经设置了最大长度， 则结果被截至这个最大长度。<span> </span></span></p>
			<ul type="disc">
				<li>
				<span>
				MIN([DISTINCT] <i>expr</i>), MAX([DISTINCT] <i>expr</i>) </span>
				</li>
			</ul>
			<p>
			<span>返回</span><i><span>expr</span></i><span>
			</span>
			<span>
			的最小值和最大值。</span><span> 
			MIN() </span>
			<span>和</span><span> 
			MAX() </span>
			<span>
			的取值可以是一个字符串参数；在这些情况下， 它们返回最小或最大字符串值。请参见</span><a href="optimization.html#mysql-indexes" title="7.4.5. How MySQL Uses Indexes">7.4.5节，“MySQL如何使用索引”</a><span>。<span>&nbsp; 
			DISTINCT</span>关键词可以被用来查找<i><span>expr</span></i><span>
			</span>的不同值的最小或最大值，然而，这产生的结果与省略<span>DISTINCT </span>
			的结果相同。</span></p>
			<p>
			<span>
			若找不到匹配的行，<span>MIN()</span>和<span>MAX()</span>返回<span> 
			NULL </span>。</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT student_name, MIN(test_score), MAX(test_score)</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>FROM student</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>GROUP BY student_name;</b></span></p>
			<p>
			<span>对于<span>MIN()</span>、<span> 
			MAX()</span>和其它集合函数，<span> MySQL</span>当前按照它们的字符串值而非字符串在集合中的相关位置比较<span> 
			ENUM</span>和<span> SET </span>列。这同<span>ORDER BY</span>比较二者的方式有所不同。这一点应该在<span>MySQL</span>的未来版本中得到改善。<span>&nbsp;
			</span></span></p>
			<ul type="disc">
				<li>
				<span >STD(<i>expr</i>) 
				STDDEV(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>expr</span></i><span>
			</span>的总体标准偏差。这是标准<span> SQL </span>的延伸。这个函数的<span>STDDEV()
			</span>形式用来提供和<span>Oracle </span>的兼容性。可使用标准<span>SQL</span>函数<span> 
			STDDEV_POP() </span>进行代替。</span></p>
			<p>
			<span>
			若找不到匹配的行，则这些函数返回<span> NULL </span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				STDDEV_POP(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>expr</span></i><span>
			</span>的总体标准偏差<span>(VAR_POP()</span>的平方根<span>)</span>。你也可以使用<span>&nbsp; 
			STD() </span>或<span>STDDEV(), </span>它们具有相同的意义，然而不是标准的<span> 
			SQL</span>。</span></p>
			<p>
			<span>
			若找不到匹配的行，则<span>STDDEV_POP()</span>返回<span> NULL</span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				STDDEV_SAMP(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>expr</span></i><span>
			</span>的样本标准差<span> ( VAR_SAMP()</span>的平方根<span>)</span>。<span>
			</span></span></p>
			<p>
			<span>
			若找不到匹配的行，则<span>STDDEV_SAMP() </span>返回<span> 
			NULL </span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				SUM([DISTINCT] <i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>expr</span></i><span>
			</span>的总数。 若返回集合中无任何行，则<span> SUM() </span>返回<span>NULL</span>。<span>DISTINCT
			</span>关键词可用于<span> MySQL 5.1 </span>中，求得<i><span>expr
			</span></i>不同值的总和。<span> </span></span></p>
			<p>
			<span>
			若找不到匹配的行，则<span>SUM()</span>返回<span> NULL</span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				VAR_POP(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>expr</span></i><span>
			</span>总体标准方差。它将行视为总体，而不是一个样本， 所以它将行数作为分母。你也可以使用<span> 
			VARIANCE(),</span>它具有相同的意义然而不是 标准的<span> SQL</span>。</span></p>
			<p>
			<span>
			若找不到匹配的项，则<span>VAR_POP()</span>返回<span>NULL</span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				VAR_SAMP(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>expr</span></i><span>
			</span>的样本方差。更确切的说，分母的数字是行数减去<span>1</span>。<span>&nbsp;&nbsp;
			</span></span></p>
			<p>
			<span>
			若找不到匹配的行，则<span>VAR_SAMP()</span>返回<span>NULL</span>。</span></p>
			<ul type="disc">
				<li>
				<span >
				VARIANCE(<i>expr</i>) </span></li>
			</ul>
			<p>
			<span>返回<i><span>expr</span></i><span>
			</span>的总体标准方差。这是标准<span>SQL </span>的延伸。可使用标准<span>SQL
			</span>函数<span> VAR_POP() </span>进行代替。</span></p>
			<p>
			<span>
			若找不到匹配的项，则<span>VARIANCE()</span>返回<span>NULL</span>。</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-by-modifiers"></a>12.10.2. GROUP 
			BY修改程序</h3></div></div></div><a class="indexterm" name="id2889264"></a><a class="indexterm" name="id2889273"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			<span >
			GROUP BY</span><span>子句允许一个将额外行添加到简略输出端<span> 
			WITH ROLLUP </span>修饰符。这些行代表高层<span>(</span>或高聚集<span>)</span>简略操作。<span>ROLLUP
			</span>因而允许你在多层分析的角度回答有关问询的问题。例如，它可以用来向<span>OLAP (</span>联机分析处理<span>)
			</span>操作提供支持。</span></p>
			<p>
			<span>
			设想一个名为<span>sales </span>的表具有年份、国家、产品及记录销售利润的利润列：</span></p>
			<p>
			<span >
			CREATE TABLE sales</span></p>
			<p>
			<span >
			(</span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; year&nbsp;&nbsp;&nbsp; INT NOT NULL,</span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; country VARCHAR(20) NOT NULL,</span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; product VARCHAR(32) NOT NULL,</span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; profit&nbsp; INT</span></p>
			<p>
			<span >
			);</span></p>
			<p>
			<span>
			可以使用这样的简单<span>GROUP BY</span>，每年对表的内容做一次总结：</span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT year, SUM(profit) FROM sales GROUP BY year;</b></span></p>
			<p>
			<span >
			+------+-------------+</span></p>
			<p>
			<span >
			| year | SUM(profit) |</span></p>
			<p>
			<span >
			+------+-------------+</span></p>
			<p>
			<span >
			| 2000 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4525 |</span></p>
			<p>
			<span >
			| 2001 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3010 |</span></p>
			<p>
			<span >
			+------+-------------+</span></p>
			<p>
			<span>
			这个输出结果显示了每年的总利润， 但如果你也想确定所有年份的总利润，你必须自己累加每年的单个值或运行一个加法询问。<span>
			</span></span></p>
			<p>
			<span>
			或者你可以使用<span> ROLLUP, </span>它能用一个问询提供双层分析。将一个<span> 
			WITH ROLLUP</span>修饰符添加到<span>GROUP BY </span>
			语句，使询问产生另一行结果，该行显示了所有年份的总价值：<span> </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT year, SUM(profit) FROM sales GROUP BY year WITH 
			ROLLUP;</b></span></p>
			<p>
			<span >
			+------+-------------+</span></p>
			<p>
			<span >
			| year | SUM(profit) |</span></p>
			<p>
			<span >
			+------+-------------+</span></p>
			<p>
			<span >
			| 2000 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4525 |</span></p>
			<p>
			<span >
			| 2001 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3010 |</span></p>
			<p>
			<span >
			| NULL |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7535 |</span></p>
			<p>
			<span >
			+------+-------------+</span></p>
			<p>
			<span>
			总计高聚集行被年份列中的<span>NULL</span>值标出。<span> </span>
			</span></p>
			<p>
			<span>当有多重<span> 
			GROUP BY </span>列时，<span>ROLLUP</span>产生的效果更加复杂。这时，每次在除了最后一个分类列之外的任何列出现一个 
			“<span>break</span>”<span> (</span>值的改变<span>)
			</span>，则问讯会产生一个高聚集累计行。<span> </span></span></p>
			<p>
			<span>
			例如，在没有<span> ROLLUP</span>的情况下，一个以年、国家和产品为基础的关于<span> 
			sales </span>表的一览表可能如下所示：<span> </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT year, country, product, SUM(profit)</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt; <b>FROM sales</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt; <b>GROUP BY year, country, product;</b></span></p>
			<p>
			<span >
			+------+---------+------------+-------------+</span></p>
			<p>
			<span >
			| year | country | product&nbsp;&nbsp;&nbsp; | SUM(profit) |</span></p>
			<p>
			<span >
			+------+---------+------------+-------------+</span></p>
			<p>
			<span >
			| 2000 | Finland | Computer&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1500 |</span></p>
			<p>
			<span >
			| 2000 | Finland | Phone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100 |</span></p>
			<p>
			<span >
			| 2000 | India&nbsp;&nbsp; | Calculator |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 150 |</span></p>
			<p>
			<span >
			| 2000 | India&nbsp;&nbsp; | Computer&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1200 |</span></p>
			<p>
			<span >
			| 2000 | USA&nbsp;&nbsp;&nbsp;&nbsp; | Calculator |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 75 |</span></p>
			<p>
			<span >
			| 2000 | USA&nbsp;&nbsp;&nbsp;&nbsp; | Computer&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1500 |</span></p>
			<p>
			<span >
			| 2001 | Finland | Phone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 |</span></p>
			<p>
			<span >
			| 2001 | USA&nbsp;&nbsp;&nbsp;&nbsp; | Calculator |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50 |</span></p>
			<p>
			<span >
			| 2001 | USA&nbsp;&nbsp;&nbsp;&nbsp; | Computer&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2700 |</span></p>
			<p>
			<span >
			| 2001 | USA&nbsp;&nbsp;&nbsp;&nbsp; | TV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 250 |</span></p>
			<p>
			<span >
			+------+---------+------------+-------------+</span></p>
			<p>
			<span>
			表示总值的输出结果仅位于年<span>/</span>国家<span>/</span>产品的分析级别。当添加了<span> 
			ROLLUP</span>后， 问询会产生一些额外的行：<span> </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT year, country, product, SUM(profit)</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt; <b>FROM sales</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt; <b>GROUP BY year, country, product WITH ROLLUP;</b></span></p>
			<p>
			<span >
			+------+---------+------------+-------------+</span></p>
			<p>
			<span >
			| year | country | product&nbsp;&nbsp;&nbsp; | SUM(profit) |</span></p>
			<p>
			<span >
			+------+---------+------------+-------------+</span></p>
			<p>
			<span >
			| 2000 | Finland | Computer&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1500 |</span></p>
			<p>
			<span >
			| 2000 | Finland | Phone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100 |</span></p>
			<p>
			<span >
			| 2000 | Finland | NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1600 |</span></p>
			<p>
			<span >
			| 2000 | India&nbsp;&nbsp; | Calculator |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 150 |</span></p>
			<p>
			<span >
			| 2000 | India&nbsp;&nbsp; | Computer&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1200 |</span></p>
			<p>
			<span >
			| 2000 | India&nbsp;&nbsp; | NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1350 |</span></p>
			<p>
			<span >
			| 2000 | USA&nbsp;&nbsp;&nbsp;&nbsp; | Calculator |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 75 |</span></p>
			<p>
			<span >
			| 2000 | USA&nbsp;&nbsp;&nbsp;&nbsp; | Computer&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1500 |</span></p>
			<p>
			<span >
			| 2000 | USA&nbsp;&nbsp;&nbsp;&nbsp; | NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1575 |</span></p>
			<p>
			<span >
			| 2000 | NULL&nbsp;&nbsp;&nbsp; | NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4525 |</span></p>
			<p>
			<span >
			| 2001 | Finland | Phone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 |</span></p>
			<p>
			<span >
			| 2001 | Finland | NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 |</span></p>
			<p>
			<span >
			| 2001 | USA&nbsp;&nbsp;&nbsp;&nbsp; | Calculator |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50 |</span></p>
			<p>
			<span >
			| 2001 | USA&nbsp;&nbsp;&nbsp;&nbsp; | Computer&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2700 |</span></p>
			<p>
			<span >
			| 2001 | USA&nbsp;&nbsp;&nbsp;&nbsp; | TV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 250 |</span></p>
			<p>
			<span >
			| 2001 | USA&nbsp;&nbsp;&nbsp;&nbsp; | NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;3000 |</span></p>
			<p>
			<span >
			| 2001 | NULL&nbsp;&nbsp;&nbsp; | NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3010 |</span></p>
			<p>
			<span >
			| NULL | NULL&nbsp;&nbsp;&nbsp; | NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7535 |</span></p>
			<p>
			<span >
			+------+---------+------------+-------------+</span></p>
			<p>
			<span>
			对于这个问询， 添加<span>ROLLUP </span>
			子句使村输出结果包含了四层分析的简略信息，而不只是一个下面是怎样解释<span>&nbsp; ROLLUP</span>输出：</span></p>
			<ul type="disc">
				<li>
				<span>
				一组给定的年份和国家的每组产品行后面<span>, </span>会产生一个额外的总计行， 
				显示所有产品的总值。这些行将产品列设置为<span> NULL</span>。</span></li>
				<li>
				<span>
				一组给定年份的行后面，会产生一个额外的总计行，显示所有国家和产品的总值。这些行将国家和产品列设置为<span>&nbsp; 
				NULL</span>。<span> </span></span></li>
				<li>
				<span>最后<span>,
				</span>在所有其它行后面，会产生一个额外的总计列，显示所有年份、国家及产品的总值。 这一行将年份、国家和产品列设置为<span> 
				NULL</span>。</span></li>
			</ul>
			<p><b>
			<span>使用<span>ROLLUP</span></span><span >
			</span>
			<span>
			时的其它注意事项 </span></b></p>
			<p>
			<span>
			以下各项列出了一些<span>MySQL</span>执行<span>ROLLUP</span>的特殊状态：<span>&nbsp;
			</span></span></p>
			<p>
			<span>当你使用<span> 
			ROLLUP</span>时<span>, </span>你不能同时使用<span> ORDER 
			BY</span>子句进行结果排序。换言之，<span> ROLLUP </span>和<span>ORDER 
			BY </span>是互相排斥的。然而，你仍可以对排序进行一些控制。在<span> MySQL</span>中，<span> 
			GROUP BY </span>可以对结果进行排序，而且你可以在<span>GROUP BY</span>列表指定的列中使用明确的<span> 
			ASC</span>和<span>DESC</span>关键词，从而对个别列进行排序。<span> 
			(</span>不论如何排序被<span>ROLLUP</span>添加的较高级别的总计行仍出现在它们被计算出的行后面）<span>。
			</span></span></p>
			<p>
			<span >
			LIMIT</span><span>可用来限制返回客户端的行数。<span>LIMIT
			</span>用在<span> ROLLUP</span>后面<span>, </span>
			因此这个限制 会取消被<span>ROLLUP</span>添加的行。例如<span>:
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT year, country, product, SUM(profit)</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt; <b>FROM sales</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt; <b>GROUP BY year, country, product WITH ROLLUP</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt; <b>LIMIT 5;</b></span></p>
			<p>
			<span >
			+------+---------+------------+-------------+</span></p>
			<p>
			<span >
			| year | country | product&nbsp;&nbsp;&nbsp; | SUM(profit) |</span></p>
			<p>
			<span >
			+------+---------+------------+-------------+</span></p>
			<p>
			<span >
			| 2000 | Finland | Computer&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1500 |</span></p>
			<p>
			<span >
			| 2000 | Finland | Phone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100 |</span></p>
			<p>
			<span >
			| 2000 | Finland | NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1600 |</span></p>
			<p>
			<span >
			| 2000 | India&nbsp;&nbsp; | Calculator |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 150 |</span></p>
			<p>
			<span >
			| 2000 | India&nbsp;&nbsp; | Computer&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1200 |</span></p>
			<p>
			<span >
			+------+---------+------------+-------------+</span></p>
			<p>
			<span>将<span>ROLLUP</span>同<span> 
			LIMIT</span>一起使用可能会产生更加难以解释的结果，原因是对于理解高聚集行，你所掌握的上下文较少。<span>
			</span></span></p>
			<p>
			<span>
			在每个高聚集行中的<span>NULL </span>
			指示符会在该行被送至客户端时产生。服务器会查看最左边的改变值后面的<span>GROUP BY</span>子句指定的列。对于任何结果集合中的，有一个词匹配这些名字的列<span>,
			</span>其值被设为<span> NULL</span>。<span>(</span>若你使用列数字指定了分组列，则服务器会通过数字确定将哪个列设置为<span> 
			NULL</span>）<span>。 </span></span></p>
			<p>
			<span>
			由于在高聚集行中的<span> NULL</span>值在问询处理阶段被放入结果集合中，你无法将它们在问询本身中作为<span>NULL</span>值检验。例如，你无法将<span> 
			HAVING product IS NULL </span>添加到问询中，从而在输出结果中删去除了高聚集行以外的部分。<span>&nbsp;
			</span></span></p>
			<p>
			<span>另一方面<span>, 
			NULL</span>值在客户端不以<span> NULL </span>的形式出现， 因而可以使用任何<span>MySQL</span>客户端编程接口进行检验。<span>
			</span></span></p>
			<h3 class="title"><a name="group-by-hidden-fields"></a>12.10.3. 具有隐含字段的GROUP 
			BY</h3></div></div></div><a class="indexterm" name="id2889825"></a>
			<p>
			<span >
			MySQL </span>
			<span>扩展了<span> 
			GROUP BY</span>的用途，因此你可以使用<span>SELECT </span>列表中不出现在<span>GROUP 
			BY</span>语句中的列或运算。这代表 “对该组的任何可能值 
			”。你可以通过避免排序和对不必要项分组的办法得到它更好的性能。例如，在下列问询中，你无须对<span>customer.name
			</span>进行分组：<span> </span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT order.custid, customer.name, MAX(payments)</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>FROM order,customer</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>WHERE order.custid = customer.custid</b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>GROUP BY order.custid;</b></span></p>
			<p>
			<span>在标准<span>SQL</span>中<span>,
			</span>你必须将<span> customer.name</span>添加到<span> 
			GROUP BY</span>子句中。在<span>MySQL</span>中<span>,
			</span>假如你不在<span>ANSI</span>模式中运行，则这个名字就是多余的。<span>
			</span></span></p>
			<p>
			<span>假如你从<span> 
			GROUP BY </span>部分省略的列在该组中不是唯一的，那么<i>不要使用这个功能</i><span>!
			</span>你会得到非预测性结果。</span></p>
			<p>
			<span>
			在有些情况下<span>,</span>你可以使用<span>MIN()</span>和<span>MAX()
			</span>获取一个特殊的列值，即使他不是唯一的。下面给出了来自包含排序列中最小值的列中的值：<span>
			</span></span></p>
			<p>
			<span >
			SUBSTR(MIN(CONCAT(RPAD(sort,6,&#39; &#39;),column)),7)</span></p>
			<p>
			<span >
			See </span> <a href="tutorial.html#example-maximum-column-group-row" title="3.6.4. The Rows Holding the Group-wise Maximum of a Certain Field">
			3.6.4节，“拥有某个字段的组间最大值的行”</a><span >.
			</span></p>
			<p>
			<span>
			注意，假如你正在尝试遵循标准<span> SQL, </span>你不能使用<span>GROUP 
			BY</span>或<span> ORDER BY</span>子句中的表达式。你可以通过使用表达式的别名绕过这一限制：<span>&nbsp;
			</span></span></p>
			<p>
			<span >
			mysql&gt; <b>SELECT id,FLOOR(value/100) AS val </b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt; <b>FROM <i>tbl_name</i></b></span></p>
			<p>
			<span >
			&nbsp;&nbsp;&nbsp; -&gt; <b>GROUP BY id, val ORDER BY val;</b></span></p>
			<p>
			<span>然而<span>, 
			MySQL</span>允许你使用<span>GROUP BY </span>及<span> 
			ORDER BY </span>子句中的表达式。例如：</span></p>
			<span >
			mysql&gt; <b>SELECT id, FLOOR(value/100) FROM <i>tbl_name</i> ORDER BY 
			RAND();</b></span></div></div></div><div><hr><p>
      这是MySQL参考手册的翻译版本，关于MySQL参考手册，<span class="GramE">请访问</span><a target="_top"  href="http://dev.mysql.com/doc/mysql/en">dev.mysql.com</a>。 
		原始参考手册为英文版，与英文版参考手册相比，本翻译版可能不是最新的。</p></div>
</body></html>
