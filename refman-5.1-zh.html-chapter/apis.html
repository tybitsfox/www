<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Chapter 25. APIs and Libraries</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="up" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="prev" href="precision-math.html" title="Chapter 24. Precision Math"><link rel="next" href="connectors.html" title="Chapter 26.   Connectors">
</head><body><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="apis"></a>
	第25章：API和库</h2></div></div></div><div class="toc"><p><b>
	目录</b></p><dl><dt><span class="section"><a href="apis.html#libmysqld">25.1. 
			libmysqld，嵌入式MySQL服务器库</a></span></dt><dd><dl><dt><span class="section"><a href="apis.html#libmysqld-overview">25.1.1. 
				嵌入式MySQL服务器库概述</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-compiling">
				25.1.2. 使用libmysqld编译程序<code class="literal"></code></a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-restrictions">
				25.1.3. 使用嵌入式MySQL服务器时的限制</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-options">25.1.4. 
				与嵌入式服务器一起使用的选项</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-todo">
				25.1.5. 嵌入式服务器中尚需完成的事项(TODO)</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-example">
				25.1.6. 嵌入式服务器示例</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-licensing">
				25.1.7. 嵌入式服务器的许可</a></span></dt></dl></dd><dt><span class="section"><a href="apis.html#c">25.2. MySQL C API</a></span></dt><dd><dl><dt><span class="section"><a href="apis.html#c-api-datatypes">
				25.2.1. C API数据类型</a></span></dt><dt><span class="section"><a href="apis.html#c-api-function-overview">
				25.2.2. C API函数概述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-functions">
				25.2.3. C API函数描述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statements">
				25.2.4. C API预处理语句</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-datatypes">
				25.2.5. C API预处理语句的数据类型</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-function-overview">
				25.2.6. C API预处理语句函数概述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-functions">
				25.2.7. C API预处理语句函数描述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-problems">
				25.2.8. C API预处理语句方面的问题</a></span></dt><dt><span class="section"><a href="apis.html#c-api-multiple-queries">
				25.2.9. 多查询执行的C API处理</a></span></dt><dt><span class="section"><a href="apis.html#c-api-date-handling">
				25.2.10. 日期和时间值的C API处理</a></span></dt><dt><span class="section"><a href="apis.html#c-thread-functions">
				25.2.11. C API线程函数介绍</a></span></dt><dt><span class="section"><a href="apis.html#c-embedded-server-func">
				25.2.12. C API嵌入式服务器函数介绍</a></span></dt><dt><span class="section"><a href="apis.html#c-api-problems">
				25.2.13. 使用C API时的常见问题</a></span></dt><dt><span class="section"><a href="apis.html#building-clients">
				25.2.14. 创建客户端程序</a></span></dt><dt><span class="section"><a href="apis.html#threaded-clients">
				25.2.15. 如何生成线程式客户端</a></span></dt></dl></dd><dt><span class="section"><a href="apis.html#php">25.3. MySQL PHP API</a></span></dt><dd><dl><dt><span class="section"><a href="apis.html#php-problems">
				25.3.1. 使用MySQL和PHP的常见问题</a></span></dt></dl></dd><dt><span class="section"><a href="apis.html#perl">25.4. MySQL Perl API</a></span></dt><dt><span class="section"><a href="apis.html#cplusplus">25.5. MySQL C++ API</a></span></dt><dd><dl><dt><span class="section"><a href="apis.html#borland-c-plus-plus">25.5.1. Borland C++</a></span></dt></dl></dd><dt><span class="section"><a href="apis.html#python">25.6. MySQL Python API</a></span></dt><dt><span class="section"><a href="apis.html#tcl">25.7. MySQL Tcl API</a></span></dt><dt><span class="section"><a href="apis.html#eiffel">25.8. MySQL Eiffel Wrapper</a></span></dt><dt><span class="section"><a href="apis.html#programming-utilities">
			25.9. MySQL程序开发实用工具</a></span></dt><dd><dl><dt><span class="section"><a href="apis.html#msql2mysql">
				25.9.1. msql2mysql：转换mSQL程序以用于MySQL</a></span></dt><dt><span class="section"><a href="apis.html#mysql-config">
				25.9.2. mysql_config：获取编译客户端的编译选项</a></span></dt></dl></dd></dl></div><a class="indexterm" name="id3006679"></a><a class="indexterm" name="id3006686"></a><a class="indexterm" name="id3006692"></a><a class="indexterm" name="id3006701"></a><a class="indexterm" name="id3006710"></a><a class="indexterm" name="id3006721"></a><a class="indexterm" name="id3006732"></a>
	<p><a name="libmysqld0">本章介绍了MySQL可使用的API，从哪里获得它们，以及如何使用它们。</a> 详细介绍C 
	API，这是因为它是由MySQL团队开发的，而且它也是大多数其他API的基础。 本章还介绍了<span>libmysqld</span>库（嵌入式服务器），以及对应用程序开发人员有用的一些程序。 
	</p>
	<div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="libmysqld"></a>
		25.1.&nbsp;libmysqld，嵌入式MySQL服务器库</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#libmysqld-overview">25.1.1. 
			嵌入式MySQL服务器库概述</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-compiling">
			25.1.2. 使用libmysqld编译程序<code class="literal"></code></a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-restrictions">
			25.1.3. 使用嵌入式MySQL服务器时的限制</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-options">25.1.4. 
			与嵌入式服务器一起使用的选项</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-todo">
			25.1.5. 嵌入式服务器中尚需完成的事项(TODO)</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-example">
			25.1.6. 嵌入式服务器示例</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-licensing">
			25.1.7. 嵌入式服务器的许可</a></span></dt></dl></div><a class="indexterm" name="id3006767"></a><a class="indexterm" name="id3006774"></a><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-overview"></a>25.1.1. 嵌入式MySQL服务器库概述</h3></div></div></div>
			<p>使用嵌入式MySQL服务器库，能够在客户端应用程序中使用具备全部特性的MySQL服务器。 
			主要优点在于，增加了速度，并使得嵌入式应用程序的管理更简单。 </p>
			<p>嵌入式服务器库是以MySQL的客户端／服务器版本为基础的，采用C/C++语言编写。 
			其结果是嵌入式服务器也是用C/C++语言编写的。 在其他语言中，嵌入式服务器不可用。 </p>
			<p>API与嵌入式MySQL版本和客户端／服务器版本等效。 
			要想更改旧的线程式应用程序以使用嵌入式库，正常情况下，仅需添加对下述函数的调用即可。 </p>
			<table border="1" cellpadding="0" id="table1">
				<tr>
					<td>
					<p><b>函数</b></td>
					<td>
					<p><b>何时调用</b></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>mysql_server_init()</span></td>
					<td>
					<p>应在调用任何其他MySQL函数之前调用，最好是在<span>main()函数中调用。</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>mysql_server_end()</span></td>
					<td>
					<p>应在程序退出前调用。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>mysql_thread_init()</span></td>
					<td>
					<p>应在你所创建的、用于访问MySQL的每个线程中调用。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>mysql_thread_end()</span></td>
					<td>
					<p>应在调用<span>pthread_exit()之前调用。</span></td>
				</tr>
			</table>
			<p>随后，必须将你的代码与<span>libmysqld.a链接起来，而不是libmysqlclient.a。</span></p>
			<p>在<span>libmysqlclient.a中还包含mysql_server_<i>xxx</i>()</span>函数，使用这类函数，通过将应用程序链接到恰当的库，即可在嵌入式版本和客户端／服务器版本之间切换。 
			请参见<a href="apis.html#mysql-server-init" title="25.2.12.1. mysql_server_init()">25.2.12.1节，“mysql_server_init()”</a>。 </p>
			<p>嵌入式服务器和独立服务器之间的一项差别在于，对于嵌入式服务器，默认情况下，连接鉴定是禁止的。 
			对于嵌入式服务器，要想使用鉴定功能，可在激活“<strong><span>configure</span></strong>”以配置<span>MySQL</span>分发版时使用“<span>--with-embedded-privilege-control</span>”选项。 </div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-compiling"></a>
			25.1.2.&nbsp;使用libmysqld编译程序<code class="literal"></code></h3></div></div></div>
			<p>要想获得<span><span>libmysqld</span>库，应使用<span  >“</span><span>--with-embedded-server</span><span  >”</span>选项配置<span>MySQL</span>。</span> 
			请参见<a href="installing.html#configure-options" title="2.8.2. Typical configure Options">2.8.2节，“典型配置选项<span><strong class="command"></strong></span>”</a>。 </p>
			<p>将你的程序与<span>libmysqld链接时，还必须包含系统的pthread库以及MySQL服务器使用的一些库。</span> 
			执行“<strong><span>mysql_config --libmysqld-libs</span></strong>”，可获得库的完整列表。 
			</p>
			<p>对于线程程序的编译和链接，必须使用正确的标志，即使你未在代码中直接调用任何线程函数也同样。 </p>
			<p>要想编译C程序以包含必要文件，并将MySQL服务器库嵌入到程序的编译版本中，可使用GNU C编译器（<span>gcc</span>）。 
			编译器需要知道各种文件的位置，并需了解如何编译程序的指令。 在下面的示例中，介绍了如何从命令行编译程序的方法： </p>
			<pre><span>gcc mysql_test.c -o mysql_test -lz \</span></pre>
			<pre><span>`/usr/local/mysql/bin/mysql_config --include --libmysqld-libs`</span></pre>
			<p>在gcc命令后紧跟着未编译C程序文件的名称。 接下来，给定的“<span>-o</span>”选项指明，它后面的文件名是编译器将输出文件的名称，即编译后的程序。 
			在下一行的代码中，通知编译器获取包含文件和库的位置，以及在其上进行编译的系统的其他设置。 由于“<strong><span>mysql_config</span></strong>”存在的问题，在此添加了“<span>-lz</span>”选项（压缩）。 
			“<strong><span>mysql_config</span></strong>”部分包含在<span>backticks</span>中，而不是单引号内。 </div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-restrictions"></a>
			25.1.3.&nbsp;使用嵌入式MySQL服务器时的限制</h3></div></div></div>
			<p>嵌入式服务器存在下述限制： </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不支持<span>ISAM表。</span> 
			（这样做的主要目的是为了使库更小）。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>没有自定义函数（UDF）。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>没有对核心转储的堆栈跟踪。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>没有内部RAID支持。 （由于大多数当前操作系统均支持大文件，通常情况下不需要它）。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不能将其设置为“主”或“从”（无复制）。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在内存较低的系统上，可能无法使用很大的结果集。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不能使用套接字或TCP/IP从外部进程连接到嵌入式服务器。 
			但是，你可以连接到中间应用程序，随后，该中间应用程序可代表远程客户端或外部进程连接到嵌入式服务器。 </p>
			<p>通过编辑“<span>mysql_embed.h</span>”包含文件并重新编译MySQL，可更改某些限制。 </div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-options"></a>25.1.4. 与嵌入式服务器一起使用的选项</h3></div></div></div><a class="indexterm" name="id3007169"></a><a class="indexterm" name="id3007180"></a><a class="indexterm" name="id3007190"></a><a class="indexterm" name="id3007200"></a>
			<p>对于任何能够与<strong><span>mysqld</span></strong>服务器端口监督程序一起给定的选项，也可以与嵌入式服务器库一起使用。在数组中，可将服务器选项作为参量指定给用于初始化服务器的<span>mysql_server_init()</span>。也能在诸如<span><span>my.cnf</span>的选项文件中给定它们。</span>要想为<span>C</span>程序指定选项文件，请使用“<span><span>--defaults-file</span><span  >”</span>选项作为函数<span>mysql_server_init()</span>的第<span>2</span>个参量的元素之一。关于<span>mysql_server_init()</span>函数的更多信息，请参见</span><a href="apis.html#mysql-server-init" title="25.2.12.1. mysql_server_init()">25.2.12.1节，“mysql_server_init()”</a>。</p>
			<p>使用选项文件，能够简化客户端／服务器应用程序和嵌入了<span>MySQL</span>的应用程序之间的切换。将常用选项置于<span>[server]</span>组。它们可被两种<span>MySQL</span>版本读取。客户端／服务器选项应被放在<span><span>[mysqld]</span>部分。将嵌入式<span>MySQL</span>服务器库的选项</span>放在<span><span>[embedded]</span>部分。将与应用程序相关的选项放在</span>标记为<span><span>[ApplicationName_SERVER]</span>的部分。</span>请参见<a href="using-mysql-programs.html#option-files" title="4.3.2. Using Option Files">4.3.2节，“使用选项文件”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-todo"></a>
			25.1.5.&nbsp;嵌入式服务器中尚需完成的事项(TODO)</h3></div></div></div><a class="indexterm" name="id3007292"></a><div class="itemizedlist">
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>我们将提供一些选项以省去<span>MySQL</span>的某些部分，从而使库变得更小。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>仍有很多速度优化工作需要完成。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>错误将被写入<span><span>stderr</span>。我们将增加<span>1</span>个选项为它们指定文件名。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>使用嵌入式版本时，需要更改<span>InnoDB</span>，使之不再冗长。如果你的数据库不含<span>InnoDB</span>表，要想抑制相关消息，可为组<span><span>[libmysqd_server]</span>下的选项文件增加</span>“<span><span>--skip-innodb”</span>选项，或在用</span><strong><span>mysql_server_init()</span></strong><span>初始化服务器时添加该选项。</span></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-example"></a>
			25.1.6.&nbsp;嵌入式服务器示例</h3></div></div></div>
			<p>在<span>Linux</span>或<span>FreeBSD</span>系统上，无需更改就能使用下面这两个示例程序。对于其他操作系统，需要进行小的修改，主要是文件路径。设计这两个示例的目的在于，为你提供足够的细节信息，以便理解问题，它们是实际应用程序的必要组成部份。第<span>1</span>个示例十分直观。第<span>2</span>个示例采用了一些错误检查功能，略为复杂。在第<span>1</span>个示例的后面，给出了用于编译程序的命令行条目。在第<span>2</span>个示例的后面，给出了<span>GNUmake</span>文件，该文件可用于编译。</p>
			<p><strong><span>示例：<span>1</span></span></strong><span>
			</span></p>
			<p><span>test1_libmysqld.c</span><span>
			</span></p>
			<pre><span>#include &lt;stdio.h&gt;</span></pre>
			<pre><span>#include &lt;stdlib.h&gt;</span></pre>
			<pre><span>#include &lt;stdarg.h&gt;</span></pre>
			<pre><span>#include &quot;mysql.h&quot;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>MYSQL *mysql;</span></pre>
			<pre><span>MYSQL_RES *results;</span></pre>
			<pre><span>MYSQL_ROW record;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>static char *server_options[] = { &quot;mysql_test&quot;, &quot;--defaults-file=my.cnf&quot; };</span></pre>
			<pre><span>int num_elements = sizeof(server_options)/ sizeof(char *);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>static char *server_groups[] = { &quot;libmysqld_server&quot;, &quot;libmysqld_client&quot; };</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>int main(void)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_server_init(num_elements, server_options, server_groups);</span></pre>
			<pre><span>&nbsp;&nbsp; mysql = mysql_init(NULL);</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_options(mysql, MYSQL_READ_DEFAULT_GROUP, &quot;libmysqld_client&quot;);</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_options(mysql, MYSQL_OPT_USE_EMBEDDED_CONNECTION, NULL);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_real_connect(mysql, NULL,NULL,NULL, &quot;database1&quot;, 0,NULL,0);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_query(mysql, &quot;SELECT column1, column2 FROM table1&quot;);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; results = mysql_store_result(mysql);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; while((record = mysql_fetch_row(results))) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;%s - %s \n&quot;, record[0], record[1]);</span></pre>
			<pre><span>&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_free_result(results);</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_close(mysql);</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_server_end();</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; return 0;</span></pre>
			<pre><span>}</span></pre>
			<p>下面给出了编译上述程序的命令行命令：</p>
			<pre><span>gcc test1_libmysqld.c -o test1_libmysqld -lz \</span></pre>
			<pre><span> `/usr/local/mysql/bin/mysql_config --include --libmysqld-libs`</span></pre>
			<p><strong><span>示例：<span>2</span></span></strong><span>
			</span></p>
			<p>要想检验该示例，创建一个与<span>MySQL</span>源目录同级的<span>test2_libmysqld</span>目录。将<span>test2_libmysqld.c</span>源文件和<span><span>GNUmakefile</span>保存到该目录，并在<span>test2_libmysqld</span>目录下运行</span><span>GNU
			<span>make</span></span>。</p>
			<p><span>test2_libmysqld.c</span><span>
			</span></p>
			<pre><span>/*</span></pre>
			<pre><span> * A simple example client, using the embedded MySQL server library</span></pre>
			<pre><span>*/</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>#include &lt;mysql.h&gt;</span></pre>
			<pre><span>#include &lt;stdarg.h&gt;</span></pre>
			<pre><span>#include &lt;stdio.h&gt;</span></pre>
			<pre><span>#include &lt;stdlib.h&gt;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>MYSQL *db_connect(const char *dbname);</span></pre>
			<pre><span>void db_disconnect(MYSQL *db);</span></pre>
			<pre><span>void db_do_query(MYSQL *db, const char *query);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>const char *server_groups[] = {</span></pre>
			<pre><span>&nbsp; &quot;test2_libmysqld_SERVER&quot;, &quot;embedded&quot;, &quot;server&quot;, NULL</span></pre>
			<pre><span>};</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>int</span></pre>
			<pre><span>main(int argc, char **argv)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; MYSQL *one, *two;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; /* mysql_server_init() must be called before any other mysql</span></pre>
			<pre><span>&nbsp;&nbsp; * functions.</span></pre>
			<pre><span>&nbsp;&nbsp; *</span></pre>
			<pre><span>&nbsp;&nbsp; * You can use mysql_server_init(0, NULL, NULL), and it</span></pre>
			<pre><span>&nbsp;&nbsp; * initializes the server using groups = {</span></pre>
			<pre><span>&nbsp;&nbsp; *&nbsp;&nbsp; &quot;server&quot;, &quot;embedded&quot;, NULL</span></pre>
			<pre><span>&nbsp;&nbsp; *&nbsp; }.</span></pre>
			<pre><span>&nbsp;&nbsp; *</span></pre>
			<pre><span>&nbsp;&nbsp; * In your $HOME/.my.cnf file, you probably want to put:</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>[test2_libmysqld_SERVER]</span></pre>
			<pre><span>language = /path/to/source/of/mysql/sql/share/english</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; * You could, of course, modify argc and argv before passing</span></pre>
			<pre><span>&nbsp;&nbsp; * them to this function.&nbsp; Or you could create new ones in any</span></pre>
			<pre><span>&nbsp;&nbsp; * way you like.&nbsp; But all of the arguments in argv (except for</span></pre>
			<pre><span>&nbsp;&nbsp; * argv[0], which is the program name) should be valid options</span></pre>
			<pre><span>&nbsp;&nbsp; * for the MySQL server.</span></pre>
			<pre><span>&nbsp;&nbsp; *</span></pre>
			<pre><span>&nbsp;&nbsp; * If you link this client against the normal mysqlclient</span></pre>
			<pre><span>&nbsp;&nbsp; * library, this function is just a stub that does nothing.</span></pre>
			<pre><span>&nbsp;&nbsp; */</span></pre>
			<pre><span>&nbsp; mysql_server_init(argc, argv, (char **)server_groups);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; one = db_connect(&quot;test&quot;);</span></pre>
			<pre><span>&nbsp; two = db_connect(NULL);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; db_do_query(one, &quot;SHOW TABLE STATUS&quot;);</span></pre>
			<pre><span>&nbsp; db_do_query(two, &quot;SHOW DATABASES&quot;);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; mysql_close(two);</span></pre>
			<pre><span>&nbsp; mysql_close(one);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; /* This must be called after all other mysql functions */</span></pre>
			<pre><span>&nbsp; mysql_server_end();</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; exit(EXIT_SUCCESS);</span></pre>
			<pre><span>}</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>static void</span></pre>
			<pre><span>die(MYSQL *db, char *fmt, ...)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; va_list ap;</span></pre>
			<pre><span>&nbsp; va_start(ap, fmt);</span></pre>
			<pre><span>&nbsp; vfprintf(stderr, fmt, ap);</span></pre>
			<pre><span>&nbsp; va_end(ap);</span></pre>
			<pre><span>&nbsp; (void)putc(&#39;\n&#39;, stderr);</span></pre>
			<pre><span>&nbsp; </span><span>if (db)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; db_disconnect(db);</span></pre>
			<pre><span>&nbsp; exit(EXIT_FAILURE);</span></pre>
			<pre><span>}</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>MYSQL *</span></pre>
			<pre><span>db_connect(const char *dbname)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; MYSQL *db = mysql_init(NULL);</span></pre>
			<pre><span>&nbsp; if (!db)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; die(db, &quot;mysql_init failed: no memory&quot;);</span></pre>
			<pre><span>&nbsp; /*</span></pre>
			<pre><span>&nbsp;&nbsp; * Notice that the client and server use separate group names.</span></pre>
			<pre><span>&nbsp;&nbsp; * This is critical, because the server does not accept the</span></pre>
			<pre><span>&nbsp;&nbsp; * client&#39;s options, and vice versa.</span></pre>
			<pre><span>&nbsp;&nbsp; */</span></pre>
			<pre><span>&nbsp; mysql_options(db, MYSQL_READ_DEFAULT_GROUP, &quot;test2_libmysqld_CLIENT&quot;);</span></pre>
			<pre><span>&nbsp; if (!mysql_real_connect(db, NULL, NULL, NULL, dbname, 0, NULL, 0))</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; die(db, &quot;mysql_real_connect failed: %s&quot;, mysql_error(db));</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; return db;</span></pre>
			<pre><span>}</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>void</span></pre>
			<pre><span>db_disconnect(MYSQL *db)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; mysql_close(db);</span></pre>
			<pre><span>}</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>void</span></pre>
			<pre><span>db_do_query(MYSQL *db, const char *query)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; if (mysql_query(db, query) != 0)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; goto err;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; if (mysql_field_count(db) &gt; 0)</span></pre>
			<pre><span>&nbsp; {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; MYSQL_RES&nbsp;&nbsp; *res;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; MYSQL_ROW&nbsp;&nbsp;&nbsp; row, end_row;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; int num_fields;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; if (!(res = mysql_store_result(db)))</span></pre>
			<pre><span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto err;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; num_fields = mysql_num_fields(res);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; while ((row = mysql_fetch_row(res)))</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
			<pre><span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)fputs(&quot;&gt;&gt; &quot;, stdout);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (end_row = row + num_fields; row &lt; end_row; ++row)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void)printf(&quot;%s\t&quot;, row ? (char*)*row : &quot;NULL&quot;);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void)fputc(&#39;\n&#39;, stdout);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; </span><span>(void)fputc(&#39;\n&#39;, stdout);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; </span><span>mysql_free_result(res);</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; else</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; (void)printf(&quot;Affected rows: %lld\n&quot;, mysql_affected_rows(db));</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; return;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>err:</span></pre>
			<pre><span>&nbsp; die(db, &quot;db_do_query failed: %s [%s]&quot;, mysql_error(db), query);</span></pre>
			<pre><span>}</span></pre>
			<p><span>GNUmakefile</span><span>
			</span></p>
			<pre><span># This assumes the MySQL software is installed in /usr/local/mysql</span></pre>
			<pre><span>inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := /usr/local/mysql/include/mysql</span></pre>
			<pre><span>lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := /usr/local/mysql/lib</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span># If you have not installed the MySQL software yet, try this instead</span></pre>
			<pre><span>#inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := $(HOME)/mysql-5.1/include</span></pre>
			<pre><span>#lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := $(HOME)/mysql-5.1/libmysqld</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>CC &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= gcc</span></pre>
			<pre><span>CPPFLAGS := -I$(inc) -D_THREAD_SAFE -D_REENTRANT</span></pre>
			<pre><span>CFLAGS&nbsp;&nbsp; := -g -W -Wall</span></pre>
			<pre><span>LDFLAGS&nbsp; := -static</span></pre>
			<pre><span># You can change -lmysqld to -lmysqlclient to use the</span></pre>
			<pre><span># client/server library</span></pre>
			<pre><span>LDLIBS&nbsp;&nbsp;&nbsp; = -L$(lib) -lmysqld -lz -lm -lcrypt</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>ifneq (,$(shell grep FreeBSD /COPYRIGHT 2&gt;/dev/null))</span></pre>
			<pre><span># FreeBSD</span></pre>
			<pre><span>LDFLAGS += -pthread</span></pre>
			<pre><span>else</span></pre>
			<pre><span># Assume Linux</span></pre>
			<pre><span>LDLIBS += -lpthread</span></pre>
			<pre><span>endif</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span># This works for simple one-file test programs</span></pre>
			<pre><span>sources := $(wildcard *.c)</span></pre>
			<pre><span>objects := $(patsubst %c,%o,$(sources))</span></pre>
			<pre><span>targets := $(basename $(sources))</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>all: $(targets)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>clean:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm -f $(targets) $(objects) *.core</span></pre>
		</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-licensing"></a>
			25.1.7.&nbsp;嵌入式服务器的许可</h3></div></div></div>
			<p>我们鼓励所有人在<span>GPL</span>或兼容许可的旗帜下通过发布代码来推广免费软件。对于有能力完成该类事项的人员，也可以选择从<span>MySQL 
			AB</span>购买<span>MySQL</span>的商用许可。详情请参见<span>http://www.mysql.com/company/legal/licensing/</span>。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="c"></a>25.2. MySQL C API</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#c-api-datatypes">
		25.2.1. C API数据类型</a></span></dt><dt><span class="section"><a href="apis.html#c-api-function-overview">
		25.2.2. C API函数概述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-functions">
		25.2.3. C API函数描述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statements">
		25.2.4. C API预处理语句</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-datatypes">
		25.2.5. C API预处理语句的数据类型</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-function-overview">
		25.2.6. C API预处理语句函数概述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-functions">
		25.2.7. C API预处理语句函数描述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-problems">
		25.2.8. C API预处理语句方面的问题</a></span></dt><dt><span class="section"><a href="apis.html#c-api-multiple-queries">
		25.2.9. 多查询执行的C API处理</a></span></dt><dt><span class="section"><a href="apis.html#c-api-date-handling">
		25.2.10. 日期和时间值的C API处理</a></span></dt><dt><span class="section"><a href="apis.html#c-thread-functions">
		25.2.11. C API线程函数介绍</a></span></dt><dt><span class="section"><a href="apis.html#c-embedded-server-func">
		25.2.12. C API嵌入式服务器函数介绍</a></span></dt><dt><span class="section"><a href="apis.html#c-api-problems">
		25.2.13. 使用C API时的常见问题</a></span></dt><dt><span class="section"><a href="apis.html#building-clients">
		25.2.14. 创建客户端程序</a></span></dt><dt><span class="section"><a href="apis.html#threaded-clients">
		25.2.15. 如何生成线程式客户端</a></span></dt></dl></div><a class="indexterm" name="id3007623"></a><a class="indexterm" name="id3007633"></a>
		<p><span>C API</span>代码是与<span>MySQL</span>一起提供的。它包含在<span><span>mysqlclient</span>库中，并允许<span>C</span>程序访问数据库。</span></p>
		<p><span>MySQL</span>源码分发版的很多客户端是用<span>C</span>语言编写的。如果你正在寻找能演示如何使用<span>C 
		API</span>的示例，可参看这些客户端程序。你可以在<span>MySQL</span>源码分发版的客户端目录下找到它们。</p>
		<p>大多数其他客户端<span>API</span>（除了<span>Connector/J</span>和<span>Connector/NET</span>）采用<span>mysqlclient</span>库来与<span>MySQL</span>服务器进行通信。这意味着（例如），你可以利用很多相同环境变量（与其他客户端程序使用的环境变量相同）带来的好处，这是因为它们是从库中引用的。关于这些变量的详细清单，请参见<a href="client-side-scripts.html">第8章：</a><a href="client-side-scripts.html" title="Chapter 8. Client and Utility Programs"><i>客户端和实用工具程序</i></a>。</p>
		<p>客户端具有最大的通信缓冲区大小。初始分配的缓冲区大小（<span>16KB</span>）将自动增加到最大（最大为<span>16MB</span>）。由于缓冲区大小将按需增加，简单地增加默认的最大限制，从其本身来说不会增加资源使用。该大小检查主要是检查错误查询和通信信息包。</p>
		<p>通信缓冲区必须足够大，足以包含<span>1</span>条<span>SQL</span>语句（用于客户端<span>-</span>服务器通信）以及<span>1</span>行返回的数据（用于服务器<span>-</span>客户端通信）。每个线程的通信缓冲区将动态增加，以处理直至最大限制的任何查询或行。例如，如果<span>BLOB</span>值包含高达<span>16MB</span>的数据，那么通信缓冲区的大小限制至少为<span>16MB</span>（在服务器和客户端）。客户端的默认最大值为<span>16MB</span>，但服务器的默认最大值为<span>1MB</span>。也可以在启动服务器时，通过更改<span><span>max_allowed_packet</span>参数的值增加它。</span>请参见<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2节，“调节服务器参数”</a>。</p>
		<p>每次查询后，<span>MySQL</span>服务器会将通信缓冲区的大小降至<span><span>net_buffer_length</span>字节。对于客户端，不会降低与连接相关缓冲区大小，直至连接关闭为止，此时</span>，客户端内存将被收回。</p>
		<p>关于使用线程的编程方法，请参见<a href="apis.html#threaded-clients" title="25.2.15. How to Make a Threaded Client">25.2.15节，“如何生成线程式客户端”</a>。关于在相同程序创建包含“服务器”和“客户端”的独立应用程序的更多信息（不与外部<span>MySQL</span>服务器通信），请参见<a href="apis.html#libmysqld" title="25.1. libmysqld, the Embedded MySQL Server Library">25.1节，“libmysqld，嵌入式MySQL服务器库”</a>。</p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-datatypes"></a>
			25.2.1.&nbsp;C API数据类型</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            <a class="indexterm" name="id3007765"></a>

            MYSQL
          </p><p>
            <span>该结构代表<span>1</span>个数据库连接的句柄。几乎所有的<span>MySQL</span>函数均使用它。不应尝试拷贝<span><span>MYSQL</span>结构。不保证这类拷贝结果会有用。</span></span>
          </p></li><li><p>
            <a class="indexterm" name="id3007796"></a>

            MYSQL_RES
          </p><p>
            <span>
			该结构代表返回行的查询结果（<span>SELECT</span><span>,
			<span>SHOW</span>,
			<span>DESCRIBE</span>,
			<span>EXPLAIN</span></span>）。在本节的剩余部分，将查询返回的信息称为“结果集”。</span>
          </p></li><li><p>
            <a class="indexterm" name="id3007840"></a>

            MYSQL_ROW
          </p><p>
            <span>这是<span>1</span>行数据的“类型安全”表示。它目前是按照计数字节字符串的数组实施的。（如果字段值可能包含二进制数据，不能将其当作<span>由Null</span>终结的字符串对待，这是因为这类值可能会包含<span>Null</span>字节）。行是通过调用<span>mysql_fetch_row()</span>获得的。</span>
          </p></li><li><p>
            <a class="indexterm" name="id3007873"></a>

            MYSQL_FIELD
          </p><p>
            <span>
			该结构包含关于字段的信息，如字段名、类型和大小。这里详细介绍了其成员。通过重复调用<span><span>mysql_fetch_field()</span>，可为每个字段获得<span>MYSQL_FIELD</span>结构。字段值不是该结构的组成部份，它们包含在<span>MYSQL_ROW</span></span>结构中。</span>
          </p></li><li><p>
            <a class="indexterm" name="id3007912"></a>

            MYSQL_FIELD_OFFSET
          </p><p>
            <span>这是<span>MySQL</span>字段列表偏移量的“类型安全”表示（由<span><span>mysql_field_seek()</span>使用</span>）。偏移量是行内的字段编号，从<span>0</span>开始。</span>
          </p></li><li><p>
            <a class="indexterm" name="id3007942"></a>

            <a class="indexterm" name="id3007951"></a>

            my_ulonglong
          </p><p>
            <span>
			用于行数以及<span>mysql_affected_rows()</span>、<span>mysql_num_rows()</span>和<span><span>mysql_insert_id()</span>的类型。该类型提供的范围为<span>0</span></span>～<span>1.84e19</span>。</span>
          </p><p>
            <span>
			在某些系统上，不能打印类型<span>my_ulonglong</span>的值。要想打印这类值，请将其转换为无符号长整数类型并使用<span><span>%lu</span>打印格式，例如：</span></span></p><pre class="programlisting">printf ("Number of rows: %lu\n", (unsigned long) mysql_num_rows(result));
</pre></li></ul></div>
			<p>下面列出了<span><span>MYSQL_FIELD</span>结构包含的成员：</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			name</span><span> </span></p>
			<p>字段名称，由<span>Null</span>终结的字符串。如果用<span>AS</span>子句为该字段指定了别名，名称的值也是别名。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			org_name</span><span> </span></p>
			<p>段名称，由<span>Null</span>终结的字符串。忽略别名。 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			table</span><span> </span></p>
			<p>
			包含该字段的表的名称，如果该字段不是计算出的字段的话。对于计算出的字段，表值为空的字符串。如果用<span>AS</span>子句为该表指定了别名，表的值也是别名。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			org_table</span><span> </span></p>
			<p>表的名称，由<span>Null</span>终结的字符串。忽略别名。 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			db</span><span> </span></p>
			<p>字段源自的数据的名称，由<span>Null</span>终结的字符串。如果该字段是计算出的字段，<span><span>db</span>为空的字符串。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			catalog</span><span> </span></p>
			<p><span>catalog</span>名称。该值总是<span>&quot;def&quot;</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			def</span><span> </span></p>
			<p>该字段的默认值，由<span>Null</span>终结的字符串。仅当使用<span><span>mysql_list_fields()</span>时才设置它。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			long length</span><span> </span></p>
			<p>字段的宽度，如表定义中所指定的那样。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			long max_length</span><span> </span></p>
			<p>
			用于结果集的字段的最大宽度（对于实际位于结果集中的行，最长字段值的长度）。如果使用<span>mysql_store_result()</span>或<span>mysql_list_fields()</span>，它将包含字段的最大长度。如果使用<span><span>mysql_use_result()</span>，该变量的值为<span>0</span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int name_length</span><span> </span></p>
			<p>名称的长度。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int org_name_length</span><span> </span></p>
			<p>
			<span>org_name</span>的长度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int table_length</span><span> </span></p>
			<p>表的长度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int org_table_length</span><span> </span></p>
			<p>
			<span>org_table</span>的长度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int db_length</span><span> </span></p>
			<p>
			<span>db</span>的长度。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int catalog_length</span><span> </span></p>
			<p>
			<span>catalog</span>的长度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int def_length</span><span> </span></p>
			<p>
			<span>def</span>的长度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int flags</span><span> </span></p>
			<p>用于字段的不同“位标志”。标志的值可以有<span>0</span>个或多个下述位集合：</p>
			<table border="1" cellpadding="0" id="table2">
				<tr>
					<td>
					<p><strong><span>
					标志值</span></strong></td>
					<td>
					<p><strong><span>
					标志描述</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>NOT_NULL_FLAG</span></td>
					<td>
					<p>字段不能为<span>NULL</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>PRI_KEY_FLAG</span></td>
					<td>
					<p>字段是主键的组成部分</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>UNIQUE_KEY_FLAG</span></td>
					<td>
					<p>字段是唯一键的组成部分</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MULTIPLE_KEY_FLAG</span></td>
					<td>
					<p>字段是非唯一键的组成部分</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>UNSIGNED_FLAG</span></td>
					<td>
					<p>字段具有<span>UNSIGNED</span>属性</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>ZEROFILL_FLAG</span></td>
					<td>
					<p>字段具有<span>ZEROFILL</span>属性</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>BINARY_FLAG</span></td>
					<td>
					<p>字段具有<span>BINARY</span>属性</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>AUTO_INCREMENT_FLAG</span></td>
					<td>
					<p>字段具有<span>AUTO_INCREMENT</span>属性</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>ENUM_FLAG</span></td>
					<td>
					<p>字段是<span>ENUM</span>（不再重视）</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>SET_FLAG</span></td>
					<td>
					<p>字段是 
					<span>SET</span>（不再重视）</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>BLOB_FLAG</span></td>
					<td>
					<p>字段是<span>BLOB</span>或<span>TEXT</span>（不再重视）</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>TIMESTAMP_FLAG</span></td>
					<td>
					<p>字段是<span>TIMESTAMP</span>（不再重视）</td>
				</tr>
			</table>
			<p>不再重视<span><span>BLOB_FLAG</span>、<span>ENUM_FLAG</span></span>、<span>SET_FLAG</span>和<span>TIMESTAMP_FLAG</span>标志，原因在于，它们指出了字段的类型，而不是类型的属性。更可取的方式是使用<span>MYSQL_TYPE_BLOB</span>、<span>MYSQL_TYPE_ENUM</span>、<span>MYSQL_TYPE_SET</span>或<span>MYSQL_TYPE_TIMESTAMP</span>测试<span><span>field-&gt;type</span>。</span></p>
			<p>在下面的示例中，介绍了标志值的典型用法：</p>
			<pre><span>if (field-&gt;flags &amp; NOT_NULL_FLAG)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;Field can&#39;t be null\n&quot;);</span></pre>
			<p>可以使用下述方面的宏来定义标志值的布尔状态：</p>
			<table border="1" cellpadding="0" id="table3">
				<tr>
					<td>
					<p><strong><span>
					标志状态</span></strong></td>
					<td>
					<p><strong><span>
					描述</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>IS_NOT_NULL(flags)</span></td>
					<td>
					<p>如果该字段定义为<span><span>NOT 
					NULL</span>，为<span>“</span>真<span>”</span>。</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>IS_PRI_KEY(flags)</span></td>
					<td>
					<p>如果该字段是主键<span>，为<span>“</span>真<span>”</span>。</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>IS_BLOB(flags)</span></td>
					<td>
					<p>如果该字段是<span>BLOB</span>或<span>TEXT</span><span>，为<span>“</span>真<span>”</span>（不再重视</span>，用测试<span>field-&gt;type</span>取而代之）。</td>
				</tr>
			</table>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int decimals</span><span> </span></p>
			<p>用于数值字段的十进制数数目。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int charset_nr</span><span> </span></p>
			<p>用于字段的字符集编号。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>enum 
			enum_field_types type</span><span> </span></p>
			<p>字段的类型。类型值可以是下标所列的<span>MYSQL_TYPE_</span>符号之一：</p>
			<table border="1" cellpadding="0" id="table4">
				<tr>
					<td>
					<p><strong><span>
					类型值</span></strong></td>
					<td>
					<p><strong><span>
					类型描述</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TINY</span></td>
					<td>
					<p>
					<span>TINYINT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_SHORT</span></td>
					<td>
					<p>
					<span>SMALLINT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_LONG</span></td>
					<td>
					<p>
					<span>INTEGER</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_INT24</span></td>
					<td>
					<p>
					<span>MEDIUMINT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_LONGLONG</span></td>
					<td>
					<p>
					<span>BIGINT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DECIMAL</span></td>
					<td>
					<p>
					<span>DECIMAL</span>或<span>NUMERIC</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_NEWDECIMAL</span></td>
					<td>
					<p>精度数学<span>DECIMAL</span>或<span>NUMERIC</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_FLOAT</span></td>
					<td>
					<p>
					<span>FLOAT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DOUBLE</span></td>
					<td>
					<p>
					<span>DOUBLE</span>或<span>REAL</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_BIT</span></td>
					<td>
					<p>
					<span>BIT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TIMESTAMP</span></td>
					<td>
					<p>
					<span>TIMESTAMP</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DATE</span></td>
					<td>
					<p>
					<span>DATE</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TIME</span></td>
					<td>
					<p>
					<span>TIME</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DATETIME</span></td>
					<td>
					<p>
					<span>DATETIME</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_YEAR</span></td>
					<td>
					<p>
					<span>YEAR</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_STRING</span></td>
					<td>
					<p>
					<span>CHAR</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_VAR_STRING</span></td>
					<td>
					<p>
					<span>VARCHAR</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_BLOB</span></td>
					<td>
					<p>
					<span>BLOB</span>或<span>TEXT</span>字段（使用<span><span>max_length</span>来确定最大长度）</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_SET</span></td>
					<td>
					<p>
					<span>SET</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_ENUM</span></td>
					<td>
					<p>
					<span>ENUM</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_GEOMETRY</span></td>
					<td>
					<p><span>Spatial</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_NULL</span></td>
					<td>
					<p>
					<span>NULL</span><span>-type</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_CHAR</span></td>
					<td>
					<p>不再重视，用<span>MYSQL_TYPE_TINY</span>取代</td>
				</tr>
			</table>
			<p>可以使用<span>IS_NUM()</span>宏来测试字段是否具有数值类型。将类型值传递给<span><span>IS_NUM()</span>，</span>如果字段为数值类型，会将其评估为“真”：</p>
			<pre><span>if (IS_NUM(field-&gt;type))</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;Field is numeric\n&quot;);</span></pre>
		</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-function-overview"></a>
			25.2.2.&nbsp;C API函数概述</h3></div></div></div><a class="indexterm" name="id3009178"></a><a class="indexterm" name="id3009188"></a>
			<p>这里归纳了<span>C API</span>可使用的函数，并在下一节详细介绍了它们。请参见<a href="apis.html#c-api-functions" title="25.2.3. C API Function Descriptions">25.2.3节，“C API函数描述”</a>。</p>
			<table border="1" cellpadding="0" id="table5">
				<tr>
					<td>
					<p><strong><span>
					函数</span></strong></td>
					<td>
					<p><strong><span>
					描述</span></strong></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_affected_rows()</span></strong></td>
					<td>
					<p>返回上次<span>UPDATE</span>、<span>DELETE</span>或<span><span>INSERT</span>查询更改／删除／插入的行数。</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_autocommit()</span></strong></td>
					<td>
					<p>切换<span> autocommit</span>模式，<span>ON/OFF</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_change_user()</span></strong></td>
					<td>
					<p>更改打开连接上的用户和数据库。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_charset_name()</span></strong></td>
					<td>
					<p>返回用于连接的默认字符集的名称。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_close()</span></strong></td>
					<td>
					<p>关闭服务器连接。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_commit()</span></strong></td>
					<td>
					<p>提交事务。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_connect()</span></strong></td>
					<td>
					<p>连接到<span>MySQL</span>服务器。该函数已不再被重视，使用<span>mysql_real_connect()</span>取代。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_create_db()</span></strong></td>
					<td>
					<p>创建数据库。该函数已不再被重视，使用<span>SQL</span>语句<span>CREATE 
					DATABASE</span>取而代之。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_data_seek()</span></strong></td>
					<td>
					<p>在查询结果集中查找属性行编号。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_debug()</span></strong></td>
					<td>
					<p>用给定的字符串执行<span>DBUG_PUSH</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_drop_db()</span></strong></td>
					<td>
					<p>撤销数据库。该函数已不再被重视，使用<span>SQL</span>语句<span>DROP 
					DATABASE</span>取而代之。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_dump_debug_info()</span></strong></td>
					<td>
					<p>让服务器将调试信息写入日志。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_eof()</span></strong></td>
					<td>
					<p>确定是否读取了结果集的最后一行。该函数已不再被重视，可以使用<span>mysql_errno()</span>或<span>mysql_error()</span>取而代之。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_errno()</span></strong></td>
					<td>
					<p>返回上次调用的<span>MySQL</span>函数的错误编号。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_error()</span></strong></td>
					<td>
					<p>返回上次调用的<span>MySQL</span>函数的错误消息。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_escape_string()</span></strong></td>
					<td>
					<p>为了用在<span>SQL</span>语句中，对特殊字符进行转义处理。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_fetch_field()</span></strong></td>
					<td>
					<p>返回下一个表字段的类型。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_fetch_field_direct()</span></strong></td>
					<td>
					<p>给定字段编号，返回表字段的类型。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_fetch_fields()</span></strong></td>
					<td>
					<p>返回所有字段结构的数组。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_fetch_lengths()</span></strong></td>
					<td>
					<p>返回当前行中所有列的长度。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_fetch_row()</span></strong></td>
					<td>
					<p>从结果集中获取下一行</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_field_seek()</span></strong></td>
					<td>
					<p>将列光标置于指定的列。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_field_count()</span></strong></td>
					<td>
					<p>返回上次执行语句的结果列的数目。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_field_tell()</span></strong></td>
					<td>
					<p>返回上次<span><span>mysql_fetch_field()</span>所使用字段光标的位置。</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_free_result()</span></strong></td>
					<td>
					<p>释放结果集使用的内存。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_client_info()</span></strong></td>
					<td>
					<p>以字符串形式返回客户端版本信息。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_client_version()</span></strong></td>
					<td>
					<p>以整数形式返回客户端版本信息。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_host_info()</span></strong></td>
					<td>
					<p>返回描述连接的字符串。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_server_version()</span></strong></td>
					<td>
					<p>以整数形式返回服务器的版本号。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_proto_info()</span></strong></td>
					<td>
					<p>返回连接所使用的协议版本。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_server_info()</span></strong></td>
					<td>
					<p>返回服务器的版本号。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_info()</span></strong></td>
					<td>
					<p>返回关于最近所执行查询的信息。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_init()</span></strong></td>
					<td>
					<p>获取或初始化<span>MYSQL</span>结构。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_insert_id()</span></strong></td>
					<td>
					<p>返回上一个查询为<span><span>AUTO_INCREMENT</span>列生成的</span><span>ID</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_kill()</span></strong></td>
					<td>
					<p>杀死给定的线程。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_library_end()</span></strong></td>
					<td>
					<p>最终确定<span>MySQL C API</span>库。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_library_init()</span></strong></td>
					<td>
					<p>初始化<span>MySQL C API</span>库。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_list_dbs()</span></strong></td>
					<td>
					<p>返回与简单正则表达式匹配的数据库名称。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_list_fields()</span></strong></td>
					<td>
					<p>返回与简单正则表达式匹配的字段名称。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_list_processes()</span></strong></td>
					<td>
					<p>返回当前服务器线程的列表。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_list_tables()</span></strong></td>
					<td>
					<p>返回与简单正则表达式匹配的表名。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_more_results()</span></strong></td>
					<td>
					<p>检查是否还存在其他结果。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_next_result()</span></strong></td>
					<td>
					<p>在多语句执行过程中返回<span>/</span>初始化下一个结果。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_num_fields()</span></strong></td>
					<td>
					<p>返回结果集中的列数。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_num_rows()</span></strong></td>
					<td>
					<p>返回结果集中的行数。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_options()</span></strong></td>
					<td>
					<p>为<span><span>mysql_connect()</span>设置连接选项。</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_ping()</span></strong></td>
					<td>
					<p>检查与服务器的连接是否工作，如有必要重新连接。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_query()</span></strong></td>
					<td>
					<p>执行指定为“以<span>Null</span>终结的字符串”的<span>SQL</span>查询。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_real_connect()</span></strong></td>
					<td>
					<p>连接到<span>MySQL</span>服务器。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_real_escape_string()</span></strong></td>
					<td>
					<p>考虑到连接的当前字符集，为了在<span>SQL</span>语句中使用，对字符串中的特殊字符进行转义处理。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_real_query()</span></strong></td>
					<td>
					<p>执行指定为计数字符串的<span>SQL</span>查询。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_refresh()</span></strong></td>
					<td>
					<p>刷新或复位表和高速缓冲。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_reload()</span></strong></td>
					<td>
					<p>通知服务器再次加载授权表。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_rollback()</span></strong></td>
					<td>
					<p>回滚事务。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_row_seek()</span></strong></td>
					<td>
					<p>使用从<span><span>mysql_row_tell()</span>返回的值，查找结果集中的行偏移。</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_row_tell()</span></strong></td>
					<td>
					<p>返回行光标位置。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_select_db()</span></strong></td>
					<td>
					<p>选择数据库。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_server_end()</span></strong></td>
					<td>
					<p>最终确定嵌入式服务器库。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_server_init()</span></strong></td>
					<td>
					<p>初始化嵌入式服务器库。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_set_server_option()</span></strong></td>
					<td>
					<p>为连接设置选项（如多语句）。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_sqlstate()</span></strong></td>
					<td>
					<p>返回关于上一个错误的<span>SQLSTATE</span>错误代码。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_shutdown()</span></strong></td>
					<td>
					<p>关闭数据库服务器。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stat()</span></strong></td>
					<td>
					<p>以字符串形式返回服务器状态。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_store_result()</span></strong></td>
					<td>
					<p>检索完整的结果集至客户端。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_thread_id()</span></strong></td>
					<td>
					<p>返回当前线程<span>ID</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_thread_safe()</span></strong></td>
					<td>
					<p>如果客户端已编译为线程安全的，返回<span>1</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_use_result()</span></strong></td>
					<td>
					<p>初始化逐行的结果集检索。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_warning_count()</span></strong></td>
					<td>
					<p>返回上一个<span>SQL</span>语句的告警数。</td>
				</tr>
			</table>
			<p>与<span>MySQL</span>交互时，应用程序应使用该一般性原则：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通过调用<span><span>mysql_library_init()</span>，初始化</span><span>MySQL</span>库。库可以是<span>mysqlclient</span><span> 
			C</span>客户端库，或<span>mysqld</span>嵌入式服务器库，具体情况取决于应用程序是否与“<span>-libmysqlclient”</span>或“<span><span>-libmysqld”</span>标志链接。</span></p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通过调用<span><span>mysql_init()</span>初始化连接处理程序，并通过调用<span>mysql_real_connect()</span>连接到服务器。</span></p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>发出<span>SQL</span>语句并处理其结果。（在下面的讨论中，详细介绍了使用它的方法）。</p>
			<p>
			<span>4.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通过调用<span><span>mysql_close()</span>，关闭</span>与<span>MySQL</span>服务器的连接。</p>
			<p>
			<span>5.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通过调用<span><span>mysql_library_end()</span>，结束</span><span>MySQL</span>库的使用。</p>
			<p>调用<span>mysql_library_init()</span>和<span><span>mysql_library_end()</span>的目的在于，为</span><span>MySQL</span>库提供恰当的初始化和结束处理。对于与客户端库链接的应用程序，它们提供了改进的内存管理功能。如果不调用<span><span>mysql_library_end()</span>，内存块仍将保持分配状态（这不会增加应用程序使用的内存量，但某些内存泄漏检测器将抗议它）</span>。对于与嵌入式服务器链接的应用程序，这些调用会启动并停止服务器。</p>
			<p><span>mysql_library_init()</span>和<span>mysql_library_end()</span>实际上是<span>#define</span>符号，这类符号使得它们等效于<span>mysql_server_init()</span>和<span>mysql_server_end()</span>，但其名称更清楚地指明，无论应用程序使用的是<span>mysqlclient</span>或<span><span>mysqld</span>库，启动或结束<span>MySQL</span>库时，应调用它们。</span>对于早期的<span>MySQL</span>版本，可调用<span>mysql_server_init()</span>和<span>mysql_server_end()</span>取而代之。</p>
			<p>如果愿意，可省略对<span><span>mysql_library_init()</span>的调用，这是因为，必要时，<span>mysql_init()</span>会自动调用它。</span></p>
			<p>要想连接到服务器，可调用<span>mysql_init()</span>来初始化连接处理程序，然后用该处理程序（以及其他信息，如主机名、用户名和密码）调用<span>mysql_real_connect()</span>。建立连接后，在低于<span>5.0.3</span>版的<span>API</span>中，<span>mysql_real_connect()</span>会将再连接标志（<span><span>MYSQL</span>结构的一部分</span>）设置为<span>1</span>，或在较新的版本中，将其设置为<span>0</span>。对于该标志，值“<span>1</span>”指明，如果因连接丢失而无法执行语句，放弃之前，会尝试再次连接到服务器。从<span>MySQL 
			5.0.13</span>开始，可以在<span><span>mysql_options()</span>上使用<span>MYSQL_OPT_RECONNECT</span>选项，以控制再连接行为。完成连接后，调用<span>mysql_close()</span>中止它。</span></p>
			<p>当连接处于活动状态时，客户端或许会使用<span>mysql_query()</span>或<span><span>mysql_real_query()</span>向服务器发出<span>SQL</span>查询。两者的差别在于，<span>mysql_query()</span></span>预期的查询为指定的、由<span>Null</span>终结的字符串，而<span><span>mysql_real_query()</span>预期的是计数字符串。如果字符串包含二进制数据（其中可能包含<span>Null</span>字节），就必须使用<span>mysql_real_query()</span></span>。</p>
			<p>对于每个非<span>SELECT</span>查询（例如<span>INSERT</span>、<span>UPDATE</span>、<span>DELETE</span>），通过调用<span><span>mysql_affected_rows()</span>，可发现有多少行已被改变</span>（影响）。</p>
			<p>对于<span><span>SELECT</span>查询，</span>能够检索作为结果集的行。注意，某些语句因其返回行，类似与<span><span>SELECT</span>。</span>包括<span>SHOW</span>、<span>DESCRIBE</span>和<span><span>EXPLAIN</span>。应按照对待<span>SELECT</span>语句的方式处理它们。</span></p>
			<p>客户端处理结果集的方式有两种。一种方式是，通过调用<span><span>mysql_store_result()</span>，一次性地检索整个结果集。该函数</span>能从服务器获得查询返回的所有行，并将它们保存在客户端。第二种方式是针对客户端的，通过调用<span><span>mysql_use_result()</span>，对<span>“</span>按行<span>”</span>结果集检索进行初始化处理。该函数能初始化检索结果，但不能从服务器获得任何实际行。</span></p>
			<p>在这两种情况下，均能通过调用<span><span>mysql_fetch_row()</span>访问行。通过<span>mysql_store_result()</span>，<span>mysql_fetch_row()</span></span>能够访问以前从服务器获得的行。通过<span>mysql_use_result()</span>，<span><span>mysql_fetch_row()</span>能够实际地检索来自服务器的行。通过调用<span>mysql_fetch_lengths()</span>，能获得关于各行中数据大小的信息。</span></p>
			<p>完成结果集操作后，请调用<span>mysql_free_result()</span>释放结果集使用的内存。</p>
			<p>这两种检索机制是互补的。客户端程序应选择最能满足其要求的方法。实际上，客户端最常使用的是<span><span>mysql_store_result()</span>。</span></p>
			<p><span><span>mysql_store_result()</span>的<span>1</span>个优点在于，</span>由于将行全部提取到了客户端上，你不仅能连续访问行，还能使用<span>mysql_data_seek()</span>或<span><span>mysql_row_seek()</span>在结果集中向前或向后移动，以更改结果集内当前行的位置。通过调用<span>mysql_num_rows()</span>，还能发现有多少行。另一方面，对于大的结果集，<span>mysql_store_result()</span>所需的内存可能会很大，你很可能遇到内存溢出状况。</span></p>
			<p><span><span>mysql_use_result()</span>的<span>1</span>个优点在于，客户端所需的用于</span>结果集的内存较少，原因在于，一次它仅维护一行（由于分配开销较低，<span><span>mysql_use_result()</span>能更快</span>）。它的缺点在于，你必须快速处理每一行以避免妨碍服务器，你不能随机访问结果集中的行（只能连续访问行），你不知道结果集中有多少行，直至全部检索了它们为止。不仅如此，即使在检索过程中你判定已找到所寻找的信息，也必须检索所有的行。</p>
			<p>通过<span>API</span>，客户端能够恰当地对查询作出响应（仅在必要时检索行），而无需知道查询是否是<span><span>SELECT</span>查询。可以在每次<span>mysql_query()</span></span>或<span>mysql_real_query()</span>后，通过调用<span><span>mysql_store_result()</span>完成该操作。如果结果集调用成功，</span>查询为<span><span>SELECT</span>，而且能够读取行。</span>如果结果集调用失败，可调用<span>mysql_field_count()</span>来判断结果是否的确是所预期的。如果<span><span>mysql_field_count()</span>返回<span>0</span>，</span>查询不返回数据（表明它是<span>INSERT</span>、<span>UPDATE</span>、<span><span>DELETE</span>等），</span>而且不返回行。如果<span><span>mysql_field_count()</span>是非<span>0</span>值，</span>查询应返回行，但没有返回行。这表明查询是失败了的<span>SELECT</span>。关于如何实现该操作的示例，请参见关于<span><span>mysql_field_count()</span>的介绍。</span></p>
			<p>无论是<span><span>mysql_store_result()</span>还是<span>mysql_use_result()</span>，均允许你获取关于构成结果集的字段的信息</span>（字段数目，它们的名称和类型等）。通过重复调用<span><span>mysql_fetch_field()</span>，可以按顺序访问行内的字段信息，或者，通过调用<span>mysql_fetch_field_direct()</span>，能够在行内按字段编号访问字段信息。通过调用<span>mysql_field_seek()</span>，可以改变当前字段的光标位置。对字段光标的设置将影响后续的<span>mysql_fetch_field()</span>调用。此外，你也能通过调用<span>mysql_fetch_fields()</span>，一次性地获得关于字段的所有信息。</span></p>
			<p>为了检测和通报错误，<span>MySQL</span>提供了使用<span>mysql_errno()</span>和<span>mysql_error()</span>函数访问错误信息的机制。它们能返回关于最近调用的函数的错误代码或错误消息，最近调用的函数可能成功也可能失败，这样，你就能判断错误是在何时出现的，以及错误是什么。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-functions"></a>
			25.2.3.&nbsp;C API函数描述</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#mysql-affected-rows">25.2.3.1. mysql_affected_rows()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-autocommit">25.2.3.2. mysql_autocommit()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-change-user">25.2.3.3. mysql_change_user()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-character-set-name">25.2.3.4. mysql_character_set_name()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-close">25.2.3.5. mysql_close()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-commit">25.2.3.6. mysql_commit()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-connect">25.2.3.7. mysql_connect()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-create-db">25.2.3.8. mysql_create_db()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-data-seek">25.2.3.9. mysql_data_seek()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-debug">25.2.3.10. mysql_debug()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-drop-db">25.2.3.11. mysql_drop_db()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-dump-debug-info">25.2.3.12. mysql_dump_debug_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-eof">25.2.3.13. mysql_eof()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-errno">25.2.3.14. mysql_errno()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-error">25.2.3.15. mysql_error()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-escape-string">25.2.3.16. mysql_escape_string()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-fetch-field">25.2.3.17. mysql_fetch_field()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-fetch-field-direct">25.2.3.18. mysql_fetch_field_direct()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-fetch-fields">25.2.3.19. mysql_fetch_fields()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-fetch-lengths">25.2.3.20. mysql_fetch_lengths()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-fetch-row">25.2.3.21. mysql_fetch_row()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-field-count">25.2.3.22. mysql_field_count()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-field-seek">25.2.3.23. mysql_field_seek()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-field-tell">25.2.3.24. mysql_field_tell()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-free-result">25.2.3.25. mysql_free_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-character-set-info">25.2.3.26. mysql_get_character_set_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-client-info">25.2.3.27. mysql_get_client_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-client-version">25.2.3.28. mysql_get_client_version()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-host-info">25.2.3.29. mysql_get_host_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-proto-info">25.2.3.30. mysql_get_proto_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-server-info">25.2.3.31. mysql_get_server_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-server-version">25.2.3.32. mysql_get_server_version()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-hex-string">25.2.3.33. mysql_hex_string()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-info">25.2.3.34. mysql_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-init">25.2.3.35. mysql_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-insert-id">25.2.3.36. mysql_insert_id()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-kill">25.2.3.37. mysql_kill()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-library-end">25.2.3.38. mysql_library_end()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-library-init">25.2.3.39. mysql_library_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-list-dbs">25.2.3.40. mysql_list_dbs()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-list-fields">25.2.3.41. mysql_list_fields()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-list-processes">25.2.3.42. mysql_list_processes()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-list-tables">25.2.3.43. mysql_list_tables()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-more-results">25.2.3.44. mysql_more_results()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-next-result">25.2.3.45. mysql_next_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-num-fields">25.2.3.46. mysql_num_fields()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-num-rows">25.2.3.47. mysql_num_rows()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-options">25.2.3.48. mysql_options()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-ping">25.2.3.49. mysql_ping()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-query">25.2.3.50. mysql_query()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-real-connect">25.2.3.51. mysql_real_connect()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-real-escape-string">25.2.3.52. mysql_real_escape_string()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-real-query">25.2.3.53. mysql_real_query()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-refresh">25.2.3.54. mysql_refresh()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-reload">25.2.3.55. mysql_reload()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-rollback">25.2.3.56. mysql_rollback()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-row-seek">25.2.3.57. mysql_row_seek()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-row-tell">25.2.3.58. mysql_row_tell()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-select-db">25.2.3.59. mysql_select_db()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-set-character-set">25.2.3.60. mysql_set_character_set()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-set-server-option">25.2.3.61. mysql_set_server_option()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-shutdown">25.2.3.62. mysql_shutdown()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-sqlstate">25.2.3.63. mysql_sqlstate()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-ssl-set">25.2.3.64. mysql_ssl_set()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stat">25.2.3.65. mysql_stat()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-store-result">25.2.3.66. mysql_store_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-thread-id">25.2.3.67. mysql_thread_id()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-use-result">25.2.3.68. mysql_use_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-warning-count">25.2.3.69. mysql_warning_count()</a></span></dt></dl></div>
			<p>在本节所作的介绍中，按照<span>C</span>编程语言，<span>为NULL</span>的参数或返回值表示<span>NULL</span>，而不是<span>MySQL 
			Null</span>值。</p>
			<p>返回值的函数通常会返回指针或整数。除非作了其他规定，返回指针的函数将返回非<span>Null</span>值，以指明成功，或返回<span>NULL</span>值以指明出错。返回整数的函数将返回<span>0</span>以指明成功，或返回非<span>0</span>值以指明出错。注意，非<span>0</span>值仅表明这点。除非在函数描述中作了其他说明，不要对非<span>0</span>值进行测试：</p>
			<pre><span>if (result)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* correct */</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ... error ...</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>if (result &lt; 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* incorrect */</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ... error ...</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>if (result == -1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* incorrect */</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ... error ...</span></pre>
			<p>当函数返回错误时，在函数描述的“错误”部分将列出可能的错误类型。通过调用<span><span>mysql_errno()</span>可发现出现的错误是什么。通过调用<span>mysql_error()</span>，可获得错误的字符串表示。</span></p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-affected-rows"></a>25.2.3.1. mysql_affected_rows()</h4></div></div></div><a class="indexterm" name="id3010933"></a>
				<p><span>my_ulonglong 
				mysql_affected_rows(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回上次<span>UPDATE</span>更改的行数，上次<span><span>DELETE</span>删除的行数，或</span>上次<span><span>INSERT</span>语句插入的行数。对于<span>UPDATE</span>、<span>DELETE</span></span>或<span><span>INSERT</span>语句，可在<span>mysql_query()</span>后立刻调用。</span>对于<span>SELECT</span>语句，<span>mysql_affected_rows()</span>的工作方式与<span>mysql_num_rows()</span>类似。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>大于<span>0</span>的整数表明受影响或检索的行数。“<span>0</span>”表示<span><span>UPDATE</span>语句未更新</span>记录，在查询中没有与<span><span>WHERE</span>匹配的行</span>，或未执行查询。“<span>-1</span>”表示查询返回错误，或者，对于<span>SELECT</span>查询，在调用<span><span>mysql_store_result()</span>之前调用了<span>mysql_affected_rows()</span></span>。由于<span><span>mysql_affected_rows()</span>返回无符号值，通过比较返回值和<span>“(my_ulonglong)-1”</span>或等效的<span>“(my_ulonglong</span><span  >)~</span><span>0”</span></span>，检查是否为“<span>-1</span>”。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>mysql_query(&amp;mysql,&quot;UPDATE products SET cost=cost*1.25 WHERE group=10&quot;);</span></pre>
				<pre><span>printf(&quot;%ld products updated&quot;,(long) mysql_affected_rows(&amp;mysql));</span></pre>
				<p>如果在连接至<strong><span>mysqld</span></strong>时指定了标志<span>CLIENT_FOUND_ROWS</span>，对于<span><span>UPDATE</span>语句，<span>mysql_affected_rows()</span></span>将返回<span><span>WHERE</span>语句匹配的行数。</span></p>
				<p>注意，使用<span><span>REPLACE</span>命令时，如果新行替代了旧行，<span>mysql_affected_rows()</span></span>返回<span>2</span>。这是因为，在该情况下，删除了重复行后插入了<span>1</span>行。</p>
				<p>如果使用“<span>INSERT ... 
				ON DUPLICATE KEY UPDATE</span>”来插入行，如果行是作为新行插入的<span>，mysql_affected_rows()</span>返回<span>1</span>，如果是更新了已有的行，返回<span>2</span>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-autocommit"></a>25.2.3.2. mysql_autocommit()</h4></div></div></div><a class="indexterm" name="id3011153"></a>
				<p><span>my_bool 
				mysql_autocommit(MYSQL *mysql, my_bool mode)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>如果模式为“<span>1</span>”，启用<span>autocommit</span>模式；如果模式为“<span>0</span>”，禁止<span>autocommit</span>模式。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>0</span>，如果出现错误，返回非<span>0</span>值。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-change-user"></a>25.2.3.3. mysql_change_user()</h4></div></div></div><a class="indexterm" name="id3011232"></a>
				<p><span>my_bool 
				mysql_change_user(MYSQL *mysql, const char *user, const char 
				*password, const char *db)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>更改用户，并使由<span><span>db</span>指定的数据库成为由<span>mysql</span>指定的连接上的默认数据库（当前数据库）。</span>在后续查询中，对于不包含显式数据库区分符的表引用，该数据库是默认数据库。</p>
				<p><span>如果不能确定已连接的用户或用户不具有使用数据库的权限，<span>mysql_change_user()</span></span>将失败。在这种情况下，不会改变用户和数据库。</p>
				<p>如果不打算拥有默认数据库，可将<span><span>db</span>参数设置为<span>NULL</span>。</span></p>
				<p>该命令总是会执行活动事务的<span><span>ROLLBACK</span>操作，关闭所有的临时表，解锁所有的锁定表，并复位状态，就像进行了新连接那样。即使未更改用户，也会出现该情况。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>表示成功，非<span>0</span>值表示出现错误。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>与从<span>mysql_real_connect()</span>获得的相同。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中丢失了与服务器的连接。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span>
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_UNKNOWN_COM_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器未实施该命令（或许是较低版本的服务器）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_ACCESS_DENIED_ERROR</span><span> </span></p>
				<p>用户或密码错误。<span> </span>
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_BAD_DB_ERROR</span><span> </span></p>
				<p>数据库不存在。<span> </span>
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_DBACCESS_DENIED_ERROR</span><span> </span>
				</p>
				<p>用户没有访问数据库的权限。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_WRONG_DB_NAME</span><span> </span></p>
				<p>数据库名称过长。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>if (mysql_change_user(&amp;mysql, &quot;user&quot;, &quot;password&quot;, &quot;new_database&quot;))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; fprintf(stderr, &quot;Failed to change user.&nbsp; </span><span>Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-character-set-name"></a>25.2.3.4. mysql_character_set_name()</h4></div></div></div><a class="indexterm" name="id3011504"></a>
				<p><span>const char *mysql_character_set_name(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>为当前连接返回默认的字符集。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>默认字符集。<span> </span></p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-close"></a>25.2.3.5. mysql_close()</h4></div></div></div><a class="indexterm" name="id3011574"></a>
				<p><span>void 
				mysql_close(MYSQL *mysql)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>关闭前面打开的连接。如果句柄是由<span>mysql_init()</span>或<span><span>mysql_connect()</span>自动分配的，<span>mysql_close()</span></span>还将解除分配由<span><span>mysql</span>指向</span>的连接句柄。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>无。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-commit"></a>25.2.3.6. mysql_commit()</h4></div></div></div><a class="indexterm" name="id3011660"></a>
				<p><span>my_bool 
				mysql_commit(MYSQL *mysql)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>提交当前事务。</p>
				<p>该函数的动作受<span><span>completion_type</span>系统变量的值控制。尤其是，</span>如果<span>completion_type</span>的值为<span>2</span>，终结事务并关闭客户端连接后，服务器将执行释放操作。客户端程序应调用<span><span>mysql_close()</span>，从客户端一侧关闭连接。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>0</span>，如果出现错误，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="mysql-connect"></a>25.2.3.7. mysql_connect()</h4>
						</div></div></div><a class="indexterm" name="id3011751">
				</a>
				<p><span>MYSQL *mysql_connect(MYSQL 
				*mysql, const char *host, const char *user, const char *passwd)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>该函数已过时。最好使用<span>mysql_real_connect()</span>取而代之。</p>
				<p><span><span>mysql_connect()</span>试图建立与运行在主机上的<span>MySQL</span>数据库引擎的连接。在能够执行任何其他<span>API</span>函数之前，<span>mysql_connect()</span></span>必须成功完成，但<span>mysql_get_client_info()</span>例外。</p>
				<p>这些参数的意义与<span><span>mysql_real_connect()</span>的对应参数的意义相同，</span>差别在于连接参数可以为<span>NULL</span>。在这种情况下，<span>C 
				API</span>将自动为连接结构分配内存，并当调用<span><span>mysql_close()</span>时释放分配的内存。该方法的缺点是，如果连接失败，你无法检索错误消息。</span>要想从<span>mysql_errno()</span>或<span><span>mysql_error()</span>获得错误消息，</span>必须提供有效的<span>MYSQL</span>指针。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>与<span>mysql_real_connect()</span>的相同。</p>
				<p><strong><span>错误</span></strong></p>
				<p>与<span>mysql_real_connect()</span>的相同。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-create-db"></a>25.2.3.8. mysql_create_db()</h4></div></div></div><a class="indexterm" name="id3011891"></a>
				<p><span>int 
				mysql_create_db(MYSQL *mysql, const char *db)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>创建由<span><span>db</span>参数命名的数据库。</span></p>
				<p>该函数已过时。最好使用<span>mysql_query()</span>来发出<span>SQL
				<span>CREATE DATABASE</span></span>语句。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果数据库已成功创建，返回<span>0</span>，如果出现错误，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span>
				</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>if(mysql_create_db(&amp;mysql, &quot;my_database&quot;))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; fprintf(stderr, &quot;Failed to create new database.&nbsp; </span><span>Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-data-seek"></a>25.2.3.9. mysql_data_seek()</h4></div></div></div><a class="indexterm" name="id3012053"></a>
				<p><span>void 
				mysql_data_seek(MYSQL_RES *result, my_ulonglong offset)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>在查询结果集中寻找任意行。偏移值为行号，范围从<span>0</span>到<span>mysql_num_rows(result)-1</span>。</p>
				<p>该函数要求结果集结构包含查询的所有结果，因此，<span>so
				<span>mysql_data_seek()</span></span>仅应与<span><span>mysql_store_result()</span>联合使用，而不是</span>与<span>mysql_use_result()</span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>无。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-debug"></a>25.2.3.10. mysql_debug()</h4></div></div></div><a class="indexterm" name="id3012152"></a>
				<p><span>void 
				mysql_debug(const char *debug)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>用给定的字符串执行<span>DBUG_PUSH</span>。<span>mysql_debug()</span>采用<span>Fred 
				Fish</span>调试库。要想使用该函数，必须编译客户端库，使之支持调试功能。请参见<a href="porting.html#debugging-server" title="E.1. Debugging a MySQL Server">E.1节，“调试MySQL服务器”</a>。请参见<a href="porting.html#debugging-client" title="E.2. Debugging a MySQL Client">E.2节，“调试MySQL客户端”</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>无。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<p><strong><span>示例：</span></strong></p>
				<p>这里给出的调用将使客户端库在客户端机器的<span><span>/tmp/client.trace</span>中生成<span>1</span>个跟踪文件。</span></p>
				<pre><span>mysql_debug(&quot;d:t:O,/tmp/client.trace&quot;);</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-drop-db"></a>25.2.3.11. mysql_drop_db()</h4></div></div></div><a class="indexterm" name="id3012263"></a>
				<p><span>int 
				mysql_drop_db(MYSQL *mysql, const char *db)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>撤销由<span>db</span>参数命名数据库。<span> </span>
				</p>
				<p>该函数已过时。最好使用<span>mysql_query()</span>来发出<span>SQL
				<span>DROP DATABASE</span></span>语句</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功撤销了数据库，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span>
				</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>if(mysql_drop_db(&amp;mysql, &quot;my_database&quot;))</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;Failed to drop the database: Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-dump-debug-info"></a>25.2.3.12. mysql_dump_debug_info()</h4></div></div></div><a class="indexterm" name="id3012424"></a>
				<p><span>int 
				mysql_dump_debug_info(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>指示服务器将一些调试信息写入日志。要想使之工作，已连接的用户必须具有<span><span>SUPER</span>权限。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果命令成功，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。 </div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-eof"></a>25.2.3.13. mysql_eof()</h4></div></div></div><a class="indexterm" name="id3012557"></a>
				<p><span>my_bool 
				mysql_eof(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>该函数已过时。应使用<span>mysql_errno()</span>或<span>mysql_error()</span>取而代之。</p>
				<p><span>mysql_eof()</span>确定是否已读取了结果集的最后<span>1</span>行。</p>
				<p>如果通过成功调用<span><span>mysql_store_result()</span>获得了结果集，客户端将在<span>1</span>次操作中收到整个结果集。在该情况下，</span>从<span><span>mysql_fetch_row()</span>返回的<span>NULL</span>总表示已到达结果集末尾，</span>而且没必要调用<span><span>mysql_eof()</span>。</span>与<span>mysql_store_result()</span>一起使用时，<span><span>mysql_eof()</span>总返回<span>“</span>真<span>”</span>。</span></p>
				<p>另一方面，如果你使用<span>mysql_use_result()</span>来初始化结果集检索，当重复调用<span><span>mysql_fetch_row()</span>时，将逐个地从服务器获取结果集的行。由于在该过程中，可能出现连接上的错误，从<span>mysql_fetch_row()</span>返回的<span>NULL</span>值不一定表示已正常地抵达结果集末尾。</span>在该情况下，可以使用<span><span>mysql_eof()</span>来判定出现了什么情况。如果抵达结果集末尾，<span>mysql_eof()</span></span>返回非<span>0</span>值，如果出现错误，返回<span>0</span>。</p>
				<p>从历史的角度上看，<span><span>mysql_eof()</span>在日期上早于</span>标准的<span>MySQL</span>错误函数<span>mysql_errno()</span>和<span>mysql_error()</span>。由于这类错误函数提供了相同的信息，它们优先于已过时的<span>mysql_eof()</span>。事实上，它们提供了更多信息，这是因为，<span><span>mysql_eof()</span>仅返回布尔值，</span>错误函数能够在出现错误时指明错误的原因。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果未出现错误，返回<span>0</span>。如果抵达结果集的末尾，返回非<span>0</span>值。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<p><strong><span>示例：</span></strong></p>
				<p>在下面的示例中，介绍了使用<span>mysql_eof()</span>的方法：</p>
				<pre><span>mysql_query(&amp;mysql,&quot;SELECT * FROM some_table&quot;);</span></pre>
				<pre><span>result = mysql_use_result(&amp;mysql);</span></pre>
				<pre><span>while((row = mysql_fetch_row(result)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // do something with data</span></pre>
				<pre><span>}</span></pre>
				<pre><span>if(!mysql_eof(result))&nbsp; // mysql_fetch_row() failed due to an error</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Error: %s\n&quot;, mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<p>但是，你也能使用标准的<span>MySQL</span>错误函数实现相同的结果：</p>
				<pre><span>mysql_query(&amp;mysql,&quot;SELECT * FROM some_table&quot;);</span></pre>
				<pre><span>result = mysql_use_result(&amp;mysql);</span></pre>
				<pre><span>while((row = mysql_fetch_row(result)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // do something with data</span></pre>
				<pre><span>}</span></pre>
				<pre><span>if(mysql_errno(&amp;mysql))&nbsp; // mysql_fetch_row() failed due to an error</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Error: %s\n&quot;, mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-errno"></a>25.2.3.14. mysql_errno()</h4></div></div></div><a class="indexterm" name="id3012790"></a>
				<p><span>unsigned int 
				mysql_errno(MYSQL *mysql)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>对于由<span><span>mysql</span>指定的连接，<span>mysql_errno()</span></span>返回最近调用的<span>API</span>函数的错误代码，该函数调用可能成功也可能失败。“<span>0</span>”返回值表示未出现错误。在<span>MySQL
				<span>errmsg.h</span></span><span>头文件中，列出了</span>客户端错误消息编号。在<a href="error-handling.html">附录B：</a><a href="error-handling.html" title="Appendix B. Error Codes and Messages"><i>错误代码和消息</i></a>中，也列出了这些错误。<span>
				</span></p>
				<p>注意，如果成功，某些函数，如<span><span>mysql_fetch_row()</span>等，不会设置<span>mysql_errno()</span></span>。</p>
				<p>经验规则是，如果成功，所有向服务器请求信息的函数均会复位<span>mysql_errno()</span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果失败，返回上次<span><span>mysql_<i>xxx</i>()</span>调用的错误代码。<span>“0”</span>表示未出现错误。</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-error"></a>25.2.3.15. mysql_error()</h4></div></div></div><a class="indexterm" name="id3012914"></a>
				<p><span>const char *mysql_error(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>对于由<span>mysql</span>指定的连接，对于失败的最近调用的<span>API</span>函数，<span><span>mysql_error()</span>返回</span>包含错误消息的、由<span>Null</span>终结的字符串。如果该函数未失败，<span><span>mysql_error()</span>的返回值可能是以前的错误，或指明无错误的空字符串。</span></p>
				<p>经验规则是，如果成功，所有向服务器请求信息的函数均会复位<span>mysql_error()</span>。</p>
				<p>对于复位<span>mysql_errno()</span>的函数，下述两个测试是等效的：</p>
				<pre><span>if(mysql_errno(&amp;mysql))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // an error occurred</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if(mysql_error(&amp;mysql)[0] != &#39;\0&#39;)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // an error occurred</span></pre>
				<pre><span>}</span></pre>
				<p>通过重新编译<span>MySQL</span>客户端库，可以更改客户端错误消息的语言。目前，能够选择数种语言显示错误消息，请参见<a href="database-administration.html#languages" title="5.10.2. Setting the Error Message Language">5.10.2节，“设置错误消息语言”</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>返回描述错误的、由<span>Null</span>终结的字符串。如果未出现错误，返回空字符串。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-escape-string"></a>25.2.3.16. mysql_escape_string()</h4></div></div></div><a class="indexterm" name="id3013037"></a>
				<p>应使用<span>mysql_real_escape_string()</span>取而代之！</p>
				<p>该函数与<span><span>mysql_real_escape_string()</span>等同，</span>但<span>mysql_real_escape_string()</span>会将连接处理程序作为其第<span>1</span>个参量，并按照当前字符集对字符串进行转义处理。<span>mysql_escape_string()</span>不采用连接参量，而且不考虑当前字符集设置。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-field"></a>25.2.3.17. mysql_fetch_field()</h4></div></div></div><a class="indexterm" name="id3013089"></a>
				<p><span>MYSQL_FIELD *mysql_fetch_field(MYSQL_RES 
				*result)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回采用<span><span>MYSQL_FIELD</span>结构的结果集的列。</span>重复调用该函数，以检索关于结果集中所有列的信息。未剩余字段时，<span>mysql_fetch_field()</span>返回<span>NULL</span>。</p>
				<p><span>每次执行新的<span>SELECT</span>查询时，将复位<span>mysql_fetch_field()</span></span>，以返回关于第<span>1</span>个字段的信息。调用<span><span>mysql_field_seek()</span>也会影响<span>mysql_fetch_field()</span>返回的字段。</span></p>
				<p>如果调用了<span><span>mysql_query()</span>以在表上执行<span>SELECT</span>，</span>但未调用<span>mysql_store_result()</span>，如果调用了<span><span>mysql_fetch_field()</span>以请求<span>BLOB</span>字段的长度，</span><span>MySQL</span>将返回默认的<span>Blob</span>长度（<span>8KB</span>）。之所以选择<span>8KB</span>是因为<span>MySQL</span>不知道<span><span>BLOB</span>的最大长度。应在日后使其成为可配置的。</span>一旦检索了结果集，<span><span>field-&gt;max_length</span>将包含特定查询中该列的最大值的长度。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>当前列的<span><span>MYSQL_FIELD</span>结构。如果未剩余任何列，返回<span>NULL</span></span>。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>MYSQL_FIELD *field;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>while((field = mysql_fetch_field(result)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;field name %s\n&quot;, field-&gt;name);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-field-direct"></a>25.2.3.18. mysql_fetch_field_direct()</h4></div></div></div><a class="indexterm" name="id3013256"></a>
				<p><span>MYSQL_FIELD *mysql_fetch_field_direct(MYSQL_RES 
				*result, unsigned int fieldnr)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>给定结果集内某<span>1</span>列的字段编号<span><span>fieldnr</span>，以<span>MYSQL_FIELD</span>结构形式返回列的字段定义</span>。可以使用该函数检索任意列的定义。<span><span>Fieldnr</span>的值应在从<span>0</span>到<span>mysql_num_fields(result)-1</span></span>的范围内。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>对于指定列，返回<span><span>MYSQL_FIELD</span>结构。</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int i;</span></pre>
				<pre><span>MYSQL_FIELD *field;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>for(i = 0; i &lt; num_fields; i++)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; field = mysql_fetch_field_direct(result, i);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;Field %u is %s\n&quot;, i, field-&gt;name);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-fields"></a>25.2.3.19. mysql_fetch_fields()</h4></div></div></div><a class="indexterm" name="id3013370"></a>
				<p><span>MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES 
				*result)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>对于结果集，返回所有<span>MYSQL_FIELD</span>结构的数组。每个结构提供了结果集中<span>1</span>列的字段定义。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>关于结果集所有列的<span><span>MYSQL_FIELD</span>结构的数组。</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int i;</span></pre>
				<pre><span>MYSQL_FIELD *fields;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>fields = mysql_fetch_fields(result);</span></pre>
				<pre><span>for(i = 0; i &lt; num_fields; i++)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; printf(&quot;Field %u is %s\n&quot;, i, fields[i].name);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-lengths"></a>25.2.3.20. mysql_fetch_lengths()</h4></div></div></div><a class="indexterm" name="id3013467"></a>
				<p><span>unsigned long *mysql_fetch_lengths(MYSQL_RES 
				*result)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回结果集内当前行的列的长度。如果打算复制字段值，该长度信息有助于优化，这是因为，你能避免调用<span><span>strlen()</span>。此外，</span>如果结果集包含二进制数据，必须使用该函数来确定数据的大小，原因在于，对于包含<span>Null</span>字符的任何字段，<span><span>strlen()</span>将返回错误的结果。</span></p>
				<p>对于空列以及包含<span>NULL</span>值的列，其长度为<span>0</span>。要想了解区分这两类情况的方法，请参见关于<span>mysql_fetch_row()</span>的介绍。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>无符号长整数的数组表示各列的大小（不包括任何终结<span>NULL</span>字符）。如果出现错误，返回<span>NULL</span>。</p>
				<p><strong><span>错误</span></strong></p>
				<p><span>
				mysql_fetch_lengths()</span>仅对结果集的当前行有效。如果在调用<span><span>mysql_fetch_row()</span>之前或检索了结果集中的所有行后调用了它，</span>将返回<span>NULL</span>。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>MYSQL_ROW row;</span></pre>
				<pre><span>unsigned long *lengths;</span></pre>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int i;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>row = mysql_fetch_row(result);</span></pre>
				<pre><span>if (row)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; lengths = mysql_fetch_lengths(result);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; num_fields; i++)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Column %u is %lu bytes in length.\n&quot;, i, lengths[i]);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-row"></a>25.2.3.21. mysql_fetch_row()</h4></div></div></div><a class="indexterm" name="id3013610"></a>
				<p><span>MYSQL_ROW 
				mysql_fetch_row(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>检索结果集的下一行。在<span><span>mysql_store_result()</span>之后使用时，如果没有要检索的行，<span>mysql_fetch_row()</span></span>返回<span>NULL</span>。在<span>mysql_use_result()</span>之后使用时，<span>如果没有要检索的行或出现了错误，<span>mysql_fetch_row()</span></span>返回<span><span>NULL</span>。</span></p>
				<p>行内值的数目由<span><span>mysql_num_fields(result)</span>给出。如果行中保存了调用<span>mysql_fetch_row()</span>返回的值，将按照<span>row[0]</span>到<span>row[mysql_num_fields(result)-1]</span>，访问这些值的指针。行中的<span>NULL</span></span>值由<span><span>NULL</span>指针指明。</span></p>
				<p>可以通过调用<span><span>mysql_fetch_lengths()</span>来获得行中字段值的长度。对于空字段以及包含<span>NULL</span>的字段，长度为<span>0</span>。通过检查字段值的指针，能够区分它们。如果指针为<span>NULL</span>，字段为<span>NULL</span>，否则字段为空。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>下一行的<span><span>MYSQL_ROW</span>结构。如果没有更多要检索的行或出现了错误，返回<span>NULL</span>。</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>注意，在对<span><span>mysql_fetch_row()</span>的两次调用之间，不会复位错误。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span>
				</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>MYSQL_ROW row;</span></pre>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int i;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>while ((row = mysql_fetch_row(result)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; unsigned long *lengths;</span></pre>
				<pre><span>&nbsp;&nbsp; lengths = mysql_fetch_lengths(result);</span></pre>
				<pre><span>&nbsp;&nbsp; for(i = 0; i &lt; num_fields; i++)</span></pre>
				<pre><span>&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;[%.*s] &quot;, (int) lengths[i], row[i] ? row[i] : &quot;NULL&quot;);</span></pre>
				<pre><span>&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp; printf(&quot;\n&quot;);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-field-count"></a>25.2.3.22. mysql_field_count()</h4></div></div></div><a class="indexterm" name="id3013828"></a>
				<p><span>unsigned int 
				mysql_field_count(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回作用在连接上的最近查询的列数。</p>
				<p>该函数的正常使用是在<span><span>mysql_store_result()</span>返回<span>NULL</span>（因而没有结果集指针）时。在这种情况下，</span>可调用<span><span>mysql_field_count()</span>来判定<span>mysql_store_result()</span>是否应生成非空结果。这样，客户端就能采取恰当的动作，而无需知道</span>查询是否是<span><span>SELECT</span>（或类似<span>SELECT</span>的）语句。</span>在这里给出的示例中，演示了完成它的方法。</p>
				<p>请参见<a href="apis.html#null-mysql-store-result" title="25.2.13.1. Why mysql_store_result() Sometimes Returns NULL After mysql_query() Returns Success">25.2.13.1节，“为什么在mysql_query()返回成功后，mysql_store_result()有时会返回NULL<code class="literal"></code>”</a><span>.
				</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>表示结果集中列数的无符号整数。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>MYSQL_RES *result;</span></pre>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int num_rows;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_query(&amp;mysql,query_string))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // error</span></pre>
				<pre><span>}</span></pre>
				<pre><span>else // query succeeded, process any data returned by it</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; result = mysql_store_result(&amp;mysql);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; if (result)&nbsp; // there are rows</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // retrieve rows, then call mysql_free_result(result)</span></pre>
				<pre><span>&nbsp; &nbsp;&nbsp;}</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; else&nbsp; // mysql_store_result() returned nothing; should it have?</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(mysql_field_count(&amp;mysql) == 0)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // query does not return data</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (it was not a SELECT)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_rows = mysql_affected_rows(&amp;mysql);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // mysql_store_result() should have returned data</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Error: %s\n&quot;, mysql_error(&amp;mysql));</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>}</span></pre>
				<p>另一种可选的方法是，用<span><span>mysql_errno(&amp;mysql)</span>替换<span>mysql_field_count(&amp;mysql)</span>调用。</span>在该情况下，无论语句是否是<span><span>SELECT</span>，</span>你将直接从<span><span>mysql_store_result()</span>查找错误，</span>而不是从<span><span>mysql_field_count()</span>的值进行推断。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-field-seek"></a>25.2.3.23. mysql_field_seek()</h4></div></div></div><a class="indexterm" name="id3014006"></a>
				<p><span>
				MYSQL_FIELD_OFFSET mysql_field_seek(MYSQL_RES *result, 
				MYSQL_FIELD_OFFSET offset)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>将字段光标设置到给定的偏移处。对<span><span>mysql_fetch_field()</span>的下一次调用将检索与该偏移相关的列定义。</span></p>
				<p>要想查找行的开始，请传递值为<span>0</span>的偏移量。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>字段光标的前一个值。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-field-tell"></a>25.2.3.24. mysql_field_tell()</h4></div></div></div><a class="indexterm" name="id3014090"></a>
				<p><span>
				MYSQL_FIELD_OFFSET mysql_field_tell(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回上一个<span><span>mysql_fetch_field()</span>所使用的字段光标的定义。该值可用作<span>mysql_field_seek()</span></span>的参量。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>字段光标的当前偏移量。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-free-result"></a>25.2.3.25. mysql_free_result()</h4></div></div></div><a class="indexterm" name="id3014168"></a>
				<p><span>void 
				mysql_free_result(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>释放由<span>mysql_store_result()</span>、<span>mysql_use_result()</span>、<span><span>mysql_list_dbs()</span>等为结果集分配的内存</span>。完成对结果集的操作后，必须调用<span><span>mysql_free_result()</span>释放结果集使用的内存。</span></p>
				<p>释放完成后，不要尝试访问结果集。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>无。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-character-set-info"></a>25.2.3.26. mysql_get_character_set_info()</h4></div></div></div><a class="indexterm" name="id3014260"></a>
				<p><span>void 
				mysql_get_character_set_info(MYSQL *mysql, MY_CHARSET_INFO *cs)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>该函数提供了关于默认客户端字符集的信息。可以使用<span><span>mysql_set_character_set()</span>函数更改默认的字符集。</span></p>
				<p>该函数是在<span>MySQL 5.0.10</span>中增加的。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>if (!mysql_set_character_set(&amp;mysql, &quot;utf8&quot;))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; MY_CHARSET_INFO cs;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; mysql_get_character_set_info(&amp;mysql, &amp;cs);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;character set information:\n&quot;);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;character set name: %s\n&quot;, cs.name);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;collation name: %s\n&quot;, cs.csname);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;comment: %s\n&quot;, cs.comment);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;directory: %s\n&quot;, cs.dir);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;multi byte character min. length: %d\n&quot;, cs.mbminlen);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;multi byte character max. length: %d\n&quot;, cs.mbmaxlen);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-client-info"></a>25.2.3.27. mysql_get_client_info()</h4></div></div></div><a class="indexterm" name="id3014349"></a>
				<p><span>char *mysql_get_client_info(void)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回表示客户端库版本的字符串。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>表示<span>MySQL</span>客户端库版本的字符串。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-client-version"></a>25.2.3.28. mysql_get_client_version()</h4></div></div></div><a class="indexterm" name="id3014419"></a>
				<p><span>unsigned long 
				mysql_get_client_version(void)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回表示客户端库版本的整数。该值的格式是<span><span>XYYZZ</span>，其中<span>X</span></span>是主版本号，<span>YY</span>是发布级别，<span><span>ZZ</span>是发布级别内的版本号。</span>例如，值<span><span>40102</span>表示客户端库的版本是<span>4.1.2</span>。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>表示<span>MySQL</span>客户端库版本的整数。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-host-info"></a>25.2.3.29. mysql_get_host_info()</h4></div></div></div><a class="indexterm" name="id3014516"></a>
				<p><span>char *mysql_get_host_info(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回描述了所使用连接类型的字符串，包括服务器主机名。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>代表服务器主机名和连接类型的字符串。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-proto-info"></a>25.2.3.30. mysql_get_proto_info()</h4></div></div></div><a class="indexterm" name="id3014587"></a>
				<p><span>unsigned int 
				mysql_get_proto_info(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回当前连接所使用的协议版本。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>代表当前连接所使用协议版本的无符号整数。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-server-info"></a>25.2.3.31. mysql_get_server_info()</h4></div></div></div><a class="indexterm" name="id3014659"></a>
				<p><span>char *mysql_get_server_info(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回代表服务器版本号的字符串。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>代表服务器版本号的字符串。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-server-version"></a>25.2.3.32. mysql_get_server_version()</h4></div></div></div><a class="indexterm" name="id3014729"></a>
				<p><span>unsigned long 
				mysql_get_server_version(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>以整数形式返回服务器的版本号。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>表示<span>MySQL</span>服务器版本的数值，格式如下：</p>
				<pre><span>major_version*10000 + minor_version *100 + sub_version</span></pre>
				<p>例如，对于<span>5.0.12</span>，返回<span>500012</span>。</p>
				<p>在客户端程序中，为了快速确定某些与版本相关的服务器功能是否存在，该函数很有用。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-hex-string"></a>25.2.3.33. mysql_hex_string()</h4></div></div></div><a class="indexterm" name="id3014815"></a>
				<p><span>unsigned long 
				mysql_hex_string(char *to, const char *from, unsigned long 
				length)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>该函数用于创建可用在<span>SQL</span>语句中的合法<span>SQL</span>字符串。请参见<a href="language-structure.html#string-syntax" title="9.1.1. Strings">9.1.1节，“字符串”</a>。</p>
				<p>该字符串从形式上编码为十六进制格式，每个字符编码为<span>2</span>个十六进制数。结果被置入其中，并添加<span>1</span>个终结<span>Null</span>字节。</p>
				<p>“<span>from</span>”所指向的字符串必须是长度字节“<span>long</span>”。必须为“<span>to</span>”分配缓冲区，缓冲区至少为<span><span>length*2+1</span>字节长。当<span>mysql_hex_string()</span>返回时，<span>“to”</span>的内容为由<span>Null</span>终结的字符串。返回值是</span>编码字符串的长度，不包括终结用<span>Null</span>字符。</p>
				<p>可采用<span>0x<i>value</i></span>或<span><span>X&#39;<i>value</i>&#39;</span>格式将返回值置于<span>SQL</span>语句中。但是，</span>返回值不包括<span>0x</span>或<span>X&#39;...&#39;</span>。调用者必须提供所希望的格式是何种。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>char query[1000],*end;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>end = strmov(query,&quot;INSERT INTO test_table values(&quot;);</span></pre>
				<pre><span>end = strmov(end,&quot;0x&quot;);</span></pre>
				<pre><span>end += mysql_hex_string(end,&quot;What&#39;s this&quot;,11);</span></pre>
				<pre><span>end = strmov(end,&quot;,0x&quot;);</span></pre>
				<pre><span>end += mysql_hex_string(end,&quot;binary data: \0\r\n&quot;,16);</span></pre>
				<pre><span>*end++ = &#39;)&#39;;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_real_query(&amp;mysql,query,(unsigned int) (end - query)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; fprintf(stderr, &quot;Failed to insert row, Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<p>示例中所使用的<span><span>strmov()</span>函数包含在<span>mysqlclient</span>库中，</span>它的工作方式类似于<span><span>strcpy()</span>，但返回指向第<span>1</span>个参数终结<span>Null</span>的指针。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>置于“<span>to</span>”中的值的长度，不包括终结用<span>Null</span>字符。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-info"></a>25.2.3.34. mysql_info()</h4></div></div></div><a class="indexterm" name="id3015005"></a>
				<p><span>char *mysql_info(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>检索字符串，该字符串提供了关于最近执行查询的信息，但仅对这里列出的语句有效。对于其他语句，<span>mysql_info()</span>返回<span>NULL</span>。字符串的格式取决于查询的类型，如本节所述。数值仅是说明性的，字符串包含与查询相适应的值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				INSERT INTO ... SELECT ...</span><span> </span>
				</p>
				<p>字符串格式：<span>记录，<span>100</span>；副本，<span>0</span>；警告，<span>0</span></span><span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				INSERT INTO ... VALUES (...),(...),(...)...</span><span>
				</span></p>
				<p>字符串格式：<span>记录，<span>3</span>；副本，<span>0</span>；警告，<span>0</span></span><span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>LOAD 
				DATA INFILE ...</span><span> </span></p>
				<p>字符串格式：<span>记录，<span>1</span>；删除，<span>0</span>；跳过，<span>0</span>；警告，<span>0</span></span><span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ALTER TABLE</span><span> </span></p>
				<p>字符串格式：<span>记录，<span>3</span>；副本，<span>0</span>；警告，<span>0</span></span><span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				UPDATE</span><span> </span></p>
				<p>字符串格式：<span>匹配行，<span>40</span>；更改，<span>40</span>；警告，<span>0</span></span><span>
				</span></p>
				<p>注意，<span><span>mysql_info()</span>为<span>INSERT 
				... VALUES</span>返回</span>非<span><span>NULL</span>值，<span>INSERT 
				... VALUES</span>仅用于</span>多行形式的语句（也就是说，仅当指定了多个值列表时）。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>字符串，它表示最近所执行查询的额外信息。如果该查询无可用信息，返回<span><span>NULL</span>。</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-init"></a>25.2.3.35. mysql_init()</h4></div></div></div><a class="indexterm" name="id3015205"></a>
				<p><span>MYSQL *mysql_init(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>分配或初始化与<span><span>mysql_real_connect()</span>相适应的<span>MYSQL</span>对象。</span>如果<span><span>mysql</span>是<span>NULL</span>指针，</span>该函数将分配、初始化、并返回新对象。否则，将初始化对象，并返回对象的地址。如果<span>mysql_init()</span>分配了新的对象，当调用<span><span>mysql_close()</span>来关闭连接时。将释放该对象。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>初始化的<span><span>MYSQL*</span>句柄。如果无足够内存以分配新的对象，返回<span>NULL</span>。</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>在内存不足的情况下，返回<span><span>NULL</span>。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-insert-id"></a>25.2.3.36. mysql_insert_id()</h4></div></div></div><a class="indexterm" name="id3015315"></a>
				<p><span>my_ulonglong 
				mysql_insert_id(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回由以前的<span>INSERT</span>或<span><span>UPDATE</span>语句为<span>AUTO_INCREMENT</span>列生成的值。在包含<span>AUTO_INCREMENT</span>字段的表中执行了<span>INSERT</span>语句后，应使用该函数。</span></p>
				<p>更准确地讲，将在下述条件下更新<span>mysql_insert_id()</span>：</p>
				<p>
				<span>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>将值保存到<span>AUTO_INCREMENT</span>列中的<span>INSERT</span>语句。无论值是通过在列中存储特殊值<span>NULL</span>或<span>0</span>自动生成的，还是确切的非特殊值，都成立。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在有多行<span><span>INSERT</span>语句的情况下，<span>mysql_insert_id()</span>返回第<span>1</span>个自动生成的<span>AUTO_INCREMENT</span>值，</span>如果未生成这类值，将返回插入在<span><span>AUTO_INCREMENT</span>列中的</span>最后<span>1</span>个确切值。</p>
				<p>
				<span>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>通过将<span>LAST_INSERT_ID(<i>expr</i>)</span>插入到任意列中以生成<span>AUTO_INCREMENT</span>值的<span>INSERT</span>语句。</span></p>
				<p>
				<span>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>通过更新任意列至<span>LAST_INSERT_ID(<i>expr</i>)</span>以生成<span>AUTO_INCREMENT</span>值的<span>INSERT</span>语句。</span></p>
				<p>
				<span>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>mysql_insert_id()</span>的值不受诸如<span>SELECT</span>等返回结果集的语句的影响。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果前面的语句返回了错误，<span><span>mysql_insert_id()</span>的值</span>将是不确定的。</p>
				<p>注意，如果前面的语句未使用<span><span>AUTO_INCREMENT</span>，<span>mysql_insert_id()</span></span>返回<span>0</span>。如果需要保存值，在生成值的语句后，务必立刻调用<span>mysql_insert_id()</span>。</p>
				<p><span><span>mysql_insert_id()</span>的值仅受在当前客户端连接内发出的语句的影响。不受由其他客户端发出的语句的影响。</span></p>
				<p>请参见<a href="functions.html#information-functions" title="12.9.3. Information Functions">12.9.3节，“信息函数”</a>。</p>
				<p>此外还应注意，<span>SQL <span>
				LAST_INSERT_ID()</span></span>函数的值总包含最近生成的<span><span>AUTO_INCREMENT</span>值，而且在语句之间不会被复位，</span>原因在于该函数的值是在服务器中维护的。另一个区别是，如果设置了<span><span>AUTO_INCREMENT</span>列来指定非特殊值，不会更新<span>LAST_INSERT_ID()</span>。</span></p>
				<p><span>LAST_INSERT_ID()</span>不同于<span><span>mysql_insert_id()</span>的原因在于，<span>LAST_INSERT_ID()</span>在脚本中很容易使用，</span>而<span><span>mysql_insert_id()</span>则试图提供关于在<span>AUTO_INCREMENT</span>列中出现情况的更准确信息。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>在前面的讨论中予以了介绍。<span> </span></p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-kill"></a>25.2.3.37. mysql_kill()</h4></div></div></div><a class="indexterm" name="id3015646"></a>
				<p><span>int 
				mysql_kill(MYSQL *mysql, unsigned long pid)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>请求服务器杀死由<span>pid</span>指定的线程。</p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>表示成功，非<span>0</span>值表示出现错误。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-library-end"></a>25.2.3.38. mysql_library_end()</h4></div></div></div><a class="indexterm" name="id3015778"></a>
				<p><span>void 
				mysql_library_end(void)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>它是<span>mysql_server_end()</span>函数的同义词。</p>
				<p>关于具体的用法，请参见<a href="apis.html#c-api-function-overview" title="25.2.2. C API Function Overview">25.2.2节，“C API函数概述”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-library-init"></a>25.2.3.39. mysql_library_init()</h4></div></div></div><a class="indexterm" name="id3015834"></a>
				<p><span>int 
				mysql_library_init(int argc, char **argv, char **groups)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>这是<span>mysql_server_init()</span>函数的同义词。</p>
				<p>关于具体的用法，请参见<a href="apis.html#c-api-function-overview" title="25.2.2. C API Function Overview">25.2.2节，“C API函数概述”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-dbs"></a>25.2.3.40. mysql_list_dbs()</h4></div></div></div><a class="indexterm" name="id3015891"></a>
				<p><span>MYSQL_RES *mysql_list_dbs(MYSQL 
				*mysql, const char *wild)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>返回由服务器上的数据库名称组成的结果集，该服务器与由通配符参数指定的简单正则表达式匹配。通配符参数可以包含通配符“<span>%</span>”或“<span>_</span>”，也可以是<span>NULL</span>指针，以便与所有的数据库匹配。调用<span><span>mysql_list_dbs()</span>的方法类似于执行</span>查询<span>SHOW 
				database [LIKE wild]</span>。</p>
				<p>必须用<span>mysql_free_result()</span>释放结果集。<span>
				</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>成功后返回<span>MYSQL_RES</span>结果集。<span>如果出现错误，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。<span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-fields"></a>25.2.3.41. mysql_list_fields()</h4></div></div></div><a class="indexterm" name="id3016079"></a>
				<p><span>MYSQL_RES *mysql_list_fields(MYSQL 
				*mysql, const char *table, const char *wild)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回由给定表中的字段名称组成的结果集，给定表与由通配符参数指定的简单正则表达式匹配。通配符参数可以包含通配符“<span>%</span>”或“<span>_</span>”，也可以是<span>NULL</span>指针，以便与所有的字段匹配。调用<span><span>mysql_list_fields()</span>的方法类似于执行</span>查询<span>SHOW 
				COLUMNS FROM <i>tbl_name</i> [LIKE <i>wild</i>]</span>。</p>
				<p>注意，建议使用<span>SHOW 
				COLUMNS FROM <i>tbl_name</i></span>，而不是<span>mysql_list_fields()</span>。</p>
				<p>必须用<span>mysql_free_result()</span>释放结果集。<span>
				</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>MYSQL_RES</span>结果集。<span>如果出现错误，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-processes"></a>25.2.3.42. mysql_list_processes()</h4></div></div></div><a class="indexterm" name="id3016277"></a>
				<p><span>MYSQL_RES *mysql_list_processes(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回描述当前服务器线程的结果集。该类信息与<strong><span>mysqladmin 
				processlist</span></strong>或<span><span>SHOW 
				PROCESSLIST</span>查询给出的信息相同。</span></p>
				<p>必须用<span>mysql_free_result()</span>释放结果集。 </p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>MYSQL_RES</span>结果集。<span>如果出现错误，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-tables"></a>25.2.3.43. mysql_list_tables()</h4></div></div></div><a class="indexterm" name="id3016429"></a>
				<p><span>MYSQL_RES *mysql_list_tables(MYSQL 
				*mysql, const char *wild)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>返回由当前数据库内的表名组成的结果集，当前数据库与由通配符参数指定的简单正则表达式匹配。通配符参数可以包含通配符“<span>%</span>”或“<span>_</span>”，也可以是<span>NULL</span>指针，以便与所有的表匹配。调用<span><span>mysql_list_tables()</span>的方法类似于执行</span>查询<span>HOW 
				tables [LIKE <i>wild</i>]</span>。</p>
				<p>必须用<span>mysql_free_result()</span>释放结果集。<span>
				</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>MYSQL_RES</span>结果集。 
				<span>如果出现错误，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-more-results"></a>25.2.3.44. mysql_more_results()</h4></div></div></div><a class="indexterm" name="id3016608"></a>
				<p><span>my_bool 
				mysql_more_results(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>如果当前执行的查询存在多个结果，返回“真”，而且应用程序必须调用<span><span>mysql_next_result()</span>来获取结果。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>如果存在多个结果，返回<span>“</span>真<span>”</span>（<span>1</span>），如果不存在多个结果，返回<span>“</span>假<span>”</span>（<span>0</span>）。</span></p>
				<p>在大多数情况下，可调用<span>mysql_next_result()</span>来测试是否存在多个结果，如果存在多个结果，对检索进行初始化操作。</p>
				<p>请参见<a href="apis.html#c-api-multiple-queries" title="25.2.9. C API Handling of Multiple Query Execution">25.2.9节，“多查询执行的C API处理”</a>。请参见<a href="apis.html#mysql-next-result" title="25.2.3.45. mysql_next_result()">25.2.3.45节，“mysql_next_result()”</a>。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-next-result"></a>25.2.3.45. mysql_next_result()</h4></div></div></div><a class="indexterm" name="id3016714"></a>
				<p><span>int 
				mysql_next_result(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>如果存在多个查询结果，<span><span>mysql_next_result()</span>将读取下一个查询结果，并将状态返回给应用程序。</span></p>
				<p>如果前面的查询返回了结果集，必须为其调用<span><span>mysql_free_result()</span>。</span></p>
				<p>调用了<span><span>mysql_next_result()</span>后，连接状态就像你已为下一查询调用了<span>mysql_real_query()</span></span>或<span>mysql_query()</span>时的一样。这意味着你能调用<span><span>mysql_store_result()</span>、<span>mysql_warning_count()</span>、<span>mysql_affected_rows()</span>等等。</span></p>
				<p>如果<span>mysql_next_result()</span>返回错误，将不执行任何其他语句，也不会获取任何更多的结果，</p>
				<p>请参见<a href="apis.html#c-api-multiple-queries" title="25.2.9. C API Handling of Multiple Query Execution">25.2.9节，“多查询执行的C API处理”</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<table border="1" cellpadding="0" id="table6">
					<tr>
						<td>
						<p><strong>
						<span>返回值</span></strong></td>
						<td>
						<p><strong>
						<span>描述</span></strong></td>
					</tr>
					<tr>
						<td>
						<p><span>0</span></td>
						<td>
						<p>成功并有多个结果。</td>
					</tr>
					<tr>
						<td>
						<p><span>-1</span></td>
						<td>
						<p>成功但没有多个结果。</td>
					</tr>
					<tr>
						<td>
						<p><span>&gt;0</span></td>
						<td>
						<p>出错</td>
					</tr>
				</table>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。例如，没有为前面的结果集调用<span><span>mysql_use_result()</span>。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-num-fields"></a>25.2.3.46. mysql_num_fields()</h4></div></div></div><a class="indexterm" name="id3016973"></a><a class="indexterm" name="id3016983"></a>
				<p><span>unsigned int 
				mysql_num_fields(MYSQL_RES *result)</span><span>
				</span></p>
				<p>要想传递<span>MYSQL*</span>参量取而代之，请使用无符号整数<span>mysql_field_count(MYSQL 
				*mysql)</span>。</p>
				<p><strong><span>描述</span></strong></p>
				<p>返回结果集中的行数。</p>
				<p>注意，你可以从指向结果集的指针或指向连接句柄的指针获得行数。如果<span>mysql_store_result()</span>或<span><span>mysql_use_result()</span>返回<span>NULL</span>，</span>应使用连接句柄（因而没有结果集指针）。在该情况下，可调用<span>mysql_field_count()</span>来判断<span>mysql_store_result()</span>是否生成了非空结果。这样，客户端程序就能采取恰当的行动，而不需要知道查询是否是<span><span>SELECT</span>语句（或类似<span>SELECT</span>的语句）。</span>在下面的示例中，介绍了执行该操作的方式。<span>
				</span></p>
				<p>请参见<a href="apis.html#null-mysql-store-result" title="25.2.13.1. Why mysql_store_result() Sometimes Returns NULL After mysql_query() Returns Success">25.2.13.1节，“为什么在mysql_query()返回成功后，mysql_store_result()有时会返回NULL<code class="literal"></code>”</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>表示结果集中行数的无符号整数。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>MYSQL_RES *result;</span></pre>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int num_rows;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_query(&amp;mysql,query_string))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // error</span></pre>
				<pre><span>}</span></pre>
				<pre><span>else // query succeeded, process any data returned by it</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; result = mysql_store_result(&amp;mysql);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; if (result)&nbsp; // there are rows</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // retrieve rows, then call mysql_free_result(result)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; else&nbsp; // mysql_store_result() returned nothing; should it have?</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mysql_errno(&amp;mysql))</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Error: %s\n&quot;, mysql_error(&amp;mysql));</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (mysql_field_count(&amp;mysql) == 0)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // query does not return data</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (it was not a SELECT)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_rows = mysql_affected_rows(&amp;mysql);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>}</span></pre>
				<p>另一种可选方式是（如果你知道你的查询应返回结果集），使用检查“<span>mysql_field_count(&amp;mysql) 
				is </span><span>= 0<span>”来替换</span><span>mysql_errno(&amp;mysql)</span></span>调用。仅当出错时才应使用它。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-num-rows"></a>25.2.3.47. mysql_num_rows()</h4></div></div></div><a class="indexterm" name="id3017164"></a>
				<p><span>my_ulonglong 
				mysql_num_rows(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回结果集中的行数。<span> </span></p>
				<p><span><span>mysql_num_rows()</span>的使用取决于</span>是否采用了<span>mysql_store_result()</span>或<span><span>mysql_use_result()</span>来返回结果集。</span>如果使用了<span>mysql_store_result()</span>，可以立刻调用<span>mysql_num_rows()</span>。如果使用了<span>mysql_use_result()</span>，<span>mysql_num_rows()</span>不返回正确的值，直至检索了结果集中的所有行为止。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>结果集中的行数。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-options"></a>25.2.3.48. mysql_options()</h4></div></div></div><a class="indexterm" name="id3017268"></a>
				<p><span>int 
				mysql_options(MYSQL *mysql, enum mysql_option option, const char 
				*arg)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>可用于设置额外的连接选项，并影响连接的行为。可多次调用该函数来设置数个选项。</p>
				<p><span>应在<span>mysql_init()</span>之后、以及<span>mysql_connect()</span></span>或<span><span>mysql_real_connect()</span>之前调用<span>mysql_options()</span></span>。</p>
				<p>选项参量指的是你打算设置的选项。<span>Arg</span>参量是选项的值。如果选项是整数，那么<span><span>arg</span>应指向</span>整数的值。</p>
				<p>可能的选项值：</p>
				<table border="1" cellpadding="0" width="612" style="width: 459.0pt" id="table7">
					<tr>
						<td>
						<p><strong>
						<span>选项</span></strong></td>
						<td>
						<p><strong>
						<span>参量类型</span></strong></td>
						<td>
						<p><strong>
						<span>功能</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_INIT_COMMAND</span></td>
						<td>
						<p>
						<span>char *</span></td>
						<td>
						<p>连接到<span>MySQL</span>服务器时将执行的命令。再次连接时将自动地再次执行。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_COMPRESS</span></td>
						<td>
						<p>未使用</td>
						<td>
						<p>使用压缩客户端／服务器协议</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_CONNECT_TIMEOUT</span></td>
						<td>
						<p>
						<span>unsigned int *</span></td>
						<td>
						<p>以秒为单位的连接超时。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_GUESS_CONNECTION</span></td>
						<td>
						<p>未使用</td>
						<td>
						<p>对于与<span><span>libmysqld</span>链接的应用程序，允许库<span>“</span>猜测<span>”</span>是否使用</span>嵌入式服务器或远程服务器。“<span class="quote">猜测</span>”表示，如果设置了主机名但不是本地主机，将使用远程服务器。该行为是默认行为。 
						可使用<span>MYSQL_OPT_USE_EMBEDDED_CONNECTION</span><span>
						</span>和<span><span>MYSQL_OPT_USE_REMOTE_CONNECTION</span>覆盖它。</span>对于与<span><span>libmysqlclient</span>链接的应用程序，该选项将被忽略。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_LOCAL_INFILE</span></td>
						<td>
						<p>指向单元的可选指针</td>
						<td>
						<p>如果未给定指针，或指针指向“<span><span>unsigned 
						int != 0”</span>，将允许</span>命令<span>LOAD 
						LOCAL INFILE</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_NAMED_PIPE</span></td>
						<td>
						<p>未使用</td>
						<td>
						<p>使用命名管道连接到<span>NT</span>平台上的<span>MySQL</span>服务器。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_PROTOCOL</span></td>
						<td>
						<p>
						<span>unsigned int *</span></td>
						<td>
						<p>要使用的协议类型。应是<span><span>mysql.h</span>中定义的<span>mysql_protocol_type</span>的枚举值之一。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_READ_TIMEOUT</span></td>
						<td>
						<p>
						<span>unsigned int *</span></td>
						<td>
						<p>从服务器读取信息的超时（目前仅在<span>Windows</span>平台的<span>TCP/IP</span>连接上有效）。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_RECONNECT</span></td>
						<td>
						<p>
						<span>my_bool *</span></td>
						<td>
						<p>如果发现连接丢失，启动或禁止与服务器的自动再连接。从<span>MySQL 
						5.0.3开始，默认情况下禁止再连接，这是5.0.13</span>中的新选项，提供了一种以显式方式设置再连接行为的方法。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_SET_CLIENT_IP</span></td>
						<td>
						<p>
						<span>char *</span></td>
						<td>
						<p>对于与<span><span>libmysqld</span>链接的应用程序（具备鉴定支持特性的已编译<span>libmysqld</span>）</span>，它意味着，出于鉴定目的，用户将被视为从指定的<span>IP</span>地址（指定为字符串）进行连接。对于与<span><span>libmysqlclient</span>链接的应用程序，，该选项将被忽略。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_USE_EMBEDDED_CONNECTION</span></td>
						<td valign="top">
						<p>未使用</td>
						<td>
						<p>对于与<span><span>libmysqld</span>链接的应用程序，对于连接来说，它将强制使用嵌入式服务器</span>。对于与<span><span>libmysqlclient</span>链接的应用程序，，该选项将被忽略。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_USE_REMOTE_CONNECTION</span></td>
						<td valign="top">
						<p>未使用</td>
						<td>
						<p>对于与<span><span>libmysqld</span>链接的应用程序，对于连接来说，它将强制使用远程服务器</span>。对于与<span><span>libmysqlclient</span>链接的应用程序，，该选项将被忽略。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_USE_RESULT</span></td>
						<td>
						<p>未使用</td>
						<td>
						<p>不使用该选项。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_WRITE_TIMEOUT</span></td>
						<td>
						<p>
						<span>unsigned int *</span></td>
						<td>
						<p>写入服务器的超时（目前仅在<span>Windows</span>平台的<span>TCP/IP</span>连接上有效）。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_READ_DEFAULT_FILE</span></td>
						<td>
						<p>
						<span>char *</span></td>
						<td>
						<p>从命名选项文件而不是从<span><span>my.cnf</span>读取选项。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_READ_DEFAULT_GROUP</span></td>
						<td>
						<p>
						<span>char *</span></td>
						<td>
						<p>从<span><span>my.cnf</span>或用<span>MYSQL_READ_DEFAULT_FILE</span>指定的文件中的命名组读取选项。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_REPORT_DATA_TRUNCATION</span></td>
						<td>
						<p>
						<span>my_bool *</span></td>
						<td>
						<p>通过<span><span>MYSQL_BIND.error</span>，对于预处理语句，允许或禁止通报数据截断错误</span>（默认为禁止）。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_SECURE_AUTH</span></td>
						<td>
						<p>
						<span>my_bool*</span></td>
						<td>
						<p>是否连接到不支持密码混编功能的服务器，在<span>MySQL 
						4.1.1</span>和更高版本中，使用了密码混编功能。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_SET_CHARSET_DIR</span></td>
						<td>
						<p>
						<span>char*</span></td>
						<td>
						<p>指向包含字符集定义文件的目录的路径名。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_SET_CHARSET_NAME</span></td>
						<td>
						<p>
						<span>char*</span></td>
						<td>
						<p>用作默认字符集的字符集的名称。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_SHARED_MEMORY_BASE_NAME</span></td>
						<td>
						<p>
						<span>char*</span></td>
						<td>
						<p>命名为与服务器进行通信的共享内存对象。应与你打算连接的<span>mysqld</span>服务器使用的选项“<span><span>-shared-memory-base-name”</span>相同。</span></td>
					</tr>
				</table>
				<p>注意，如果使用了<span>MYSQL_READ_DEFAULT_FILE</span>或<span><span>MYSQL_READ_DEFAULT_GROUP</span>，总会读取客户端组。</span></p>
				<p>选项文件中指定的组可能包含下述选项：</p>
				<table border="1" cellpadding="0" id="table8">
					<tr>
						<td>
						<p><strong>
						<span>选项</span></strong></td>
						<td>
						<p><strong>
						<span>描述</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>connect-timeout</span></td>
						<td>
						<p>以秒为单位的连接超时。在<span>Linux</span>平台上，该超时也用作等待服务器首次回应的时间。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>compress</span></td>
						<td>
						<p>使用压缩客户端／服务器协议。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>database</span></td>
						<td>
						<p>如果在连接命令中未指定数据库，连接到该数据库。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>debug</span></td>
						<td>
						<p>调试选项。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>disable-local-infile</span></td>
						<td>
						<p>禁止使用<span>LOAD 
						DATA LOCAL</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>host</span></td>
						<td>
						<p>默认主机名。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>init-command</span></td>
						<td>
						<p>连接到<span>MySQL</span>服务器时将执行的命令。再次连接时将自动地再次执行。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>interactive-timeout</span></td>
						<td>
						<p>等同于将<span>CLIENT_INTERACTIVE</span>指定为<span>mysql_real_connect()</span>。请参见<a href="apis.html#mysql-real-connect" title="25.2.3.51. mysql_real_connect()">25.2.3.51节，“mysql_real_connect()”</a>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>local-infile[=(0|1)]</span></td>
						<td>
						<p>如果无参量或参量<span>!= 0</span>，那么将允许使用<span>LOAD 
						DATA LOCAL</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>max_allowed_packet</span></td>
						<td>
						<p>客户端能够从服务器读取的最大信息包。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>multi-results</span></td>
						<td>
						<p>允许多语句执行或存储程序的多个结果集。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>multi-statements</span></td>
						<td>
						<p>允许客户端在<span>1</span>个字符串内发送多条语句。（由“<span>;</span>”隔开）。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>password</span></td>
						<td>
						<p>默认密码。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>pipe</span></td>
						<td>
						<p>使用命名管道连接到<span>NT</span>平台上的<span>MySQL</span>服务器。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>protocol={TCP | SOCKET | PIPE | 
						MEMORY}</span></td>
						<td>
						<p>连接到服务器时将使用的协议。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>port</span></td>
						<td>
						<p>默认端口号。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>return-found-rows</span></td>
						<td>
						<p>通知<span><span>mysql_info()</span>返回发现的行，而不是使用<span>UPDATE</span>时更新的行</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>shared-memory-base-name=<i>name</i></span></td>
						<td>
						<p>共享内存名称，用于连接到服务器（默认为<span>&quot;MYSQL&quot;</span>）。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>socket</span></td>
						<td>
						<p>默认的套接字文件。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>user</span></td>
						<td>
						<p>默认用户。</td>
					</tr>
				</table>
				<p>注意，“<span><span>timeout”</span>（超时）已被</span>“<span><span>connect-timeout”</span>（连接超时）取代，但为了保持向后兼容，</span>在<span>MySQL 
				5.1.2-alpha</span>中仍支持“<span><span>timeout”</span>（超时）。</span></p>
				<p>关于选项文件的更多信息，请参见<a href="using-mysql-programs.html#option-files" title="4.3.2. Using Option Files">4.3.2节，“使用选项文件”</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>成功时返回<span>0</span>。如果使用了未知选项，返回非<span>0</span>值。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>MYSQL mysql;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql_init(&amp;mysql);</span></pre>
				<pre><span>mysql_options(&amp;mysql,MYSQL_OPT_COMPRESS,0);</span></pre>
				<pre><span>mysql_options(&amp;mysql,MYSQL_READ_DEFAULT_GROUP,&quot;odbc&quot;);</span></pre>
				<pre><span>if (!mysql_real_connect(&amp;mysql,&quot;host&quot;,&quot;user&quot;,&quot;passwd&quot;,&quot;database&quot;,0,NULL,0))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Failed to connect to database: Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<p>该代码请求客户端使用压缩客户端／服务器协议，并从<span><span>my.cnf</span>文件的<span>obdc</span>部分读取额外选项。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-ping"></a>25.2.3.49. mysql_ping()</h4></div></div></div><a class="indexterm" name="id3018282"></a>
				<p><span>int 
				mysql_ping(MYSQL *mysql)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>检查与服务器的连接是否工作。如果连接丢失，将自动尝试再连接。</p>
				<p>该函数可被闲置了较长时间的客户端使用，用以检查服务器是否已关闭了连接，并在必要时再次连接。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果与服务器的连接有效返回<span>0</span>。如果出现错误，返回非<span>0</span>值。返回的非<span>0</span>值不表示<span>MySQL</span>服务器本身是否已关闭，连接可能因其他原因终端，如网络问题等。</p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-query"></a>25.2.3.50. mysql_query()</h4></div></div></div><a class="indexterm" name="id3018406"></a>
				<p><span>int 
				mysql_query(MYSQL *mysql, const char *query)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>执行由“<span>Null</span>终结的字符串”查询指向的<span>SQL</span>查询。正常情况下，字符串必须包含<span>1</span>条<span>SQL</span>语句，而且不应为语句添加终结分号（‘<span>;</span>’）或“<span><span>\g”</span>。如果允许多语句执行，</span>字符串可包含多条由分号隔开的语句。请参见<a href="apis.html#c-api-multiple-queries" title="25.2.9. C API Handling of Multiple Query Execution">25.2.9节，“多查询执行的C API处理”</a>。</p>
				<p><span>mysql_query()</span>不能用于包含二进制数据的查询，应使用<span>mysql_real_query()</span>取而代之（二进制数据可能包含字符‘<span><span>\0’<span>，</span>mysql_query()</span>会将该字符解释为查询字符串结束）。</span></p>
				<p>如果希望了解查询是否应返回结果集，可使用<span>mysql_field_count()</span>进行检查。请参见<a href="apis.html#mysql-field-count" title="25.2.3.22. mysql_field_count()">25.2.3.22节，“mysql_field_count()”</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果查询成功，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-real-connect"></a>25.2.3.51. mysql_real_connect()</h4></div></div></div><a class="indexterm" name="id3018593"></a>
				<p><span>MYSQL *mysql_real_connect(MYSQL 
				*mysql, const char *host, const char *user, const char *passwd, 
				const char *db, unsigned int port, const char *unix_socket, 
				unsigned long client_flag)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p><span>
				mysql_real_connect()</span>尝试与运行在主机上的<span>MySQL</span>数据库引擎建立连接。在你能够执行需要有效<span>MySQL</span>连接句柄结构的任何其他<span>API</span>函数之前，<span>mysql_real_connect()</span>必须成功完成。</p>
				<p>参数的指定方式如下：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>第<span>1</span>个参数应是已有<span><span>MYSQL</span>结构的地址。</span>调用<span>mysql_real_connect()</span>之前，必须调用<span><span>mysql_init()</span>来初始化<span>MYSQL</span>结构。通过<span>mysql_options()</span>调用，</span>可更改多种连接选项。请参见<a href="apis.html#mysql-options" title="25.2.3.48. mysql_options()">25.2.3.48节，“mysql_options()”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>“<span>host</span>”的值必须是主机名或<span>IP</span>地址。如果“<span>host</span>”是<span><span>NULL</span>或字符串<span>&quot;localhost&quot;</span></span>，连接将被视为与本地主机的连接。如果操作系统支持套接字（<span>Unix</span>）或命名管道（<span>Windows</span>），将使用它们而不是<span>TCP/IP</span>连接到服务器。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>“<span><span>user”</span>参数</span>包含用户的<span>MySQL</span>登录<span>ID</span>。如果“<span><span>user”</span>是<span>NULL</span>或空字符串<span>&quot;&quot;</span></span>，用户将被视为当前用户。在<span>UNIX</span>环境下，它是当前的登录名。在<span>Windows 
				ODBC</span>下，必须明确指定当前用户名。请参见<a href="connectors.html#dsn-on-windows" title="26.1.9.2. Configuring a MyODBC DSN on Windows">26.1.9.2节，“在Windows上配置MyODBC DSN”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>“<span><span>passwd”</span>参数包含用户的密码。</span>如果“<span><span>passwd”</span>是<span>NULL</span>，</span>仅会对该用户的（拥有<span>1</span>个空密码字段的）用户表中的条目进行匹配检查。这样，数据库管理员就能按特定的方式设置<span>MySQL</span>权限系统，根据用户是否拥有指定的密码，用户将获得不同的权限。</p>
				<p><strong>
				<span>注释：</span></strong>调用<span><span>mysql_real_connect()</span>之前，不要尝试加密密码，密码加密将由客户端<span>API</span>自动处理。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>“db”</span>是数据库名称。如果<span><span>db</span>为<span>NULL</span>，</span>连接会将默认的数据库设为该值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果“<span><span>port”</span>不是<span>0</span>，</span>其值将用作<span>TCP/IP</span>连接的端口号。注意，“<span>host</span>”参数决定了连接的类型。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果<span>unix_socket</span>不是<span>NULL</span>，该字符串描述了应使用的套接字或命名管道。注意，“<span>host</span>”参数决定了连接的类型。</p>
				<p>
				<span>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>client_flag</span>的值通常为<span>0</span>，但是，也能将其设置为下述标志的组合，以允许特定功能：</span></p>
				<table border="1" cellpadding="0" id="table9">
					<tr>
						<td>
						<p><strong>
						<span>标志名称</span></strong></td>
						<td>
						<p><strong>
						<span>标志描述</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_COMPRESS</span></td>
						<td>
						<p>使用压缩协议。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_FOUND_ROWS</span></td>
						<td>
						<p>返回发现的行数（匹配的），而不是受影响的行数。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_IGNORE_SPACE</span></td>
						<td>
						<p>允许在函数名后使用空格。使所有的函数名成为保留字。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_INTERACTIVE</span></td>
						<td>
						<p>关闭连接之前，允许<span><span>interactive_timeout</span>（取代了<span>wait_timeout</span>）秒的不活动时间。</span>客户端的会话<span><span>wait_timeout</span>变量被设为会话<span>interactive_timeout</span>变量的值。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_LOCAL_FILES</span></td>
						<td>
						<p>允许<span>LOAD 
						DATA LOCAL</span>处理功能。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_MULTI_STATEMENTS</span></td>
						<td>
						<p>通知服务器，客户端可能在单个字符串内发送多条语句（由‘<span>;</span>’隔开）。如果未设置该标志，将禁止多语句执行。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_MULTI_RESULTS</span></td>
						<td>
						<p>
						通知服务器，客户端能够处理来自多语句执行或存储程序的多个结果集。如果设置了<span><span>CLIENT_MULTI_STATEMENTS</span>，将自动设置它。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_NO_SCHEMA</span></td>
						<td>
						<p>禁止<span><i><span>db_name.tbl_name.col_name</span></i></span>语法。它用于<span>ODBC</span>。如果使用了该语法，它会使分析程序生成错误，在捕获某些<span>ODBC</span>程序中的缺陷时，它很有用。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_ODBC</span></td>
						<td>
						<p>客户端是<span>ODBC</span>客户端。它将<strong><span>mysqld</span></strong>变得更为<span>ODBC</span>友好。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_SSL</span></td>
						<td>
						<p>使用<span>SSL</span>（加密协议）。该选项不应由应用程序设置，它是在客户端库内部设置的。</td>
					</tr>
				</table>
				<p>对于某些参数，能够从选项文件获得取值，而不是取得<span><span>mysql_real_connect()</span>调用中的确切值。为此，在调用<span>mysql_real_connect()</span>之前，应与<span>MYSQL_READ_DEFAULT_FILE</span></span>或<span><span>MYSQL_READ_DEFAULT_GROUP</span>选项一起调用<span>mysql_options()</span>。随后，在<span>mysql_real_connect()</span></span>调用中，为准备从选项文件读取值的每个参数指定“<span class="quote">无值</span>”值：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span><span>host</span>，指定<span>NULL</span>值或空字符串</span><span>(<span>&quot;&quot;</span>)</span>。</p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span><span>user</span>，指定<span>NULL</span>值或空字符串。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span><span>passwd</span>，指定<span>NULL</span>值。（对于密码，<span>mysql_real_connect()</span>调用中的空字符串的值不能被选项文件中的字符串覆盖，这是因为，空字符串明确指明</span><span>MySQL</span>账户必须有空密码）。</p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span><span>db</span>，指定<span>NULL</span>值或空字符串</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span><span>port</span>，指定<span>“0”</span>值。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span>unix_socket</span>，<span>指定<span>NULL</span>值。</span></p>
				<p>对于某一参数，如果在选项文件中未发现值，将使用它的默认值，如本节前面介绍的那样。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果连接成功，返回<span><span>MYSQL*</span>连接句柄。如果连接失败，返回<span>NULL</span>。对于成功的连接，返回值与第<span>1</span>个参数的值相同。</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_CONN_HOST_ERROR</span><span> </span></p>
				<p>无法连接到<span>MySQL</span>服务器。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_CONNECTION_ERROR</span><span> </span></p>
				<p>无法连接到本地<span>MySQL</span>服务器。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_IPSOCK_ERROR</span><span> </span></p>
				<p>无法创建<span>IP</span>套接字。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。<span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SOCKET_CREATE_ERROR</span><span> </span></p>
				<p>无法创建<span>Unix</span>套接字。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_HOST</span><span> </span></p>
				<p>无法找到主机名的<span>IP</span>地址。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_VERSION_ERROR</span><span> </span></p>
				<p>
				协议不匹配，起因于：试图连接到具有特定客户端库（该客户端库使用了不同的协议版本）的服务器。如果使用很早的客户端库来建立与较新的服务器（未使用“<span>--old-protocol</span>”选项开始的）的连接，就会出现该情况。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_NAMEDPIPEOPEN_ERROR</span><span> </span></p>
				<p>无法在<span>Windows</span>平台下创建命名管道。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_NAMEDPIPEWAIT_ERROR</span><span> </span></p>
				<p>在<span>Windows</span>平台下等待命名管道失败。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_NAMEDPIPESETSTATE_ERROR</span><span> </span>
				</p>
				<p>在<span>Windows</span>平台下获取管道处理程序失败。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>如果<span>connect_timeout</span><span> 
				&gt; 0</span>，而且在连接服务器时所用时间长于<span><span>connect_timeout</span>秒，或在执行<span>init-command</span>时服务器</span>消失。</p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>MYSQL mysql;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql_init(&amp;mysql);</span></pre>
				<pre><span>mysql_options(&amp;mysql,MYSQL_READ_DEFAULT_GROUP,&quot;your_prog_name&quot;);</span></pre>
				<pre><span>if (!mysql_real_connect(&amp;mysql,&quot;host&quot;,&quot;user&quot;,&quot;passwd&quot;,&quot;database&quot;,0,NULL,0))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Failed to connect to database: Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<p>通过使用<span><span>mysql_options()</span>，</span><span>MySQL</span>库将读取<span><span>my.cnf</span>文件的<span>[client]</span></span>和<span>[your_prog_name]</span>部分，以确保程序工作，即使某人以某种非标准的方式设置<span>MySQL</span>也同样。</p>
				<p>注意，一旦建立了连接，<span><span>mysql_real_connect()</span>将设置再连接标志（<span>MYSQL</span>结构的组成部份）的值，在低于</span><span>5.0.3</span>版的<span>API</span>中，将其设为“<span>1</span>”，在较新的版本中，将其设为“<span>0</span>”。对于该标志，值“<span>1</span>”表示，如果因连接丢失而无法执行语句，放弃前，将尝试再次连接到服务器。从<span>MySQL 
				5.0.13</span>开始，可以对<span><span>mysql_options()</span>使用<span>MYSQL_OPT_RECONNECT</span>选项，对再连接行为进行控制。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-real-escape-string"></a>25.2.3.52. mysql_real_escape_string()</h4></div></div></div><a class="indexterm" name="id3019536"></a>
				<p><span>unsigned long 
				mysql_real_escape_string(MYSQL *mysql, char *to, const char 
				*from, unsigned long length)</span><span>
				</span></p>
				<p>注意，<span><span>mysql</span>必须是有效的开放式连接。</span>之所以需要它是因为，转义功能取决于服务器使用的字符集。</p>
				<p><strong><span>描述</span></strong></p>
				<p>该函数用于创建可在<span>SQL</span>语句中使用的合法<span>SQL</span>字符串。请参见<a href="language-structure.html#string-syntax" title="9.1.1. Strings">9.1.1节，“字符串”</a>。</p>
				<p>按照连接的当前字符集，将“<span>from</span>”中的字符串编码为转义<span>SQL</span>字符串。将结果置于“<span><span>to”</span>中，并添加<span>1</span>个终结用<span>NULL</span>字节。编码的字符为<span>NUL</span></span><span> 
				(ASCII 0)</span>、‘<span>\n</span>’、‘<span>\r</span>’、‘<span>\</span>’、‘<span>&#39;</span>’、‘<span>&quot;</span>’、以及<span>Control-Z</span>（请参见<a href="language-structure.html#literals" title="9.1. Literal Values">9.1节，“文字值”</a>）。（严格地讲，<span>MySQL</span>仅需要反斜杠和引号字符，用于引用转义查询中的字符串。该函数能引用其他字符，从而使得它们在日志文件中具有更好的可读性）。</p>
				<p>“<span>from</span>”指向的字符串必须是长度字节“<span>long</span>”。必须为“<span>to</span>”缓冲区分配至少<span><span>length*2+1</span>字节。</span>在最坏的情况下，每个字符或许需要使用<span>2</span>个字节进行编码，而且还需要终结<span>Null</span>字节。当<span><span>mysql_real_escape_string()</span>返回时，</span>“<span>to</span>”的内容是由<span>Null</span>终结的字符串。返回值是编码字符串的长度，不包括终结用<span>Null</span>字符。</p>
				<p>如果需要更改连接的字符集，应使用<span>mysql_set_character_set()</span>函数，而不是执行<span>SET 
				NAMES</span><span> (</span>或<span>SET 
				CHARACTER SET</span><span>)</span>语句。<span><span>mysql_set_character_set()</span>的工作方式类似于<span>SET 
				NAMES</span>，但它还能影响<span>mysql_real_escape_string()</span>所使用的字符集，而<span>SET 
				NAMES</span>则不能。</span></p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>char query[1000],*end;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>end = strmov(query,&quot;INSERT INTO test_table values(&quot;);</span></pre>
				<pre><span>*end++ = &#39;\&#39;&#39;;</span></pre>
				<pre><span>end += mysql_real_escape_string(&amp;mysql, end,&quot;What&#39;s this&quot;,11);</span></pre>
				<pre><span>*end++ = &#39;\&#39;&#39;;</span></pre>
				<pre><span>*end++ = &#39;,&#39;;</span></pre>
				<pre><span>*end++ = &#39;\&#39;&#39;;</span></pre>
				<pre><span>end += mysql_real_escape_string(&amp;mysql, end,&quot;binary data: \0\r\n&quot;,16);</span></pre>
				<pre><span>*end++ = &#39;\&#39;&#39;;</span></pre>
				<pre><span>*end++ = &#39;)&#39;;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_real_query(&amp;mysql,query,(unsigned int) (end - query)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; fprintf(stderr, &quot;Failed to insert row, Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<p>该示例中使用的<span><span>strmov()</span>函数包含在<span>mysqlclient</span>库中，工作方式与<span>strcpy()</span>类似，</span>但会返回指向第<span>1</span>个参数终结用<span>Null</span>的指针。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>置于“<span>to</span>”中的值的长度，不包括终结用<span>Null</span>字符。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-real-query"></a>25.2.3.53. mysql_real_query()</h4></div></div></div><a class="indexterm" name="id3019781"></a>
				<p><span>int 
				mysql_real_query(MYSQL *mysql, const char *query, unsigned long 
				length)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>执行由“<span>query</span>”指向的<span>SQL</span>查询，它应是字符串长度字节“<span>long</span>”。正常情况下，<span>字符串必须包含<span>1</span>条<span>SQL</span>语句，而且不应为语句添加</span>终结分号（‘<span>;</span>’）或“<span>\g</span>”。如果允许多语句执行，字符串可包含由分号隔开的多条语句。请参见<a href="apis.html#c-api-multiple-queries" title="25.2.9. C API Handling of Multiple Query Execution">25.2.9节，“多查询执行的C API处理”</a>。</p>
				<p>对于包含二进制数据的查询，必须使用<span><span>mysql_real_query()</span>而不是<span>mysql_query()</span>，这是因为，二进制数据可能会包含</span>‘<span><span>\0’<span>字符。此外，</span>mysql_real_query()</span>比<span>mysql_query()</span>快，这是因为它不会在查询字符串上调用<span>strlen()</span>。</span></p>
				<p>如果希望知道查询是否应返回结果集，可使用<span><span>mysql_field_count()</span>进行检查</span><a href="apis.html#mysql-field-count" title="25.2.3.22. mysql_field_count()">25.2.3.22节，“mysql_field_count()”</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果查询成功，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-refresh"></a>25.2.3.54. mysql_refresh()</h4></div></div></div><a class="indexterm" name="id3019989"></a>
				<p><span>int 
				mysql_refresh(MYSQL *mysql, unsigned int options)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>该函数用于刷新表或高速缓冲，或复位复制服务器信息。连接的用户必须具有<span><span>RELOAD</span>权限。</span></p>
				<p>“<span><span>options”</span>参量是</span>一种位掩码，由下述值的任意组合构成。能够以“<span>Or</span>”（或）方式将多个值组合在一起，用一次调用执行多项操作。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_GRANT</span><span> </span></p>
				<p>刷新授权表，与<span>FLUSH 
				PRIVILEGES</span>类似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_LOG</span><span> </span></p>
				<p>刷新日志，与<span>FLUSH 
				LOGS</span>类似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_TABLES</span><span> </span></p>
				<p>刷新表高速缓冲，与<span>FLUSH 
				TABLES</span>类似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_HOSTS</span><span> </span></p>
				<p>刷新主机高速缓冲，与<span>FLUSH 
				HOSTS</span>类似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_STATUS</span><span> </span></p>
				<p>复位状态变量，与<span>FLUSH 
				STATUS</span>类似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_THREADS</span><span> </span></p>
				<p>刷新线程高速缓冲。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_SLAVE</span><span> </span></p>
				<p>在从复制服务器上，复位主服务器信息，并重新启动从服务器，与<span>RESET 
				SLAVE</span>类似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_MASTER</span><span> </span></p>
				<p>
				在主复制服务器上，删除二进制日志索引中列出的二进制日志文件，并截短索引文件，与<span>RESET 
				MASTER</span>类似。</p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>表示成功，非<span>0</span>值表示出现错误。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-reload"></a>25.2.3.55. mysql_reload()</h4></div></div></div><a class="indexterm" name="id3020280"></a>
				<p><span>int 
				mysql_reload(MYSQL *mysql)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>请求<span>MySQL</span>服务器重新加载授权表。连接的用户必须具有<span>RELOAD</span>权限。</p>
				<p>该函数已过时。最好使用<span>mysql_query()</span>来发出<span>SQL
				<span>FLUSH PRIVILEGES</span></span><span>语句。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>表示成功，非<span>0</span>值表示出现错误。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-rollback"></a>25.2.3.56. mysql_rollback()</h4></div></div></div><a class="indexterm" name="id3020424"></a>
				<p><span>my_bool 
				mysql_rollback(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>回滚当前事务。</p>
				<p>该函数的动作取决于<span><span>completion_type</span>系统变量的值。</span>尤其是，如果<span><span>completion_type</span>的值为<span>“2”</span></span>，终结事务后，服务器将执行释放操作，并关闭客户端连接。客户端程序应调用<span><span>mysql_close()</span>，</span>从客户端一侧关闭连接。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>0</span>，如果出现错误，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-row-seek"></a>25.2.3.57. mysql_row_seek()</h4></div></div></div><a class="indexterm" name="id3020516"></a>
				<p><span>
				MYSQL_ROW_OFFSET mysql_row_seek(MYSQL_RES *result, 
				MYSQL_ROW_OFFSET offset)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>将行光标置于查询结果集中的任意行。“<span><span>offset”</span>值是行偏移量，它应是</span>从<span>mysql_row_tell()</span>或<span><span>mysql_row_seek()</span>返回的值。该值不是行编号，如果你打算按编号查找结果集中的行，</span>请使用<span>mysql_data_seek()</span>。</p>
				<p>该函数要求在结果集的结构中包含查询的全部结果，因此，<span><span>mysql_row_seek()</span>仅应与<span>mysql_store_result()</span>一起使用，而不是与<span>mysql_use_result()</span></span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>行光标的前一个值。该值可传递给对<span>mysql_row_seek()</span>的后续调用。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-row-tell"></a>25.2.3.58. mysql_row_tell()</h4></div></div></div><a class="indexterm" name="id3020628"></a>
				<p><span>
				MYSQL_ROW_OFFSET mysql_row_tell(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>对于上一个<span><span>mysql_fetch_row()</span>，</span>返回行光标的当前位置。该值可用作<span>mysql_row_seek()</span>的参量。</p>
				<p>仅应在<span>mysql_store_result()</span>之后，而不是<span><span>mysql_use_result()</span>之后使用<span>mysql_row_tell()</span>。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>行光标的当前偏移量。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-select-db"></a>25.2.3.59. mysql_select_db()</h4></div></div></div><a class="indexterm" name="id3020723"></a>
				<p><span>int 
				mysql_select_db(MYSQL *mysql, const char *db)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>使由<span>db</span>指定的数据库成为由<span><span>mysql</span>指定的连接上的</span>默认数据库（当前数据库）。在后续查询中，该数据库将是未包含明确数据库区分符的表引用的默认数据库。</p>
				<p><span>除非已连接的用户具有使用数据库的权限，否则<span>mysql_select_db()</span>将失败。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>表示成功，非<span>0</span>值表示出现错误。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-set-character-set"></a>25.2.3.60. mysql_set_character_set()</h4></div></div></div><a class="indexterm" name="id3020871"></a>
				<p><span>int 
				mysql_set_character_set(MYSQL *mysql, char *csname)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>该函数用于为当前连接设置默认的字符集。字符串<span>csname</span>指定了<span>1</span>个有效的字符集名称。连接校对成为字符集的默认校对。该函数的工作方式与<span><span>SET 
				NAMES</span>语句类似，</span>但它还能设置<span>mysql-&gt;charset</span>的值，从而影响了由<span><span>mysql_real_escape_string()</span>设置的字符集。</span></p>
				<p>该函数是在<span>MySQL 5.0.7</span>中增加的。</p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>表示成功，非<span>0</span>值表示出现错误。<span>
				</span></p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>MYSQL mysql;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql_init(&amp;mysql);</span></pre>
				<pre><span>if (!mysql_real_connect(&amp;mysql,&quot;host&quot;,&quot;user&quot;,&quot;passwd&quot;,&quot;database&quot;,0,NULL,0))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Failed to connect to database: Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (!mysql_set_charset_name(&amp;mysql, &quot;utf8&quot;)) </span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;New client character set: %s\n&quot;, mysql_character_set_name(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-set-server-option"></a>25.2.3.61. mysql_set_server_option()</h4></div></div></div><a class="indexterm" name="id3020976"></a>
				<p><span>int 
				mysql_set_server_option(MYSQL *mysql, enum enum_mysql_set_option 
				option)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>允许或禁止连接的选项。<span>选项可以取下述值之一：</span></p>
				<table border="1" cellpadding="0" id="table10">
					<tr>
						<td>
						<p><span>
						MYSQL_OPTION_MULTI_STATEMENTS_ON</span></td>
						<td>
						<p>允许多语句支持。</td>
					</tr>
					<tr>
						<td>
						<p><span>
						MYSQL_OPTION_MULTI_STATEMENTS_OFF</span></td>
						<td>
						<p>禁止多语句支持。</td>
					</tr>
				</table>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>表示成功，非<span>0</span>值表示出现错误。<span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_UNKNOWN_COM_ERROR</span><span> </span></p>
				<p>服务器不支持<span><span>mysql_set_server_option()</span>（当服务器版本低于</span><span>4.1.1</span>时），或服务器不支持试图设置的选项。</p>
				<div class="itemizedlist">&nbsp;</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-shutdown"></a>25.2.3.62. mysql_shutdown()</h4></div></div></div><a class="indexterm" name="id3021157"></a>
			<p><span>int 
			mysql_shutdown(MYSQL *mysql, enum enum_shutdown_level shutdown_level)</span><span>
			</span></p>
			<p><strong><span>描述</span></strong></p>
			<p>请求数据库服务器关闭。已连接的用户必须具有<span>SHUTDOWN</span>权限。<span>MySQL 
			5.1</span>服务器仅支持<span>1</span>种关闭类型，<span>shutdown_level</span>必须<span>等效于SHUTDOWN_DEFAULT</span>。设计规划了额外的关闭级别，以便能够选择所需的级别。对于用旧版本<span><span>libmysqlclient</span>头文件编译并调用<span>mysql_shutdown()</span>的动态链接可执行程序，需要与旧版的<span>libmysqlclient</span>动态库一起使用。</span></p>
			<p>在<a href="database-administration.html#server-shutdown" title="5.5. The MySQL Server Shutdown Process">5.5节，“MySQL服务器关机进程”</a>中，介绍了关机进程。</p>
			<p><strong><span>返回值</span></strong></p>
			<p><span>0</span>表示成功，非<span>0</span>值表示出现错误。<span>
			</span></p>
			<p><strong><span>错误</span></strong></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_COMMANDS_OUT_OF_SYNC</span><span> </span></p>
			<p>以不恰当的顺序执行了命令。<span> </span>
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_SERVER_GONE_ERROR</span><span> </span></p>
			<p><span>MySQL</span>服务器不可用。<span>
			</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_SERVER_LOST</span><span> </span></p>
			<p>在查询过程中，与服务器的连接丢失。<span>
			</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_UNKNOWN_ERROR</span><span> </span></p>
			<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-sqlstate"></a>25.2.3.63. mysql_sqlstate()</h4></div></div></div><a class="indexterm" name="id3021331"></a>
				<p><span>const char *mysql_sqlstate(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回由<span>Null</span>终结的字符串，该字符串包含关于上次错误的<span>SQLSTATE</span>错误代码。错误代码包含<span>5</span>个字符。<span><span>&#39;00000&#39;</span>表示</span>无错误。其值由<span>ANSI 
				SQL</span>和<span>ODBC</span>指定。关于可能取值的列表，请参见<a href="error-handling.html">附录B：</a><a href="error-handling.html" title="Appendix B. Error Codes and Messages"><i>错误代码和消息</i></a>。</p>
				<p>注意，并非所有的<span>MySQL</span>错误均会被映射到<span>SQLSTATE</span>错误代码。值<span>&#39;HY000&#39;</span>（一般错误）用于未映射的错误。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>包含<span>SQLSTATE</span>错误码的、由<span>Null</span>终结的字符串。</p>
				<p><strong><span>另请参见：</span></strong></p>
				<p>请参见<a href="apis.html#mysql-errno" title="25.2.3.14. mysql_errno()">25.2.3.14节，“mysql_errno()”</a>。请参见<a href="apis.html#mysql-error" title="25.2.3.15. mysql_error()">25.2.3.15节，“mysql_error()”</a>。请参见<a href="apis.html#mysql-stmt-sqlstate" title="25.2.7.26. mysql_stmt_sqlstate()">25.2.7.26节，“mysql_stmt_sqlstate()”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-ssl-set"></a>25.2.3.64. mysql_ssl_set()</h4></div></div></div><a class="indexterm" name="id3021440"></a>
				<p><span>int 
				mysql_ssl_set(MYSQL *mysql, const char *key, const char *cert, 
				const char *ca, const char *capath, const char *cipher)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p><span>使用<span>mysql_ssl_set()</span>，可采用<span>SSL</span>建立安全连接。必须在<span>mysql_real_connect()</span>之前调用它。</span></p>
				<p><span>除非在客户端库中允许了</span><span>OpenSSL</span>支持，否则<span>mysql_ssl_set()</span>不作任何事。</p>
				<p><span><span>Mysql</span>是从<span>mysql_init()</span>返回的连接处理程序。</span>其他参数的指定如下：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>key</span>是<span>key</span>文件的路径名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>cert</span>是证书文件的路径名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>ca</span>是证书授权文件的路径名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span><span>
				capath</span>是指向目录的路径名，该目录中</span>包含以<span>pem</span>格式给出的受信任<span>SSL 
				CA</span>证书。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				cipher</span>是允许密码的列表，用于<span>SSL</span>加密。</p>
				<p>对于任何未使用的<span>SSL</span>参数，可为其给定<span>NULL</span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>该函数总返回<span>0</span>。如果<span>SSL</span>设置不正确，当你尝试连接时，<span><span>mysql_real_connect()</span>将返回错误。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stat"></a>25.2.3.65. mysql_stat()</h4></div></div></div><a class="indexterm" name="id3021604"></a>
				<p><span>char *mysql_stat(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回包含特定信息的字符串，该信息与<strong><span>mysqladmin 
				status</span></strong>命令提供的信息类似。包括以秒为单位的正常运行时间，以及运行线程的数目，问题数，再加载次数，以及打开的表数目。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>描述服务器状态的字符集。<span>如果出现错误，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-store-result"></a>25.2.3.66. mysql_store_result()</h4></div></div></div><a class="indexterm" name="id3021742"></a>
				<p><span>MYSQL_RES *mysql_store_result(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>对于成功检索了数据的每个查询（<span>SELECT</span>、<span>SHOW</span>、<span>DESCRIBE</span>、<span>EXPLAIN</span>、<span><span>CHECK 
				TABLE</span>等</span>），必须调用<span>mysql_store_result()</span>或<span>mysql_use_result()</span><span>
				</span>。</p>
				<p>对于其他查询，不需要调用<span>mysql_store_result()</span>或<span>mysql_use_result()</span>，但是如果在任何情况下均调用了<span><span>mysql_store_result()</span>，</span>它也不会导致任何伤害或性能降低。通过检查<span><span>mysql_store_result()</span>是否返回<span>0</span>，可检测查询是否没有结果集</span>（以后会更多）。</p>
				<p>如果希望了解查询是否应返回结果集，可使用<span>mysql_field_count()</span>进行检查。请参见<a href="apis.html#mysql-field-count" title="25.2.3.22. mysql_field_count()">25.2.3.22节，“mysql_field_count()”</a>。</p>
				<p><span><span>
				mysql_store_result()</span>将查询的全部结果读取到客户端，</span>分配<span>1</span>个<span><span>MYSQL_RES</span>结构，</span>并将结果置于该结构中。</p>
				<p><span>如果查询未返回结果集，<span>mysql_store_result()</span></span>将返回<span>Null</span>指针（例如，如果查询是<span><span>INSERT</span>语句</span>）。</p>
				<p><span>如果读取结果集失败，<span>mysql_store_result()</span></span>还会返回<span>Null</span>指针。通过检查<span><span>mysql_error()</span>是否返回非空字符串，<span>mysql_errno()</span>是否返回非<span>0</span>值，或<span>mysql_field_count()</span>是否返回<span>0</span>，可以检查是否出现了错误。</span></p>
				<p>如果未返回行，将返回空的结果集。（空结果集设置不同于作为返回值的空指针）。</p>
				<p>一旦调用了<span><span>mysql_store_result()</span>并获得了不是<span>Null</span>指针的结果，</span>可调用<span><span>mysql_num_rows()</span>来找出结果集中的行数。</span></p>
				<p>可以调用<span>mysql_fetch_row()</span>来获取结果集中的行，或调用<span>mysql_row_seek()</span>和<span><span>mysql_row_tell()</span>来获取或设置结果集中的当前行位置。</span></p>
				<p>一旦完成了对结果集的操作，必须调用<span>mysql_free_result()</span>。</p>
				<p>请参见<a href="apis.html#null-mysql-store-result" title="25.2.13.1. Why mysql_store_result() Sometimes Returns NULL After mysql_query() Returns Success">25.2.13.1节，“为什么在mysql_query()返回成功后，mysql_store_result()有时会返回NULL<code class="literal"></code>”</a><span>.
				</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>具有多个结果的<span>MYSQL_RES</span>结果集合。<span>如果出现错误，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p><span>如果成功，<span>mysql_store_result()</span>将</span>复位<span>mysql_error()</span>和<span>mysql_errno()</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。<span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-id"></a>25.2.3.67. mysql_thread_id()</h4></div></div></div><a class="indexterm" name="id3022075"></a>
				<p><span>unsigned long 
				mysql_thread_id(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回当前连接的线程<span>ID</span>。该值可用作<span><span>mysql_kill()</span>的参量以杀死线程。</span></p>
				<p>如果连接丢失，并使用<span><span>mysql_ping()</span>进行了再连接，</span>线程<span>ID</span>将改变。这意味着你不应获取线程<span>ID</span>并保存它供以后使用。应在需要时获取它。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>当前连接的线程<span>ID</span>。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-use-result"></a>25.2.3.68. mysql_use_result()</h4></div></div></div><a class="indexterm" name="id3022161"></a>
				<p><span>MYSQL_RES *mysql_use_result(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>对于成功检索数据的每个查询（<span>SELECT</span>、<span><span>SHOW</span>、<span>DESCRIBE</span>、<span>EXPLAIN</span></span>），必须调用<span>mysql_store_result()</span>或<span><span>mysql_use_result()</span>。</span></p>
				<p><span>
				mysql_use_result()</span>将初始化结果集检索，但并不像<span><span>mysql_store_result()</span>那样将结果集实际读取到客户端。</span>它必须通过对<span><span>mysql_fetch_row()</span>的调用，对每一行分别进行检索。</span>这将直接从服务器读取结果，而不会将其保存在临时表或本地缓冲区内，与<span><span>mysql_store_result()</span>相比，速度更快而且使用的内存也更少。客户端仅为当前行和通信缓冲区分配内存，</span>分配的内存可增加到<span>max_allowed_packet</span>字节。</p>
				<p>另一方面，如果你正在客户端一侧为各行进行大量的处理操作，或者将输出发送到了用户可能会键入“<span>^S</span>”（停止滚动）的屏幕，就不应使用<span>mysql_use_result()</span>。这会绑定服务器，并阻止其他线程更新任何表（数据从这类表获得）。</p>
				<p>使用<span>mysql_use_result()</span>时，必须执行<span>mysql_fetch_row()</span>，直至返回<span><span>NULL</span>值，否则，未获取的行将作为下一个检索的一部分返回。</span><span>C 
				API</span>给出命令不同步错误，如果忘记了执行该操作，将不能<span>运行该命令。</span></p>
				<p>不应与从<span><span>mysql_use_result()</span>返回的结果一起使用<span>mysql_data_seek()</span></span>、<span>mysql_row_seek()</span>、<span>mysql_row_tell()</span>、<span>mysql_num_rows()</span>或<span><span>mysql_affected_rows()</span>，也不应发出其他查询，直至<span>mysql_use_result()</span></span>完成为止。（但是，提取了所有行后，<span><span>mysql_num_rows()</span>将准确返回提取的行数）。</span></p>
				<p>一旦完成了对结果集的操作，必须调用<span>mysql_free_result()</span>。</p>
				<p>使用<span><span>libmysqld</span>嵌入式服务器时，由于在调用<span>mysql_free_result()</span>之前，内存使用将随着每个检索的行增加，内存</span>效益将基本丧失。</p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>MYSQL_RES</span>结果结构。<span>如果出现错误，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>错误</span></strong></p>
				<p><span>如果成功，<span>mysql_use_result()</span></span>将复位<span>mysql_error()</span>和<span><span>mysql_errno()</span>。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。<span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-warning-count"></a>25.2.3.69. mysql_warning_count()</h4></div></div></div><a class="indexterm" name="id3022482"></a></div></div><div class="section"><div class="titlepage"><div><div>
		<span>unsigned int 
		mysql_warning_count(MYSQL *mysql)</span><span> </span>
		<p><strong><span>错误</span></strong></p>
		<p>返回执行前一个<span>SQL</span>语句期间生成的告警数目。</p>
		<p><strong><span>返回值</span></strong></p>
		<p>告警计数。</p>
		<p><strong><span>错误</span></strong></p>
		<p>无。</p>
		<h3 class="title"><a name="c-api-prepared-statements"></a>
			25.2.4.&nbsp;C API预处理语句</h3></div></div></div>
		<p><span>MySQL</span>客户端／服务器协议提供了预处理语句。该功能采用了由<span><span>mysql_stmt_init()</span>初始化函数返回的<span>MYSQL_STMT</span>语句处理程序数据结构。对于多次执行的语句，预处理执行是一种有效的方式。</span>首先对语句进行解析，为执行作好准备。接下来，在以后使用初始化函数返回的语句句柄执行一次或多次。</p>
		<p><span>对于多次执行的语句，预处理执行比直接执行快，主要原因在于</span>，仅对查询执行一次解析操作。在直接执行的情况下，每次执行语句时，均将进行查询。此外，由于每次执行预处理语句时仅需发送参数的数据，从而减少了网络通信量。</p>
		<p>预处理语句的另一个优点是，它采用了二进制协议，从而使得客户端和服务器之间的数据传输更有效率。</p>
		<p>下述语句可用作预处理语句：<span>CREATE 
		TABLE</span>、<span>DELETE</span>、<span>DO</span>、<span>INSERT</span>、<span>REPLACE</span>、<span>SELECT</span>、<span>SET</span>、<span>UPDATE</span>、以及大多数<span><span>SHOW</span>语句。</span>在<span>MySQL 
		5.1</span>中，不支持其他语句。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-datatypes"></a>
			25.2.5.&nbsp;C API预处理语句的数据类型</h3></div></div></div>
			<p>预处理语句主要使用<span>MYSQL_STMT</span>和<span><span>MYSQL_BIND</span>数据结构。</span>第<span>3</span>种结构<span><span>MYSQL_TIME</span>用于传输暂时性数据。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			MYSQL_STMT</span><span> </span>

            <a class="indexterm" name="id3032628"></a>
          	</p>
			<p>该结构表示预处理语句。通过调用<span>mysql_stmt_init()</span>创建语句，返回语句句柄，即指向<span><span>MYSQL_STMT</span>的指针。该句柄用户所有后续的与语句有关的函数，直至使用<span>mysql_stmt_close()</span></span>关闭了它为止。</p>
			<p><span>
			<span>MYSQL_STMT</span>结构没有供应用程序使用的参数。此外，不应尝试复制<span>MYSQL_STMT</span></span>结构。不保证这类复制物会有用。</p>
			<p>多个语句句柄能够与单个连接关联起来。对句柄数目的限制取决于系统资源。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			MYSQL_BIND</span><a class="indexterm" name="id3032629"></a><span>
			</span></p>
			<p>
			该结构用于语句输入（发送给服务器的数据值）和输出（从服务器返回的结果值）。对于输入，它与<span><span>mysql_stmt_bind_param()</span>一起使用，用于将参数数据值绑定到缓冲区上，以供<span>mysql_stmt_execute()</span>使用。对于输出，它与<span>mysql_stmt_bind_result()</span>一起使用，用于绑定结果缓冲区，</span>以便用于<span>with
			<span>mysql_stmt_fetch()</span></span><span>以获取行。</span></p>
			<p>
			<span>MYSQL_BIND</span>结构包含下述供应用程序使用的成员。每个成员用于输入和输出，但在某些时候，也能用于不同的目的，具体情况取决于数据传输的方向。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>enum 
			enum_field_types buffer_type</span><span> </span>
			</p>
			<p>缓冲的类型。在本节后面列出了允许的<span><span>buffer_type</span>值。对于</span>输入，<span><span>buffer_type</span>指明了与语句参数捆绑的值类型。对于输出，</span>它指明了你希望从结果缓冲收到的值类型。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>void *buffer</span><span>
			</span></p>
			<p>
			对于输入，这是指向存储语句参数数据值的缓冲的指针。对于输出，它是指向返回结果集列值的缓冲的指针。对于数值列类型，缓冲应指向恰当的<span>C</span>类型变量（如果将该变量与具有<span><span>UNSIGNED</span>属性的列关联起来，</span>变量<span>unsigned</span><span> 
			C</span>类型。通过使用<span><span>is_unsigned</span>成员，指明变量是</span><span>signed</span>或<span>unsigned</span>类型，详情请参见本节后面的介绍）。对于日期和时间列类型，缓冲应指向<span><span>MYSQL_TIME</span>结构。</span>对于字符和二进制字符串列类型，缓冲应指向字符缓冲区。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned long 
			buffer_length</span><span> </span></p>
			<p><span>
			<span>*buffer</span>的实际大小，单位为字节。</span>它指明了可保存在缓冲区内的最大数据。对于字符和二进制<span>C</span>数据，<span>buffer_length</span>值指定了与<span><span>mysql_stmt_bind_param()</span>一起使用时的<span>*buffer</span></span>长度，或与<span><span>mysql_stmt_bind_result()</span>一起使用时能够提取到缓冲区内的最大数据。</span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned long 
			*length</span><span> </span></p>
			<p>指向<span><span>unsigned 
			long</span>变量的指针，该变量指明了存储在<span>*buffer</span>中数据的实际字节数。<span>“length”</span>用于字符或二进制<span>C</span>数据。对于输入参数数据绑定，<span>“length”</span>指向<span>unsigned 
			long</span>变量，该变量指明了存储在<span>*buffer</span>中参数值的长度，供<span>mysql_stmt_execute()</span>使用。对于</span>输出值绑定，<span><span>mysql_stmt_fetch()</span>会将返回的列值保存到<span>“length”</span>指向的</span>变量中。</p>
			<p><span>
			对于数值和临时数据类型，<span>“length”</span>将被忽略，原因在于，</span>数据值的长度是由<span>buffer_type</span>值决定的。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>my_bool *is_null</span><span>
			</span></p>
			<p>该成员指向<span><span>my_bool</span>变量，如果值为<span>NULL</span>，该变量为<span>“</span>真<span>”</span>，如果值为非<span>Null</span>，</span>该变量为“假”。对于输入，将<span>*is_null</span>设置为“真”，指明以语句参数的形式传递<span>NULL</span>值。对于输出，如果从语句返回的结果集列值为<span>NULL</span>，当获取了行后，该值将被设为“真”。</p>
			<p><span>
			<span>“is_null”</span>是指向布尔类型的指针，而不是布尔标量，以便能以下述方式使用它：</span></p>
			<p >
			<span  >§<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果数据值总是<span>NULL</span>，使用<span><span>MYSQL_TYPE_NULL</span>绑定列。</span></p>
			<p >
			<span >
			§<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果数据值总是<span><span>NOT 
			NULL</span>，设置<span>is_null = (my_bool*) 0</span></span>。</p>
			<p >
			<span  >§<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在所有其他情况下，应将<span><span>is_null</span>设置为<span>my_bool</span></span>变量的地址，并在各次执行之间恰当地更改变量的值，以指明数据值是<span>NULL</span>或<span>NOT 
			NULL</span>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>my_bool 
			is_unsigned</span><span> </span></p>
			<p>该成员用于整数类型。（对应于<span>MYSQL_TYPE_TINY</span>、<span>MYSQL_TYPE_SHORT</span>、<span>MYSQL_TYPE_LONG</span>、以及<span><span>MYSQL_TYPE_LONGLONG</span>类型的代码）。对于无符号类型，应将</span>“<span><span>is_unsigned”</span>设置为<span>“</span>真<span>”</span>，对于带符号类型，应将其设置为<span>“</span>假<span>”</span>。</span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>my_bool error</span><span>
			</span></p>
			<p>对于输出，该成员用于通报数据截短错误。必须通过调用带有<span><span>MYSQL_REPORT_DATA_TRUNCATION</span>选项的<span>mysql_options()</span>，启用</span>截短通报功能。允许该功能后，<span>mysql_stmt_fetch()</span>返回<span><span>MYSQL_DATA_TRUNCATED</span>，而且对于出现截短情况的参数，在<span>MYSQL_BIND</span>结构中，错误标志为<span>“</span>真<span>”</span>。截短指明丢失了符号或有效位数，或字符串过长以至于无法容纳在<span>1</span>列中。</span></p>
			<p>要想使用<span>MYSQL_BIND</span>结构，应将其内容置为<span>0</span>以便初始化它，然后对其进行设置，恰当地描述它。例如，要想声明并初始化<span>三个MYSQL_BIND</span><span>结构的数组，可使用下述代码：</span></p>
			<pre><span>MYSQL_BIND&nbsp;&nbsp;&nbsp; bind[3];</span></pre>
			<pre><span>memset(bind, 0, sizeof(bind));</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			MYSQL_TIME</span><a class="indexterm" name="id3032630"></a><span>
			</span></p>
			<p>该结构用于将<span>DATE</span>、<span>TIME</span>、<span>DATETIME</span>和<span>TIMESTAMP</span>数据直接发送到服务器，或从服务器直接接收这类数据。将<span><span>MYSQL_BIND</span>结构的<span>buffer_type</span>成员设置为临时值之一，并将<span>buffer</span>成员设置为指向<span>MYSQL_TIME</span></span>结构，即可实现该点。</p>
			<p><span>
			<span>MYSQL_TIME</span>结构包含下述成员：</span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			year</span><span> </span></p>
			<p>年份</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			month</span><span> </span></p>
			<p>月份</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			day</span><span> </span></p>
			<p>天</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			hour</span><span> </span></p>
			<p>小时</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			minute</span><span> </span></p>
			<p>分钟</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			second</span><span> </span></p>
			<p>秒</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>my_bool neg</span><span>
			</span></p>
			<p>布尔标志，用于指明时间是否为负数。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned long 
			second_part</span><span> </span></p>
			<p>秒的分数部分。该成员目前不使用。</p>
			<p>仅使用施加在给定临时类型值上的<span><span>MYSQL_TIME</span>结构的部分</span>：用于<span>DATE</span>、<span>DATETIME</span>和<span><span>TIMESTAMP</span>的</span>年、月、日部分。用于<span>TIME</span>、<span>DATETIME</span>和<span><span>TIMESTAMP</span>值的小时、分钟、秒部分</span>。请参见<a href="apis.html#c-api-date-handling" title="25.2.10. C API Handling of Date and Time Values">25.2.10节，“日期和时间值的C API处理”</a>。</p>
			<p>在下面的表格中，给出了可在<span><span>MYSQL_BIND</span>结构的<span>buffer_type</span>成员中指定的允许值。在该表中，还给出了与每个<span>buffer_type</span>值最接近的对应</span><span>SQL</span>类型，对于数值和临时类型，给出了对应的<span>C</span>类型。</p>
			<table border="1" cellpadding="0" id="table11">
				<tr>
					<td>
					<p>
					<span>buffer_type</span><strong><span>值</span></strong></td>
					<td>
					<p><strong>
					<span>SQL</span><span>类型</span></strong></td>
					<td>
					<p><strong>
					<span>C</span><span>类型</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TINY</span></td>
					<td>
					<p>
					<span>TINYINT</span></td>
					<td>
					<p>
					<span>char</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_SHORT</span></td>
					<td>
					<p>
					<span>SMALLINT</span></td>
					<td>
					<p>
					<span>short int</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_LONG</span></td>
					<td>
					<p>
					<span>INT</span></td>
					<td>
					<p>
					<span>int</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_LONGLONG</span></td>
					<td>
					<p>
					<span>BIGINT</span></td>
					<td>
					<p>
					<span>long long int</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_FLOAT</span></td>
					<td>
					<p>
					<span>FLOAT</span></td>
					<td>
					<p>
					<span>float</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DOUBLE</span></td>
					<td>
					<p>
					<span>DOUBLE</span></td>
					<td>
					<p>
					<span>double</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TIME</span></td>
					<td>
					<p>
					<span>TIME</span></td>
					<td>
					<p>
					<span>MYSQL_TIME</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DATE</span></td>
					<td>
					<p>
					<span>DATE</span></td>
					<td>
					<p>
					<span>MYSQL_TIME</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DATETIME</span></td>
					<td>
					<p>
					<span>DATETIME</span></td>
					<td>
					<p>
					<span>MYSQL_TIME</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TIMESTAMP</span></td>
					<td>
					<p>
					<span>TIMESTAMP</span></td>
					<td>
					<p>
					<span>MYSQL_TIME</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_STRING</span></td>
					<td>
					<p>
					<span>CHAR</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_VAR_STRING</span></td>
					<td>
					<p>
					<span>VARCHAR</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TINY_BLOB</span></td>
					<td>
					<p>
					<span>TINYBLOB/TINYTEXT</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_BLOB</span></td>
					<td>
					<p>
					<span>BLOB/TEXT</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_MEDIUM_BLOB</span></td>
					<td>
					<p>
					<span>MEDIUMBLOB/MEDIUMTEXT</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_LONG_BLOB</span></td>
					<td>
					<p>
					<span>LONGBLOB/LONGTEXT</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
			</table>
			<p>隐式类型转换可沿两个方向执行。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-function-overview"></a>
			25.2.6.&nbsp;C API预处理语句函数概述</h3></div></div></div><a class="indexterm" name="id3023820"></a><a class="indexterm" name="id3023830"></a>
			<p>在此归纳了预处理语句处理功能可使用的函数，并在后面的章节中详细介绍了它。请参见<a href="apis.html#c-api-prepared-statement-functions" title="25.2.7. C API Prepared Statement Function Descriptions">25.2.7节，“C API预处理语句函数描述”</a>。</p>
			<table border="1" cellpadding="0" id="table12">
				<tr>
					<td>
					<p><strong><span>
					函数</span></strong></td>
					<td>
					<p><strong><span>
					描述</span></strong></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_affected_rows()</span></strong></td>
					<td>
					<p>返回由预处理语句<span>UPDATE</span>、<span>DELETE</span>或<span>INSERT</span>变更、删除或插入的行数目。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_attr_get()</span></strong></td>
					<td>
					<p>获取预处理语句属性的值。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_attr_set()</span></strong></td>
					<td>
					<p>设置预处理语句的属性。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_bind_param()</span></strong></td>
					<td>
					<p>将应用程序数据缓冲与预处理<span>SQL</span>语句中的参数标记符关联起来。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_bind_result()</span></strong></td>
					<td>
					<p>将应用程序数据缓冲与结果集中的列关联起来。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_close()</span></strong></td>
					<td>
					<p>释放预处理语句使用的内存。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_data_seek()</span></strong></td>
					<td>
					<p>寻找语句结果集中的任意行编号。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_errno()</span></strong></td>
					<td>
					<p>返回上次语句执行的错误编号。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_error()</span></strong></td>
					<td>
					<p>返回上次语句执行的错误消息。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_execute()</span></strong></td>
					<td>
					<p>执行预处理语句。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_fetch()</span></strong></td>
					<td>
					<p>从结果集获取数据的下一行，并返回所有绑定列的数据。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_fetch_column()</span></strong></td>
					<td>
					<p>获取结果集当前行中某列的数据。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_field_count()</span></strong></td>
					<td>
					<p>对于最近的语句，返回结果行的数目。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_free_result()</span></strong></td>
					<td>
					<p>释放分配给语句句柄的资源。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_init()</span></strong></td>
					<td>
					<p><span>为<span>MYSQL_STMT</span>结构分配内存并初始化它</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_insert_id()</span></strong></td>
					<td>
					<p>对于预处理语句的<span><span>AUTO_INCREMENT</span>列，</span>返回生成的<span>ID</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_num_rows()</span></strong></td>
					<td>
					<p>从语句缓冲结果集返回总行数。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_param_count()</span></strong></td>
					<td>
					<p>返回预处理<span>SQL</span>语句中的参数数目。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_param_metadata()</span></strong></td>
					<td>
					<p>返回结果集的参数元数据。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_prepare()</span></strong></td>
					<td>
					<p>为执行操作准备<span>SQL</span>字符串。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_reset()</span></strong></td>
					<td>
					<p>复位服务器中的语句缓冲区。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_result_metadata()</span></strong></td>
					<td>
					<p>以结果集形式返回预处理语句元数据。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_row_seek()</span></strong></td>
					<td>
					<p>使用从<span><span>mysql_stmt_row_tell()</span>返回的值，查找语句结果集中的行偏移。</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_row_tell()</span></strong></td>
					<td>
					<p>返回语句行光标位置。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_send_long_data()</span></strong></td>
					<td>
					<p>将程序块中的长数据发送到服务器。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_sqlstate()</span></strong></td>
					<td>
					<p>返回关于上次语句执行的<span>SQLSTATE</span>错误代码。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_store_result()</span></strong></td>
					<td>
					<p>将完整的结果集检索到客户端。</td>
				</tr>
			</table>
			<p>调用<span>mysql_stmt_init()</span>以创建语句句柄，然后调用<span>mysql_stmt_prepare</span>准备语句，调用<span>mysql_stmt_bind_param()</span>提供参数数据，并调用<span><span>mysql_stmt_execute()</span>执行语句。通过更改<span>mysql_stmt_bind_param()</span>提供的相应缓冲区中的参数值，可重复执行<span>mysql_stmt_execute()</span>。</span></p>
			<p>如果语句是<span><span>SELECT</span>或任何其他能生成结果集的语句，<span>mysql_stmt_prepare()</span></span>也会通过<span><span>mysql_stmt_result_metadata()</span>以<span>MYSQL_RES</span>结果集的形式</span>返回结果集元数据信息。</p>
			<p>你可以使用<span><span>mysql_stmt_bind_result()</span>提供结果缓冲，以便<span>mysql_stmt_fetch()</span>能自动将数据返回给这些缓冲。</span>这是一种按行获取方式。</p>
			<p>此外，你也能使用<span><span>mysql_stmt_send_long_data()</span>将程序块中的文本或二进制数据发送到服务器。</span>请参见<a href="apis.html#mysql-stmt-send-long-data" title="25.2.7.25. mysql_stmt_send_long_data()">25.2.7.25节，“mysql_stmt_send_long_data()”</a>。</p>
			<p>完成语句执行后，必须使用<span><span>mysql_stmt_close()</span>关闭语句句柄，以便与之相关的所有资源均能被释放。</span></p>
			<p>如果通过调用<span><span>mysql_stmt_result_metadata()</span>获得了<span>SELECT</span>语句的结果集</span>元数据，也应<span>使用mysql_free_result()</span>释放元数据。</p>
			<p><strong><span>执行步骤</span></strong></p>
			<p>要想准备和执行语句，应用程序必须采取下述步骤：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>用<span><span>msyql_stmt_init()</span>创建预处理语句句柄。要想在服务器上准备预处理语句，可调用<span>mysql_stmt_prepare()</span>，并为其传递包含<span>SQL</span>语句的字符串。</span></p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>如果语句生成了结果集，调用<span>mysql_stmt_result_metadata()</span>以获得结果集元数据。虽然与包含查询返回列的结果集不同，该元数据本身也采用了结果集的形式。元数据结果集指明了结果中包含多少列，并包含每一列的信息。</p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>使用<span><span>mysql_stmt_bind_param()</span>设置任何参数的值。必须设置所有参数。否则，语句执行将返回错误，或生成无法预料的结果。</span></p>
			<p>
			<span>4.<span>&nbsp;&nbsp;&nbsp;
			</span></span>调用<span><span>mysql_stmt_execute()</span>执行语句。</span></p>
			<p>
			<span>5.<span>&nbsp;&nbsp;&nbsp;
			</span></span>如果语句生成了结果集，捆绑数据缓冲，通过调用<span><span>mysql_stmt_bind_result()</span>，检索行值。</span></p>
			<p>
			<span>6.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通过重复调用<span><span>mysql_stmt_fetch()</span>，按行将数据提取到缓冲区</span>，直至未发现更多行为止。</p>
			<p>
			<span>7.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通过更改参数值并再次执行语句，重复步骤<span>3</span>到步骤<span>6</span>。</p>
			<p>调用<span><span>mysql_stmt_prepare()</span>时，</span><span>MySQL</span>客户端／服务器协议将执行下述动作：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>服务器解析语句，并通过赋值语句<span>ID</span>将<span>OK</span>状态发回客户端。此外，如果它是面向结果集的语句，还将发送总的参数数目，列计数和元数据。在此调用过程中，服务器将检查语句的所有语法和语义。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>客户端采用该语句<span>ID</span>用于进一步操作，以便服务器能从其语句池中识别语句。</p>
			<p>调用<span><span>mysql_stmt_execute()</span>时，</span><span>MySQL</span>客户端／服务器协议将执行下述动作：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>客户端使用语句句柄，并将参数数据发送到服务器。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>服务器使用由客户端提供的<span>ID</span>来识别语句，用新提供的数据替换参数标记符，并执行语句。如果语句生成了结果集，服务器将数据发回客户端。否则，服务器会将发送<span>OK</span>状态，以及总的变更、删除和插入行数。</p>
			<p>调用<span><span>mysql_stmt_fetch()</span>时，</span><span>MySQL</span>客户端／服务器协议将执行下述动作：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			客户端按行从信息包读取数据，并通过执行必要的转换操作将其放入应用程序数据缓冲中。如果应用程序的缓冲类型与服务器返回的字段类型相同，转换十分简明。</p>
			<p>如果出现了错误，可分别使用<span>mysql_stmt_errno()</span>、<span>mysql_stmt_error()</span>和<span>mysql_stmt_sqlstate()</span>获取语句错误代码、错误消息和<span>SQLSTATE</span>值。</p>
			<p><strong><span>预处理语句日志功能</span></strong></p>
			<p>对于与<span>mysql_stmt_prepare()</span>和<span>mysql_stmt_execute()</span><span> 
			C API</span>函数一起执行的预处理语句，服务器会将“准备”和“执行”行写入一般查询日志，以便你能了解语句是在何时准备和执行的。</p>
			<p>假定按下述方式准备和执行了语句：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>调用<span><span>mysql_stmt_prepare()</span>以准备</span>语句字符串<span>&quot;SELECT 
			?&quot;</span>。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>调用<span><span>mysql_stmt_bind_param()</span>将值<span>“3”</span>绑定到预处理语句中的参数。</span></p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>调用<span><span>mysql_stmt_execute()</span>，执行预处理语句。</span></p>
			<p>上述调用的结果是，服务器将下述行写入一般查询日志：</p>
			<pre><span>Prepare&nbsp; [1] SELECT ?</span></pre>
			<pre><span>Execute&nbsp; [1] SELECT 3</span></pre>
			<p>日志中的每个“准备”和“执行”行均具有<span><span>[<i>n</i>]</span>语句<span>ID</span>标识，这样，你就能跟踪已记录的预处理语句。<i><span>N</span></i></span>是正整数。对于客户端，如果同时有多个活动的预处理语句，<span><i><span>n</span></i></span>可能会大于<span>1</span>。替换了“<span>?</span>”参数的数据值后，每个“执行”行将显示一条预处理语句。</p>
			<p>版本说明：在<span>MySQL 4.1.10</span>之前，显示的“准备”行无<span><span>[<i>n</i>]</span>标识。在</span><span>MySQL 
			4.1.10</span>之前，不显示“执行”行。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-functions"></a>
			25.2.7.&nbsp;C API预处理语句函数描述</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#mysql-stmt-affected-rows">25.2.7.1. mysql_stmt_affected_rows()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-attr-get">25.2.7.2. mysql_stmt_attr_get()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-attr-set">25.2.7.3. mysql_stmt_attr_set()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-bind-param">25.2.7.4. mysql_stmt_bind_param()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-bind-result">25.2.7.5. mysql_stmt_bind_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-close">25.2.7.6. mysql_stmt_close()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-data-seek">25.2.7.7. mysql_stmt_data_seek()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-errno">25.2.7.8. mysql_stmt_errno()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-error">25.2.7.9. mysql_stmt_error()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-execute">25.2.7.10. mysql_stmt_execute()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-fetch">25.2.7.11. mysql_stmt_fetch()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-fetch-column">25.2.7.12. mysql_stmt_fetch_column()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-field-count">25.2.7.13. mysql_stmt_field_count()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-free-result">25.2.7.14. mysql_stmt_free_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-init">25.2.7.15. mysql_stmt_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-insert-id">25.2.7.16. mysql_stmt_insert_id()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-num-rows">25.2.7.17. mysql_stmt_num_rows()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-param-count">25.2.7.18. mysql_stmt_param_count()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-param-metadata">25.2.7.19. mysql_stmt_param_metadata()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-prepare">25.2.7.20. mysql_stmt_prepare()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-reset">25.2.7.21. mysql_stmt_reset()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-result-metadata">25.2.7.22. mysql_stmt_result_metadata()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-row-seek">25.2.7.23. mysql_stmt_row_seek()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-row-tell">25.2.7.24. mysql_stmt_row_tell()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-send-long-data">25.2.7.25. mysql_stmt_send_long_data()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-sqlstate">25.2.7.26. mysql_stmt_sqlstate()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-store-result">25.2.7.27. mysql_stmt_store_result()</a></span></dt></dl></div>
			<p>为了准备和执行查询，请使用下述部分详细介绍的函数。</p>
			<p>注意，与<span><span>MYSQL_STMT</span>结构一起使用的所有函数均以前缀<span>mysql_stmt_</span></span>开始。</p>
			<p>要想创建<span><span>MYSQL_STMT</span>句柄，请使用<span>mysql_stmt_init()</span></span>函数。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-affected-rows"></a>25.2.7.1. mysql_stmt_affected_rows()</h4></div></div></div><a class="indexterm" name="id3024852"></a>
				<p><span>my_ulonglong 
				mysql_stmt_affected_rows(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回上次执行语句更改、删除或插入的总行数。对于<span>UPDATE</span>、<span>DELETE</span>或<span>INSERT</span>语句，可在<span><span>mysql_stmt_execute()</span>之后立刻调用它们。</span>对于<span>SELECT</span>语句，<span><span>mysql_stmt_affected_rows()</span>的工作方式类似于<span>mysql_num_rows()</span></span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>大于<span>0</span>的整数指明了受影响或检索的行数。对于<span>UPDATE</span>语句，“<span>0</span>”表明未更新任何记录，在查询中没有与<span><span>WHERE</span>子句匹配的行，或尚未执行任何查询。</span>“<span>-1</span>”表明返回了错误，或对<span>SELECT</span>查询，在调用<span><span>mysql_stmt_store_result()</span>之前调用了<span>mysql_stmt_affected_rows()</span></span>。由于<span>mysql_stmt_affected_rows()</span>返回无符号值，可通过比较返回值和“<span><span>(my_ulonglong)-1”</span>（或等效的<span>“(my_ulonglong)~0”</span>）</span>，检查“<span>-1</span>”。</p>
				<p>关于返回值的额外信息，请参见<a href="apis.html#mysql-affected-rows" title="25.2.3.1. mysql_affected_rows()">25.2.3.1节，“mysql_affected_rows()”</a>。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<p><strong><span>示例：</span></strong></p>
				<p>关于<span><span>mysql_stmt_affected_rows()</span>的用法，</span>请参阅<a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10节，“mysql_stmt_execute()”</a>中给出的示例。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-attr-get"></a>25.2.7.2. mysql_stmt_attr_get()</h4></div></div></div><a class="indexterm" name="id3025030"></a>
				<p><span>int 
				mysql_stmt_attr_get(MYSQL_STMT *stmt, enum enum_stmt_attr_type 
				option, void *arg)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>可用于获得语句属性的当前值。</p>
				<p>“<span><span>option”</span>参量是希望获取的选项，<span>“arg”</span>应指向包含选项值的变量。如果</span>“<span>option</span>”是整数，那么“<span><span>arg”</span>应指向</span>整数的值。</p>
				<p>关于选项和选项类型的清单，请参见<a href="apis.html#mysql-stmt-attr-set" title="25.2.7.3. mysql_stmt_attr_set()">25.2.7.3节，“mysql_stmt_attr_set()”</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>如果<span>OK</span>，返回<span>0</span>。</span>如果选项未知，返回非<span>0</span>值。 
				</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-attr-set"></a>25.2.7.3. mysql_stmt_attr_set()</h4></div></div></div><a class="indexterm" name="id3025135"></a>
				<p><span>int 
				mysql_stmt_attr_set(MYSQL_STMT *stmt, enum enum_stmt_attr_type 
				option, const void *arg)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>可用于影响预处理语句的行为。可多次调用该函数来设置多个选项。</p>
				<p>“<span><span>option”</span>参量是希望设置的选项，</span>“<span><span>arg”</span>参量</span>是选项的值。<span>如果</span>“<span>option</span>”是整数，那么“<span><span>arg”</span>应指向</span>整数的值。</p>
				<p>可能的选项值：</p>
				<table border="1" cellpadding="0" id="table13">
					<tr>
						<td>
						<p><strong>
						<span>选项</span></strong></td>
						<td>
						<p><strong>
						<span>参量类型</span></strong></td>
						<td>
						<p><strong>
						<span>功能</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>STMT_ATTR_UPDATE_MAX_LENGTH</span></td>
						<td>
						<p>
						<span>my_bool *</span></td>
						<td>
						<p>如果设为<span>1</span>：更新<span><span>mysql_stmt_store_result()</span>中的</span>元数据<span>MYSQL_FIELD-&gt;max_length</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>STMT_ATTR_CURSOR_TYPE</span></td>
						<td>
						<p>
						<span>unsigned long *</span></td>
						<td>
						<p>调用<span><span>mysql_stmt_execute()</span>时，语句将打开的光标类型。<span>*arg</span>可以是<span>CURSOR_TYPE_NO_CURSOR</span>（默认值）或<span>CURSOR_TYPE_READ_ONLY</span></span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>STMT_ATTR_PREFETCH_ROWS</span></td>
						<td>
						<p>
						<span>unsigned long *</span></td>
						<td>
						<p>使用光标时，一次从服务器获取的行数。<span><span>*arg</span>的范围从<span>1</span>到<span>unsigned 
						long</span>的最大值。默认值为<span>1</span>。</span></td>
					</tr>
				</table>
				<p>如果与<span><span>CURSOR_TYPE_READ_ONLY</span>一起使用了<span>STMT_ATTR_CURSOR_TYPE</span></span>选项，当调用了<span><span>mysql_stmt_execute()</span>时，将为语句打开光标。如果存在由前一个<span>mysql_stmt_execute()</span>调用打开的光标，在打开新的光标前，将关闭该光标。此外，为再执行而准备语句之前，<span>mysql_stmt_reset()</span>还将关闭任何打开的光标。<span>mysql_stmt_free_result()</span>将关闭任何打开的光标。</span></p>
				<p>如果为预处理语句打开了光标，没必要调用<span>mysql_stmt_store_result()</span>，这是因为，该函数会导致在客户端一侧对结果集进行缓冲处理。</p>
				<p>在<span>MySQL 5.0.2<span>中增加了</span><span>STMT_ATTR_CURSOR_TYPE</span></span>选项。在<span>MySQL 
				5.0.6</span>中，增加了<span><span>STMT_ATTR_PREFETCH_ROWS</span>选项。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>如果<span>OK</span>，返回<span>0</span>。</span>如果选项未知，返回非<span>0</span>值。 
				</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<p><strong><span>示例：</span></strong></p>
				<p>在下述示例中，为预处理语句打开了<span>1</span>个光标，并将每次获取的行数设为<span>5</span>：</p>
				<pre><span>MYSQL_STMT *stmt;</span></pre>
				<pre><span>int rc;</span></pre>
				<pre><span>unsigned long type;</span></pre>
				<pre><span>unsigned long prefetch_rows = 5;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>stmt = mysql_stmt_init(mysql);</span></pre>
				<pre><span>type = (unsigned long) CURSOR_TYPE_READ_ONLY;</span></pre>
				<pre><span>rc = mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &amp;type);</span></pre>
				<pre><span>/* ... check return value ... */</span></pre>
				<pre><span>rc = mysql_stmt_attr_set(stmt, STMT_ATTR_PREFETCH_ROWS,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; (void*) &amp;prefetch_rows);</span></pre>
				<pre><span>/* ... check return value ... */</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-bind-param"></a>25.2.7.4. mysql_stmt_bind_param()</h4></div></div></div><a class="indexterm" name="id3025455"></a>
				<p><span>my_bool 
				mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *bind)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p><span><span>
				mysql_stmt_bind_param()</span>用于</span>为<span>SQL</span>语句中的参数标记符绑定数据，以传递给<span><span>mysql_stmt_prepare()</span>。它使用<span>MYSQL_BIND</span>结构来提供数据。</span>“<span><span>bind”</span>是<span>MYSQL_BIND</span>结构的某一数组的地址。按照客户端库的预期，对于查询中出现的每个<span>“?”</span>参数标记符，数组中均包含<span>1</span>个元素。</span></p>
				<p>假定你准备了下述语句：</p>
				<pre><span>INSERT INTO mytbl VALUES(?,?,?)</span></pre>
				<p>绑定参数时，<span><span>MYSQL_BIND</span>结构的数组包含</span><span>3</span>个元素，并能声明如下：</p>
				<pre><span>MYSQL_BIND bind[3];</span></pre>
				<p>在<a href="apis.html#c-api-prepared-statement-datatypes" title="25.2.5. C API Prepared Statement Data types">25.2.5节，“C API预处理语句的数据类型”</a>中，介绍了应设置的每个<span><span>MYSQL_BIND</span>元素的成员。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果绑定成功，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。 
				</p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_INVALID_BUFFER_USE</span><span> </span></p>
				<p>指明“<span>bind</span>”（绑定）是否将提供程序块中的长数据，以及缓冲类型是否为非字符串或二进制类型。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNSUPPORTED_PARAM_TYPE</span><span> </span>
				</p>
				<p>不支持该转换。或许<span><span>buffer_type</span>值是非法的，或不是所支持的类型之一。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。 </p>
				<p><strong><span>示例：</span></strong></p>
				<p>关于<span><span>mysql_stmt_bind_param()</span>的用法，请参见</span><a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10节，“mysql_stmt_execute()”</a>给出的示例。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-bind-result"></a>25.2.7.5. mysql_stmt_bind_result()</h4></div></div></div><a class="indexterm" name="id3025676"></a>
				<p><span>my_bool 
				mysql_stmt_bind_result(MYSQL_STMT *stmt, MYSQL_BIND *bind)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p><span>
				mysql_stmt_bind_result()</span>用于将结果集中的列与数据缓冲和长度缓冲关联（绑定）起来。当调用<span><span>mysql_stmt_fetch()</span>以获取数据时，</span><span>MySQL</span>客户端／服务器协议会将绑定列的数据置于指定的缓冲区内。</p>
				<p>调用<span><span>mysql_stmt_fetch()</span>之前，必须</span>将所有列绑定到缓冲。<span><span>“bind”</span>是<span>MYSQL_BIND</span>结构某一数组的地址。</span>按照客户端库的预期，对于结果集中的每一列，数组应包含相应的元素。如果未将列绑定到<span>MYSQL_BIND</span>结构，<span>mysql_stmt_fetch()</span>将简单地忽略数据获取操作。缓冲区应足够大，足以容纳数据值，这是因为协议不返回成块的数据值。</p>
				<p>可以在任何时候绑定或再绑定列，即使已部分检索了结果集后也同样。新的绑定将在下一次调用<span><span>mysql_stmt_fetch()</span>时起作用。假定某一应用程序绑定了结果集中的列，并调用了<span>mysql_stmt_fetch()</span>。客户端／服务器协议将返回绑定缓冲区中的数据。接下来，假定应用程序将多个列绑定到不同的缓冲。该协议不会将数据置于新绑定的缓冲区，直至</span>下次调用<span>mysql_stmt_fetch()</span>为止。</p>
				<p>要想绑定列，应用程序将调用<span><span>mysql_stmt_bind_result()</span>，并传递类型、地址、以及长度缓冲的地址。在</span><a href="apis.html#c-api-prepared-statement-datatypes" title="25.2.5. C API Prepared Statement Data types">25.2.5节，“C API预处理语句的数据类型”</a>中，介绍了应设置的各<span><span>MYSQL_BIND</span>元素的成员。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果绑定成功，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。 
				</p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNSUPPORTED_PARAM_TYPE</span><span> </span>
				</p>
				<p>不支持该转换。或许<span>buffer_type</span>值是非法的，或不是所支持的类型之一。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。 </p>
				<p><strong><span>示例：</span></strong></p>
				<p>关于<span><span>mysql_stmt_bind_result()</span>的用法，请参见</span><a href="apis.html#mysql-stmt-fetch" title="25.2.7.11. mysql_stmt_fetch()">25.2.7.11节，“mysql_stmt_fetch()”</a>中给出的示例。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-close"></a>25.2.7.6. mysql_stmt_close()</h4></div></div></div><a class="indexterm" name="id3025901"></a>
				<p><span>my_bool 
				mysql_stmt_close(MYSQL_STMT *)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>关闭预处理语句。此外，<span><span>mysql_stmt_close()</span>还会取消由<span>“stmt”</span>指向的语句句柄分配。</span></p>
				<p>如果当前语句已挂起或未读取结果，该函数将取消它们，以便能执行下一个查询，</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功释放了语句，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。 
				</p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。 </p>
				<p><strong><span>示例：</span></strong></p>
				<p>关于<span><span>mysql_stmt_close()</span>的用法，请参见</span><a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10节，“mysql_stmt_execute()”</a>中给出的示例。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-data-seek"></a>25.2.7.7. mysql_stmt_data_seek()</h4></div></div></div><a class="indexterm" name="id3026036"></a>
				<p><span>void 
				mysql_stmt_data_seek(MYSQL_STMT *stmt, my_ulonglong offset)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>查找语句结果集中的任意行。偏移量为行编号，应位于从<span>0</span>到<span>mysql_stmt_num_rows(stmt)-1</span>的范围内。</p>
				<p>该函数要求语句结果集结构包含上次执行查询的全部结果，这样，<span><span>mysql_stmt_data_seek()</span>就能与<span>mysql_stmt_store_result()</span></span>一起使用。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>无。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-errno"></a>25.2.7.8. mysql_stmt_errno()</h4></div></div></div><a class="indexterm" name="id3026132"></a>
				<p><span>unsigned int 
				mysql_stmt_errno(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>对于由<span><span>stmt</span>指定的语句，<span>mysql_stmt_errno()</span>将返回最近调用的语句<span>API</span>函数的错误代码，该函数或成功或失败。</span>“<span>0</span>”返回值表示未出现错误。在<span>MySQL
				<span>errmsg.h</span></span><span>头文件中列出了客户端错误消息编号。在<span>mysqld_error.h</span>中，列出了服务器错误消息。</span>此外，在<a href="error-handling.html">附录B：</a><a href="error-handling.html" title="Appendix B. Error Codes and Messages"><i>错误代码和消息</i></a>中，也列出了错误消息。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>错误代码值。如果未出现错误，返回<span>0</span>。 </p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-error"></a>25.2.7.9. mysql_stmt_error()</h4></div></div></div><a class="indexterm" name="id3026228"></a>
				<p><span>const char *mysql_stmt_error(MYSQL_STMT 
				*stmt)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>对于由<span><span>stmt</span>指定的语句，<span>mysql_stmt_error()</span>返回由<span>Null</span>终结的字符串，该字符串包含最近调用的语句<span>API</span>函数的错误消息，该函数或成功或失败。如果未出现错误，返回</span>空字符串<span>(<span>&quot;&quot;</span>)</span>。这意味着下述两个测试是等效的：</p>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_stmt_errno(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; // an error occurred</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_stmt_error(stmt)[0])</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; // an error occurred</span></pre>
				<pre><span>}</span></pre>
				<p>通过重新编译<span>MySQL</span>客户端库，可更改客户端错误消息的语言。目前，能够选择数种语言之一显示错误消息。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>描述了错误的字符串。如果未出现错误，返回空字符串。 </p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-execute"></a>25.2.7.10. mysql_stmt_execute()</h4></div></div></div><a class="indexterm" name="id3026327"></a>
				<p><span>int 
				mysql_stmt_execute(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p><span>
				mysql_stmt_execute()</span>执行与语句句柄相关的预处理查询。在该调用期间，将当前绑定的参数标记符的值发送到服务器，服务器用新提供的数据替换标记符。</p>
				<p>如果语句是<span>UPDATE</span>、<span>DELETE</span>或<span><span>INSERT</span>，通过调用<span>mysql_stmt_affected_rows()</span>，可发现</span>更改、删除或插入的总行数。如果这是诸如<span>SELECT</span>等能生成结果集的语句，调用任何其他能导致查询处理的函数之前，必须调用<span><span>mysql_stmt_fetch()</span>来获取数据。关于如何获取结果的更多信息，请参见</span><a href="apis.html#mysql-stmt-fetch" title="25.2.7.11. mysql_stmt_fetch()">25.2.7.11节，“mysql_stmt_fetch()”</a>。</p>
				<p>对于生成结果集的语句，执行语句之前，可通过调用<span><span>mysql_stmt_attr_set()</span>，</span>请求<span><span>mysql_stmt_execute()</span>为语句打开光标。</span>如果多次执行某一语句，在打开新的光标前，<span>mysql_stmt_execute()</span>将关闭任何已打开的光标。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果执行成功，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。 
				</p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。 </p>
				<p><strong><span>示例：</span></strong></p>
				<p>在下面的示例中，介绍了使用<span>mysql_stmt_init()</span>、<span>mysql_stmt_prepare()</span>、<span>mysql_stmt_param_count()</span>、<span>mysql_stmt_bind_param()</span>、<span><span>mysql_stmt_execute()</span>、以及<span>mysql_stmt_affected_rows()</span>创建和填充表的方法。假定<span>mysql</span>变量具有有效的连接句柄。</span></p>
				<pre><span>#define STRING_SIZE 50</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>#define DROP_SAMPLE_TABLE &quot;DROP TABLE IF EXISTS test_table&quot;</span></pre>
				<pre><span>#define CREATE_SAMPLE_TABLE &quot;CREATE TABLE test_table(col1 INT,\</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2 VARCHAR(40),\</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col3 SMALLINT,\</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col4 TIMESTAMP)&quot;</span></pre>
				<pre><span>#define INSERT_SAMPLE &quot;INSERT INTO test_table(col1,col2,col3) VALUES(?,?,?)&quot;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>MYSQL_STMT&nbsp;&nbsp;&nbsp; *stmt;</span></pre>
				<pre><span>MYSQL_BIND&nbsp;&nbsp;&nbsp; bind[3];</span></pre>
				<pre><span>my_ulonglong&nbsp; affected_rows;</span></pre>
				<pre><span>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param_count;</span></pre>
				<pre><span>short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small_data;</span></pre>
				<pre><span>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int_data;</span></pre>
				<pre><span>char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str_data[STRING_SIZE];</span></pre>
				<pre><span>unsigned long str_length;</span></pre>
				<pre><span>my_bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_null;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_query(mysql, DROP_SAMPLE_TABLE))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; DROP TABLE failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_error(mysql));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_query(mysql, CREATE_SAMPLE_TABLE))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; CREATE TABLE failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_error(mysql));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Prepare an INSERT query with 3 parameters */</span></pre>
				<pre><span>/* (the TIMESTAMP column is not named; the server */</span></pre>
				<pre><span>/*&nbsp; sets it to the current date and time) */</span></pre>
				<pre><span>stmt = mysql_stmt_init(mysql);</span></pre>
				<pre><span>if (!stmt)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_init(), out of memory\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>if (mysql_stmt_prepare(stmt, INSERT_SAMPLE, strlen(INSERT_SAMPLE)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_prepare(), INSERT failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>fprintf(stdout, &quot; prepare, INSERT successful\n&quot;);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Get the parameter count from the statement */</span></pre>
				<pre><span>param_count= mysql_stmt_param_count(stmt);</span></pre>
				<pre><span>fprintf(stdout, &quot; total parameters in INSERT: %d\n&quot;, param_count);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (param_count != 3) /* validate parameter count */</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; invalid parameter count returned by MySQL\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Bind the data for all 3 parameters */</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>memset(bind, 0, sizeof(bind));</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* INTEGER PARAM */</span></pre>
				<pre><span>/* This is a number type, so there is no need to specify buffer_length */</span></pre>
				<pre><span>bind[0].buffer_type= MYSQL_TYPE_LONG;</span></pre>
				<pre><span>bind[0].buffer= (char *)&amp;int_data;</span></pre>
				<pre><span>bind[0].is_null= 0;</span></pre>
				<pre><span>bind[0].length= 0;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* STRING PARAM */</span></pre>
				<pre><span>bind[1].buffer_type= MYSQL_TYPE_STRING;</span></pre>
				<pre><span>bind[1].buffer= (char *)str_data;</span></pre>
				<pre><span>bind[1].buffer_length= STRING_SIZE;</span></pre>
				<pre><span>bind[1].is_null= 0;</span></pre>
				<pre><span>bind[1].length= &amp;str_length;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* SMALLINT PARAM */</span></pre>
				<pre><span>bind[2].buffer_type= MYSQL_TYPE_SHORT;</span></pre>
				<pre><span>bind[2].buffer= (char *)&amp;small_data;</span></pre>
				<pre><span>bind[2].is_null= &amp;is_null;</span></pre>
				<pre><span>bind[2].length= 0;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Bind the buffers */</span></pre>
				<pre><span>if (mysql_stmt_bind_param(stmt, bind))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_bind_param() failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Specify the data values for the first row */</span></pre>
				<pre><span>int_data= 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* integer */</span></pre>
				<pre><span>strncpy(str_data, &quot;MySQL&quot;, STRING_SIZE); /* string&nbsp; */</span></pre>
				<pre><span>str_length= strlen(str_data);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* INSERT SMALLINT data as NULL */</span></pre>
				<pre><span>is_null= 1;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Execute the INSERT statement - 1*/</span></pre>
				<pre><span>if (mysql_stmt_execute(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_execute(), 1 failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Get the total number of affected rows */</span></pre>
				<pre><span>affected_rows= mysql_stmt_affected_rows(stmt);</span></pre>
				<pre><span>fprintf(stdout, &quot; total affected rows(insert 1): %lu\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long) affected_rows);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (affected_rows != 1) /* validate affected rows */</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; invalid affected rows by MySQL\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Specify data values for second row, then re-execute the statement */</span></pre>
				<pre><span>int_data= 1000;</span></pre>
				<pre><span>strncpy(str_data, &quot;The most popular Open Source database&quot;, STRING_SIZE);</span></pre>
				<pre><span>str_length= strlen(str_data);</span></pre>
				<pre><span>small_data= 1000;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* smallint */</span></pre>
				<pre><span>is_null= 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* reset */</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Execute the INSERT statement - 2*/</span></pre>
				<pre><span>if (mysql_stmt_execute(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_execute, 2 failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Get the total rows affected */</span></pre>
				<pre><span>affected_rows= mysql_stmt_affected_rows(stmt);</span></pre>
				<pre><span>fprintf(stdout, &quot; total affected rows(insert 2): %lu\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long) affected_rows);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (affected_rows != 1) /* validate affected rows */</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; invalid affected rows by MySQL\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Close the statement */</span></pre>
				<pre><span>if (mysql_stmt_close(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; failed while closing the statement\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<p><strong><span>注释</span></strong>：关于使用预处理语句函数的完整示例，请参见文件<span>tests/mysql_client_test.c</span>。该文件可从<span>MySQL</span>源码分发版获得，或从<span>BitKeeper</span>源码仓库获得。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-fetch"></a>25.2.7.11. mysql_stmt_fetch()</h4></div></div></div><a class="indexterm" name="id3026780"></a>
				<p><span>int 
				mysql_stmt_fetch(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p><span>
				mysql_stmt_fetch()</span>返回结果集中的下一行。仅能当结果集存在时调用它，也就是说，调用了能创建结果集的<span><span>mysql_stmt_execute()</span>之后，</span>或当<span><span>mysql_stmt_execute()</span>对整个结果集即行缓冲处理后</span>调用了<span><span>mysql_stmt_store_result()</span>。</span></p>
				<p><span>使用<span>mysql_stmt_bind_result()</span>绑定的缓冲，<span>mysql_stmt_fetch()</span></span>返回行数据。对于当前列集合中的所有列，它将返回缓冲内的数据，并将长度返回到长度指针。</p>
				<p>调用<span><span>mysql_stmt_fetch()</span>之前，应用程序必须绑定所有列。</span></p>
				<p>如果获取的数据值是<span>NULL</span>值，对应<span><span>MYSQL_BIND</span>结构的<span>*is_null</span>值将包含</span><span>TRUE 
				(1)</span>。否则，将根据应用程序指定的缓冲类型，在<span>*buffer</span>和<span><span>*length</span>内返回数据及其长度。每个数值类型和临时类型都有固定的长度，请参见下面的表格。字符串类型的长度取决于由<span>data_length</span>指明的</span>实际数据值的长度。</p>
				<table border="1" cellpadding="0" id="table14">
					<tr>
						<td>
						<p><strong>
						<span>类型</span></strong></td>
						<td>
						<p><strong>
						<span>长度</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_TINY</span></td>
						<td>
						<p><span>1</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_SHORT</span></td>
						<td>
						<p><span>2</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_LONG</span></td>
						<td>
						<p><span>4</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_LONGLONG</span></td>
						<td>
						<p><span>8</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_FLOAT</span></td>
						<td>
						<p><span>4</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_DOUBLE</span></td>
						<td>
						<p><span>8</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_TIME</span></td>
						<td>
						<p>
						<span>sizeof(MYSQL_TIME)</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_DATE</span></td>
						<td>
						<p>
						<span>sizeof(MYSQL_TIME)</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_DATETIME</span></td>
						<td>
						<p>
						<span>sizeof(MYSQL_TIME)</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_STRING</span></td>
						<td>
						<p>
						<span>data length</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_BLOB</span></td>
						<td>
						<p>
						<span>data_length</span></td>
					</tr>
				</table>
				<p><strong><span>返回值</span></strong></p>
				<table border="1" cellpadding="0" id="table15">
					<tr>
						<td>
						<p><strong>
						<span>返回值</span></strong></td>
						<td>
						<p><strong>
						<span>描述</span></strong></td>
					</tr>
					<tr>
						<td>
						<p><span>0</span></td>
						<td>
						<p>成功，数据被提取到应用程序数据缓冲区。</td>
					</tr>
					<tr>
						<td>
						<p><span>1</span></td>
						<td>
						<p>出现错误。通过调用<span>mysql_stmt_errno()</span>和<span><span>mysql_stmt_error()</span>，可获取错误代码和错误消息。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_NO_DATA</span></td>
						<td>
						<p>不存在行／数据。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_DATA_TRUNCATED</span></td>
						<td>
						<p>出现数据截短。</td>
					</tr>
				</table>
				<p><span>不返回<span>MYSQL_DATA_TRUNCATED</span>，除非用<span>mysql_options()</span>启用了截短通报功能。返回该值时，为了确定截短的参数是哪个，</span>可检查<span><span>MYSQL_BIND</span>参数结构的错误成员。</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNSUPPORTED_PARAM_TYPE</span><span> </span>
				</p>
				<p>缓冲类型为<span>MYSQL_TYPE_DATE</span>、<span>MYSQL_TYPE_TIME</span>、<span>MYSQL_TYPE_DATETIME</span>、或<span><span>MYSQL_TYPE_TIMESTAMP</span>，但数据类型</span>不是<span>DATE</span>、<span>TIME</span>、<span>DATETIME</span>、或<span>TIMESTAMP</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>从<span><span>mysql_stmt_bind_result()</span>返回所有其他不支持的转换错误。</span></p>
				<p><strong><span>示例：</span></strong></p>
				<p>在下面的示例中，介绍了使用<span>mysql_stmt_result_metadata()</span>、<span><span>mysql_stmt_bind_result()</span>和<span>mysql_stmt_fetch()</span>从表中获取数据的方法。（在本示例中，将检索在</span><a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10节，“mysql_stmt_execute()”</a>一节的示例中插入的两行内容<span>）</span>。假定<span>mysql</span>变量具有有效的连接句柄。 
				</p>
				<pre><span>#define STRING_SIZE 50</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>#define SELECT_SAMPLE &quot;SELECT col1, col2, col3, col4 FROM test_table&quot;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>MYSQL_STMT&nbsp;&nbsp;&nbsp; *stmt;</span></pre>
				<pre><span>MYSQL_BIND&nbsp;&nbsp;&nbsp; bind[4];</span></pre>
				<pre><span>MYSQL_RES&nbsp;&nbsp;&nbsp;&nbsp; *prepare_meta_result;</span></pre>
				<pre><span>MYSQL_TIME&nbsp;&nbsp;&nbsp; ts;</span></pre>
				<pre><span>unsigned long length[4];</span></pre>
				<pre><span>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param_count, column_count, row_count;</span></pre>
				<pre><span>short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small_data;</span></pre>
				<pre><span>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int_data;</span></pre>
				<pre><span>char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str_data[STRING_SIZE];</span></pre>
				<pre><span>my_bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_null[4];</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Prepare a SELECT query to fetch data from test_table */</span></pre>
				<pre><span>stmt = mysql_stmt_init(mysql);</span></pre>
				<pre><span>if (!stmt)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_init(), out of memory\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>if (mysql_stmt_prepare(stmt, SELECT_SAMPLE, strlen(SELECT_SAMPLE)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_prepare(), SELECT failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>fprintf(stdout, &quot; prepare, SELECT successful\n&quot;);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Get the parameter count from the statement */</span></pre>
				<pre><span>param_count= mysql_stmt_param_count(stmt);</span></pre>
				<pre><span>fprintf(stdout, &quot; total parameters in SELECT: %d\n&quot;, param_count);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (param_count != 0) /* validate parameter count */</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; invalid parameter count returned by MySQL\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Fetch result set meta information */</span></pre>
				<pre><span>prepare_meta_result = mysql_stmt_result_metadata(stmt);</span></pre>
				<pre><span>if (!prepare_meta_result)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; mysql_stmt_result_metadata(), returned no meta information\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Get total columns in the query */</span></pre>
				<pre><span>column_count= mysql_num_fields(prepare_meta_result);</span></pre>
				<pre><span>fprintf(stdout, &quot; total columns in SELECT statement: %d\n&quot;, column_count);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (column_count != 4) /* validate column count */</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; invalid column count returned by MySQL\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Execute the SELECT query */</span></pre>
				<pre><span>if (mysql_stmt_execute(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_execute(), failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Bind the result buffers for all 4 columns before fetching them */</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>memset(bind, 0, sizeof(bind));</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* INTEGER COLUMN */</span></pre>
				<pre><span>bind[0].buffer_type= MYSQL_TYPE_LONG;</span></pre>
				<pre><span>bind[0].buffer= (char *)&amp;int_data;</span></pre>
				<pre><span>bind[0].is_null= &amp;is_null[0];</span></pre>
				<pre><span>bind[0].length= &amp;length[0];</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* STRING COLUMN */</span></pre>
				<pre><span>bind[1].buffer_type= MYSQL_TYPE_STRING;</span></pre>
				<pre><span>bind[1].buffer= (char *)str_data;</span></pre>
				<pre><span>bind[1].buffer_length= STRING_SIZE;</span></pre>
				<pre><span>bind[1].is_null= &amp;is_null[1];</span></pre>
				<pre><span>bind[1].length= &amp;length[1];</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* SMALLINT COLUMN */</span></pre>
				<pre><span>bind[2].buffer_type= MYSQL_TYPE_SHORT;</span></pre>
				<pre><span>bind[2].buffer= (char *)&amp;small_data;</span></pre>
				<pre><span>bind[2].is_null= &amp;is_null[2];</span></pre>
				<pre><span>bind[2].length= &amp;length[2];</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* TIMESTAMP COLUMN */</span></pre>
				<pre><span>bind[3].buffer_type= MYSQL_TYPE_TIMESTAMP;</span></pre>
				<pre><span>bind[3].buffer= (char *)&amp;ts;</span></pre>
				<pre><span>bind[3].is_null= &amp;is_null[3];</span></pre>
				<pre><span>bind[3].length= &amp;length[3];</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Bind the result buffers */</span></pre>
				<pre><span>if (mysql_stmt_bind_result(stmt, bind))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_bind_result() failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Now buffer all results to client */</span></pre>
				<pre><span>if (mysql_stmt_store_result(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_store_result() failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Fetch all rows */</span></pre>
				<pre><span>row_count= 0;</span></pre>
				<pre><span>fprintf(stdout, &quot;Fetching results ...\n&quot;);</span></pre>
				<pre><span>while (!mysql_stmt_fetch(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; row_count++;</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;&nbsp; row %d\n&quot;, row_count);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; /* column 1 */</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;&nbsp;&nbsp; column1 (integer)&nbsp; : &quot;);</span></pre>
				<pre><span>&nbsp; if (is_null[0])</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; NULL\n&quot;);</span></pre>
				<pre><span>&nbsp; else</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; %d(%ld)\n&quot;, int_data, length[0]);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; /* column 2 */</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;&nbsp;&nbsp; column2 (string)&nbsp;&nbsp; : &quot;);</span></pre>
				<pre><span>&nbsp; if (is_null[1])</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; NULL\n&quot;);</span></pre>
				<pre><span>&nbsp; else</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; %s(%ld)\n&quot;, str_data, length[1]);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; /* column 3 */</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;&nbsp;&nbsp; column3 (smallint) : &quot;);</span></pre>
				<pre><span>&nbsp; if (is_null[2])</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; NULL\n&quot;);</span></pre>
				<pre><span>&nbsp; else</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; %d(%ld)\n&quot;, small_data, length[2]);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; /* column 4 */</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;&nbsp;&nbsp; column4 (timestamp): &quot;);</span></pre>
				<pre><span>&nbsp; if (is_null[3])</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; NULL\n&quot;);</span></pre>
				<pre><span>&nbsp; else</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; %04d-%02d-%02d %02d:%02d:%02d (%ld)\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ts.year, ts.month, ts.day,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ts.hour, ts.minute, ts.second,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length[3]);</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;\n&quot;);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Validate rows fetched */</span></pre>
				<pre><span>fprintf(stdout, &quot; total rows fetched: %d\n&quot;, row_count);</span></pre>
				<pre><span>if (row_count != 2)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; MySQL failed to return all rows\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Free the prepared result metadata */</span></pre>
				<pre><span>mysql_free_result(prepare_meta_result);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Close the statement */</span></pre>
				<pre><span>if (mysql_stmt_close(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; failed while closing the statement\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-fetch-column"></a>25.2.7.12. mysql_stmt_fetch_column()</h4></div></div></div><a class="indexterm" name="id3027579"></a>
				<p><span>int 
				mysql_stmt_fetch_column(MYSQL_STMT *stmt, MYSQL_BIND *bind, 
				unsigned int column, unsigned long offset)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>从当前结果集行获取<span>1</span>列。“<span><span>bind”</span>提供了应将数据置于其中的缓冲。其设置方法应与</span>设置<span><span>mysql_stmt_bind_result()</span>的相同。</span>“<span><span>column”</span>指明了将获取哪个列。第<span>1</span>列编号为<span>0</span>。</span>“<span><span>offset”</span>是数据值内的偏移量，将从该处开始检索数据。可将其用于获取碎片形式的数据值。</span>值开始部分的偏移量为<span>0</span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功获取了值，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。 
				</p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_INVALID_PARAMETER_NO</span><span> </span>
				</p>
				<p><span>Invalid column 
				number. </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_NO_DATA</span><span> </span></p>
				<p>已抵达结果集的末尾。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-field-count"></a>25.2.7.13. mysql_stmt_field_count()</h4></div></div></div><a class="indexterm" name="id3027701"></a>
				<p><span>unsigned int 
				mysql_stmt_field_count(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>为语句处理程序返回关于最近语句的行数。对于诸如<span>INSERT</span>或<span><span>DELETE</span>等不生成结果集的语句，该值为<span>0</span>。</span></p>
				<p><span>通过调用<span>mysql_stmt_prepare()</span>准备好了语句后，可调用<span>mysql_stmt_field_count()</span>。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>表示结果集中行数的无符号整数。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-free-result"></a>25.2.7.14. mysql_stmt_free_result()</h4></div></div></div><a class="indexterm" name="id3027795"></a>
				<p><span>my_bool 
				mysql_stmt_free_result(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>释放与执行预处理语句生成的结果集有关的内存。对于该语句，如果存在打开的光标，<span>mysql_stmt_free_result()</span>将关闭它。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功释放了结果集，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。 
				</p>
				<p><strong><span>错误</span></strong></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-init"></a>25.2.7.15. mysql_stmt_init()</h4></div></div></div><a class="indexterm" name="id3027868"></a>
				<p><span>MYSQL_STMT *mysql_stmt_init(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>创建<span><span>MYSQL_STMT</span>句柄。</span>对于该句柄，应使用<span><span>mysql_stmt_close(MYSQL_STMT 
				*)</span>释放。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>成功时，返回指向<span><span>MYSQL_STMT</span>结构的指针</span>。如果内存溢出，返回<span>NULL</span>。</p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。 </div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-insert-id"></a>25.2.7.16. mysql_stmt_insert_id()</h4></div></div></div><a class="indexterm" name="id3027967"></a>
				<p><span>my_ulonglong 
				mysql_stmt_insert_id(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回预处理<span>INSERT</span>或<span><span>UPDATE</span>语句</span>为<span><span>AUTO_INCREMENT</span>列生成的值。在包含<span>AUTO_INCREMENT</span>字段的表上执行了预处理<span>INSERT</span>语句后，使用该函数。</span></p>
				<p>更多信息，请参见<a href="apis.html#mysql-insert-id" title="25.2.3.36. mysql_insert_id()">25.2.3.36节，“mysql_insert_id()”</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>为在执行预处理语句期间自动生成或明确设置的<span><span>AUTO_INCREMENT</span>列返回值，或</span>由<span>LAST_INSERT_ID(<i>expr</i>)</span>函数生成的值。如果语句未设置<span><span>AUTO_INCREMENT</span>值，返回值不确定。</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-num-rows"></a>25.2.7.17. mysql_stmt_num_rows()</h4></div></div></div><a class="indexterm" name="id3028095"></a>
				<p><span>my_ulonglong 
				mysql_stmt_num_rows(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回结果集中的行数。 </p>
				<p><span><span>
				mysql_stmt_num_rows()</span>的用法取决于是否使用了<span>mysql_stmt_store_result()</span>来对语句句柄中的全部结果集进行了缓冲处理。</span></p>
				<p>如果使用了<span><span>mysql_stmt_store_result()</span>，可立刻调用<span>mysql_stmt_num_rows()</span></span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>结果集中的行数。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-param-count"></a>25.2.7.18. mysql_stmt_param_count()</h4></div></div></div><a class="indexterm" name="id3028198"></a>
				<p><span>unsigned long 
				mysql_stmt_param_count(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回预处理语句中参数标记符的数目。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>表示语句中参数数目的无符号长整数。 </p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</p>
				<p><strong><span>示例：</span></strong></p>
				<p>关于<span><span>mysql_stmt_param_count()</span>的用法，请参见</span><a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10节，“mysql_stmt_execute()”</a>中给出的示例。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-param-metadata"></a>25.2.7.19. mysql_stmt_param_metadata()</h4></div></div></div><a class="indexterm" name="id3028293"></a></div><div class="section"><div class="titlepage"><div><div>
			<span>MYSQL_RES *mysql_stmt_param_metadata(MYSQL_STMT 
			*stmt)</span><span> </span>
			<p>该函数目前不做任何事。 </p>
			<p><strong><span>描述</span></strong></p>
			<p><strong><span>返回值</span></strong></p>
			<p><strong><span>错误</span></strong></p>
			<h4 class="title"><a name="mysql-stmt-prepare"></a>25.2.7.20. mysql_stmt_prepare()</h4></div></div></div><a class="indexterm" name="id3028355"></a>
			<p><span>int 
			mysql_stmt_prepare(MYSQL_STMT *stmt, const char *query, unsigned 
			long length)</span><span> </span></p>
			<p><strong><span>描述</span></strong></p>
			<p>给定<span><span>mysql_stmt_init()</span>返回的语句句柄，准备字符串查询指向的</span><span>SQL</span>语句，并返回状态值。字符串长度应由“<span>length</span>”参量给出。字符串必须包含<span>1</span>条<span>SQL</span>语句。不应为语句添加终结用分号<span>(</span>‘<span>;</span>’<span>)</span>或<span>\g</span>。 
			</p>
			<p>通过将问号字符“<span>?</span>”嵌入到<span>SQL</span>字符串的恰当位置，应用程序可包含<span>SQL</span>语句中的一个或多个参数标记符。</p>
			<p>标记符仅在<span>SQL</span>语句中的特定位置时才是合法的。例如，它可以在<span>INSERT</span>语句的<span><span>VALUES()</span>列表中</span>（为行指定列值），或与<span>WHERE</span>子句中某列的比较部分（用以指定比较值）。但是，对于<span>ID</span>（例如表名或列名），不允许使用它们，不允许指定二进制操作符（如等于号“<span>=</span>”）的操作数。后一个限制是有必要的，原因在于，无法确定参数类型。一般而言，参数仅在<span>DML</span>（数据操作语言）语句中才是合法的，在<span>DDL</span>（数据定义语言）语句中不合法。</p>
			<p>执行语句之前，必须使用<span><span>mysql_stmt_bind_param()</span>，将参数标记符与应用程序变量绑定在一起。</span></p>
			<p><strong><span>返回值</span></strong></p>
			<p>如果成功处理了语句，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。 
			</p>
			<p><strong><span>错误</span></strong></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_COMMANDS_OUT_OF_SYNC</span><span> </span></p>
			<p>以不恰当的顺序执行了命令。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_OUT_OF_MEMORY</span><span> </span></p>
			<p>内存溢出。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_SERVER_GONE_ERROR</span><span> </span></p>
			<p><span>MySQL</span>服务器不可用。 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_SERVER_LOST</span><span> </span></p>
			<p>查询过程中，与服务器的连接丢失。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_UNKNOWN_ERROR</span><span> </span></p>
			<p>出现未知错误。 </p>
			<p>如果准备操作失败（即<span>mysql_stmt_prepare()</span>返回非<span>0</span>值），可通过调用<span><span>mysql_stmt_error()</span>获取错误消息。</span></p>
			<p><strong><span>示例：</span></strong></p>
			<p>关于<span>mysql_stmt_prepare()</span>的用法，请参见<a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10节，“mysql_stmt_execute()”</a>中给出的示例。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-reset"></a>25.2.7.21. mysql_stmt_reset()</h4></div></div></div><a class="indexterm" name="id3028616"></a>
				<p><span>my_bool 
				mysql_stmt_reset(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>在客户端和服务器上，将预处理语句复位为完成准备后的状态。主要用于复位用<span><span>mysql_stmt_send_long_data()</span>发出的数据。对于语句，任何已打开的光标将被关闭。</span></p>
				<p>要想重新准备用于另一查询的语句，可使用<span>mysql_stmt_prepare()</span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果语句成功复位，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。 
				</p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>查询过程中，与服务器的连接丢失。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。 </div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-result-metadata"></a>25.2.7.22. mysql_stmt_result_metadata()</h4></div></div></div><a class="indexterm" name="id3028759"></a>
				<p><span>MYSQL_RES *mysql_stmt_result_metadata(MYSQL_STMT 
				*stmt)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>如果传递给<span><span>mysql_stmt_prepare()</span>的语句能够成生结果集，<span>mysql_stmt_result_metadata()</span>将以指针的形式返回结果集元数据，该指针指向<span>MYSQL_RES</span>结构，可用于处理元信息，如</span>总的字段数以及单独的字段信息。该结果集指针可作为参量传递给任何基于字段且用于处理结果集元数据的<span>API</span>函数，如：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_num_fields()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_fetch_field()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_fetch_field_direct()</span><span> </span>
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_fetch_fields()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_field_count()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_field_seek()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_field_tell()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_free_result()</span><span> </span></p>
				<p>完成操作后，应释放结果集结构，可通过将其传递给<span><span>mysql_free_result()</span>完成</span>。它与释放通过<span>mysql_store_result()</span>调用获得的结果集的方法类似。</p>
				<p><span>
				mysql_stmt_result_metadata()</span>返回的结果集仅包含元数据。不含任何行结果。与<span><span>mysql_stmt_fetch()</span>一起使用语句句柄，可获取行。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>MYSQL_RES</span>结果结构。如果不存在关于预处理查询的任何元信息，返回<span><span>NULL</span>。</span></p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。 </p>
				<p><strong><span>示例：</span></strong></p>
				<p>关于<span><span>mysql_stmt_result_metadata()</span>的用法，请参见</span><a href="apis.html#mysql-stmt-fetch" title="25.2.7.11. mysql_stmt_fetch()">25.2.7.11节，“mysql_stmt_fetch()”</a>中给出的示例。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-row-seek"></a>25.2.7.23. mysql_stmt_row_seek()</h4></div></div></div><a class="indexterm" name="id3029020"></a>
				<p><span>
				MYSQL_ROW_OFFSET mysql_stmt_row_seek(MYSQL_STMT *stmt, 
				MYSQL_ROW_OFFSET offset)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>将行光标设置到语句结果集中的任意行。“<span><span>offset”</span>值是行偏移的值，行偏移应是</span>从<span>mysql_stmt_row_tell()</span>或<span><span>mysql_stmt_row_seek()</span>返回的值。</span>该值不是行编号，如果打算按编号查找结果集中的行，可使用<span><span>mysql_stmt_data_seek()</span>取而代之。</span></p>
				<p>该函数要求结果集结构包含查询的全部结果，以便<span>mysql_stmt_row_seek()</span>能够仅与<span>mysql_stmt_store_result()</span>一起使用。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>行光标的前一个值。可以将该值换递给后续的<span>mysql_stmt_row_seek()</span>调用。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-row-tell"></a>25.2.7.24. mysql_stmt_row_tell()</h4></div></div></div><a class="indexterm" name="id3029139"></a>
				<p><span>
				MYSQL_ROW_OFFSET mysql_stmt_row_tell(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回针对前一个<span><span>mysql_stmt_fetch()</span>的行光标的当前位置。该值可用作<span>mysql_stmt_row_seek()</span></span>的参量。</p>
				<p>仅应在<span><span>mysql_stmt_store_result()</span>之后使用<span>mysql_stmt_row_tell()</span>。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>行光标的当前偏移量。</p>
				<p><strong><span>错误</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-send-long-data"></a>25.2.7.25. mysql_stmt_send_long_data()</h4></div></div></div><a class="indexterm" name="id3029230"></a>
				<p><span>my_bool 
				mysql_stmt_send_long_data(MYSQL_STMT *stmt, unsigned int 
				parameter_number, const char *data, unsigned long length)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>
				允许应用程序分段地（分块）将参数数据发送到服务器。可以多次调用该函数，以便发送关于某一列的字符或二进制数据的不同部分，列必须是<span>TEXT</span>或<span>BLOB</span>数据类型之一。</p>
				<p><span><span>
				“parameter_number”</span>指明了与数据关联的参数。参数从<span>0</span>开始编号。<span>“data”</span>是指向包含将要发送的数据的缓冲区的指针，</span>“<span><span>length”</span>指明了缓冲区内的字节数。</span></p>
				<p><strong><span>注释：</span></strong>自上一个<span>mysql_stmt_execute()</span>或<span><span>mysql_stmt_reset()</span>后，对于与<span>mysql_stmt_send_long_data()</span>一起使用的所有参数，下一个<span>mysql_stmt_execute()</span>调用将忽略</span>绑定缓冲。</p>
				<p>如果希望复位／忽略已发送的数据，可使用<span>mysql_stmt_reset()</span>。请参见<a href="apis.html#mysql-stmt-reset" title="25.2.7.21. mysql_stmt_reset()">25.2.7.21节，“mysql_stmt_reset()”</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功地将数据发送到服务器，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。 
				</p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。 </p>
				<p><strong><span>示例：</span></strong></p>
				<p>在下面的示例中，介绍了以信息块形式为<span>TEXT</span>列发送数据的方法。它会将数据值“<span><span>MySQL</span>，最流行的开放源码数据库</span>”插入到<span><span>text_column</span>列中。</span>假定<span>mysql</span>变量具有有效的连接句柄。 
				</p>
				<pre><span>#define INSERT_QUERY &quot;INSERT INTO test_long_data(text_column) VALUES(?)&quot;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>MYSQL_BIND bind[1];</span></pre>
				<pre><span>long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>smtt = mysql_stmt_init(mysql);</span></pre>
				<pre><span>if (!stmt)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_init(), out of memory\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>if (mysql_stmt_prepare(stmt, INSERT_QUERY, strlen(INSERT_QUERY)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n mysql_stmt_prepare(), INSERT failed&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n %s&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span> memset(bind, 0, sizeof(bind));</span></pre>
				<pre><span> bind[0].buffer_type= MYSQL_TYPE_STRING;</span></pre>
				<pre><span> bind[0].length= &amp;length;</span></pre>
				<pre><span> bind[0].is_null= 0;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Bind the buffers */</span></pre>
				<pre><span>if (mysql_stmt_bind_param(stmt, bind))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n param bind failed&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n %s&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span> /* Supply data in chunks to server */</span></pre>
				<pre><span> if (!mysql_stmt_send_long_data(stmt,0,&quot;MySQL&quot;,5))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n send_long_data failed&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n %s&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span> /* Supply the next piece of data */</span></pre>
				<pre><span> if (mysql_stmt_send_long_data(stmt,0,&quot; - The most popular Open Source database&quot;,40))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n send_long_data failed&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n %s&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span> /* Now, execute the query */</span></pre>
				<pre><span> if (mysql_stmt_execute(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n mysql_stmt_execute failed&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n %s&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-sqlstate"></a>25.2.7.26. mysql_stmt_sqlstate()</h4></div></div></div><a class="indexterm" name="id3029537"></a>
				<p><span>const char *mysql_stmt_sqlstate(MYSQL_STMT 
				*stmt)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>对于由<span><span>stmt</span>指定的语句，<span>mysql_stmt_sqlstate()</span></span>返回由<span>Null</span>终结的字符串，该字符串包含针对最近调用预处理语句<span>API</span>函数的<span>SQLSTATE</span>错误代码，该函数或成功或失败。错误代码由<span>5</span>个字符构成。<span><span>&quot;00000&quot;</span>表示</span>“无错误”。这些值由<span>ANSI 
				SQL</span>和<span>ODBC</span>指定。关于可能值的列表，请参见<a href="error-handling.html" title="Appendix B. Error Codes and Messages">附录B：错误代码和消息</a><span>。 
				</span></p>
				<p>注意，并非所有的<span>MySQL</span>错误均会被映射到<span>SQLSTATE</span>代码。值<span>&quot;HY000&quot;</span>（一般错误）用于未映射的错误。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>包含<span>SQLSTATE</span>错误代码、由<span>Null</span>终结的字符串。 </div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-store-result"></a>25.2.7.27. mysql_stmt_store_result()</h4></div></div></div><a class="indexterm" name="id3029630"></a>
				<p><span>int 
				mysql_stmt_store_result(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>对于成功生成结果集的所有语句（<span>SELECT</span>、<span>SHOW</span>、<span>DESCRIBE</span>、<span>EXPLAIN</span>），而且仅当你打算对客户端的全部结果集进行缓冲处理时，必须调用<span><span>mysql_stmt_store_result()</span>，以便后续的<span>mysql_stmt_fetch()</span></span>调用能返回缓冲数据。</p>
				<p>对于其他语句，没有必要调用<span><span>mysql_stmt_store_result()</span>，但如果调用了它，</span>也不会造成任何伤害或导致任何性能问题。通过检查<span><span>mysql_stmt_result_metadata()</span>是否</span>返回<span><span>NULL</span>，可检测语句是否生成了结果集。</span>更多信息，请参见<a href="apis.html#mysql-stmt-result-metadata" title="25.2.7.22. mysql_stmt_result_metadata()">25.2.7.22节，“mysql_stmt_result_metadata()”</a>。</p>
				<p><strong><span>注释：</span><span>默认情况下，对于</span></strong><span><span>mysql_stmt_store_result()</span>中的所有列，</span><span>MySQL</span>不计算<span>MYSQL_FIELD-&gt;max_length</span>，这是因为，计算它会显著降低<span><span>mysql_stmt_store_result()</span>的性能，而且大多数应用程序</span>不需要<span>max_length</span>。如果打算更新<span><span>max_length</span>，</span>可通过调用<span>mysql_stmt_attr_set(MYSQL_STMT, 
				STMT_ATTR_UPDATE_MAX_LENGTH, &amp;flag)</span>启用它。请参见<a href="apis.html#mysql-stmt-attr-set" title="25.2.7.3. mysql_stmt_attr_set()">25.2.7.3节，“mysql_stmt_attr_set()”</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功完成了对结果的缓冲处理，返回<span>0</span>。如果出现错误，返回非<span>0</span>值。</p>
				<p><strong><span>错误</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰当的顺序执行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>内存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>服务器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查询过程中，与服务器的连接丢失。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出现未知错误。 </div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-problems"></a>
			25.2.8.&nbsp;C API预处理语句方面的问题</h3></div></div></div>
			<p>下面列出了一些目前已知的与预处理语句有关的问题：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>TIME</span>、<span><span>TIMESTAMP</span>和<span>DATETIME</span></span>不支持秒部分，例如来自<span><span>DATE_FORMAT()</span>的秒部分</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>将整数转换为字符串时，在某些情况下，当<span>MySQL</span>不打印前导<span>0</span>时，可与预处理语句一起使用<span>ZEROFILL</span>。例如，与<span><span>MIN(number-with-zerofill)</span>一起。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>将浮点数转换为客户端中的字符串时，被转换值最右侧的位可能会与原始值的有所不同。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><em><span>
			预处理语句不使用查询高速缓冲，即使当查询不含任何占位符时也同样。。</span></em>请参见<a href="database-administration.html#query-cache-how" title="5.13.1. How the Query Cache Operates">5.13.1节，“查询高速缓冲如何工作”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-multiple-queries"></a>
			25.2.9.&nbsp;多查询执行的C API处理</h3></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			<span>MySQL 5.1</span>支持在单个查询字符串中指定的多语句的执行。要想与给定的连接一起使用该功能，打开连接时，必须将标志参数中的<span><span>CLIENT_MULTI_STATEMENTS</span>选项指定给<span>mysql_real_connect()</span>。</span>也可以通过调用<span><span>mysql_set_server_option(MYSQL_OPTION_MULTI_STATEMENTS_ON)</span>，为已有的连接设置它。</span><p>
			在默认情况下，<span>mysql_query()</span>和<span>mysql_real_query()</span>仅返回第<span>1</span>个查询的状态，并能使用<span>mysql_more_results()</span>和<span>mysql_next_result()</span>对后续查询的状态进行处理。</p>
			<pre><span>/* Connect to server with option CLIENT_MULTI_STATEMENTS */</span></pre>
			<pre><span>mysql_real_connect(..., CLIENT_MULTI_STATEMENTS);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>/* Now execute multiple queries */</span></pre>
			<pre><span>mysql_query(mysql,&quot;DROP TABLE IF EXISTS test_table;\</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CREATE TABLE test_table(id INT);\</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO test_table VALUES(10);\</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UPDATE test_table SET id=20 WHERE id=10;\</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT * FROM test_table;\</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;DROP TABLE test_table&quot;);</span></pre>
			<pre><span>do</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; /* Process all results */</span></pre>
			<pre><span>&nbsp; ...</span></pre>
			<pre><span>&nbsp; printf(&quot;total affected rows: %lld&quot;, mysql_affected_rows(mysql));</span></pre>
			<pre><span>&nbsp; ...</span></pre>
			<pre><span>&nbsp; if (!(result= mysql_store_result(mysql)))</span></pre>
			<pre><span>&nbsp; {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; printf(stderr, &quot;Got fatal error processing query\n&quot;);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; exit(1);</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; process_result_set(result); /* client function */</span></pre>
			<pre><span>&nbsp; mysql_free_result(result);</span></pre>
			<pre><span>} while (!mysql_next_result(mysql));</span></pre>
			<p>多语句功能可与<span>mysql_query()</span>或<span><span>mysql_real_query()</span>一起使用。它不能与预处理语句接口一起使用。按照定义，预处理语句仅能与包含单个语句的字符串一起使用。</span></p>
			<h3 class="title"><a name="c-api-date-handling"></a>
			25.2.10.&nbsp;日期和时间值的C API处理</h3></div></div></div>
			<p>二进制协议允许你使用<span><span>MYSQL_TIME</span>结构</span>发送和接受日期和时间值（<span>DATE</span>、<span>TIME</span>、<span>DATETIME</span>和<span><span>TIMESTAMP</span>）。</span>在<a href="apis.html#c-api-prepared-statement-datatypes" title="25.2.5. C API Prepared Statement Data types">25.2.5节，“C API预处理语句的数据类型”</a>中，介绍了该结构的成员。</p>
			<p>要想发送临时数据值，可使用<span><span>mysql_stmt_prepare()</span>创建预处理语句。然后，在调用<span>mysql_stmt_execute()</span>执行语句之前，可采用下述步骤设置每个临时参数：</span></p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>在与数据值相关的<span><span>MYSQL_BIND</span>结构中，将<span>buffer_type</span>成员设置为相应的类型，该类型指明了发送的临时值类型。</span>对于<span>DATE</span>、<span>TIME</span>、<span>DATETIME</span>或<span><span>TIMESTAMP</span>值，</span>将<span><span>buffer_type</span>分别设置为<span>MYSQL_TYPE_DATE</span>、<span>MYSQL_TYPE_TIME</span>、<span>MYSQL_TYPE_DATETIME</span></span>或<span>MYSQL_TYPE_TIMESTAMP</span>。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>将<span><span>MYSQL_BIND</span>结构的</span>缓冲成员设置为用于传递临时值的<span><span>MYSQL_TIME</span>结构的地址。</span></p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>填充<span><span>MYSQL_TIME</span>结构的成员，使之与打算传递的临时支的类型相符。</span></p>
			<p>使用<span><span>mysql_stmt_bind_param()</span>将参数数据绑定到语句。然后可调用<span>mysql_stmt_execute()</span></span>。</p>
			<p>要想检索临时值，可采用类似的步骤，但应将<span><span>buffer_type</span>成员设置为打算接受的值的类型，并将</span>缓冲成员设为应将返回值置于其中的<span><span>MYSQL_TIME</span>结构的地址。调用<span>mysql_stmt_execute()</span>之后，并在获取结果之前，使用<span>mysql_bind_results()</span>将缓冲绑定到语句上。</span></p>
			<p>下面给出了一个插入<span>DATE</span>、<span>TIME</span>和<span><span>TIMESTAMP</span>数据的简单示例</span>。假定<span>mysql</span>变量具有有效的连接句柄。 
			</p>
			<pre class="programlisting">
  MYSQL_TIME  ts;
  MYSQL_BIND  bind[3];
  MYSQL_STMT  *stmt;

  strmov(query, "INSERT INTO test_table(date_field, time_field,
                                        timestamp_field) VALUES(?,?,?");

  stmt = mysql_stmt_init(mysql);
  if (!stmt)
  {
    fprintf(stderr, " mysql_stmt_init(), out of memory\n");
    exit(0);
  }
  if (mysql_stmt_prepare(mysql, query, strlen(query)))
  {
    fprintf(stderr, "\n mysql_stmt_prepare(), INSERT failed");
    fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
    exit(0);
  }

  /* set up input buffers for all 3 parameters */
  bind[0].buffer_type= MYSQL_TYPE_DATE;
  bind[0].buffer= (char *)&amp;ts;
  bind[0].is_null= 0;
  bind[0].length= 0;
  ...
  bind[1]= bind[2]= bind[0];
  ...

  mysql_stmt_bind_param(stmt, bind);

  /* supply the data to be sent in the ts structure */
  ts.year= 2002;
  ts.month= 02;
  ts.day= 03;

  ts.hour= 10;
  ts.minute= 45;
  ts.second= 20;

  mysql_stmt_execute(stmt);
  ..

</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-thread-functions"></a>
			25.2.11.&nbsp;C API线程函数介绍</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#my-init">25.2.11.1. my_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-thread-init">25.2.11.2. mysql_thread_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-thread-end">25.2.11.3. mysql_thread_end()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-thread-safe">25.2.11.4. mysql_thread_safe()</a></span></dt></dl></div>
			<p>当你打算创建线程客户端时，需要使用下述函数。请参见<a href="apis.html#threaded-clients" title="25.2.15. How to Make a Threaded Client">25.2.15节，“如何生成线程式客户端”</a>。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="my-init"></a>25.2.11.1. my_init()</h4></div></div></div><a class="indexterm" name="id3030299"></a>
				<p><span>void 
				my_init(void)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>调用任何<span>MySQL</span>函数之前，需要在程序中调用该函数。它将初始化<span>MySQL</span>所需的某些全局变量。如果你正在使用线程安全客户端库，它还能为该线程调用<span><span>mysql_thread_init()</span>。</span></p>
				<p>通过<span>mysql_init()</span>、<span>mysql_library_init()</span>、<span>mysql_server_init()</span>和<span><span>mysql_connect()</span>，可自动调用该函数。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-init"></a>25.2.11.2. mysql_thread_init()</h4></div></div></div><a class="indexterm" name="id3030382"></a>
				<p><span>my_bool 
				mysql_thread_init(void)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>对于每个创建的线程，需要调用该函数来初始化与线程相关的变量。</p>
				<p>它可由<span>my_init()</span>和<span>mysql_connect()</span>自动调用。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>0</span>，如果出现错误，返回非<span>0</span>值。 </div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-end"></a>25.2.11.3. mysql_thread_end()</h4></div></div></div><a class="indexterm" name="id3030452"></a>
				<p><span>void 
				mysql_thread_end(void)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>调用<span><span>pthread_exit()</span>来释放<span>mysql_thread_init()</span>分配的内存之前，需要调用该函数。</span></p>
				<p>注意，该函数不会被客户端库自动调用。必须明确调用它以避免内存泄漏。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>无。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-safe"></a>25.2.11.4. mysql_thread_safe()</h4></div></div></div><a class="indexterm" name="id3030526"></a>
				<p><span>unsigned int 
				mysql_thread_safe(void)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>该函数指明了客户端是否编译为线程安全的。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果客户端是线程安全的，返回<span>1</span>，否则返回<span>0</span>。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-embedded-server-func"></a>
			25.2.12.&nbsp;C API嵌入式服务器函数介绍</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#mysql-server-init">25.2.12.1. mysql_server_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-server-end">25.2.12.2. mysql_server_end()</a></span></dt></dl></div>
			<p>如果希望允许应用程序链接到嵌入式<span>MySQL</span>服务器库，必须使用<span>mysql_server_init()</span>和<span>mysql_server_end()</span>函数。请参见<a href="apis.html#libmysqld" title="25.1. libmysqld, the Embedded MySQL Server Library">25.1节，“libmysqld，嵌入式MySQL服务器库”</a>。</p>
			<p>但是，要想提供改进的内存管理，即使是对与“<span>-lmysqlclient</span>”而不是与“<span>-lmysqld</span>”链接的程序，也应包含启用和结束库使用的调用。<span>mysql_library_init()</span>和<span><span>mysql_library_end()</span>函数可用于该目的。它们实际上是使其等效于<span>mysql_server_init()</span></span>和<span><span>mysql_server_end()</span>的<span>#define</span>符号</span>，但它们的名称更清楚地指明，无论应用程序使用的是<span>libmysqlclient</span>或<span><span>libmysqld</span>，开始使用或结束</span><span>MySQL 
			C API</span>库的使用时，应调用它们。关于更多信息，请参见<a href="apis.html#c-api-function-overview" title="25.2.2. C API Function Overview">25.2.2节，“C API函数概述”</a>。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-server-init"></a>25.2.12.1. mysql_server_init()</h4></div></div></div><a class="indexterm" name="id3030666"></a>
				<p><span>int 
				mysql_server_init(int argc, char **argv, char **groups)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>调用任何其他<span>MySQL</span>函数之前，必须在使用嵌入式服务器的程序中调用该函数。它将启动服务器，并初始化服务器使用的任何子系统（<span><span>mysys</span>、<span>InnoDB</span></span>等）。如果未调用该函数，对<span><span>mysql_init()</span>的下一次调用将执行<span>mysql_server_init()</span></span>。如果你正在使用与<span>MySQL</span>一起提供的<span>DBUG</span>软件包，应在调用了<span>my_init()</span>之后调用它。</p>
				<p>对于<span><span>main()</span>的参量，<span>argc</span>和<span>argv</span>是类似的参量。<span>argv</span>的第<span>1</span>个元素将被忽略</span>（典型情况下，它包含程序名）。为了方便起见，如果没有针对服务器的命令行参量，<span>argc</span>可以是<span>0</span>。<span><span>mysql_server_init()</span>将复制参量，以便能够在调用之后安全地摧毁<span>argv</span></span>或<span>groups</span>。</p>
				<p>如果打算连接到外部服务器而不启动嵌入式服务器，应为<span>argc</span>指定负值。</p>
				<p>“<span>groups</span>”中以<span>Null</span>终结的字符串列表选择了选项文件中的活动“<span>groups</span>”。请参见<a href="using-mysql-programs.html#option-files" title="4.3.2. Using Option Files">4.3.2节，“使用选项文件”</a>。为了方便起见，<span><span>groups</span>可以是<span>NULL</span>，在该情况下，<span>[server]</span>和<span>[embedded]</span>组是活动的。</span></p>
				<p><strong><span>示例：</span></strong></p>
				<pre><span>#include &lt;mysql.h&gt;</span></pre>
				<pre><span>#include &lt;stdlib.h&gt;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>static char *server_args[] = {</span></pre>
				<pre><span>&nbsp; &quot;this_program&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* this string is not used */</span></pre>
				<pre><span>&nbsp; &quot;--datadir=.&quot;,</span></pre>
				<pre><span>&nbsp; &quot;--key_buffer_size=32M&quot;</span></pre>
				<pre><span>};</span></pre>
				<pre><span>static char *server_groups[] = {</span></pre>
				<pre><span>&nbsp; &quot;embedded&quot;,</span></pre>
				<pre><span>&nbsp; &quot;server&quot;,</span></pre>
				<pre><span>&nbsp; &quot;this_program_SERVER&quot;,</span></pre>
				<pre><span>&nbsp; (char *)NULL</span></pre>
				<pre><span>};</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>int main(void) {</span></pre>
				<pre><span>&nbsp; if (mysql_server_init(sizeof(server_args) / sizeof(char *),</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; server_args, server_groups))</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; exit(1);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; /* Use any MySQL API functions here */</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; mysql_server_end();</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; return EXIT_SUCCESS;</span></pre>
				<pre><span>}</span></pre>
				<p><strong><span>返回值</span></strong></p>
				<p>如果<span>OK</span>，返回<span>0</span>。如果出现错误，返回<span>1</span>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-server-end"></a>25.2.12.2. mysql_server_end()</h4></div></div></div><a class="indexterm" name="id3030870"></a>
				<p><span>void 
				mysql_server_end(void)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>在所有其他<span>MySQL</span>函数后，在程序中必须调用该函数一次。它将关闭嵌入式服务器。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>无。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-problems"></a>
			25.2.13.&nbsp;使用C API时的常见问题</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#null-mysql-store-result">
				25.2.13.1. 为什么在mysql_query()返回成功后，mysql_store_result()有时会返回NULL<code class="literal"></code></a></span></dt><dt><span class="section"><a href="apis.html#query-results">25.2.13.2. What Results You Can Get from a Query</a></span></dt><dt><span class="section"><a href="apis.html#getting-unique-id">
				25.2.13.3. 如何获得上次插入行的唯一ID</a></span></dt><dt><span class="section"><a href="apis.html#c-api-linking-problems">
				25.2.13.4. 与C API有关的问题</a></span></dt></dl></div><a class="indexterm" name="id3030934"></a><a class="indexterm" name="id3030944"></a><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="null-mysql-store-result"></a>
				25.2.13.1.&nbsp;为什么在mysql_query()返回成功后，mysql_store_result()有时会返回NULL<code class="literal"></code></h4></div></div></div>
				<p>成功调用<span><span>mysql_query()</span>后，<span>mysql_store_result()</span>能够返回<span>NULL</span>。出现该情况时，</span>表明出现了下述条件之一：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>出现了<span><span>malloc()</span>故障（例如，如果结果集过大</span>）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>无法读取数据（在连接上出现了错误）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>查询未返回数据（例如，它是<span>INSERT</span>、<span>UPDATE</span>或<span>DELETE</span>）。</p>
				<p>通过调用<span><span>mysql_field_count()</span>，</span>始终能检查语句是否应生成非空结果。如果<span><span>mysql_field_count()</span>返回<span>0</span>，结果为空，而且上一个查询</span>是未返回值的语句（例如<span>INSERT</span>或<span>DELETE</span>）。如果<span><span>mysql_field_count()</span>返回非<span>0</span>值，语句应生成非空结果</span>。关于这方面的示例，请参见<span><span>mysql_field_count()</span>函数介绍。</span></p>
				<p>通过调用<span>mysql_error()</span>或<span><span>mysql_errno()</span>，</span>可测试是否出现了错误。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="query-results"></a>25.2.13.2. What Results You Can Get from a Query</h4></div></div></div>
				<p>除了查询返回的结果集外，还能获取下述信息：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>执行<span>INSERT</span></span>、<span>UPDATE</span>或<span><span>DELETE</span>时，<span>mysql_affected_rows()</span></span>返回上次查询影响的行数。</p>
				<p>对于快速在创建，请使用<span>TRUNCATE 
				TABLE</span>。</p>
				<p>
				<span>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>mysql_num_rows()</span></span>返回结果集中的行数。使用<span>mysql_store_result()</span>，一旦<span><span>mysql_store_result()</span>返回，就能调用<span>mysql_num_rows()</span></span>。使用<span><span>mysql_use_result()</span>，仅当用<span>mysql_fetch_row()</span>获取了所有行后，才能调用<span>mysql_num_rows()</span>。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span><span>
				mysql_insert_id()</span>返回上次查询生成的<span>ID</span>，该查询使用<span>AUTO_INCREMENT</span>索引将行插入到表内</span>。请参见<a href="apis.html#mysql-insert-id" title="25.2.3.36. mysql_insert_id()">25.2.3.36节，“mysql_insert_id()”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>某些查询（<span>LOAD 
				DATA INFILE ...</span>、<span>INSERT 
				INTO ... SELECT ...</span>、<span><span>UPDATE</span>）将返回额外信息。</span>结果由<span><span>mysql_info()</span>返回。关于它返回的字符串格式，</span>请参见关于<span><span>mysql_info()</span>的介绍。如果没有额外信息，<span>mysql_info()</span>将返回<span>NULL</span>指针。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="getting-unique-id"></a>
				25.2.13.3.&nbsp;如何获得上次插入行的唯一ID</h4></div></div></div><a class="indexterm" name="id3031244"></a><a class="indexterm" name="id3031251"></a><a class="indexterm" name="id3031261"></a><a class="indexterm" name="id3031271"></a>
				<p>如果将记录插入包含<span><span>AUTO_INCREMENT</span>列的表中，通过调用<span>mysql_insert_id()</span>函数，可获取</span>保存在该列中的值。</p>
				<p>通过执行下述代码，可从<span>C</span>应用程序检查某一值是否保存在<span>AUTO_INCREMENT</span>列中（假定该语句已成功执行）。它能确定查询是否是具有<span><span>AUTO_INCREMENT</span>索引的<span>INSERT</span>：</span></p>
				<pre><span>if ((result = mysql_store_result(&amp;mysql)) == 0 &amp;&amp;</span></pre>
				<pre><span>&nbsp; &nbsp;&nbsp;mysql_field_count(&amp;mysql) == 0 &amp;&amp;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; mysql_insert_id(&amp;mysql) != 0)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; used_id = mysql_insert_id(&amp;mysql);</span></pre>
				<pre><span>}</span></pre>
				<p>关于更多信息，请参见<a href="apis.html#mysql-insert-id" title="25.2.3.36. mysql_insert_id()">25.2.3.36节，“mysql_insert_id()”</a>。</p>
				<p>生成新的<span><span>AUTO_INCREMENT</span>值时，也能与<span>mysql_query()</span>一起通过执行<span>SELECT 
				LAST_INSERT_ID()</span>语句获得它，并从该语句返回的结果集检索该值。</span></p>
				<p>对于<span><span>LAST_INSERT_ID()</span>，最近生成的<span>ID</span>是在服务器上按连接维护的。它不会被另一个客户端改变。即使用</span><span>non-magic</span>值（即非<span>Null</span>非<span>0</span>值）更新了另一个<span><span>AUTO_INCREMENT</span>列，也不会更改它。</span></p>
				<p>如果打算使用从某一表生成的<span>ID</span>，并将其插入到第<span>2</span>个表中，可使用如下所示的<span>SQL</span>语句：</p>
				<pre><span>INSERT INTO foo (auto,text)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; VALUES(NULL,&#39;text&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # generate ID by inserting NULL</span></pre>
				<pre><span>INSERT INTO foo2 (id,text)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; VALUES(LAST_INSERT_ID(),&#39;text&#39;);&nbsp; # use ID in second table</span></pre>
				<p>注意，<span><span>mysql_insert_id()</span>返回保存在<span>AUTO_INCREMENT</span>列中的值，无论该值是因存储<span>NULL</span>或<span>0</span>而自动生成的，或是明确指定的，均如此。<span>LAST_INSERT_ID()</span>仅返回自动生成的<span>AUTO_INCREMENT</span>值。</span>如果你保存了除<span>NULL</span>或<span>0</span>之外的确切值，不会影响<span>LAST_INSERT_ID()</span>返回的值。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="c-api-linking-problems"></a>
				25.2.13.4.&nbsp;与C API有关的问题</h4></div></div></div><a class="indexterm" name="id3031439"></a><a class="indexterm" name="id3031449"></a></div></div><div class="section"><div class="titlepage"><div><div>
			与<span>C API</span>链接时，在某些系统上可能出现下述错误：<pre><span>gcc -g -o client test.o -L/usr/local/lib/mysql -lmysqlclient -lsocket -lnsl</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>Undefined&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first referenced</span></pre>
			<pre><span> symbol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in file</span></pre>
			<pre><span>floor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /usr/local/lib/mysql/libmysqlclient.a(password.o)</span></pre>
			<pre><span>ld: fatal: Symbol referencing errors. No output written to client</span></pre>
			<p>如果在你的系统上出现了该情况，必须在编译<span>/</span>链接行的末尾增加“<span>-lm</span>”，通过该方式包含数学库。</p>
			<h3 class="title"><a name="building-clients"></a>
			25.2.14.&nbsp;创建客户端程序</h3></div></div></div><a class="indexterm" name="id3031495"></a><a class="indexterm" name="id3031505"></a><a class="indexterm" name="id3031512"></a><a class="indexterm" name="id3031522"></a>
			<p>如果你编译了自己编写的<span>MySQL</span>客户端，或编译了从第三方获取的<span>MySQL</span>客户端，必须在链接命令中使用“<span>-lmysqlclient 
			-lz</span>”选项链接它们。你或许还应指定“<span><span>-L”</span>选项，通知</span>链接程序到哪里找到库。例如，如果将库安装到了<span><span>/usr/local/mysql/lib</span>，可在链接命令中使用<span>sr/local/mysql/lib 
			-lmysqlclient –lz</span>。</span></p>
			<p>对于使用<span>MySQL</span>头文件的客户端，编译它们时还须指定“<span><span>-I”</span>选项（例如</span>，<span><span>-I/usr/local/mysql/include</span>），以便</span>编译器能找到头文件。</p>
			<p>为了使在<span>Unix</span>平台上编译<span>MySQL</span>程序变得简单，提供了<strong><span>mysql_config</span></strong>脚本。请参见<a href="apis.html#mysql-config" title="25.9.2. mysql_config — Get Compile Options for Compiling Clients">25.9.2节，“mysql_config：获取编译客户端的编译选项”</a>。</p>
			<p>你也可以使用它来编译<span>MySQL</span>客户端，如下所述：</p>
			<pre><span>CFG=/usr/local/mysql/bin/mysql_config</span></pre>
			<pre><span>sh -c &quot;gcc -o progname `$CFG --cflags` progname.c `$CFG --libs`&quot;</span></pre>
			<p>需要使用“<span><span>sh –c”</span>，使得<span>shell</span>不将</span><strong><span>mysql_config</span></strong><span>的输出当作<span>1</span>个词对待。</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="threaded-clients"></a>
			25.2.15.&nbsp;如何生成线程式客户端</h3></div></div></div><a class="indexterm" name="id3031620"></a><a class="indexterm" name="id3031630"></a>
			<p>客户端库总是线程安全的。最大的问题在于从套接字读取的<span><span>net.c</span>中的子程序并不是中断安全的。或许你可能希望用自己的告警中断对服务器的长时间读取，以此来解决问题。如果为<span>SIGPIPE</span>中断安装了中断处理程序，套接字处理功能应是线程安全的。</span></p>
			<p>为了避免连接中断时放弃程序，<span>MySQL</span>将在首次调用<span>mysql_server_init</span><span>()</span>、<span>mysql_init()</span>或<span><span>mysql_connect()</span>时屏蔽<span>SIGPIPE</span></span>。如果你打算使用自己的<span><span>SIGPIPE</span>处理程序，</span>首先应调用<span><span>mysql_server_init()</span>，然后安装你的处理程序，</span></p>
			<p>在较旧的发布在我方网站上（<span>http://www.mysql.com/</span>）的二进制版本中，未用线程安全的选项对客户端库进行正常编译（默认情况下，编译的<span>Windows</span>二进制版本是线程安全的）。较新的二进制分发版应是正常的和线程安全的客户端库。</p>
			<p>为了获得能从其他线程中断客户端的线程式客户端，并在与<span>MySQL</span>服务器通信时设置超时，应使用“<span>-lmysys</span>”、“<span><span>-lmystrings”</span>和</span>“<span><span>-ldbug”</span>库，以及服务器使用的<span>net_serv.o</span></span>代码。</p>
			<p>如果你不需要使用中断或超时，可编译线程安全客户端库（<span>mysqlclient_r</span>）并使用它。。请参见<a href="apis.html#c" title="25.2. MySQL C API">25.2节，“MySQL C API”</a>。在该情况下，不必担心<span><span>net_serv.o</span>对象文件或其他</span><span>MySQL</span>库。</p>
			<p>使用线程式客户端并打算使用超时或中断时，可更好地利用<span><span>thr_alarm.c</span>文件中的子程序。如果你正在使用来自<span>mysys</span>库的子程序，唯一需要记住的事是首先调用<span>my_init()</span>！请参见</span><a href="apis.html#c-thread-functions" title="25.2.11. C API Threaded Function Descriptions">25.2.11节，“C API线程函数介绍”</a>。</p>
			<p>对于除<span><span>mysql_real_connect()</span>外的所有函数，在默认情况下它们均是线程安全的。在下面的说明中，介绍了编译线程安全客户端库的方法，</span>以及以线程安全方式使用它的方法。（下面关于<span><span>mysql_real_connect()</span>的说明实际上也适用于<span>mysql_connect()</span></span>，但由于<span><span>mysql_connect()</span>已不再被重视，</span>总应尽量使用<span>mysql_real_connect()</span>）。</p>
			<p>要想使<span><span>mysql_real_connect()</span>成为线程安全的，必须用下述命令再次编译</span>客户端库：</p>
			<pre><span>shell&gt; <span><b>./configure --enable-thread-safe-client</b></span></span></pre>
			<p>它创建了线程安全客户端库<span><span>libmysqlclient_r</span>。（假定</span>你的操作系统有线程安全的<span><span>gethostbyname_r()</span>函数）。按照连接，</span>该库是线程安全的。可遵循下述警告，使两个线程共享相同的连接： 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在相同的连接上，两个线程不能同时将查询发送到<span>MySQL</span>服务器。尤其是，必须确保在<span>mysql_query()</span>和<span><span>mysql_store_result()</span>之间，没有使用相同连接的其他线程。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>很多线程均能访问由<span><span>mysql_store_result()</span>检索的不同结果集。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果使用了<span><span>mysql_use_result</span>，务必确保无其他线程正在使用相同的连接，直至关闭了结果集为止。然而，对于线程式客户端，最好是共享相同的连接以使用<span>mysql_store_result()</span></span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果打算在相同的连接上使用多个线程，必须在<span>mysql_query()</span>和<span><span>mysql_store_result()</span>调用组合上拥有互斥锁。</span>一旦<span><span>mysql_store_result()</span>准备就绪，可释放锁定，其他线程可在相同的连接上执行查询。</span>
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果使用<span>POSIX</span>线程进行编程，可使用<span>pthread_mutex_lock()</span>和<span><span>pthread_mutex_unlock()</span>来建立并释放互斥锁。</span>
			</p>
			<p>如果你有<span>1</span>个调用<span>MySQL</span>函数的线程，而该函数未创建与<span>MySQL</span>数据库的连接，就需了解下述事宜：</p>
			<p>调用<span>mysql_init()</span>或<span>mysql_connect()</span>时，<span>MySQL</span>会为调试库使用的线程创建与线程相关的变量（尤其）。</p>
			<p>在线程调用<span>mysql_init()</span>或<span><span>mysql_connect()</span>之前，</span>如果调用了<span>MySQL</span>函数，该线程将没有所需的线程类变量，而且你很可能或早或晚结束于内核转储。</p>
			<p>要想使这些操作平稳工作，需要采取下述措施：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>如果程序在调用<span><span>mysql_real_connect()</span>之前需要调用任何其他<span>MySQL</span>函数，请在启动程序时调用<span>my_init()</span></span>。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span><span>调用任何<span>MySQL</span>函数之前，在线程处理程序中调用<span>mysql_thread_init()</span></span>。</p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>在线程中，调用<span><span>pthread_exit()</span>之前请调用<span>mysql_thread_end()</span></span>。这样，就能释放<span>MySQL</span>线程类变量使用的内存。 
			</p>
			<p>将客户端链接到<span>libmysqlclient_r</span>时，如果存在未定义的符号，可能会出错。在大多数情况下，其原因在于，未将线程库包含在<span>link/compile</span>行上。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="php"></a>25.3. MySQL PHP API</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#php-problems">
		25.3.1. 使用MySQL和PHP的常见问题</a></span></dt></dl></div><a class="indexterm" name="id3032032"></a>
		<p><span>PHP</span>是一种服务器端、<span>HTML</span>嵌入式脚本处理语言，可使用该语言创建动态网页。它可用于大多数操作系统和<span>Web</span>服务器，也能访问大多数常见数据库，包括<span>MySQL</span>。<span>PHP</span>可以作为单独程序运行，也能编译为模块，用于<span>Apache 
		Web</span>服务器。</p>
		<p><span>PHP</span>实际上提供了两种不同的<span>MySQL API</span>扩展：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span><span>mysql</span>：适用于<span>PHP</span>版本<span>4</span>和<span>5</span>，该扩展用于<span>MySQL 
		4.1</span>之前的<span>MySQL</span>版本。该扩展不支持<span>MySQL 
		5.1</span>中采用的、改进的鉴定协议，也不支持与预处理语句或多语句。如果打算与<span>MySQL 5.1</span>一起使用该扩展，应配置<span>MySQL</span>服务器，以使用“<strong><span>--old-passwords</span></strong>”选项（请参见<a href="problems.html#old-client" title="A.2.3. Client does not support authentication protocol">A.2.3节，“客户端不支持鉴定协议”</a>）。在<span>PHP</span>网站的文档中记录了该该扩展<span><a target="_top"  href="http://php.net/mysql">http://php.net/mysql</a></span>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span><span>mysqli</span>是“<span class="quote"><span>MySQL, 
		Improved</span></span>”的缩写，该扩展仅适用于<span>PHP 5</span>。它能用于<span>MySQL 
		4.1.1</span>和更高版本。该扩展完全支持<span>MySQL 5.1</span>中采用的鉴定协议，也支持预处理语句和多语句<span>API</span>。此外，该扩展还提供了先进的、面向对象的编程接口。在<span><a target="_top"  href="http://php.net/mysqli">http://php.net/mysqli</a></span>上，可找到关于<span>mysqli</span>扩展的文档。在<span><a target="_top"  href="http://www.zend.com/php5/articles/php5-mysqli.php">http://www.zend.com/php5/articles/php5-mysqli.php</a></span>处，给出了一篇有用的文章。</p>
		<p><span>PHP</span>分发版和文档均能从<span><a target="_top"  href="http://www.php.net/">PHP<span>网站</span></a></span>获得。</p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="php-problems"></a>
			25.3.1.&nbsp;使用MySQL和PHP的常见问题</h3></div></div></div><div class="itemizedlist">
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>错误：超出了最大执行时间，这是一种</span><span>PHP</span>限制，如果需要，进入文件<span><span>php.ini</span>，并设置最大执行时间（开始为<span>30</span>秒）。此外，还可以将每脚本允许使用的<span>RAM</span>增加一倍，</span>从<span>8MB</span>变为<span>16MB</span>，这也是个不错的主意。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>致命错误：在<span>…</span>中调用了不支持或未定义的<span>mysql_connect()</span>函数，这意味着，你的</span><span>PHP</span>版本不支持<span>MySQL</span>。你可以编译动态<span>MySQL</span>模块并将其加载到<span>PHP</span>，或使用内置的<span>MySQL</span>支持重新编译<span>PHP</span>。在<span>PHP</span>手册中，详细介绍了该进程。 
				</p>
				<p>
				<span>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>错误：对<span>&#39;uncompress&#39;</span>的未定义引用，</span>这意味着所编译的客户端库支持压缩客户端／服务器协议。更正方法是，用“<span>-lmysqlclient</span>”进行链接时，在最后添加“<span><span>-lz”</span>。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>错误：客户端不支持鉴定协议，与</span><span>MySQL 
				4.1.1</span>和更高版本一起使用较旧的<span>mysql</span>扩展时常会遇到该问题。可能的解决方案是：降级到<span>MySQL 
				4.0</span>，转向<span>PHP 5</span>和较新的<span><span>mysqli</span>扩展，或用<span>“--old-passwords”</span>配置<span>MySQL</span>服务器</span>（更多信息，请参见<a href="problems.html#old-client" title="A.2.3. Client does not support authentication protocol">A.2.3节，“客户端不支持鉴定协议”</a>）。</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="perl"></a>25.4. MySQL Perl API</h2></div></div></div><a class="indexterm" name="id3032259"></a><a class="indexterm" name="id3032269"></a><a class="indexterm" name="id3032276"></a><a class="indexterm" name="id3032284"></a>
		<p><span>Perl <span>DBI</span></span><span>模块为数据库访问提供了一个通用接口。</span>能够编写无需更改就能与不同的数据库引擎一起工作的<span>DBI</span>脚本。要想使用<span>DBI</span>，必须安装<span>DBI</span>模块，并为打算访问的每种服务器安装数据库驱动程序（<span>DBD</span>）模块。对于<span>MySQL</span>，该驱动程序是<span>DBD::mysql</span>模块。</p>
		<p><span>Perl DBI</span>是推荐的<span>Perl</span>接口。它取代了旧的名为<span><span>mysqlperl</span>的接口，<span>mysqlperl</span>已过时。</span></p>
		<p>关于<span>Perl DBI</span>支持的安装说明，请参见<a href="installing.html#perl-support" title="2.13. Perl Installation Notes">2.13节，“Perl安装注意事项”</a>。</p>
		<p><span>DBI</span>信息能够在命令行上提供，也能以在线方式提供，或采用印刷形式：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>一旦安装了<span>DBI</span>和<span>DBD::mysql</span>模块，可使用<span>perldoc</span><span>
		</span>命令在命令行上获取关于它们的信息：</p>
		<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; <span><b>perldoc DBI</b></span></span></pre>
		<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; <span><b>perldoc DBI::FAQ</b></span></span></pre>
		<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; <span><b>perldoc DBD::mysql</b></span></span></pre>
		<p>也可以使用<span>pod2man</span>、<span><span>pod2html</span>等</span>将这类信息转换为其他格式。 
		</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>关于<span>Perl DBI</span>的在线信息，请访问<span>DBI</span>网站，<span><a target="_top"  href="http://dbi.perl.org/">http://dbi.perl.org/</a></span>。该站点还提供了<span>1</span>个一般性<span>DBI</span>邮件列表。<span>MySQL 
		AB</span>提供了<span>1</span>个专门针对<span>DBD::mysql</span><span>
		</span>的邮件列表，请参见<span><a title="1.7.1.1.&nbsp;The MySQL Mailing Lists"  href="file:///H:/introduction.html#mailing-list">1.7.1.1
		<span>“</span>MySQL<span>邮件列表”</span></a></span>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>至于印刷版信息，官方的<span>DBI</span>书籍是<em><span>编程<span>Perl 
		DBI</span></span></em>（<span>Alligator Descartes</span>和<span>Tim 
		Bunce</span>，<span>O&#39;Reilly &amp; Associates, 2000</span>）。关于该书的信息，请访问<span>DBI</span>网站<span><a target="_top"  href="http://dbi.perl.org/">http://dbi.perl.org/</a></span>。</p>
		<p>关于与<span>MySQL</span>一起使用<span>DBI</span>的专门信息，请参见<em><span>针对<span>Web</span>的<span>MySQL</span>和<span>Perl</span>（</span></em><span>Paul 
		DuBois, New Riders, 2001</span>）。该书的网站是<span><a target="_top"  href="http://www.kitebird.com/mysql-perl/">http://www.kitebird.com/mysql-perl/</a></span>。</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="cplusplus"></a>25.5. MySQL C++ API</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#borland-c-plus-plus">25.5.1. Borland C++</a></span></dt></dl></div><a class="indexterm" name="id3032468"></a><a class="indexterm" name="id3032474"></a>
		<p><span>MySQL++</span>是用于<span>C++</span>的<span>MySQL 
		API</span>。<span>Warren Young</span>负责该项目。要想了解更多信息，请访问<span>http://www.mysql.com/products/mysql++/</span>。</p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="borland-c-plus-plus"></a>25.5.1. Borland C++</h3></div></div></div><a class="indexterm" name="id3032506"></a></div></div><div class="section"><div class="titlepage"><div><div>
	可以使用<span>Borland C++ 5.02</span>编译<span>MySQL Windows</span>源码（<span>Windows</span>源码仅包括用于<span>Microsoft 
	VC++</span>的项目，对于<span>Borland C++</span>，你将不得不自己编制项目文件）。<p>使用<span>Borland 
	C++</span>时的<span>1</span>个已知问题是，它采用了不同于<span>VC++</span>的结构对齐方式。这意味着，如果你打算与<span>Borland 
	C++</span>一起使用默认的<span>libmysql.dll</span>库（它是使用<span>VC++</span>编译的），将会遇到问题。为了避免该问题，仅应调用将<span>Null</span>作为参量的<span><span>mysql_init()</span>，而不是预先分配<span>MYSQL</span>结构。</span></p>
	<h2 class="title"><a name="python"></a>25.6. MySQL Python API</h2></div></div></div><a class="indexterm" name="id3032556"></a></div><div class="section"><div class="titlepage"><div><div>
		<span><span>MySQLdb</span>为</span><span>Python</span>提供了<span>MySQL</span>支持，它符合<span>Python 
		DB API</span>版本<span>2.0</span>的要求，可在<span><a target="_top"  href="http://sourceforge.net/projects/mysql-python/">http://sourceforge.net/projects/mysql-python/</a></span>上找到它。<h2 class="title"><a name="tcl"></a>25.7. MySQL Tcl API</h2></div></div></div><a class="indexterm" name="id3032588"></a></div><div class="section"><div class="titlepage"><div><div>
		<span>MySQLtcl</span>是一种简单的<span>API</span>，用于从<span>Tcl</span>编程语言访问<span>MySQL</span>数据库服务器。可在<span><a target="_top"  href="http://www.xdobry.de/mysqltcl/">http://www.xdobry.de/mysqltcl/</a></span>上找到它。<h2 class="title"><a name="eiffel"></a>25.8. MySQL Eiffel Wrapper</h2></div></div></div><a class="indexterm" name="id3032620"></a><a class="indexterm" name="id3032627"></a>
		<p><span>Eiffel MySQL</span>是一种与<span>MySQL</span>数据库服务器的接口，它采用的是<span>Eiffel</span>编程语言，由<span>Michael 
		Ravits</span>编写。可在<span><a target="_top"  href="http://efsa.sourceforge.net/archive/ravits/mysql.htm">http://efsa.sourceforge.net/archive/ravits/mysql.htm</a></span>上找到它。</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="programming-utilities"></a>
		25.9.&nbsp;MySQL程序开发实用工具</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#msql2mysql">
			25.9.1. msql2mysql：转换mSQL程序以用于MySQL</a></span></dt><dt><span class="section"><a href="apis.html#mysql-config">
			25.9.2. mysql_config：获取编译客户端的编译选项</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div>
			在本节中，介绍了开发<span>MySQL</span>程序时可能会有用的一些实用工具。<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			msql2mysql</span><span> </span></p>
			<p><span>1</span>种<span>shell</span>脚本，用于将<span><span>mSQL</span>程序转换为</span><span>MySQL</span>程序。它不能处理所有情况，但能为转换提供良好的开端。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			mysql_config</span><span> </span></p>
			<p><span>1</span>种<span>shell</span>脚本，能生成编译<span>MySQL</span>程序时所需的选项值。</p>
			<h3 class="title"><a name="msql2mysql"></a>
			25.9.1.&nbsp;msql2mysql：转换mSQL程序以用于MySQL</h3></div></div></div>
			<p>最初，开发的<span>MySQL C API</span>很类似为<span>mSQL</span>数据库系统开发的<span>API</span>。正因为如此，通过更改<span>C 
			API</span>函数的名称，通常能相对容易地转换<span>mSQL</span>程序，使之用于<span>MySQL</span>。</p>
			<p><strong><span>msql2mysql</span></strong>实用工具用于将<span>mSQL 
			C API</span>函数调用转换为其<span>MySQL</span>对等物。<strong><span>msql2mysql</span></strong>能够转换位于恰当位置输入文件，在执行具体转换之前复制原件。例如，可采用下述方式使用<strong><span>msql2mysql</span></strong>：</p>
			<pre><span>shell&gt; <span><b>cp client-prog.c client-prog.c.orig</b></span></span></pre>
			<pre><span>shell&gt; <span><b>msql2mysql client-prog.c</b></span></span></pre>
			<pre><span>client-prog.c converted</span></pre>
			<p>然后，检查<span><span>client-prog.c</span>，并执行可能需要的</span>后期转换修订。</p>
			<p><strong><span>msql2mysql</span></strong>使用<strong><span>replace</span></strong>实用工具来替换函数名。请参见<a href="client-side-scripts.html#replace-utility" title="8.14. replace — A String-Replacement Utility">8.14节，“replace：字符串替换实用工具”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-config"></a>
			25.9.2.&nbsp;mysql_config：获取编译客户端的编译选项</h3></div></div></div>
			<p><strong><span>mysql_config</span></strong>提供了关于编译<span>MySQL</span>客户端以及将其连接到<span>MySQL</span>的有用信息。</p>
			<p><strong><span>mysql_config</span></strong>支持下述选项：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--cflags</span><span>
			</span></p>
			<p>编译器标志，用于查找包含文件，以及编译<span><span>libmysqlclient</span>库时所要使用的</span>关键编译器标志和定义。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			--include</span><span> </span></p>
			<p>编译器选项，用于查找<span>MySQL</span>包含文件（注意，正常情况下应使用“<span><span>—cflags”</span>而不是该选项）。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--libmysqld-libs</span><span>,
			<span>---embedded</span> </span></p>
			<p>与<span>MySQL</span>嵌入式服务器进行链接所需的库和选项。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--libs</span><span>
			</span></p>
			<p>与<span>MySQL</span>客户端库进行链接所需的库和选项。 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--libs_r</span><span>
			</span></p>
			<p>与线程安全<span>MySQL</span>客户端库进行链接所需的库和选项。 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--port</span><span>
			</span></p>
			<p>默认的<span>TCP/IP</span>端口号，配置<span>MySQL</span>时定义。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--socket</span><span>
			</span></p>
			<p>默认的<span>Unix</span>套接字文件，配置<span>MySQL</span>时定义。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			--version</span><span> </span></p>
			<p>版本号以及<span>MySQL</span>分发版的版本。 
			</p>
			<p>如果未使用任何选项调用了<strong><span>mysql_config</span></strong>，将显示它所支持的所有选项的列表，以及它们的值：</p>
			<pre><span>shell&gt; <span><b>mysql_config</b></span></span></pre>
			<pre><span>Usage: /usr/local/mysql/bin/mysql_config [options]</span></pre>
			<pre><span>Options:</span></pre>
			<pre><span>&nbsp; --cflags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-I/usr/local/mysql/include/mysql -mcpu=pentiumpro]</span></pre>
			<pre><span>&nbsp; --include&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-I/usr/local/mysql/include/mysql]</span></pre>
			<pre><span>&nbsp; --libs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-L/usr/local/mysql/lib/mysql -lmysqlclient -lz</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -lcrypt -lnsl -lm -L/usr/lib -lssl -lcrypto]</span></pre>
			<pre><span>&nbsp; --libs_r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-L/usr/local/mysql/lib/mysql -lmysqlclient_r</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -lpthread -lz -lcrypt -lnsl -lm -lpthread]</span></pre>
			<pre><span>&nbsp; </span><span>--socket&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [/tmp/mysql.sock]</span></pre>
			<pre><span>&nbsp; --port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;[3306]</span></pre>
			<pre><span>&nbsp; --version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [4.0.16]</span></pre>
			<pre><span>&nbsp; </span><span>--libmysqld-libs [-L/usr/local/mysql/lib/mysql -lmysqld -lpthread -lz</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -lcrypt -lnsl -lm -lpthread -lrt]</span></pre>
			<p>可以在命令行上使用<strong><span>mysql_config</span></strong>，并包含针对特定选项的值。例如，要想编译<span>MySQL</span>客户端程序，可使用<strong><span>mysql_config</span></strong>，如下例所示：</p>
			<pre><span>shell&gt; <span><b>CFG=/usr/local/mysql/bin/mysql_config</b></span></span></pre>
			<pre><span>shell&gt; <span><b>sh -c &quot;gcc -o progname `$CFG --cflags` progname.c `$CFG --libs`&quot;</b></span></span></pre>
			<p>以这种方式使用<strong><span>mysql_config</span></strong>时，务必在字符<span>(</span>‘<span>`</span>’<span>)</span>内调用它。这样，就能通知<span>shell</span>执行它，并将其输出代入到环境命令中。</div></div></div><div><hr>
	<p><a name="OLE_LINK1">这是MySQL参考手册的翻译版本，关于MySQL参考手册，请访问</a><a target="_top"  href="http://dev.mysql.com/doc/mysql/en">dev.mysql.com</a>。 
	原始参考手册为英文版，与英文版参考手册相比，本翻译版可能不是最新的。 </div>
</body></html>
