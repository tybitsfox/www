<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Chapter 7. Optimization</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="up" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="prev" href="replication.html" title="Chapter 6. Replication in MySQL"><link rel="next" href="client-side-scripts.html" title="Chapter 8. Client and Utility Programs">
<style>
<!--
span.GramE
	{}
 li.MsoNormal
	{mso-style-parent:"";
	margin-bottom:.0001pt;
	font-size:12.0pt;
	
	; margin-left:0cm; margin-right:0cm; margin-top:0cm}
span.quote
	{}
 table.MsoNormalTable
	{mso-style-parent:"";
	font-size:10.0pt;
	
	}
-->
</style>
</head><body><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="optimization"></a>
	第7章：优化</h2></div></div></div><div class="toc"><p><b>
	目录</b></p><dl><dt><span class="section"><a href="optimization.html#optimize-overview">7.1. 
			优化概述</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#design-limitations">7.1.1. 
				MySQL设计局限与折衷</a></span></dt><dt><span class="section"><a href="optimization.html#portability">
				7.1.2. 为可移植性设计应用程序</a></span></dt><dt><span class="section"><a href="optimization.html#internal-use">
				7.1.3. 我们已将MySQL用在何处？</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-benchmarks">
				7.1.4. MySQL基准套件</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">
				7.1.5. 使用自己的基准</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#query-speed">
			7.2. 优化SELECT语句和其它查询</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#explain">7.2.1. 
				EXPLAIN语法（获取SELECT相关信息）<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">
				7.2.2. 估计查询性能</a></span></dt><dt><span class="section"><a href="optimization.html#select-speed">
				7.2.3. SELECT查询的速度</a></span></dt><dt><span class="section"><a href="optimization.html#where-optimizations">
				7.2.4. MySQL怎样优化WHERE子句<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#range-optimization">
				7.2.5. 范围优化</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-optimization">
				7.2.6. 索引合并优化</a></span></dt><dt><span class="section"><a href="optimization.html#is-null-optimization">
				7.2.7. MySQL如何优化IS NULL<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#distinct-optimization">
				7.2.8. MySQL如何优化DISTINCT<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#left-join-optimization">
				7.2.9. MySQL如何优化LEFT JOIN和RIGHT JOIN</a></span></dt><dt><span class="section"><a href="optimization.html#nested-joins">
				7.2.10. MySQL如何优化嵌套Join</a></span></dt><dt><span class="section"><a href="optimization.html#outer-join-simplification">
				7.2.11. MySQL如何简化外部联合</a></span></dt><dt><span class="section"><a href="optimization.html#order-by-optimization">
				7.2.12. MySQL如何优化ORDER BY<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#group-by-optimization">
				7.2.13. MySQL如何优化GROUP BY<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#limit-optimization">
				7.2.14. MySQL如何优化LIMIT<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#how-to-avoid-table-scan">
				7.2.15. 如何避免表扫描</a></span></dt><dt><span class="section"><a href="optimization.html#insert-speed">
				7.2.16. INSERT语句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#update-speed">
				7.2.17. UPDATE语句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#delete-speed">
				7.2.18. DELETE语句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#tips">
				7.2.19. 其它优化技巧</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#locking-issues">
			7.3. 锁定事宜</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#internal-locking">
				7.3.1. 锁定方法</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">
				7.3.2. 表锁定事宜</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-database-structure">
			7.4. 优化数据库结构</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#design">
				7.4.1. 设计选择</a></span></dt><dt><span class="section"><a href="optimization.html#data-size">
				7.4.2. 使你的数据尽可能小</a></span></dt><dt><span class="section"><a href="optimization.html#indexes">
				7.4.3. 列索引</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">
				7.4.4. 多列索引</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-indexes">
				7.4.5. MySQL如何使用索引</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">
				7.4.6. MyISAM键高速缓冲</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-index-statistics">7.4.7. 
				MyISAM索引统计集合</a></span></dt><dt><span class="section"><a href="optimization.html#open-tables">
				7.4.8. MySQL如何计算打开的表</a></span></dt><dt><span class="section"><a href="optimization.html#table-cache">
				7.4.9. MySQL如何打开和关闭表</a></span></dt><dt><span class="section"><a href="optimization.html#creating-many-tables">
				7.4.10. 在同一个数据库中创建多个表的缺陷</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-the-server">
			7.5. 优化MySQL服务器</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#system">
				7.5.1. 系统因素和启动参数的调节</a></span></dt><dt><span class="section"><a href="optimization.html#server-parameters">
				7.5.2. 调节服务器参数</a></span></dt><dt><span class="section"><a href="optimization.html#controlling-optimizer">
				7.5.3. 控制查询优化器的性能</a></span></dt><dt><span class="section"><a href="optimization.html#compile-and-link-options">
				7.5.4. 编译和链接怎样影响MySQL的速度</a></span></dt><dt><span class="section"><a href="optimization.html#memory-use">
				7.5.5. MySQL如何使用内存</a></span></dt><dt><span class="section"><a href="optimization.html#dns">
				7.5.6. MySQL如何使用DNS</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#disk-issues">
			7.6. 磁盘事宜</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#symbolic-links">
				7.6.1. 使用符号链接</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div>
		<p>
		优化是一个复杂的任务，因为最终要求了解整个待优化的系统。尽管可以进行局部优化而不需要了解系统或应用程序，为了优化得更好，你必须知道更多的信息。</p>
		<p>
		本章解释并给出不同的优化<span>MySQL</span>的方法示例。但要记住总有一些其它方法使系统更快，尽管需要更多的工作。</p>
		<h2 class="title"><a name="optimize-overview"></a>7.1. 优化概述</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#design-limitations">
		7.1.1. MySQL设计局限与折衷</a></span></dt><dt><span class="section"><a href="optimization.html#portability">
		7.1.2. 为可移植性设计应用程序</a></span></dt><dt><span class="section"><a href="optimization.html#internal-use">
		7.1.3. 我们已将MySQL用在何处？</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-benchmarks">
		7.1.4. MySQL基准套件</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">
		7.1.5. 使用自己的基准</a></span></dt></dl></div>
		<p>
		使一个系统更快的最重要因素当然是基本设计。此外，还需要知道系统正做什么样的事情，以及瓶颈是什么。</p>
		<p>
		最常见的系统瓶颈是：</p>
		<ul type="disc">
			<li>
			磁盘搜索。需要花时间从磁盘上找到一个数据，用在现代磁盘的平均时间通常小于<span>10ms</span>，因此理论上我们能够每秒大约搜索<span>1000</span>次。这个时间在新磁盘上提高不大并且很难为一个表进行优化。优化它的方法是将数据分布在多个磁盘上。</li>
			<li>
			磁盘读<span>/</span>写。当磁盘放入正确位置后，我们需要从中读取数据。对于现代的磁盘，一个磁盘至少传输<span>10-20Mb/s</span>的吞吐。这比搜索要容易优化，因为你能从多个磁盘并行地读。</li>
			<li>
			<span>CPU</span>周期。我们将数据读入内存后，需要对它进行处理以获得我们需要的结果。表相对于内存较小是最常见的限制因素。但是对于小表，速度通常不成问题。</li>
		</ul>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>内存带宽。当<span>CPU</span>需要的数据超出<span>CPU</span>缓存时，主缓存带宽就成为内存的一个瓶颈。这在大多数系统正是一个不常见的瓶颈但是你应该知道它。</p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="design-limitations"></a>
			7.1.1.&nbsp;MySQL设计局限与折衷</h3></div></div></div><a class="indexterm" name="id2798886"></a><a class="indexterm" name="id2798896"></a>
			<p>
			当使用<span>MyISAM</span>存储引擎时，<span>MySQL</span>使用极快速的表锁定，以便允许多次读或一次写。使用该存储引擎的最大问题出现在同一个表中进行混合稳定数据流更新与慢速选择。如果这只是某些表的问题，你可以使用另一个存储引擎。参见<a href="storage-engines.html">第15章：</a><a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types"><i>存储引擎和表类型</i></a>。</p>
			<p>
			<span>MySQL</span>可以使用事务表和非事务表。为了更容易地让非事务表顺利工作<span>(</span>如果出现问题不能回滚<span>)</span>，<span>MySQL</span>采用下述规则。请注意这些规则<em><span>只适用于</span></em>不运行在严格模式下或为<span>INSERT</span>或<span>UPDATE</span>使用<span>IGNORE</span>规定程序时。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有列有默认值。请注意当运行在严格<span>SQL</span>模式<span>(</span>包括<span>TRADITIONAL</span><span> 
			SQL</span>模式<span>)</span>时，必须为<span>NOT 
			NULL</span>列指定默认值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果向列内插入不合适的或超出范围的值，<span>MySQL</span>将该列设定为“最好的可能的<span class="quote">值</span>”，而不是报告错误。对于数字值，为<span>0</span>、可能的最小值或最大值。对于字符串，为空字符串或列内可以保存的字符串。请注意当运行在严格模式或<span>TRADITIONAL</span><span> 
			SQL</span>模式时该行为不 适用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有表达式的计算结果返回一个表示错误状况的信号。例如，<span>1/0</span>返回<span>NULL</span>。<span>(</span>使用<span>ERROR_FOR_DIVISION_BY_ZERO</span><span> 
			SQL</span>模式可以更改该行为<span>)</span>。</p>
			<p>
			如果正使用非事务表，不应该使用<span>MySQL</span>来检查列的内容。一般情况，最安全的<span>(</span>通常是最快的<span>)</span>方法径是让应用程序确保只向数据库传递合法值。</p>
			<p>
			相关详细信息参见<a href="introduction.html#constraints" title="1.8.6. How MySQL Deals with Constraints">1.8.6节，“MySQL处理约束的方式”</a>和<a href="sql-syntax.html#insert" title="13.2.4. INSERT Syntax">13.2.4节，“INSERT语法”</a>或<a href="database-administration.html#server-sql-mode" title="5.3.2. The Server SQL Mode">5.3.2节，“SQL服务器模式”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="portability"></a>
			7.1.2.&nbsp;为可移植性设计应用程序</h3></div></div></div><a class="indexterm" name="id2799063"></a><a class="indexterm" name="id2799069"></a><a class="indexterm" name="id2799076"></a>
			<p>
			<span>因为不同<span>SQL</span>服务器实现了标准<span>SQL</span>的不同部分，需要花功夫来编写可移植的<span>SQL</span>应用程序。对很简单的选择<span>/</span>插入，很容易实现移植，但是需要的功能越多则越困难。如果想要应用程序对很多数据库系统都快，它变得更难！</span></p>
			<p>
			为了使一个复杂应用程序可移植，你需要选择它应该工作的<span>SQL</span>服务器，并确定这些服务器支持什么特性。</p>
			<p>
			所有数据库都有一些弱点。这就是它们不同的设计折衷导致的不同行为。</p>
			<p>
			可以使用<strong><span>MySQL</span></strong>的<b><span>crash-me</span></b>程序来找出能用于数据库服务器选择的函数、类型和限制。<b><span>crash-me</span></b>并不能找出所有的特性，但是其广度仍然很合理，可以进行大约<span>450</span>个测试。</p>
			<p>
			<strong><span>crash-me</span></strong>可以提供的一种类型的信息的例子：如果想要使用<span>Informix</span>或<span>DB2</span>，不应该使用超过<span>18</span>个字符的列名。</p>
			<p><b><span>
			crash-me</span></b>程序和<strong><span>MySQL</span></strong>基准程序是独立于数据库的。通过观察它们是如何编写的，编可以知道必须为编写独立于数据库的应用程序做什么。基准本身可在<strong><span>MySQL</span></strong>源码分发的<tt ><span>“sql-bench”</span></tt>目录下找到。它们用<span>DBI</span>数据库接口以<span>Perl</span>写成。使用<span>DBI</span>本身即可以解决部分移植性问题，因为它提供与数据库无关的的存取方法。</p>
			<p>如果你为数据库的独立性而努力，需要很好地了解每个<span>SQL</span>服务器的瓶颈。例如，<strong><span style="font-family:
宋体;">MySQL</span></strong>在检索和更新<span>MyISAM</span>表记录方面很快，但是在同一个表上混合慢速读者和写者方面有一个问题。另一方面，当你试图访问最近更新了<span>(</span>直到它们被刷新到磁盘上<span>)</span>的行时，在<span>Oracle</span>中有一个很大的问题。事务数据库总的来说在从记录文件表中生成总结表方面不是很好，因为在这种情况下，行锁定几乎没有用。</p>
			<p>
			为了使应用程序“确实”独立于数据库，需要定义一个容易扩展的接口，用它可操纵数据。因为<span>C++</span>在大多数系统上可以适用，使用数据库的一个<span>C++
			</span>类接口是有意义的。</p>
			<p>如果你使用某个数据库特定的功能<span>(</span>例如<strong><span>MySQL</span><span>专用的</span></strong><span>REPLACE</span>语句<span>)</span>，应该为<span>SQL</span>服务器编码一个方法以实现同样的功能。尽管慢些，但确允许其它服务器执行同样的任务。</p>
			<p>用<strong><span>MySQL</span></strong>，可以使用<span>/*! 
			*/</span>语法把<strong><span style="font-family:
宋体;">MySQL</span></strong>特定的关键词加到查询中。在<span>/**/</span>中的代码将被其它大多数<span>SQL</span>服务器视为注释<span>(</span>并被忽略<span>)</span>。</p>
			<p>如果高性能真的比准确性更重要，就像在一些<span>web</span>应用程序那样，一种可行的方法是创建一个应用层，缓存所有的结果以便得到更高的性能。通过只是让旧的结果在短时间后‘过期’，能保持缓存合理地刷新。这在极高负载的情况下是相当不错的，在此情况下，能动态地增加缓存并且设定较高的过期时限直到一切恢复正常。</p>
			<p>
			在这种情况下，表创建信息应该包含缓存初始大小和表刷新频率等信息。</p>
			<p>
			实施应用程序缓存的一种方法是使用<span>MySQL</span>查询缓存。启用查询缓存后，服务器可以确定是否可以重新使用查询结果。这样简化了你的应用程序。参见<a href="database-administration.html#query-cache" title="5.13. The MySQL Query Cache">5.13节，“MySQL查询高速缓冲”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="internal-use"></a>
			7.1.3.&nbsp;我们已将MySQL用在何处？</h3></div></div></div><a class="indexterm" name="id2799272"></a><a class="indexterm" name="id2799282"></a>
			<p>
			该节描述了<span>Mysql</span>的早期应用程序。</p>
			<p>在<span>MySQL</span>最初开发期间，<span>MySQL</span>的功能适合大多数客户。<span>MySQL</span>为瑞典的一些最大的零售商处理数据仓库。</p>
			<p>
			我们从所有商店得到所有红利卡交易的每周总结，并且我们期望为所有店主提供有用的信息以帮助他们得出他们的广告战如何影响他们的顾客。</p>
			<p>数据是相当巨量的<span>(</span>大约每月<span>7</span>百万宗交易总结<span>)</span>并且我们保存<span>4-10</span>年来的数据需要呈现给用户。我们每周从顾客那里得到请求，他们想要“立刻”访问来自该数据的新报告。</p>
			<p>
			我们通过每月将所有信息存储在压缩的“交易”表中来解决它。我们有一套简单的宏<span>/</span>脚本用来生成来自交易表的不同条件<span>(
			</span>产品组、顾客<span>id</span>，商店<span>...)</span>的总结表。报告是由一个进行语法分析网页的小<span>perl</span>脚本动态生成的网页，在脚本中执行<span>SQL</span>语句并且插入结果。我们很想使用<span>PHP</span>或<b><span>mod_perl</span></b>，但是那时它们还不可用。</p>
			<p>对图形数据，我们用<span>C</span>语言编写了一个简单的工具，它能基于那些结果处理<span>SQL</span>查询结果并生成<span>GIF</span>图形。该工具也从分析<span>Web</span>网页的<span>perl</span>脚本中动态地执行。</p>
			<p>
			在大多数情况下，一个新的报告通过简单地复制一个现有脚本并且修改其中的<span>SQL</span>查询来完成。在一些情况下，我们将需要把更多的列加到一个现有的总结表中或产生一个新的，但是这也相当简单，因为我们在磁盘上保存所有交易表。（目前我们大约有<span>50G</span>的交易表和<span>200G</span>的其它顾客数据<span>)</span>。 
			</p>
			<p>我们也让我们的顾客直接用<span>ODBC</span>访问总结表以便高级用户能自己用这些数据进行试验。</p>
			<p>
			该系统工作得很好，我们可以毫无问题地用很适度的<span>Sun Ultra SPARC</span>工作站硬件<span>(2x200MHz)</span>来处理数据。该系统被逐步移植到了<span>Linux</span>中。</p>
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title"><a name="mysql-benchmarks"></a>7.1.4.&nbsp;MySQL基准套件</h3>
					</div></div></div><a class="indexterm" name="id2799384"></a>
			<a class="indexterm" name="id2799391"></a>
			<p>
			<span>本节应该包含<strong><span>MySQL</span></strong>基准套件<span>(</span>和</span><span><b><span>crash-me</span></b></span><span>)</span><span>的技术描述，但是该描述还没写成。目前，你可以通过在</span><span >MySQL</span><span>源码</span><span>分发中的</span><tt ><span>“sql-bench”</span></tt><span>目录下的代码和结果了解基准套件是如何工作的。</span></p>
			<p>
			<span>通过基准用户可以了解一个给定的<span>SQL</span>实现在哪方面执行得很好或很糟糕。</span></p>
			<p>
			注意，这个基准是单线程的，它可以测量操作执行的最小时间。我们计划将来在基准套件中添加多线程测试。</p>
			<p>
			要使用基准套件，必须满足下面的要求：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>基准套件随<span>MySQL</span>源码分发提供。可以从<span><a target="_top"  href="http://dev.mysql.com/downloads/">http://dev.mysql.com/downloads/</a></span>下载分发，或者使用当前的开发源码树<span>(</span>参见<a href="installing.html#installing-source-tree" title="2.8.3. Installing from the Development Source Tree">2.8.3节，“从开发源码树安装”</a><span>)</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>基准脚本用<span>Perl</span>编写而成，使用<span>Perl 
			DBI</span>模块访问数据库服务器，因此必须安装<span>DBI</span>。还需要为每个待测试的服务器提供服务器专用<span>DBD</span>驱动程序。例如，要测试<span>MySQL</span>、<span>PostgreSQL</span>和<span>DB2</span>，必须安装<span><span>DBD::mysql</span><span>、<span>DBD::Pg</span></span></span>和<span>DBD::DB2</span>模块。参见<a href="installing.html#perl-support" title="2.13. Perl Installation Notes">2.13节，“Perl安装注意事项”</a>。</p>
			<p>
			获得<span>MySQL</span>源码分发后，可以在<span>sql-bench</span>目录找到基准套件。要运行基准测试，应构建<span>MySQL</span>，然后进入<span>sql-bench</span>目录并执行<span>run-all-tests</span>脚本：</p>
			<p><span>shell&gt; <b>cd sql-bench</b></span></p>
			<p><span>shell&gt; <b>perl run-all-tests 
			--server=<i>server_name</i></b></span></p>
			<p>
			<span><i>
			<span>server_name</span></i></span>是一个支持的服务器。要获得所有选项和支持的服务器，调用命令：</p>
			<pre><span >shell&gt; </span><b><span >perl run-all-tests --help</span></b></pre>
			<p>
			<strong><span>crash-me</span></strong>脚本也位于<span>sql-bench</span>目录。<strong><span>crash-me</span></strong>尝试通过实际运行查询确定数据库支持的特性以及其功能和限制。例如，它确定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>支持什么列类型</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>支持多少索引</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>支持什么函数</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>查询可以多大</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>VARCHAR</span>列可以多大</p>
			<p>
			关于一些可移植的基准程序的例子，参见<span>MySQL</span>基准套件。请参见<a href="optimization.html#mysql-benchmarks" title="7.1.4. The MySQL Benchmark Suite">7.1.4节，“MySQL基准套件”</a>。可以利用这个套件的任何程序并且根据你的需要修改它。通过这样做，可以尝试不同的问题的解决方案并测试哪一个是最好的解决方案。</p>
			<p>
			另一个免费基准套件是开放源码数据库基准套件，参见<span><a target="_top"  href="http://osdb.sourceforge.net/">http://osdb.sourceforge.net/</a></span>。</p>
			<p>
			在系统负载繁重时出现一些问题是很普遍的，并且很多客户已经与我们联系了，他们在生产系统中有一个<span>(</span>测试<span>)</span>系统并且有负载问题。大多数情况下，性能问题经证明是与基本数据库设计有关的问题<span>(</span>例如，表扫描在高负载时表现不好<span>)</span>或操作系统或库问题。如果系统已经不在生产系统中，它们大多数将<strong><span>很</span></strong>容易修正。</p>
			<p>
			为了避免这样的问题，应该把工作重点放在在可能最坏的负载下测试你的整个应用程序。你可以使用<span>Super 
			Smack</span>。该工具可以从<span><a target="_top"  href="http://jeremy.zawodny.com/mysql/super-smack/">http://jeremy.zawodny.com/mysql/super-smack/</a></span>获得。正如它的名字所建议，它可以根据你的需要提供合理的系统，因此确保只用于你的开发系统。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="query-speed"></a>
		7.2.&nbsp;优化SELECT语句和其它查询</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#explain">7.2.1. 
			EXPLAIN语法（获取SELECT相关信息）<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">
			7.2.2. 估计查询性能</a></span></dt><dt><span class="section"><a href="optimization.html#select-speed">
			7.2.3. SELECT查询的速度</a></span></dt><dt><span class="section"><a href="optimization.html#where-optimizations">
			7.2.4. MySQL怎样优化WHERE子句<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#range-optimization">
			7.2.5. 范围优化</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-optimization">
			7.2.6. 索引合并优化</a></span></dt><dt><span class="section"><a href="optimization.html#is-null-optimization">
			7.2.7. MySQL如何优化IS NULL<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#distinct-optimization">
			7.2.8. MySQL如何优化DISTINCT<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#left-join-optimization">
			7.2.9. MySQL如何优化LEFT JOIN和RIGHT JOIN</a></span></dt><dt><span class="section"><a href="optimization.html#nested-joins">
			7.2.10. MySQL如何优化嵌套Join</a></span></dt><dt><span class="section"><a href="optimization.html#outer-join-simplification">
			7.2.11. MySQL如何简化外部联合</a></span></dt><dt><span class="section"><a href="optimization.html#order-by-optimization">
			7.2.12. MySQL如何优化ORDER BY<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#group-by-optimization">
			7.2.13. MySQL如何优化GROUP BY<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#limit-optimization">
			7.2.14. MySQL如何优化LIMIT<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#how-to-avoid-table-scan">
			7.2.15. 如何避免表扫描</a></span></dt><dt><span class="section"><a href="optimization.html#insert-speed">
			7.2.16. INSERT语句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#update-speed">
			7.2.17. UPDATE语句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#delete-speed">
			7.2.18. DELETE语句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#tips">
			7.2.19. 其它优化技巧</a></span></dt></dl></div><a class="indexterm" name="id2799739"></a><a class="indexterm" name="id2799749"></a><a class="indexterm" name="id2799759"></a><div class="section"><div class="titlepage"><div><div>
			<p>
			首先，影响所有语句的一个因素是：你的许可设置得越复杂，所需要的开销越多。</p>
			<p>
			执行<span>GRANT</span>语句时使用简单的许可，当客户执行语句时，可以使<span>MySQL</span>降低许可检查开销。例如，如果未授予任何表级或列级权限，服务器不需要检查<span >tables_priv</span>和<span >columns_priv</span>表的内容。同样地，如果不对任何
			账户进行限制，服务器不需要对资源进行统计。如果查询量很高，可以花一些时间使用简化的授权结构来降低许可检查开销。</p>
			<p>
			如果你的问题是与具体<span>MySQL</span>表达式或函数有关，可以使用<strong><span>mysql</span></strong>客户程序所带的<span>BENCHMARK()</span>函数执行定时测试。其语法为<span >BENCHMARK(<i>loop_count</i>,<i>expression</i>)</span>。例如：</p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT BENCHMARK(1000000,1+1)</span><span>；</span></b></span></pre>
			<pre><span>+------------------------+</span></pre>
			<pre><span>| BENCHMARK(1000000,1+1) |</span></pre>
			<pre><span>+------------------------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
			<pre><span>+------------------------+</span></pre>
			<pre><span>1 row in set (0.32 sec)</span></pre>
			<p>
			上面结果在<span>PentiumII 
			400MHz</span>系统上获得。它显示<strong><span>MySQL</span></strong>在该系统上在<span>0.32</span>秒内可以执行<span>1,000,000</span>个简单的<span>+</span>表达式运算。</p>
			<p>所有<strong><span style="font-family:
宋体;">MySQL</span></strong>函数应该被高度优化，但是总有可能有一些例外。<span >BENCHMARK()</span>是一个找出是否查询有问题的优秀的工具。</p>
			<h3 class="title"><a name="explain"></a>7.2.1. EXPLAIN语法（获取SELECT相关信息）<code class="literal"></code></h3></div></div></div><a class="indexterm" name="id2799867"></a><a class="indexterm" name="id2799876"></a>
			<pre><span>EXPLAIN </span><span><i><span>tbl_name</span></i></span></pre>
			<p>
			或：</p>
			<pre><span>EXPLAIN [EXTENDED] SELECT </span><span><i><span>select_options</span></i></span></pre>
			<p>
			<span>EXPLAIN</span>语句可以用作<span >DESCRIBE</span>的一个同义词，或获得关于<span>MySQL</span>如何执行<span>SELECT</span>语句的信息：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>EXPLAIN <i>tbl_name</i></span>是<span >DESCRIBE
			<i>tbl_name</i></span>或<span >SHOW 
			COLUMNS FROM <i>tbl_name</i></span>的一个同义词。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果在<span>SELECT</span>语句前放上关键词<span>EXPLAIN</span>，<strong><span>MySQL</span></strong>将解释它如何处理<span>SELECT</span>，提供有关表如何联接和联接的次序。</p>
			<p>
			该节解释<span>EXPLAIN</span>的第<span>2</span>个用法。</p>
			<p>
			借助于<span>EXPLAIN</span>，可以知道什么时候必须为表加入索引以得到一个使用索引来寻找记录的更快的<span>SELECT</span>。</p>
			<p>
			如果由于使用不正确的索引出现了问题，应运行<span>ANALYZE 
			TABLE</span>更新表的统计（例如关键字集的势），这样会影响优化器进行的选择。参见<a href="sql-syntax.html#analyze-table" title="13.5.2.1. ANALYZE TABLE Syntax">13.5.2.1节，“ANALYZE 
		TABLE语法”</a>。</p>
			<p>
			还可以知道优化器是否以一个最佳次序联接表。为了强制优化器让一个<span>SELECT</span>语句按照表命名顺序的联接次序，语句应以<span>STRAIGHT_JOIN</span>而不只是<span >SELECT</span>开头。</p>
			<p>
			<span>EXPLAIN</span>为用于<span>SELECT</span>语句中的每个表返回一行信息。表以它们在处理查询过程中将被<span>MySQL</span>读入的顺序被列出。<strong><span>MySQL</span></strong>用一遍扫描多次联接（<em><span>single-sweep 
			multi-join</span></em>）的方式解决所有联接。这意味着<strong><span>MySQL</span></strong>从第一个表中读一行，然后找到在第二个表中的一个匹配行，然后在第<span>3</span>个表中等等。当所有的表处理完后，它输出选中的列并且返回表清单直到找到一个有更多的匹配行的表。从该表读入下一行并继续处理下一个表。</p>
			<p>
			当使用<span>EXTENDED</span>关键字时，<span>EXPLAIN</span>产生附加信息，可以用<span>SHOW 
			WARNINGS</span>浏览。该信息显示优化器限定<span>SELECT</span>语句中的表和列名，重写并且执行优化规则后<span>SELECT</span>语句是什么样子，并且还可能包括优化过程的其它注解。</p>
			<p>
			<span>EXPLAIN</span>的每个输出行提供一个表的相关信息，并且每个行包括下面的列：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>id</span></p>
			<p>
			<span>SELECT</span>识别符。这是<span>SELECT</span>的查询序列号。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>select_type</span></p>
			<p>
			<span>SELECT</span>类型，可以为以下任何一种：</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>SIMPLE</span></p>
			<p>
			简单<span>SELECT</span><span>(</span>不使用<span>UNION</span>或子查询<span>)
			</span></p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>PRIMARY</span></p>
			<p>
			最外面的<span>SELECT</span></p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>UNION</span></p>
			<p>
			<span>UNION</span>中的第二个或后面的<span>SELECT</span>语句</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>DEPENDENT UNION</span></p>
			<p>
			<span>UNION</span>中的第二个或后面的<span>SELECT</span>语句，取决于外面的查询</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >UNION RESULT</span></p>
			<p>
			<span>UNION</span>的结果。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>SUBQUERY</span></p>
			<p>
			子查询中的第一个<span>SELECT</span></p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>DEPENDENT SUBQUERY</span></p>
			<p>
			子查询中的第一个<span>SELECT</span>，取决于外面的查询</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>DERIVED</span></p>
			<p>
			导出表的<span>SELECT</span><span>(</span><span >FROM</span>子句的子查询<span>)</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span >table</span></p>
			<p>
			输出的行所引用的表。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>type</span></p>
			<p>
			联接类型。下面给出各种联接类型，按照从最佳类型到最坏类型进行排序：</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >system</span></p>
			<p>
			表仅有一行<span>(=</span>系统表<span>)</span>。这是<span>const</span>联接类型的一个特例。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>const</span></p>
			<p>
			表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。<span>const</span>表很快，因为它们只读取一次！</p>
			<p>
			<span>const</span>用于用常数值比较<span>PRIMARY 
			KEY</span>或<span>UNIQUE</span>索引的所有部分时。在下面的查询中，<span><i><span>tbl_name</span></i></span>可以用于<span>const</span>表：</p>
			<pre><span>SELECT * from </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>primary_key</span></i></span><span>=1</span>；</pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * from </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>primary_key_part1</span></i></span><span>=1</span>和 <span><i><span>primary_key_part2</span></i></span><span>=2</span>；</pre>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>eq_ref</span></p>
			<p>
			对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了<span>const</span>类型。它用在一个索引的所有部分被联接使用并且索引是<span>UNIQUE</span>或<span>PRIMARY 
			KEY</span>。</p>
			<p>
			<span>eq_ref</span>可以用于使用<span>=</span><span>
			</span>操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。</p>
			<p>
			在下面的例子中，<span>MySQL</span>可以使用<span>eq_ref</span>联接来处理<span><i><span>ref_tables</span></i></span>：</p>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span><span>,</span><span><i><span>other_table</span></i></span></pre>
			<pre><span>&nbsp; WHERE </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column</span></i></span><span>=</span><span><i><span>other_table</span></i></span><span>.</span><span><i><span>column</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span><span>,</span><span><i><span>other_table</span></i></span></pre>
			<pre><span>&nbsp; WHERE </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column_part1</span></i></span><span>=</span><span><i><span>other_table</span></i></span><span>.</span><span><i><span>column</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; AND </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column_part2</span></i></span><span>=1;</span></pre>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>ref</span></p>
			<p>
			对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是<span>UNIQUE</span>或<span>PRIMARY 
			KEY</span>（换句话说，如果联接不能基于关键字选择单个行的话），则使用<span>ref</span>。如果使用的键仅仅匹配少量行，该联接类型是不错的。</p>
			<p>
			<span>ref</span>可以用于使用<span>=</span>或<span>&lt;=&gt;</span>操作符的带索引的列。</p>
			<p>
			在下面的例子中，<span>MySQL</span>可以使用<span>ref</span>联接来处理<span><i><span>ref_tables</span></i></span>：</p>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span><span> WHERE </span><span><i><span>key_column</span></i></span><span>=</span><span><i><span>expr</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span><span>,</span><span><i><span>other_table</span></i></span></pre>
			<pre><span>&nbsp; WHERE </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column</span></i></span><span>=</span><span><i><span>other_table</span></i></span><span>.</span><span><i><span>column</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span><span>,</span><span><i><span>other_table</span></i></span></pre>
			<pre><span>&nbsp; WHERE </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column_part1</span></i></span><span>=</span><span><i><span>other_table</span></i></span><span>.</span><span><i><span>column</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; AND </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column_part2</span></i></span><span>=1;</span></pre>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>ref_or_null</span></p>
			<p>
			该联接类型如同<span>ref</span>，但是添加了<span>MySQL</span>可以专门搜索包含<span>NULL</span>值的行。在解决子查询中经常使用该联接类型的优化。</p>
			<p>
			在下面的例子中，<span>MySQL</span>可以使用<span>ref_or_null</span>联接来处理<span><i><span>ref_tables</span></i></span>：</p>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>key_column</span></i></span><span>=</span><span><i><span>expr</span></i></span><span> OR </span><span><i><span>key_column</span></i></span><span> IS NULL;</span></pre>
			<p>
			参见<a href="optimization.html#is-null-optimization" title="7.2.7. How MySQL Optimizes IS NULL">7.2.7节，“MySQL如何优化IS NULL<code class="literal"></code>”</a>。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>index_merge</span></p>
			<p>
			该联接类型表示使用了索引合并优化方法。在这种情况下，<span>key</span>列包含了使用的索引的清单，<span>key_len</span>包含了使用的索引的最长的关键元素。详细信息参见<a href="optimization.html#index-merge-optimization" title="7.2.6. Index Merge Optimization">7.2.6节，“索引合并优化”</a>。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>unique_subquery</span></p>
			<p>
			该类型替换了下面形式的<span>IN</span>子查询的<span>ref</span>：</p>
			<pre><span><i><span>value</span></i></span><span> IN (SELECT </span><span><i><span>primary_key</span></i></span><span> FROM </span><span><i><span>single_table</span></i></span><span> WHERE </span><span><i><span>some_expr</span></i></span><span>)</span></pre>
			<p>
			<span>unique_subquery</span>是一个索引查找函数，可以完全替换子查询，效率更高。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>index_subquery</span></p>
			<p>
			该联接类型类似于<span>unique_subquery</span>。可以替换<span>IN</span>子查询，但只适合下列形式的子查询中的非唯一索引：</p>
			<pre><span><i><span>value</span></i></span><span> IN (SELECT </span><span><i><span>key_column</span></i></span><span> FROM </span><span><i><span>single_table</span></i></span><span> WHERE </span><span><i><span>some_expr</span></i></span><span>)</span></pre>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>range</span></p>
			<p>
			只检索给定范围的行，使用一个索引来选择行。<span>key</span>列显示使用了哪个索引。<span>key_len</span>包含所使用索引的最长关键元素。在该类型中<span>ref</span>列为<span>NULL</span>。</p>
			<p>
			当使用<span>=</span>、<span>&lt;&gt;</span>、<span>&gt;</span>、<span>&gt;=</span>、<span>&lt;</span>、<span>&lt;=</span>、<span>IS 
			NULL</span>、<span>&lt;=&gt;</span>、<span>BETWEEN</span>或者<span>IN</span>操作符，用常量比较关键字列时，可以使用<span>range</span>：</p>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>key_column</span></i></span><span> = 10;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>key_column</span></i></span><span> BETWEEN 10 and 20;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>key_column</span></i></span><span> IN (10,20,30);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>key_part1</span></i></span><span>= 10 AND </span><span><i>key_part2<span> IN (10,20,30);</span></i></span></pre>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >index</span></p>
			<p>
			该联接类型与<span>ALL</span>相同，除了只有索引树被扫描。这通常比<span>ALL</span>快，因为索引文件通常比数据文件小。</p>
			<p>
			当查询只使用作为单索引一部分的列时，<span>MySQL</span>可以使用该联接类型。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >ALL</span></p>
			<p>
			对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记<span>const</span>的表，这通常不好，并且通常在它情况下<strong><i><span>很</span></i></strong>差。通常可以增加更多的索引而不要使用<span>ALL</span>，使得行能基于前面的表中的常数值或列值被检索出。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>possible_keys</span></p>
			<p>
			<span>possible_keys</span>列指出<strong><span>MySQL</span></strong>能使用哪个索引在该表中找到行。注意，该列完全独立于<span >EXPLAIN</span>输出所示的表的次序。这意味着在<span>possible_keys</span>中的某些键实际上不能按生成的表次序使用。</p>
			<p>
			如果该列是<span >NULL</span>，则没有相关的索引。在这种情况下，可以通过检查<span>WHERE</span>子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用<span>EXPLAIN</span>检查查询。参见<a href="sql-syntax.html#alter-table" title="13.1.2. ALTER TABLE Syntax">13.1.2节，“ALTER 
			TABLE语法”</a>。</p>
			<p>
			为了看清一张表有什么索引，使用<span >SHOW 
			INDEX FROM <i>tbl_name</i></span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>key</span></p>
			<p>
			<span>key</span>列显示<strong><span>MySQL</span></strong>实际决定使用的键（索引）。如果没有选择索引，键是<span>NULL</span>。要想强制<span>MySQL</span>使用或忽视<span>possible_keys</span>列中的索引，在查询中使用<span>FORCE 
			INDEX</span>、<span >USE 
			INDEX</span>或者<span >IGNORE 
			INDEX</span>。参见<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。</p>
			<p>
			对于<span>MyISAM</span>和<span>BDB</span>表，运行<span>ANALYZE 
			TABLE</span>可以帮助优化器选择更好的索引。对于<span>MyISAM</span>表，可以使用<strong><span>myisamchk 
			--analyze</span></strong>。参见<a href="sql-syntax.html#analyze-table" title="13.5.2.1. ANALYZE TABLE Syntax">13.5.2.1节，“ANALYZE 
			TABLE语法”</a>和<a href="database-administration.html#table-maintenance" title="5.9.4. Table Maintenance and Crash Recovery">5.9.4节，“表维护和崩溃恢复”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>key_len</span></p>
			<p>
			<span>key_len</span>列显示<strong><span>MySQL</span></strong>决定使用的键长度。如果键是<span>NULL</span>，则长度为<span>NULL</span>。注意通过<span >key_len</span>值我们可以确定<span>MySQL</span>将实际使用一个多部关键字的几个部分。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>ref</span></p>
			<p>
			<span>ref</span>列显示使用哪个列或常数与<span>key</span>一起从表中选择行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span >rows</span></p>
			<p>
			<span>rows</span>列显示<strong><span>MySQL</span></strong>认为它执行查询时必须检查的行数。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>Extra</span></p>
			<p>
			该列包含<span>MySQL</span>解决查询的详细信息。下面解释了该列可以显示的不同的文本字符串：</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>Distinct</span></p>
			<p><span>MySQL</span>发现第<span>1</span>个匹配行后，停止为当前的行组合搜索更多的行。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Not exists</span></p>
			<p>
			<span>MySQL</span>能够对查询进行<span>LEFT 
			JOIN</span>优化，发现<span>1</span>个匹配<span >LEFT 
			JOIN</span>标准的行后，不再为前面的的行组合在该表内检查更多的行。</p>
			<p>
			下面是一个可以这样优化的查询类型的例子：</p>
			<pre><span>SELECT * </span>从<span>t1 LEFT JOIN t2 ON t1.id=t2.id</span></pre>
			<pre><span>&nbsp; WHERE t2.id IS NULL</span>；</pre>
			<p>
			假定<span>t2.id</span>定义为<span>NOT 
			NULL</span>。在这种情况下，<span>MySQL</span>使用<span>t1.id</span>的值扫描<span>t1</span>并查找<span>t2</span>中的行。如果<span>MySQL</span>在<span>t2</span>中发现一个匹配的行，它知道<span>t2.id</span>绝不会为<span>NULL</span>，并且不再扫描<span>t2</span>内有相同的<span>id</span>值的行。换句话说，对于<span>t1</span>的每个行，<span>MySQL</span>只需要在<span>t2</span>中查找一次，无论<span>t2</span>内实际有多少匹配的行。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span><span>range checked 
			for each record (index map: </span>
			<span>#)</span></span></p>
			<p>
			<span>MySQL</span>没有发现好的可以使用的索引，但发现如果来自前面的表的列值已知，可能部分索引可以使用。对前面的表的每个行组合，<span>MySQL</span>检查是否可以使用<span>range</span>或<span>index_merge</span>访问方法来索取行。关于适用性标准的描述参见<a href="optimization.html#range-optimization" title="7.2.5. Range Optimization">7.2.5节，“范围优化”</a>和<a href="optimization.html#index-merge-optimization" title="7.2.6. Index Merge Optimization">7.2.6节，“索引合并优化”</a>，不同的是前面表的所有列值已知并且认为是常量。</p>
			<p>这并不很快，但比执行没有索引的联接要快得多。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using filesort</span></p>
			<p>
			<span>MySQL</span>需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配<span>WHERE</span>子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。参见<a href="optimization.html#order-by-optimization" title="7.2.12. How MySQL Optimizes ORDER BY">7.2.12节，“MySQL如何优化ORDER BY<code class="literal"></code>”</a>。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using index</span></p>
			<p>
			从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。当查询只使用作为单一索引一部分的列时，可以使用该策略。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using temporary</span></p>
			<p>
			为了解决查询，<span>MySQL</span>需要创建一个临时表来容纳结果。典型情况如查询包含可以按不同情况列出列的<span>GROUP 
			BY</span>和<span>ORDER 
			BY</span>子句时。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using where</span></p>
			<p>
			<span>WHERE</span>子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果<span>Extra</span>值不为<span>Using 
			where</span>并且表联接类型为<span >ALL</span>或<span >index</span>，查询可能会有一些错误。</p>
			<p>
			如果想要使查询尽可能快，应找出<span>Using 
			filesort </span>和<span>Using 
			temporary</span>的<span>Extra</span>值。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using 
			sort_union(...)</span><span>, </span>
			<span >Using union(...)</span><span>,
			</span><span >Using 
			intersect(...)</span></p>
			<p>
			这些函数说明如何为<span>index_merge</span>联接类型合并索引扫描。详细信息参见<a href="optimization.html#index-merge-optimization" title="7.2.6. Index Merge Optimization">7.2.6节，“索引合并优化”</a>。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using index for 
			group-by</span></p>
			<p>
			类似于访问表的<span>Using 
			index</span>方式，<span>Using 
			index for group-by</span>表示<span>MySQL</span>发现了一个索引，可以用来查询<span>GROUP 
			BY</span>或<span>DISTINCT</span>查询的所有列，而不要额外搜索硬盘访问实际的表。并且，按最有效的方式使用索引，以便对于每个组，只读取少量索引条目。详情参见<a href="optimization.html#group-by-optimization" title="7.2.13. How MySQL Optimizes GROUP BY">7.2.13节，“MySQL如何优化GROUP BY<code class="literal"></code>”</a>。</p>
			<p>
			通过相乘<span>EXPLAIN</span>输出的<span>rows</span>列的所有值，你能得到一个关于一个联接如何的提示。这应该粗略地告诉你<strong><span>MySQL</span></strong>必须检查多少行以执行查询。当你使用<span>max_join_size</span>变量限制查询时，也用这个乘积来确定执行哪个多表<span >SELECT</span>语句。参见<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2节，“调节服务器参数”</a>。</p>
			<p>
			下列例子显示出一个多表<span>JOIN</span>如何能使用<span>EXPLAIN</span>提供的信息逐步被优化。</p>
			<p>假定你有下面所示的<span>SELECT</span>语句，计划使用<span>EXPLAIN</span>来检查它：</p>
			<pre><span>EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ProjectReference, tt.EstimatedShipDate,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ActualShipDate, tt.ClientID,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ServiceCodes, tt.RepetitiveID,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.CurrentProcess, tt.CurrentDPPerson,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.RecordVolume, tt.DPPrinted, et.COUNTRY,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; et_1.COUNTRY, do.CUSTNAME</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM tt, et, et AS et_1, do</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE tt.SubmitTime IS NULL</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND tt.ActualPC = et.EMPLOYID</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND tt.AssignedPC = et_1.EMPLOYID</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND tt.ClientID = do.CUSTNMBR;</span></pre>
			<p>
			对于这个例子，假定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>被比较的列声明如下：</p>
			<table border="1" cellpadding="0" id="table1">
				<tr>
					<td>
					<p><strong><span>表</span></strong></td>
					<td width="113">
					<p><strong><span>列</span></strong></td>
					<td width="105">
					<p><strong><span>
					列类型</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td width="113">
					<p>
					<span>ActualPC</span></td>
					<td width="105">
					<p>
					<span>CHAR(10)</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td width="113">
					<p>
					<span>AssignedPC</span></td>
					<td width="105">
					<p>
					<span>CHAR(10)</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td width="113">
					<p>
					<span>ClientID</span></td>
					<td width="105">
					<p>
					<span>CHAR(10)</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>et</span></td>
					<td width="113">
					<p>
					<span>EMPLOYID</span></td>
					<td width="105">
					<p>
					<span>CHAR(15)</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>do</span></td>
					<td width="113">
					<p>
					<span>CUSTNMBR</span></td>
					<td width="105">
					<p>
					<span>CHAR(15)</span></td>
				</tr>
			</table>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>表有下面的索引：</p>
			<table border="1" cellpadding="0" id="table2">
				<tr>
					<td>
					<p><strong><span>表</span></strong></td>
					<td>
					<p><strong><span>索引</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td>
					<p>
					<span>ActualPC</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td>
					<p>
					<span>AssignedPC</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td>
					<p>
					<span>ClientID</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>et</span></td>
					<td>
					<p>
					<span>EMPLOYID</span><span>(</span>主键<span>)</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>do</span></td>
					<td>
					<p>
					<span>CUSTNMBR</span><span>(</span>主键<span>)</span></td>
				</tr>
			</table>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			tt.ActualPC</span>值不是均匀分布的。</p>
			<p>
			开始，在进行优化前，<span>EXPLAIN</span>语句产生下列信息：</p>
			<p>
			<span>&nbsp;</span></p>
			<pre><span>table type possible_keys key&nbsp; key_len ref&nbsp; rows&nbsp; Extra</span></pre>
			<pre><span>et&nbsp;&nbsp;&nbsp; ALL&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 74</span></pre>
			<pre><span>do&nbsp;&nbsp;&nbsp; ALL&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 2135</span></pre>
			<pre><span>et_1&nbsp; ALL&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 74</span></pre>
			<pre><span>tt&nbsp;&nbsp;&nbsp; ALL&nbsp; AssignedPC,&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 3872</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range checked for each record (key map: 35)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			因为<span>type</span>对每张表是<span>ALL</span>，这个输出显示<strong><span>MySQL</span></strong>正在对所有表产生一个笛卡尔乘积；即每一个行的组合！这将花相当长的时间，因为必须检查每张表的行数的乘积！对于一个实例，这是<span>74 
			* 2135 * 74 * 3872 = 45,268,558,720</span>行。如果表更大，你只能想象它将花多长时间……
			</p>
			<p>
			这里的一个问题是<strong><span>MySQL</span></strong>能更高效地在声明具有相同类型和尺寸的列上使用索引。在本文中，<span>VARCHAR</span>和<span>CHAR</span>是相同的，除非它们声明为不同的长度。因为<span>tt.ActualPC</span>被声明为<span>CHAR(10)</span>并且<span>et.EMPLOYID</span>被声明为<span>CHAR(15)</span>，长度不匹配。</p>
			<p>
			为了修正在列长度上的不同，使用<span>ALTER 
			TABLE</span>将<span>ActualPC</span>的长度从<span>10</span>个字符变为<span>15</span>个字符：</p>
			<pre><span>mysql&gt; </span><span><b><span>ALTER TABLE tt MODIFY ActualPC VARCHAR(15);</span></b></span></pre>
			<p>
			现在<span>tt.ActualPC</span>和<span>et.EMPLOYID</span>都是<span>VARCHAR(15)</span>，再执行<span>EXPLAIN</span>语句产生这个结果：</p>
			<p>
			<span>&nbsp;</span></p>
			<pre><span>table type&nbsp;&nbsp; possible_keys key&nbsp;&nbsp;&nbsp;&nbsp; key_len ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows&nbsp;&nbsp;&nbsp; Extra</span></pre>
			<pre><span>tt&nbsp;&nbsp;&nbsp; ALL &nbsp;&nbsp;&nbsp;AssignedPC,&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3872&nbsp;&nbsp;&nbsp; Using</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC</span></pre>
			<pre><span>do&nbsp;&nbsp;&nbsp; ALL&nbsp;&nbsp;&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2135</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range checked for each record (key map: 1)</span></pre>
			<pre><span>et_1&nbsp; ALL&nbsp;&nbsp;&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 74</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range checked for each record (key map: 1)</span></pre>
			<pre><span>et&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ActualPC 1</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			这不是完美的，但是好一些了：<span>rows</span>值的乘积少了一个因子<span>74</span>。这个版本在几秒内执行完。</p>
			<p>
			第<span>2</span>种方法能消除<span>tt.AssignedPC 
			= et_1.EMPLOYID</span>和<span>tt.ClientID 
			= do.CUSTNMBR</span>比较的列的长度失配问题：</p>
			<pre><span>mysql&gt; </span><span><b><span>ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>MODIFY ClientID&nbsp;&nbsp; VARCHAR(15);</span></b></span></pre>
			<p><span>EXPLAIN</span>产生的输出显示在下面：</p>
			<pre><span>table type&nbsp;&nbsp; possible_keys key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key_len ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows Extra</span></pre>
			<pre><span>et&nbsp;&nbsp;&nbsp; ALL&nbsp;&nbsp;&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 74</span></pre>
			<pre><span>tt&nbsp;&nbsp;&nbsp; ref&nbsp;&nbsp;&nbsp; AssignedPC,&nbsp;&nbsp; ActualPC 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; et.EMPLOYID&nbsp;&nbsp; 52&nbsp;&nbsp; Using</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC</span></pre>
			<pre><span>et_1&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.AssignedPC 1</span></pre>
			<pre><span>do&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ClientID&nbsp;&nbsp; 1</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			这几乎很好了。 </p>
			<p>
			剩下的问题是，默认情况，<strong><span>MySQL</span></strong>假设在<span>tt.ActualPC</span>列的值是均匀分布的，并且对<span>tt</span>表不是这样。幸好，很容易告诉<strong><span>MySQL</span></strong>来分析关键字分布：</p>
			<pre><span>mysql&gt; </span><span><b><span>ANALYZE TABLE tt</span><span>；</span></b></span></pre>
			<p>
			现在联接是“完美”的了，而且<span>EXPLAIN</span>产生这个结果：</p>
			<pre><span>table type&nbsp;&nbsp; possible_keys key&nbsp;&nbsp;&nbsp;&nbsp; key_len ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows Extra</span></pre>
			<pre><span>tt&nbsp;&nbsp;&nbsp; ALL&nbsp;&nbsp;&nbsp; AssignedPC&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3872 Using</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC</span></pre>
			<pre><span>et&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ActualPC&nbsp;&nbsp; 1</span></pre>
			<pre><span>et_1&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.AssignedPC 1</span></pre>
			<pre><span>do&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ClientID&nbsp;&nbsp; 1</span></pre>
			<p>注意在从<span>EXPLAIN</span>输出的<span>rows</span>列是一个来自<strong><span>MySQL</span></strong>联接优化器的“教育猜测”。你应该检查数字是否接近事实。如果不是，可以通过在<span>SELECT</span>语句里面使用<span>STRAIGHT_JOIN</span>并且试着在<span>FROM</span>子句以不同的次序列出表，可能得到更好的性能。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="estimating-performance"></a>
			7.2.2.&nbsp;估计查询性能</h3></div></div></div><a class="indexterm" name="id2802305"></a><a class="indexterm" name="id2802316"></a><a class="indexterm" name="id2802326"></a>
			<p>
			在大多数情况下，可以通过计算磁盘搜索来估计性能。对小的表，通常能在<span>1</span>次磁盘搜索中找到行<span>(</span>因为索引可能被缓存<span>)</span>。对更大的表，可以使用<span>B</span>－树索引进行估计，将需要<span >log(<i>row_count</i>)/log(<i>index_block_length</i>/3 
			* 2/(<i>index_length</i> + <i>data_pointer_length</i>))+1</span>次搜索才能找到行。</p>
			<p>
			在<strong><span style="font-family:
宋体;">MySQL</span></strong>中，索引块通常是<span>1024</span>个字节，数据指针通常是<span>4</span>个字节，这对于有一个长度为<span>3(</span>中等整数<span>)</span>的索引的<span>500,000</span>行的表，通过公式可以计算出<span>log(500,000)/log(1024/3*2/(3+4))+1</span><span>= 
			4</span>次搜索。</p>
			<p>
			上面的索引需要大约<span>500,000 * 7 * 3/2 = 5.2</span><span>MB</span>，<span>(</span>假设典型情况下索引缓存区填充率为<span>2/3)</span>，可以将大部分索引保存在内存中，仅需要<span>1-2</span>调用从<span>OS</span>读数据来找出行。</p>
			<p>
			然而对于写，将需要<span>4</span>次搜索请求<span>(</span>如上<span>)</span>来找到在哪儿存放新索引，并且通常需要<span>2</span>次搜索来更新这个索引并且写入行。</p>
			<p>注意，上述讨论并不意味着应用程序的性能将缓慢地以<span>log<i>N</i> </span>
			退化！当表格变得更大时，所有内容缓存到<span>OS</span>或<span>SQL</span>服务器后，将仅仅或多或少地更慢。在数据变得太大不能缓存后，将逐渐变得更慢，直到应用程序只能进行磁盘搜索<span>(</span>以<span>log<i>N</i></span>增加<span>)</span>。为了避免这个问题，随数据增加而增加
			键高速缓冲区大小。对于<span >MyISAM</span>表<span>,
			</span>由<span >key_buffer_size</span>系统变量控制
			键高速缓冲区大小。参见<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2节，“调节服务器参数”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="select-speed"></a>
			7.2.3.&nbsp;SELECT查询的速度</h3></div></div></div><a class="indexterm" name="id2802441"></a><a class="indexterm" name="id2802450"></a>
			<p>
			总的来说，要想使一个较慢速<span>SELECT 
			... WHERE</span>更快，应首先检查是否能增加一个索引。不同表之间的引用通常通过索引来完成。你可以使用<span>EXPLAIN</span>语句来确定<span>SELECT</span>语句使用哪些索引。参见<a href="optimization.html#mysql-indexes" title="7.4.5. How MySQL Uses Indexes">7.4.5节，“MySQL如何使用索引”</a>和<a href="optimization.html#explain" title="7.2.1. EXPLAIN Syntax (Get Information About a SELECT)">7.2.1节，“EXPLAIN语法（获取关于SELECT的信息）<code class="literal"></code>”</a>。</p>
			<p>
			下面是一些加速对<span>MyISAM</span>表的查询的一般建议：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>为了帮助<strong><span>MySQL</span></strong>更好地优化查询，在一个装载数据后的表上运行<span >ANALYZE 
			TABLE</span>或<strong><span>myisamchk 
			--analyze</span></strong>。这样为每一个索引更新指出有相同值的行的平均行数的值（当然，如果只有一个索引，这总是<span>1</span>。）<span>MySQL</span>使用该方法来决定当你联接两个基于非常量表达式的表时选择哪个索引。你可以使用<span >SHOW 
			INDEX FROM <i>tbl_name</i></span>并检查<span>Cardinality</span>值来检查表分析结果。<strong><span>myisamchk 
			--</span><span>description 
			--verbose</span></strong>可以显示索引分布信息。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>要想根据一个索引排序一个索引和数据，使用<strong><span>myisamchk 
			--sort-index --sort-records=1</span></strong>（如果你想要在索引<span>1</span>上排序）。如果只有一个索引，想要根据该索引的次序读取所有的记录，这是使查询更快的一个好方法。但是请注意，第一次对一个大表按照这种方法排序时将花很长时间！</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="where-optimizations"></a>
			7.2.4.&nbsp;MySQL怎样优化WHERE子句<code class="literal"></code></h3></div></div></div><a class="indexterm" name="id2802573"></a><a class="indexterm" name="id2802582"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			该节讨论为处理<span>WHERE</span>子句而进行的优化。例子中使用了<span>SELECT</span>语句，但相同的优化也适用<span>DELETE</span>和<span>UPDATE</span>语句中的<span>WHERE</span>子句。</p>
			<p>
			请注意对<span>MySQL</span>优化器的工作在不断进行中，因此该节并不完善。<span>MySQL</span>执行了大量的优化，本文中所列的并不详尽。</p>
			<p>
			下面列出了<span>MySQL</span>执行的部分优化：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>去除不必要的括号：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;((a AND b) AND c OR (((a AND b) AND (c AND d))))</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>-&gt; (a AND b AND c) OR (a AND b AND c AND d)</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>常量重叠：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;(a&lt;b AND b=c) AND a=5</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>-&gt; b&gt;5 AND b=c AND a=5</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>去除常量条件<span>(</span>由于常量重叠需要<span>)</span>：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;(B&gt;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>-&gt; B=5 OR B=6</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>索引使用的常数表达式仅计算一次。</p>
			<ul type="disc">
				<li>对于<span >MyISAM</span>和<span >HEAP</span>表，在一个单个表上的没有一个<span>WHERE</span>的<span>COUNT(*)</span>直接从表中检索信息。当仅使用一个表时，对<span>NOT 
				NULL</span>表达式也这样做。</li>
				<li>无效常数表达式的早期检测。<strong><span style="
     ">MySQL</span></strong>快速检测某些<span>SELECT</span>语句是不可能的并且不返回行。</li>
				<li>如果不使用<span>GROUP 
				BY</span>或分组函数<span>(</span><span>COUNT()</span>、<span>MIN()</span>……<span>)</span>，<span>HAVING</span>与<span>WHERE</span>合并。</li>
				<li>对于联接内的每个表，构造一个更简单的<span>WHERE</span>以便更快地对表进行<span>WHERE</span>计算并且也尽快跳过记录。</li>
				<li>所有常数的表在查询中比其它表先读出。常数表为：
 				<ul type="circle">
					<li>空表或只有<span>1</span>行的表。</li>
					<li>与在一个<span >PRIMARY 
					KEY</span>或<span >UNIQUE</span>索引的<span>WHERE</span>子句一起使用的表，这里所有的索引部分使用常数表达式并且索引部分被定义为<span>NOT 
					NULL</span>。 </li>
				</ul>
				</li>
			</ul>
			<p>下列的所有表用作常数表： </p>
			<pre ><span>mysql&gt; SELECT * FROM t WHERE primary_key=1;</span></pre>
			<pre ><span>mysql&gt; SELECT * FROM t1,t2</span></pre>
			<pre ><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE t1.primary_key=1 AND t2.primary_key=t1.id;</span></pre>
			<ul type="disc">
				<li>尝试所有可能性便可以找到表联接的最好联接组合。如果所有在<span>ORDER 
				BY</span>和<span>GROUP 
				BY</span>的列来自同一个表，那么当联接时，该表首先被选中。</li>
				<li>如果有一个<span>ORDER 
				BY</span>子句和不同的<span>GROUP 
				BY</span>子句，或如果<span>ORDER 
				BY</span>或<span>GROUP 
				BY</span>包含联接队列中的第一个表之外的其它表的列，则创建一个临时表。</li>
				<li>如果使用<span>SQL_SMALL_RESULT</span>，<strong><span>MySQL</span></strong>使用内存中的一个临时表。</li>
				<li>
				每个表的索引被查询，并且使用最好的索引，除非优化器认为使用表扫描更有效。是否使用扫描取决于是否最好的索引跨越超过<span>30%</span>的表。优化器更加复杂，其估计基于其它因素，例如表大小、行数和<span>I/O</span>块大小，因此固定比例不再决定选择使用索引还是扫描。</li>
				<li>在一些情况下，<strong><span style="font-weight:
     normal">MySQL</span></strong>能从索引中读出行，甚至不查询数据文件。如果索引使用的所有列是数值类，那么只使用索引树来进行查询。</li>
				<li>输出每个记录前，跳过不匹配<span>HAVING</span>子句的行。</li>
			</ul>
			<p>
			下面是一些快速查询的例子：</p>
			<pre><span>SELECT COUNT(*) FROM </span><span><i><span>tbl_name</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT MIN(</span><span><i><span>key_part1</span></i></span><span>),MAX(</span><span><i><span>key_part1</span></i></span><span>) FROM </span><span><i><span>tbl_name</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT MAX(</span><span><i><span>key_part2</span></i></span><span>) FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE </span><span><i><span>key_part1</span></i></span><span>=</span><span><i><span>constant</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT ... FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ORDER BY </span><span><i><span>key_part1</span></i></span><span>,</span><span><i><span>key_part2</span></i></span><span>,... LIMIT 10;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT ... FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ORDER BY </span><span><i><span>key_part1</span></i></span><span> DESC, </span><span><i><span>key_part2</span></i></span><span> DESC, ... LIMIT 10;</span></pre>
			<p>
			下列查询仅使用索引树就可以解决<span>(</span>假设索引的列为数值型<span>)</span>：</p>
			<pre><span>SELECT </span><span><i><span>key_part1</span></i></span><span>,</span><span><i><span>key_part2</span></i></span><span> FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_part1</span></i></span><span>=</span><span><i><span>val</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT COUNT(*) FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE </span><span><i><span>key_part1</span></i></span><span>=</span><span><i><span>val1</span></i></span><span> AND </span><span><i><span>key_part2</span></i></span><span>=</span><span><i><span>val2</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT </span><span><i><span>key_part2</span></i></span><span> FROM </span><span><i><span>tbl_name</span></i></span><span> GROUP BY </span><span><i><span>key_part1</span></i></span><span>;</span></pre>
			<p>
			下列查询使用索引按排序顺序检索行，不用另外的排序：</p>
			<pre><span>SELECT ... FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ORDER BY </span><span><i><span>key_part1</span></i></span><span>,</span><span><i><span>key_part2</span></i></span><span>,... ;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT ... FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ORDER BY </span><span><i><span>key_part1</span></i></span><span> DESC, </span><span><i><span>key_part2</span></i></span><span> DESC, ... ;</span></pre>
			<h3 class="title"><a name="range-optimization"></a>
			7.2.5.&nbsp;范围优化</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#range-access-single-part">
				7.2.5.1. 单元素索引的范围访问方法</a></span></dt><dt><span class="section"><a href="optimization.html#range-access-multi-part">
				7.2.5.2. 多元素索引的范围访问方法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div>
				<p>
				<span >range</span>访问方法使用单一索引来搜索包含在一个或几个索引值距离内的表记录的子集。可以用于单部分或多元素索引。后面的章节将详细描述如何从<span>WHERE</span>子句提取区间。</p>
				<h4 class="title"><a name="range-access-single-part"></a>
				7.2.5.1.&nbsp;单元素索引的范围访问方法</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<p>
				对于单元素索引，可以用<span>WHERE</span>子句中的相应条件很方便地表示索引值区间，因此我们称为<em><span>范围条件</span></em>而不是“区间”。</p>
				<p>
				单元素索引范围条件的定义如下：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span>BTREE</span>和<span>HASH</span>索引，当使用<span>=</span>、<span>&lt;=&gt;</span>、<span>IN</span>、<span>IS 
				NULL</span>或者<span>IS 
				NOT NULL</span>操作符时，关键元素与常量值的比较关系对应一个范围条件。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span>BTREE</span>索引，当使用<span>&gt;</span>、<span>&lt;</span>、<span>&gt;=</span>、<span>&lt;=</span>、<span>BETWEEN</span>、<span>!=</span>或者<span>&lt;&gt;</span>，或者<span><span>LIKE
				</span><span>&#39;<i>pattern</i>&#39;</span></span><span>(</span>其中 
				 
				<span >&#39;<i>pattern</i>&#39;</span>不以通配符开始<span>)</span>操作符时，关键元素与常量值的比较关系对应一个范围条件。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于所有类型的索引，多个范围条件结合<span>OR</span>或<span>AND</span>则产生一个范围条件。</p>
				<p>
				前面描述的“<span class="quote">常</span>量值”系指：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>查询字符串中的常量</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>同一联接中的<span>const</span>或<span >system</span>表中的列</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>无关联子查询的结果</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>完全从前面类型的子表达式组成的表达式</p>
				<p>
				下面是一些<span>WHERE</span>子句中有范围条件的查询的例子：</p>
				<pre><span>SELECT * FROM t1 </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE </span><span><i><span>key_col</span></i></span><span> &gt; 1 </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;AND </span><span><i><span>key_col</span></i></span><span> &lt; 10;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>SELECT * FROM t1 </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE </span><span><i><span>key_col</span></i></span><span> = 1 </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;OR </span><span><i><span>key_col</span></i></span><span> IN (15,18,20);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>SELECT * FROM t1 </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE </span><span><i><span>key_col</span></i></span><span> LIKE &#39;ab%&#39; </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;OR </span><span><i><span>key_col</span></i></span><span> BETWEEN &#39;bar&#39; AND &#39;foo&#39;;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<p>
				请注意在常量传播阶段部分非常量值可以转换为常数。</p>
				<p>
				<span>MySQL</span>尝试为每个可能的索引从<span>WHERE</span>子句提取范围条件。在提取过程中，不能用于构成范围条件的条件被放弃，产生重叠范围的条件组合到一起，并且产生空范围的条件被删除。</p>
				<p>
				例如，考虑下面的语句，其中<span >key1</span>是有索引的列，<span>nonkey</span>没有索引：</p>
				<pre><span>SELECT * FROM t1 WHERE</span></pre>
				<pre><span>&nbsp;&nbsp; (key1 &lt; &#39;abc&#39; AND (key1 LIKE &#39;abcde%&#39; OR key1 LIKE &#39;%b&#39;)) OR</span></pre>
				<pre><span>&nbsp;&nbsp; (key1 &lt; &#39;bar&#39; AND nonkey = 4) OR</span></pre>
				<pre><span>&nbsp;&nbsp; (key1 &lt; &#39;uux&#39; AND key1 &gt; &#39;z&#39;);</span></pre>
				<p>
				<span >key1</span>的提取过程如下：</p>
				<p>
				<span>1.<span>&nbsp;&nbsp;&nbsp;
				</span></span>用原始<span>WHERE</span>子句开始：</p>
				<p>
				<span>2.<span>&nbsp;&nbsp;&nbsp;
				</span>(key1 &lt; &#39;abc&#39; AND (key1 LIKE &#39;abcde%&#39; OR key1 LIKE &#39;%b&#39;)) 
				OR</span></p>
				<p>
				<span>3.<span>&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>
				&nbsp;</span><span>(key1 &lt; &#39;bar&#39; AND nonkey = 4) OR</span></p>
				<p>
				<span>4.<span>&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>
				&nbsp;</span><span>(key1 &lt; &#39;uux&#39; AND key1 &gt; &#39;z&#39;)</span></p>
				<p>
				<span>5.<span>&nbsp;&nbsp;&nbsp;
				</span></span>删除<span>nonkey 
				= 4</span>和<span>key1 
				LIKE &#39;%b&#39;</span>，因为它们不能用于范围扫描。删除它们的正确途径是用<span>TRUE</span>替换它们，以便进行范围扫描时不会丢失匹配的记录。用<span>TRUE</span>替换它们后，可以得到：</p>
				<pre><span>6.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(key1 &lt; &#39;abc&#39; AND (key1 LIKE &#39;abcde%&#39; OR TRUE)) OR</span></pre>
				<pre><span>7.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(key1 &lt; &#39;bar&#39; AND TRUE) OR</span></pre>
				<pre><span>8.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(key1 &lt; &#39;uux&#39; AND key1 &gt; &#39;z&#39;)</span></pre>
				<p>
				<span>9.<span>&nbsp;&nbsp;&nbsp;
				</span></span>取消总是为<span>true</span>或<span>false</span>的条件：</p>
				<p >
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span >
				(key1 LIKE &#39;abcde%&#39; OR TRUE)</span>总是<span>true</span></p>
				<p >
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span >
				(key1 &lt; &#39;uux&#39; AND key1 &gt; &#39;z&#39;)</span>总是<span>false
				</span></p>
				<p>
				用常量替换这些条件，我们得到：</p>
				<pre ><span>(key1 &lt; &#39;abc&#39; AND TRUE) OR (key1 &lt; &#39;bar&#39; AND TRUE) OR (FALSE)</span></pre>
				<p>
				删除不必要的<span>TRUE</span>和<span>FALSE</span>常量，我们得到</p>
				<pre ><span>(key1 &lt; &#39;abc&#39;) OR (key1 &lt; &#39;bar&#39;)</span></pre>
				<p>
				<span>10.</span>将重叠区间组合成一个产生用于范围扫描的最终条件：</p>
				<pre><span>11.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(key1 &lt; &#39;bar&#39;)</span></pre>
				<p>
				<span>总的来说<span>(</span>如前面的例子所述<span>)</span>，用于范围扫描的条件比</span><span  >WHERE</span><span>子句限制少。<span>MySQL</span>再执行检查以过滤掉满足范围条件但不完全满足</span><span  >WHERE</span><span>子句的行。</span></p>
				<p><span>范围条件提取算法可以处理嵌套的任意深度的</span><span  >AND</span><span >/</span><span  >OR</span><span>结构，并且其输出不依赖条件在</span><span  >WHERE</span><span>子句中出现的顺序。</span></p>
				<h4 class="title"><a name="range-access-multi-part"></a>
				7.2.5.2.&nbsp;多元素索引的范围访问方法</h4></div></div></div>
				<p>
				多元素索引的范围条件是单元素索引的范围条件的扩展。多元素索引的范围条件将索引记录限制到一个或几个关键元组内。使用索引的顺序，通过一系列关键元组来定义关键元组区间。</p>
				<p>
				例如，考虑定义为<span >key1(<i>key_part1</i>,
				<i>key_part2</i>, <i>key_part3</i>)</span>的多元素索引，以及下面的按关键字顺序所列的关键元组：</p>
				<pre><span><i><span>key_part1</span></i></span><span>&nbsp; </span><span><i><span>key_part2</span></i></span><span>&nbsp; </span><span><i><span>key_part3</span></i></span></pre>
				<pre><span>&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;abc&#39;</span></pre>
				<pre><span>&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;xyz&#39;</span></pre>
				<pre><span>&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;foo&#39;</span></pre>
				<pre><span>&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;abc&#39;</span></pre>
				<pre><span>&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;xyz&#39;</span></pre>
				<pre><span>&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;abc&#39;</span></pre>
				<pre><span>&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;aaa&#39;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<p>
				条件<span><i><span>key_part1</span></i><span> 
				= 1</span></span>定义了下面的范围：</p>
				<pre><span>(1</span>，<span>-inf</span>，<span>-inf) &lt;= (</span><span><i><span>key_part1</span></i></span>，<span><i><span>key_part2</span></i></span>，<span><i><span>key_part3</span></i></span><span>) &lt; (1</span>，<span>+inf</span>，<span>+inf)</span></pre>
				<p>
				范围包括前面数据集中的第<span>4</span>、<span>5</span>和<span>6</span>个元组，可以用于范围访问方法。</p>
				<p>
				通过对比，条件<i><span>key_part3</span></i><span> = 
				&#39;abc&#39;</span>不定义单一的区间，不能用于范围访问方法。</p>
				<p>
				下面更加详细地描述了范围条件如何用于多元素索引中。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span>HASH</span>索引，可以使用包含相同值的每个区间。这说明区间只能由下面形式的条件产生：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span><i><span>key_part1</span></i></span><span> </span><span><i><span>cmp</span></i></span><span> </span><span><i><span>const1</span></i></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span><span>AND </span><span><i><span>key_part2</span></i></span><span> </span><span><i><span>cmp</span></i></span><span> </span><span><i><span>const2</span></i></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span><span>AND ...</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>AND </span><span><i><span>key_partN</span></i></span><span> </span><span><i><span>cmp</span></i></span><span> </span><span><i><span>constN</span></i></span><span>;</span></pre>
				<p>
				这里，<span><i><span>const1</span></i></span>，<span><i><span>const2</span></i></span>，<span>...</span>为常量，<span><i><span>cmp</span></i></span>是<span><span>=</span><span>、<span>&lt;=&gt;</span></span></span>或者<span>IS 
				NULL</span>比较操作符之一，条件包括所有索引部分。<span>(</span>也就是说，有<span><i><span>N</span></i></span><span>
				</span>个条件，每一个对应<span><i><span>N</span></i></span><span>-</span>元素索引的每个部分）<span>。</span></p>
				<p>
				关于常量的定义，参见<a href="optimization.html#range-access-single-part" title="7.2.5.1. Range Access Method for Single-Part Indexes">7.2.5.1节，“单元素索引的范围访问方法”</a>。</p>
				<p>
				例如，下面为三元素<span>HASH</span>索引的范围条件：</p>
				<pre ><i><span >key_part1</span></i><span > = 1 AND </span><i><span >key_part2</span></i><span > IS NULL AND </span><i><span >key_part3</span></i><span > = &#39;foo&#39;</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span>BTREE</span>索引，区间可以对结合<span>AND</span>的条件有用，其中每个条件用一个常量值通过<span><span>=</span><span>、<span>&lt;=&gt;</span>、<span>IS 
				NULL</span>、<span>&gt;</span>、<span>&lt;</span>、<span>&gt;=</span>、<span>&lt;=</span>、<span>!=</span>、<span>&lt;&gt;</span>、<span>BETWEEN</span></span></span>或者<span >LIKE 
				&#39;<i>pattern</i>&#39;</span><span> (</span>其中<span>&#39;<i>pattern</i>&#39;</span>不以通配符开头<span>)</span>比较一个关键元素。区间可以足够长以确定一个包含所有匹配条件<span>(</span>或如果使用<span>&lt;&gt;</span>或<span>!=</span>，为两个区间<span>)</span>的记录的单一的关键元组。例如，对于条件：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp; </span><i><span >key_part1</span></i><span > = &#39;foo&#39; AND </span><i><span >key_part2</span></i><span > &gt;= 10 AND </span><i><span >key_part3</span></i><span > &gt; 10</span></pre>
				<p>
				单一区间为：</p>
				<pre ><span>(&#39;foo&#39;</span>，<span>10</span>，<span>10)</span></pre>
				<pre ><span>&nbsp;&nbsp; &lt; (</span><span><i><span>key_part1</span></i></span>，<span><i><span>key_part2</span></i></span>，<span><i><span>key_part3</span></i></span><span>)</span></pre>
				<pre ><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; (&#39;foo&#39;</span>，<span>+inf</span>，<span>+inf)</span></pre>
				<p>
				创建的区间可以比原条件包含更多的记录。例如，前面的区间包括值<span><span>(&#39;foo&#39;</span><span>，<span>11</span>，<span>0)</span></span></span>，不满足原条件。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果包含区间内的一系列记录的条件结合使用<span>OR</span>，则形成包括一系列包含在区间并集的记录的一个条件。如果条件结合使用了<span>AND</span>，则形成包括一系列包含在区间交集内的记录的一个条件。例如，对于两部分索引的条件：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >(</span><i><span >key_part1</span></i><span > = 1 AND </span><i><span >key_part2</span></i><span > &lt; 2)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >OR (</span><i><span >key_part1</span></i><span > &gt; 5)</span></pre>
				<p>
				区间为：</p>
				<p>
				<span>(1, -inf) &lt; (<i>key_part1</i>, <i>key_part2</i>) 
				&lt; (1, 2)</span></p>
				<p>
				<span>(5, -inf) &lt; (<i>key_part1</i>, <i>key_part2</i>)</span></p>
				<p>
				在该例子中，第<span>1</span>行的区间左侧的约束使用了一个关键元素，右侧约束使用了两个关键元素。第<span>2</span>行的区间只使用了一个关键元素。<span>EXPLAIN</span>输出的<span>key_len</span>列表示所使用关键字前缀的最大长度。</p>
				<p>
				在某些情况中，<span>key_len</span>可以表示使用的关键元素，但可能不是你所期望的。假定<i><span>key_part1</span></i>和<span><i><span>key_part2</span></i></span>可以为<span>NULL</span>。则<span>key_len</span>列显示下面条件的两个关键元素的长度：</p>
				<pre ><span><i><span>key_part1</span></i></span><span> &gt;= 1 AND </span><span><i><span>key_part2</span></i></span><span> &lt; 2</span></pre>
				<p>
				但实际上，该条件可以变换为：</p>
				<pre ><i><span >key_part1</span></i><span > &gt;= 1 AND </span><i><span >key_part2</span></i><span > IS NOT NULL</span></pre>
				<p> <a href="optimization.html#range-access-single-part" title="7.2.5.1. Range Access Method for Single-Part Indexes">
				7.2.5.1节，“单元素索引的范围访问方法”</a>描述了如何进行优化以结合或删除单元素索引范围条件的区间。多元素索引范围条件的区间的步骤类似。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="index-merge-optimization"></a>
			7.2.6.&nbsp;索引合并优化</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#index-merge-intersection">
				7.2.6.1. 索引合并交集访问算法</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-union">
				7.2.6.2. 索引合并并集访问算法</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-sort-union">
				7.2.6.3. 索引合并排序并集访问算法</a></span></dt></dl></div><a class="indexterm" name="id2804075"></a><a class="indexterm" name="id2804084"></a><a class="indexterm" name="id2804091"></a><div class="section"><div class="titlepage"><div><div>
				<p>
				<em><span>索引合并</span></em>方法用于通过<span>range</span>扫描搜索行并将结果合成一个。合并会产生并集、交集或者正在进行的扫描的交集的并集。</p>
				<p>
				在<span>EXPLAIN</span>输出中，该方法表现为<span>type</span>列内的<span>index_merge</span>。在这种情况下，<span>key</span>列包含一列使用的索引，<span>key_len</span>包含这些索引的最长的关键元素。</p>
				<p>
				例如：</p>
				<p><span>SELECT * FROM <i>tbl_name</i> 
				WHERE <i>key_part1</i> = 10 OR <i>key_part2</i> = 20;</span></p>
				<p><span>&nbsp;</span></p>
				<p><span>SELECT * FROM <i>tbl_name</i></span></p>
				<p><span>&nbsp;&nbsp;&nbsp; WHERE (<i>key_part1</i> 
				= 10 OR <i>key_part2</i> = 20) AND <i>non_key_part</i>=30;</span></p>
				<p><span>&nbsp;</span></p>
				<p><span>SELECT * FROM t1, t2</span></p>
				<p><span>&nbsp; &nbsp;&nbsp;WHERE (t1.<i>key1<span style="font-style:normal"> 
				IN (1,2) OR t1.</span>key2</i> LIKE &#39;<i>value</i>%&#39;)</span></p>
				<p><span>&nbsp;&nbsp;&nbsp; AND t2.<i>key1</i>=t1.<i>some_col</i>;</span></p>
				<p><span>&nbsp;</span></p>
				<p><span>SELECT * FROM t1, t2</span></p>
				<p><span>&nbsp;&nbsp;&nbsp; WHERE t1.<i>key1</i>=1</span></p>
				<p><span>&nbsp;&nbsp;&nbsp; AND (t2.<i>key1</i>=t1.<i>some_col</i> 
				OR t2.<i>key2</i>=t1.<i>some_col2</i>);</span></p>
				<p>
				<span>&nbsp;</span></p>
				<p>
				索引合并方法有几种访问算法<span> (</span>参见<span>EXPLAIN</span>输出的<span>Extra</span>字段<span>)</span>：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>交集</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>联合</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>排序并集</p>
				<p>
				后面几节更加详细地描述了这些方法。</p>
				<p>
				<strong><span>注释：</span></strong>索引合并优化算法具有以下几个已知缺陷：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果可以对某些关键字进行范围扫描，则不考虑索引合并。例如，下面的查询：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE (goodkey1 &lt; 10 OR goodkey2 &lt; 20) AND badkey &lt; 30;</span></pre>
				<p>
				对于该查询，可以有两个方案：</p>
				<p >
				<span>1.<span>&nbsp;&nbsp;&nbsp;
				</span></span>使用<span>(goodkey1 &lt; 10 OR goodkey2 &lt; 20)</span>条件进行索引合并扫描。</p>
				<p >
				<span>2.<span>&nbsp;&nbsp;&nbsp;
				</span></span>使用<span>badkey 
				&lt; 30</span>条件进行范围扫描。</p>
				<p>
				然而，优化器只考虑第<span>2</span>个方案。如果这不是你想要的，你可以通过使用<span>IGNORE 
				INDEX</span>或<span>FORCE INDEX</span>让优化器考虑<span>index_merge</span>。下面的查询使用索引合并执行：</p>
				<p>
				<span>SELECT * FROM t1 FORCE INDEX(goodkey1,goodkey2)</span></p>
				<p>
				<span>WHERE (goodkey1 &lt; 10 OR goodkey2 &lt; 20) AND 
				badkey &lt; 30;</span></p>
				<p>
				<span>&nbsp;</span></p>
				<p>
				<span>SELECT * FROM t1 IGNORE INDEX(badkey)</span></p>
				<p>
				<span>WHERE (goodkey1 &lt; 10 OR goodkey2 &lt; 20) AND 
				badkey &lt; 30;</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果查询有一个复杂的<span>WHERE</span>子句，有较深的<span>AND/OR</span>嵌套关系，<span>MySQL</span>不选择该优选方案，通过下面的识别法则尝试分布各条件：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >(</span><i><span >x</span></i><span > AND </span><i><span >y</span></i><span >) OR </span><i><span >z</span></i><span > = (</span><i><span >x</span></i><span > OR </span><i><span >z</span></i><span >) AND (</span><i><span >y</span></i><span > OR </span><i><span >z</span></i><span >)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >(</span><i><span >x</span></i><span > OR </span><i><span >y</span></i><span >) AND </span><i><span >z</span></i><span > = (</span><i><span >x</span></i><span > AND </span><i><span >z</span></i><span >) OR (</span><i><span >y</span></i><span > AND </span><i><span >z</span></i><span >)</span></pre>
				<p>
				<span>index_merge</span>访问方法的不同变量之间的选择和其它访问方法基于各适用选项的成本估计。</p>
				<h4 class="title"><a name="index-merge-intersection"></a>
				7.2.6.1.&nbsp;索引合并交集访问算法</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<p>
				该访问算法可以用于当<span >WHERE</span>子句结合<span >AND</span>被转换为不同的关键字的几个范围条件，每个条件为下面之一：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>以这种形式，即索引有确切的<span><i><span>N</span></i></span>部分<span>(</span>即包括了所有索引部分<span>)</span>：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><i><span >key_part1</span></i><span >=</span><i><span >const1</span></i><span > AND </span><i><span >key_part2</span></i><span >=</span><i><span >const2</span></i><span > ... AND </span><i><span >key_partN</span></i><span >=</span><i><span >constN</span></i></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>任何<span>InnoDB</span>或<span>BDB</span>表的主键的范围条件。</p>
				<p>
				下面是一些例子：</p>
				<p><span>SELECT * FROM <i>
				innodb_table</i> WHERE <i>primary_key</i> &lt; 10 AND <i>key_col1</i>=20;</span></p>
				<p><span>&nbsp;</span></p>
				<p><span>SELECT * FROM <i>tbl_name</i></span></p>
				<p><span>WHERE (<i>key1_part1</i>=1 
				AND <i>key1_part2</i>=2) AND <i>key2</i>=2;</span></p>
				<p>
				索引合并交集算法同时对所有使用的索引进行扫描，并产生从合并的索引扫描接收的行序列的交集。</p>
				<p>
				如果使用的索引包括查询中使用的所有列，所有表记录均不搜索，并且在这种情况下<span>EXPLAIN</span>的输出包含<span >Extra</span>字段中的<span>Using 
				index</span>。下面是一个此类查询的例子：</p>
				<pre><span>SELECT COUNT(*) FROM t1 WHERE key1=1 AND key2=1;</span></pre>
				<p>
				如果使用的索引未包括查询中使用的所有列，只有满足所有使用的关键字的范围条件才搜索所有记录。</p>
				<p>如果某个合并条件是<span>InnoDB</span>或<span>BDB</span>表的主键的一个条件，不用于记录查询，但用于过滤使用其它条件搜索的记录。</p>
				<h4 class="title"><a name="index-merge-union"></a>
				7.2.6.2.&nbsp;索引合并并集访问算法</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<p>
				该算法的适用标准类似于索引合并方法交集算法的标准。算法可以用于当<span >WHERE</span>子句结合<span >OR</span>被转换为不同的关键字的几个范围条件的时候，每个条件为下面之一：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>以这种形式，即索引有确切的<span><i><span>N</span></i></span>部分<span>(</span>即包括了所有索引部分<span>)</span>：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span><i><span>key_part1</span></i></span><span>=</span><span><i><span>const1</span></i></span><span> AND </span><span><i><span>key_part2</span></i></span><span>=</span><span><i><span>const2</span></i></span><span> ... AND </span><span><i><span>key_partN</span></i></span><span>=</span><span><i><span>constN</span></i></span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>任何<span>InnoDB</span>或<span>BDB</span>表的主键的范围条件。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>索引合并方法交集算法适用的一个条件。</p>
				<p>
				下面是一些例子：</p>
				<pre><span>SELECT * FROM t1 WHERE </span><span><i><span>key1</span></i></span><span>=1 OR </span><span><i><span>key2</span></i></span><span>=2 OR </span><span><i><span>key3</span></i></span><span>=3;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>SELECT * FROM </span><span><i><span>innodb_table</span></i></span><span> WHERE (</span><span><i><span>key1</span></i></span><span>=1 AND </span><span><i><span>key2</span></i></span><span>=2) OR</span></pre>
				<pre><span>&nbsp; (</span><span><i><span>key3</span></i></span><span>=&#39;foo&#39; AND </span><span><i><span>key4</span></i></span><span>=&#39;bar&#39;) AND </span><span><i><span>key5</span></i></span><span>=5;</span></pre>
				<h4 class="title"><a name="index-merge-sort-union"></a>
				7.2.6.3.&nbsp;索引合并排序并集访问算法</h4></div></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			<p>
			该访问算法可以用于当<span >WHERE</span>子句结合<span >OR</span>被转换为不同的关键字的几个范围条件，但索引合并方法联合算法并不适用的时候。</p>
			<p>
			下面是一些例子：</p>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col1</span></i></span><span> &lt; 10 OR </span><span><i><span>key_col2</span></i></span><span> &lt; 20;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; WHERE (</span><span><i><span>key_col1</span></i></span><span> &gt; 10 OR </span><span><i><span>key_col2</span></i></span><span> = 20) AND </span><span><i><span>nonkey_col</span></i></span><span>=30;</span></pre>
			<p>
			排序联合算法和联合算法的区别是排序联合算法必须先索取所有记录的行<span>ID</span>，然后在返回记录前对它们进行排序。</p>
			<h3 class="title"><a name="is-null-optimization"></a>
			7.2.7.&nbsp;MySQL如何优化IS NULL<code class="literal"></code></h3></div></div></div><a class="indexterm" name="id2804804"></a><a class="indexterm" name="id2804813"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			<span>MySQL</span>可以对可以结合<span><i><span>col_name</span></i></span><span>
			</span>
			<span>=</span><span>
			</span><span><i>
			<span>constant_value</span></i></span>使用的<span><i><span>col_name</span></i></span><span>
			</span>
			<span>IS NULL</span>进行相同的优化。例如，<span>MySQL</span>可以使用索引和范围用<span>IS 
			NULL</span>搜索<span>NULL</span>。</p>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> IS NULL;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> &lt;=&gt; NULL;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE </span><span><i><span>key_col</span></i></span><span>=</span><span><i><span>const1</span></i></span><span> OR </span><span><i><span>key_col</span></i></span><span>=</span><span><i><span>const2</span></i></span><span> OR </span><span><i><span>key_col</span></i></span><span> IS NULL;</span></pre>
			<p>
			如果<span>WHERE</span>子句包括声明为<span>NOT 
			NULL</span>的列的<span><i><span>col_name</span></i></span><span>
			</span>
			<span>IS NULL</span>条件，表达式则优化。当列会产生<span>NULL</span>时，不会进行优化；例如，如果来自<span>LEFT 
			JOIN</span>右侧的表。</p>
			<p>
			<span>MySQL</span>也可以优化组合<span><i><span>col_name</span></i><span> 
			= <i>expr</i> AND <i>col_name</i> IS NULL</span></span>，这是解决子查询的一种常用形式。当使用优化时<span>EXPLAIN</span>显示<span>ref_or_null</span>。</p>
			<p>
			该优化可以为任何关键元素处理<span>IS 
			NULL</span>。</p>
			<p>
			下面是一些优化的查询例子，假定表<span>t2</span>的列<span>a</span>和<span>b</span>有一个索引：</p>
			<pre><span>SELECT * FROM t1 WHERE t1.a=</span><span><i><span>expr</span></i></span><span> OR t1.a IS NULL;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM t1, t2 WHERE t1.a=t2.a OR t2.a IS NULL;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM t1, t2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE (t1.a=t2.a OR t2.a IS NULL) AND t2.b=t1.b;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM t1, t2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE t1.a=t2.a AND (t2.b=t1.b OR t2.b IS NULL);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM t1, t2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE (t1.a=t2.a AND t2.a IS NULL AND ...)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; OR (t1.a=t2.a AND t2.a IS NULL AND ...);</span></pre>
			<p>
			<span>ref_or_null</span>首先读取参考关键字，然后单独搜索<span>NULL</span>关键字的行。</p>
			<p>
			请注意该优化只可以处理一个<span>IS 
			NULL</span>。在后面的查询中，<span>MySQL</span>只对表达式<span><span>(</span><span>t1.a=t2.a 
			AND t2.a IS NULL</span><span>)</span></span>使用关键字查询，不能使用<span>b</span>的关键元素：</p>
			<pre><span>SELECT * FROM t1, t2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; WHERE (t1.a=t2.a AND t2.a IS NULL)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; OR (t1.b=t2.b AND t2.b IS NULL);</span></pre>
			<h3 class="title"><a name="distinct-optimization"></a>
			7.2.8.&nbsp;MySQL如何优化DISTINCT<code class="literal"></code></h3></div></div></div><a class="indexterm" name="id2805038"></a><a class="indexterm" name="id2805047"></a>
			<p>
			在许多情况下结合<span>ORDER 
			BY</span>的<span>DISTINCT</span>需要一个临时表。</p>
			<p>
			请注意因为<span>DISTINCT</span>可能使用<span>GROUP 
			BY</span>，必须清楚<span>MySQL</span>如何使用所选定列的一部分的<span>ORDER 
			BY</span>或<span>HAVING</span>子句中的列。参见<a href="functions.html#group-by-hidden-fields" title="12.10.3. GROUP BY with Hidden Fields">12.10.3节，“具有隐含字段的GROUP 
		BY”</a>。</p>
			<p>
			在大多数情况下，<span>DISTINCT</span>子句可以视为<span>GROUP 
			BY</span>的特殊情况。例如，下面的两个查询是等效的：</p>
			<pre><span>SELECT DISTINCT c1, c2, c3 FROM t1 WHERE c1 &gt; </span><span><i><span>const</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT c1, c2, c3 FROM t1 WHERE c1 &gt; </span><span><i><span>const</span></i></span><span> GROUP BY c1, c2, c3;</span></pre>
			<p>
			由于这个等效性，适用于<span>GROUP 
			BY</span>查询的优化也适用于有<span>DISTINCT</span>子句的查询。这样，关于<span>DISTINCT</span>查询的优化的更详细的情况，参见<a href="optimization.html#group-by-optimization" title="7.2.13. How MySQL Optimizes GROUP BY">7.2.13节，“MySQL如何优化GROUP BY<code class="literal"></code>”</a>。</p>
			<p>
			结合<span>LIMIT
			<i>row_count</i></span>和<span>DISTINCT</span>后，<span>MySQL</span>发现唯一的<span><i><span>row_count</span></i></span>行后立即停止。</p>
			<p>
			如果不使用查询中命名的所有表的列，<span>MySQL</span>发现第<span>1</span>个匹配后立即停止扫描未使用的表。在下面的情况中，假定<span>t1</span>在<span>t2</span>之前使用<span>(</span>可以用<span>EXPLAIN</span>检查<span>)</span>，发现<span>t2</span>中的第<span>1</span>行后，<span>MySQL</span>不再<span>(</span>为<span>t1</span>中的任何行<span>)</span>读<span>t2</span>：</p>
			<pre><span>SELECT DISTINCT t1.a FROM t1, t2 where t1.a=t2.a;</span></pre>
		</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="left-join-optimization"></a>
			7.2.9.&nbsp;MySQL如何优化LEFT JOIN和RIGHT JOIN</h3></div></div></div><a class="indexterm" name="id2805216"></a><a class="indexterm" name="id2805224"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			在<span>MySQL</span>中，<span><i><span>A</span></i><span> 
			LEFT JOIN <i>B</i> join_condition</span></span>执行过程如下：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>根据表<span><i><span>A</span></i></span>和<span><i><span>A</span></i></span>依赖的所有表设置表<span>B</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>根据<span>LEFT 
			JOIN</span>条件中使用的所有表<span>(</span>除了<span><i><span>B</span></i></span><span>)</span>设置表<span><i><span>A</span></i></span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>LEFT JOIN</span>条件用于确定如何从表<span><i><span>B</span></i></span>搜索行。<span>(</span>换句话说，不使用<span>WHERE</span>子句中的任何条件）<span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>可以对所有标准联接进行优化，只是只有从它所依赖的所有表读取的表例外。如果出现循环依赖关系，<span>MySQL</span>提示出现一个错误。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>进行所有标准<span>WHERE</span>优化。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span><i><span>A</span></i></span>中有一行匹配<span>WHERE</span>子句，但<span><i><span>B</span></i></span>中没有一行匹配<span>ON</span>条件，则生成另一个<span><i><span>B</span></i></span>行，其中所有列设置为<span>NULL</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果使用<span>LEFT 
			JOIN</span>找出在某些表中不存在的行，并且进行了下面的测试：<span>WHERE</span>部分的<span><i><span>col_name</span></i><span> 
			IS NULL</span></span>，其中<span><i><span>col_name</span></i></span>是一个声明为 
			<span>NOT NULL</span>的列，<span>MySQL</span>找到匹配<span>LEFT 
			JOIN</span>条件的一个行后停止<span>(</span>为具体的关键字组合<span>)</span>搜索其它行。</p>
			<p>
			<span>RIGHT JOIN</span>的执行类似<span>LEFT 
			JOIN</span>，只是表的角色反过来。</p>
			<p>
			联接优化器计算表应联接的顺序。<span>LEFT 
			JOIN</span>和<span>STRAIGHT_JOIN</span>强制的表读顺序可以帮助联接优化器更快地工作，因为检查的表交换更少。请注意这说明如果执行下面类型的查询，<span>MySQL</span>进行全扫描<span >b</span>，因为<span>LEFT 
			JOIN</span>强制它在<span>d</span>之前读取：</p>
			<pre><span>SELECT *</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FROM a,b LEFT JOIN c ON (c.key=a.key) LEFT JOIN d ON (d.key=a.key)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE b.key=d.key;</span></pre>
			<p>
			在这种情况下修复时用<span>a</span>的相反顺序，<span>b</span>列于<span >FROM</span>子句中：</p>
			<pre><span>SELECT *</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FROM b,a LEFT JOIN c ON (c.key=a.key) LEFT JOIN d ON (d.key=a.key)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE b.key=d.key;</span></pre>
			<p>
			<span>MySQL</span>可以进行下面的<span>LEFT 
			JOIN</span>优化：如果对于产生的<span>NULL</span>行，<span>WHERE</span>条件总为假，<span>LEFT 
			JOIN</span>变为普通联接。</p>
			<p>
			例如，在下面的查询中如果<span >t2.column1</span>为<span>NULL</span>，<span>WHERE</span><span>
			</span>子句将为<span>false</span>：</p>
			<pre><span>SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;</span></pre>
			<p>
			因此，可以安全地将查询转换为普通联接：</p>
			<pre><span>SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;</span></pre>
			<p>这样可以更快，因为如果可以使查询更佳，<span>MySQL</span>可以在表<span>t1</span>之前使用表<span>t2</span>。为了强制使用表顺序，使用<span>STRAIGHT_JOIN</span>。</p>
			<h3 class="title"><a name="nested-joins"></a>
			7.2.10.&nbsp;MySQL如何优化嵌套Join</h3></div></div></div>
			<p>
			表示联接的语法允许嵌套联接。下面的讨论引用了<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>中描述的联接语法。</p>
			<p>
			同<span>SQL</span>标准比较，<span><i><span>table_factor</span></i></span>语法已经扩展了。后者只接受<span><i><span>table_reference</span></i></span>，而不是括号内所列的。</p>
			<p>
			<span><i>
			<span>table_reference</span></i></span>项列表内的每个逗号等价于内部联接，这是一个保留扩展名。例如：</p>
			<pre><span>SELECT * FROM t1 LEFT JOIN (t2, t3, t4)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span></pre>
			<p>
			等价于：</p>
			<pre><span>SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span></pre>
			<p>
			在<span>MySQL</span>中，<span>CROSS 
			JOIN</span>语法上等价于<span >INNER 
			JOIN</span><span> (</span>它们可以彼此代替。在标准<span>SQL</span>中，它们不等价。<span >INNER 
			JOIN</span>结合<span>ON</span>子句使用；<span>CROSS 
			JOIN</span><span> </span>用于其它地方。</p>
			<p>
			总的来说，在只包含内部联接操作的联接表达式中可以忽略括号。删除括号并将操作组合到左侧后，联接表达式：</p>
			<pre><span>t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)</span></pre>
			<pre><span>&nbsp;&nbsp; ON t1.a=t2.a</span></pre>
			<p>
			转换为表达式：</p>
			<pre><span>(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ON t2.b=t3.b OR t2.b IS NULL</span></pre>
			<p>
			但是这两个表达式不等效。要说明这点，假定表<span>t1</span>、<span>t2</span>和<span>t3</span>有下面的状态：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>表<span>t1</span>包含行<span>{1}</span>、<span>{2}</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>表<span>t2</span>包含行<span>{1,101}</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>表<span>t3</span>包含行<span>{101}</span></p>
			<p>
			在这种情况下，第<span>1</span>个表达式返回包括行<span>{1,1,101,101}</span>、<span>{2,NULL,NULL,NULL}</span>的结果，第<span>2</span>个表达式返回行<span>{1,1,101,101}</span>、<span>{2,NULL,NULL,101}</span>：</p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT *</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>FROM t1</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>LEFT JOIN</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>(t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>ON t1.a=t2.a;</span></b></span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>| a&nbsp;&nbsp;&nbsp; | a&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp; 101 |&nbsp; 101 |</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 2 | NULL | NULL | NULL |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT *</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>LEFT JOIN t3</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>ON t2.b=t3.b OR t2.b IS NULL;</span></b></span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>| a&nbsp;&nbsp;&nbsp; | a&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp; 101 |&nbsp; 101 |</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 2 | NULL | NULL |&nbsp; 101 |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<p>
			在下面的例子中，外面的联接操作结合内部联接操作使用：</p>
			<pre><span>t1 LEFT JOIN (t2</span>，<span>t3) ON t1.a=t2.a</span></pre>
			<p>
			该表达式不能转换为下面的表达式：</p>
			<pre><span>t1 LEFT JOIN t2 ON t1.a=t2.a</span>，<span>t3.</span></pre>
			<p>
			对于给定的表状态，第<span>1</span>个表达式返回行<span>{1,1,101,101}</span>、<span>{2,NULL,NULL,NULL}</span>，第<span>2</span>个表达式返回行<span>{1,1,101,101}</span>、<span>{2,NULL,NULL,101}</span>：</p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT *</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;</span></b></span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>| a &nbsp;&nbsp;&nbsp;| a&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp; 101 |&nbsp; 101 |</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 2 | NULL | NULL | NULL |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT *</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;</span></b></span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>| a&nbsp;&nbsp;&nbsp; | a&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp; 101 |&nbsp; 101 |</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 2 | NULL | NULL |&nbsp; 101 |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<p>
			因此，如果我们忽略联接表达式中的括号连同外面的联接操作符，我们会改变原表达式的结果。</p>
			<p>
			更确切地说，我们不能忽视左外联接操作的右操作数和右联接操作的左操作数中的括号。换句话说，我们不能忽视外联接操作中的内表达式中的括号。可以忽视其它操作数中的括号<span>(</span>外部表的操作数<span>)</span>。</p>
			<p>
			对于任何表<span><span>t1</span><span>、<span>t2</span>、<span>t3</span></span></span>和属性<span>t2.b</span>和<span>t3.b</span>的任何条件<span>P</span>，下面的表达式：</p>
			<pre><span>(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)</span></pre>
			<p>
			等价于表达式 </p>
			<pre><span>t1</span>，<span>t2 LEFT JOIN t3 ON P(t2.b,t3.b)</span></pre>
			<p>
			如果联接表达式<span>(</span><span><i><span>join_table</span></i></span><span>)</span>中的联接操作的执行顺序不是从左到右，我们则应讨论嵌套的联接。这样，下面的查询：</p>
			<pre><span>SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a</span></pre>
			<pre><span>&nbsp; WHERE t1.a &gt; 1</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a</span></pre>
			<pre><span>&nbsp; WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a &gt; 1</span></pre>
			<p>
			联接表：</p>
			<pre><span>t2 LEFT JOIN t3 ON t2.b=t3.b</span></pre>
			<pre><span>t2, t3</span></pre>
			<p>
			认为是嵌套的。第<span>1</span>个查询结合左联接操作则形成嵌套的联接，而在第二个查询中结合内联接操作形成嵌套联接。</p>
			<p>
			在第<span>1</span>个查询中，括号可以忽略：联接表达式的语法结构与联接操作的执行顺序相同。但对于第<span>2</span>个查询，括号不能省略，尽管如果没有括号，这里的联接表达式解释不清楚。<span>(</span>在外部扩展语法中，需要第<span>2</span>个查询的<span><span>(t2</span><span>，<span>t3)</span></span></span>的括号，尽管从理论上对查询分析时不需要括号：这些查询的语法结构将仍然不清楚，因为<span>LEFT 
			JOIN</span>和<span>ON</span>将充当表达式<span>(t2,t3)</span>的左、右界定符的角色<span>)</span>。</p>
			<p>
			前面的例子说明了这些点：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于只包含内联接<span>(</span>而非外联接<span>)</span>的联接表达式，可以删除括号。你可以移除括号并从左到右评估<span>(</span>或实际上，你可以按任何顺序评估表<span>)</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>总的来说，对外联接却不是这样。去除括号可能会更改结果。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>总的来说，对外联接和内联接的结合，也不是这样。去除括号可能会更改结果。</p>
			<p>
			含嵌套外联接的查询按含内联接的查询的相同的管道方式执行。更确切地说，利用了嵌套环联接算法。让我们回忆嵌套环联接执行查询时采用什么算法。</p>
			<p>
			假定我们有一个如下形式的表<span><span>T1</span><span>、<span>T2</span>、<span>T3</span></span></span>的联接查询：</p>
			<pre><span>SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INNER JOIN T3 ON P2(T2,T3)</span></pre>
			<pre><span>&nbsp; WHERE P(T1,T2,T3).</span></pre>
			<p>
			这里，<span>P1(T1,T2)</span>和<span>P2(T3,T3)</span>是一些联接条件<span>(</span>表达式<span>)</span>，其中<span>P(t1,t2,t3)</span>是表<span><span>T1</span><span>、<span>T2</span>、<span>T3</span></span></span>的列的一个条件。</p>
			<p>
			嵌套环联接算法将按下面的方式执行该查询：</p>
			<p>
			<span>&nbsp;</span></p>
			<pre><span>FOR each row t1 in T1 {</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2 such that P1(t1,t2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t3 in T3 such that P2(t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p >
			符号<span>t1||t2||t3</span>表示“<span class="quote">连接行</span><span>t1</span><span class="quote">、</span><span>t2</span><span class="quote">和</span><span>t3</span><span class="quote">的列组成的行</span>”。在下面的一些例子中，出现行名的<span>NULL</span>表示<span>NULL</span>用于行的每个列。例如，<span>t1||t2||NULL</span>表示“<span class="quote">连接行</span><span>t1</span><span class="quote">和</span><span>t2</span><span class="quote">的列以及</span><span>t3</span><span class="quote">的每个列的</span><span>NULL</span><span class="quote">组成的行</span>”。</p>
			<p>
			现在让我们考虑带嵌套的外联接的查询：</p>
			<pre><span>SELECT * FROM T1 LEFT JOIN</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2 LEFT JOIN T3 ON P2(T2,T3))</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON P1(T1,T2)</span></pre>
			<pre><span>&nbsp; WHERE P(T1,T2,T3)</span>。</pre>
			<p>
			对于该查询我们修改嵌套环模式可以得到：</p>
			<pre><span>FOR each row t1 in T1 {</span></pre>
			<pre><span>&nbsp; BOOL f1:=FALSE;</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2 such that P1(t1,t2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; BOOL f2:=FALSE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t3 in T3 such that P2(t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f2=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; IF (!f2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,NULL) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; IF (!f1) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; IF P(t1,NULL,NULL) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||NULL||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			总的来说，对于外联接操作中的第一个内表的嵌套环，引入了一个标志，在环之前关闭并且在环之后打开。如果对于外部表的当前行，如果匹配表示内操作数的表，则标志打开。如果在循环结尾处标志仍然关闭，则对于外部表的当前行，没有发现匹配。在这种情况下，对于内表的列，应使用<span>NULL</span>值补充行。结果行被传递到输出进行最终检查或传递到下一个嵌套环，但只能在行满足所有嵌入式外联接的联接条件时。</p>
			<p>
			在我们的例子中，嵌入了下面表达式表示的外联接表：</p>
			<pre><span>(T2 LEFT JOIN T3 ON P2(T2,T3))</span></pre>
			<p>
			请注意对于有内联接的查询，优化器可以选择不同的嵌套环顺序，例如：</p>
			<pre><span>FOR each row t3 in T3 {</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2 such that P2(t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t1 in T1 such that P1(t1,t2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p>
			对于有外联接的查询，优化器可以只选择这样的顺序：外表的环优先于内表的环。这样，对于有外联接的查询，只可能有一种嵌套顺序。在下面的查询中，优化器将评估两个不同的嵌套：</p>
			<pre><span>SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)</span></pre>
			<pre><span>&nbsp; WHERE P(T1,T2,T3)</span></pre>
			<p>
			嵌套为：</p>
			<pre><span>FOR each row t1 in T1 {</span></pre>
			<pre><span>&nbsp; BOOL f1:=FALSE;</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2 such that P1(t1,t2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t3 in T3 such that P2(t1,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1:=TRUE</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; IF (!f1) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; IF P(t1,NULL,NULL) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||NULL||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p>
			和</p>
			<pre><span>FOR each row t1 in T1 {</span></pre>
			<pre><span>&nbsp; BOOL f1:=FALSE;</span></pre>
			<pre><span>&nbsp; FOR each row t3 in T3 such that P2(t1,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t2 in T2 such that P1(t1,t2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1:=TRUE</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; IF (!f1) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; IF P(t1,NULL,NULL) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||NULL||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p>
			在两个嵌套中，必须在外环中处理<span>T1</span>，因为它用于外联接中。<span>T2</span>和<span>T3</span>用于内联接中，因此联接必须在内环中处理。但是，因为该联接是一个内联接，<span>T2</span>和<span>T3</span>可以以任何顺序处理。</p>
			<p>
			当讨论内联接嵌套环的算法时，我们忽略了部分详情，可能对查询执行的性能的影响会很大。我们没有提及所谓的“下推”条件。假定可以用连接公式表示我们的<span>WHERE</span>条件<span>P(T1,T2,T3)</span>：</p>
			<pre><span>P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3)</span><span>。</span></pre>
			<p>
			在这种情况下，<span>MySQL</span>实际使用了下面的嵌套环方案来执行带内联接得到查询：</p>
			<pre><span>FOR each row t1 in T1 such that C1(t1) {</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)&nbsp; {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p>
			你会看见每个连接 
			<span>C1(T1)</span>，<span>C2(T2)</span>，<span>C3(T3)</span>被从最内部的环内推出到可以对它进行评估的最外的环中。如果<span>C1(T1)</span>是一个限制性很强的条件，下推条件可以大大降低从表<span>T1</span>传递到内环的行数。结果是查询大大加速。</p>
			<p>
			对于有外联接的查询，只有查出外表的当前的行可以匹配内表后，才可以检查<span>WHERE</span>条件。这样，对内嵌套环下推的条件不能直接用于带外联接的查询。这里我们必须引入有条件下推前提，由遇到匹配后打开的标志保护。</p>
			<p>
			对于带下面的外联接的例子</p>
			<pre><span>P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)</span></pre>
			<p>
			使用受保护的下推条件的嵌套环方案看起来应为：</p>
			<pre><span>FOR each row t1 in T1 such that C1(t1) {</span></pre>
			<pre><span>&nbsp; BOOL f1:=FALSE;</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; such that P1(t1,t2) AND (f1?C2(t2):TRUE) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; BOOL f2:=FALSE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t3 in T3</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; such that P2(t2,t3) AND (f1&amp;&amp;f2?C3(t3):TRUE) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF (f1&amp;&amp;f2?TRUE:(C2(t2) AND C3(t3))) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f2=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; IF (!f2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF (f1?TRUE:C2(t2) &amp;&amp; P(t1,t2,NULL)) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; IF (!f1 &amp;&amp; P(t1,NULL,NULL)) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||NULL||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p>
			总的来说，可以从联接条件（例如<span>P1(T1,T2)</span>和<span>P(T2,T3)</span>）提取下推前提。在这种情况下，下推前提也受一个标志保护，防止检查由相应外联接操作所产生的<span>NULL</span><span>-</span>补充的行的断言。</p>
			<p>请注意如果从判断式的<span>WHERE</span>条件推导出，根据从一个内表到相同嵌套联接的另一个表的关键字进行的访问被禁止。<span>(</span>在这种情况下，我们可以使用有条件关键字访问，但是该技术还未用于<span>MySQL 
			5.1</span>中）<span>。</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="outer-join-simplification"></a>
			7.2.11.&nbsp;MySQL如何简化外部联合</h3></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			<p>
			在许多情况下，一个查询的<span >FROM</span>子句的表的表达式可以简化。</p>
			<p>
			在分析阶段，带右外联接操作的查询被转换为只包含左联接操作的等效查询。总的来说，根据以下原则进行转换：</p>
			<pre><span>(T1, ...) RIGHT JOIN (T2,...) ON P(T1,...,T2,...) =</span></pre>
			<pre><span>(T2, ...) LEFT JOIN (T1,...) ON P(T1,...,T2,...)</span></pre>
			<p>
			所有<span >T1 INNER JOIN T2 ON 
			P(T1,T2)</span>形式的内联接表达式被替换为<span>T1,T2</span>、<span><span>P(T1,T2)</span><span>，</span></span>并根据<span>WHERE</span>条件<span>(</span>或嵌入连接的联接条件，如果有<span>)</span>联接为一个连接。</p>
			<p>
			当优化器为用外联接操作的联接查询评估方案时，它只考虑在访问内表之前访问外表的操作的方案。优化器选项受到限制，因为只有这样的方案允许我们用嵌套环机制执行带外联接操作的查询。</p>
			<p>
			假定我们有一个下列形式的查询：</p>
			<p><span>SELECT * T1 LEFT JOIN T2 ON 
			P1(T1,T2)</span></p>
			<p><span>&nbsp; WHERE P(T1,T2) AND R(T2)</span></p>
			<p>
			<span>R(T2)</span>大大减少了表<span>T2</span>中匹配的行数。如果我们这样执行查询，优化器将不会有其它选择，只能在访问表<span>T2</span>之前访问表<span>T1</span>，从而导致执行方案非常低。</p>
			<p>
			幸运的是，如果<span>WHERE</span>条件拒绝<span>null</span>，<span>MySQL</span>可以将此类查询转换为没有外联接操作的查询。如果为该操作构建的<span>NULL</span>补充的行评估为<span>FALSE</span>或<span>UNKNOWN</span>，则该条件称为对于某个外联接操作拒绝<span>null</span>。</p>
			<p>
			因此，对于该外联接：</p>
			<pre><span>T1 LEFT JOIN T2 ON T1.A=T2.A</span></pre>
			<p>
			类似下面的条件为拒绝<span>null</span>：</p>
			<pre><span>T2.B IS NOT NULL,</span></pre>
			<pre><span>T2.B &gt; 3,</span></pre>
			<pre><span>T2.C &lt;= T1.C,</span></pre>
			<pre><span>T2.B &lt; 2 OR T2.C &gt; 1</span></pre>
			<p>
			类似下面的条件不为拒绝<span>null</span>：</p>
			<pre><span>T2.B IS NULL,</span></pre>
			<pre><span>T1.B &lt; 3 OR T2.B IS NOT NULL,</span></pre>
			<pre><span>T1.B &lt; 3 OR T2.B &gt; 3</span></pre>
			<p>
			检查一个外联接操作的条件是否拒绝<span>null</span>的总原则很简单。以下情况下为拒绝<span>null</span>的条件：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>形式为<span>A 
			IS NOT NULL</span>，其中<span>A</span>是任何内表的一个属性</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>包含内表引用的判断式，当某个参量为<span>NULL</span>时评估为<span>UNKNOWN</span></p>
			<p>
			<span  >
			·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>包含用于连接的拒绝<span>null</span>的条件的联合</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>拒绝<span>null</span>的条件的逻辑和</span></p>
			<p>
			一个条件可以对于一个查询中的一个外联接操作为拒绝<span>null</span>的而对于另一个不为拒绝<span>null</span>的。在下面的查询中：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN T2 
			ON T2.A=T1.A</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LEFT JOIN T3 
			ON T3.B=T1.B</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span></p>
			<p>
			<span>WHERE</span>条件对于第<span>2</span>个外联接操作为拒绝<span>null</span>的但对于第<span>1</span>个不为拒绝<span>null</span>的。</p>
			<p>
			如果<span>WHERE</span>条件对于一个查询中的一个外联接操作为拒绝<span>null</span>的，外联接操作被一个内联接操作代替。</p>
			<p>
			例如，前面的查询被下面的查询代替：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN T2 
			ON T2.A=T1.A</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INNER JOIN T3 
			ON T3.B=T1.B</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span></p>
			<p>
			对于原来的查询，优化器将评估只与一个访问顺序<span><span>T1</span><span>、<span>T2</span>、<span>T3</span></span></span>兼容的方案。在替换的查询中，还考虑了访问顺序<span><span>T3</span><span>、<span>T1</span>、<span>T2</span>。</span></span></p>
			<p>
			一个外联接操作的转化可以触发另一个的转化。这样，查询：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN T2 
			ON T2.A=T1.A</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LEFT JOIN T3 
			ON T3.B=T2.B</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span></p>
			<p>
			将首先转换为查询：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN T2 
			ON T2.A=T1.A</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INNER JOIN T3 
			ON T3.B=T2.B</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span></p>
			<p>
			该查询等效于查询：</p>
			<p><span>SELECT * FROM (T1 LEFT JOIN T2 
			ON T2.A=T1.A), T3</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0 AND T3.B=T2.B</span></p>
			<p>
			现在剩余的外联接操作也可以被一个内联接替换，因为条件<span>T3.B=T2.B</span>为拒绝<span>null</span>的，我们可以得到一个根本没有外联接的查询：</p>
			<p><span>SELECT * FROM (T1 INNER JOIN T2 
			ON T2.A=T1.A), T3</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0 AND T3.B=T2.B</span></p>
			<p>
			有时我们可以成功替换嵌入的外联接操作，但不能转换嵌入的外联接。下面的查询：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2 LEFT JOIN T3 
			ON T3.B=T2.B)</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON T2.A=T1.A</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span></p>
			<p>
			被转换为：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2 INNER JOIN T3 
			ON T3.B=T2.B)</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON T2.A=T1.A</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span>，</p>
			<p>
			只能重新写为仍然包含嵌入式外联接操作的形式：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2,T3)</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (T2.A=T1.A AND 
			T3.B=T2.B)</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span>。</p>
			<p>
			如果试图转换一个查询中的嵌入式外联接操作，我们必须考虑嵌入式外联接的联接条件和<span>WHERE</span>条件。在下面的查询中：</p>
			<pre><span>SELECT * FROM T1 LEFT JOIN</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2 LEFT JOIN T3 ON T3.B=T2.B)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON T2.A=T1.A AND T3.C=T1.C</span></pre>
			<pre><span>&nbsp; WHERE T3.D &gt; 0 OR T1.D &gt; 0</span></pre>
			<pre><span  >WHERE</span><span>条件对于嵌入式外联接不为拒绝<span>null</span>的，但嵌入式外联接</span><span >T2.A=T1.A AND T3.C=T1.C</span><span>的联接条件为拒绝<span>null</span>的</span>。<span>因此该查询可以转换为</span>：</pre>
			<p><span>SELECT * FROM T1 LEFT JOIN</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2, T3)</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON T2.A=T1.A AND 
			T3.C=T1.C AND T3.B=T2.B</span></p>
			<p><span>&nbsp; WHERE T3.D &gt; 0 OR T1.D &gt; 0</span></p>
			<h3 class="title"><a name="order-by-optimization"></a>
			7.2.12.&nbsp;MySQL如何优化ORDER BY<code class="literal"></code></h3></div></div></div>
			<p>
			在某些情况中，<span>MySQL</span>可以使用一个索引来满足<span>ORDER 
			BY</span>子句，而不需要额外的排序。</p>
			<p>
			即使<span>ORDER 
			BY</span>不确切匹配索引，只要<span>WHERE</span>子句中的所有未使用的索引部分和所有额外的<span>ORDER 
			BY </span>列为常数，就可以使用索引。下面的查询使用索引来解决<span>ORDER BY</span>部分：</p>
			<p><span>SELECT * FROM t1 </span></p>
			<p><span>&nbsp;&nbsp;&nbsp; ORDER BY <i>key_part1</i>,<i>key_part2</i>,... 
			;</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; </span></p>
			<p><span>SELECT * FROM t1 </span></p>
			<p><span>&nbsp;&nbsp;&nbsp; WHERE <i>key_part1</i>=<i>constant</i>
			</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; ORDER BY <i>key_part2</i>;</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; </span></p>
			<p><span>SELECT * FROM t1 </span></p>
			<p><span>&nbsp;&nbsp;&nbsp; ORDER BY <i>key_part1</i> 
			DESC, <i>key_part2</i> DESC;</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; </span></p>
			<p><span>SELECT * FROM t1</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; WHERE <i>key_part1</i>=1
			</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; ORDER BY <i>key_part1</i> 
			DESC, <i>key_part2</i> DESC;</span></p>
			<p>
			在某些情况下，<span>MySQL</span><em><span>不能</span></em>使用索引来解决<span>ORDER 
			BY</span>，尽管它仍然使用索引来找到匹配<span>WHERE</span>子句的行。这些情况包括：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对不同的关键字使用<span>ORDER 
			BY</span>：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >SELECT * FROM t1 ORDER BY </span><i><span >key1</span></i><span >, </span><i><span >key2</span><span>；</span></i></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对关键字的非连续元素使用<span>ORDER 
			BY</span>：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >SELECT * FROM t1 WHERE </span><i><span >key2</span></i><span >=</span><i><span >constant</span></i><span > ORDER BY </span><i><span >key_part2</span></i>；</pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>混合<span>ASC</span>和<span>DESC</span>：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >SELECT * FROM t1 ORDER BY </span><i><span >key_part1</span></i><span > DESC, </span><i><span >key_part2</span></i><span > ASC</span>；</pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>用于查询行的关键字与<span>ORDER BY</span>中所使用的不相同：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >SELECT * FROM t1 WHERE </span><i><span >key2</span></i><span >=</span><i><span >constant</span></i><span > ORDER BY </span><i><span >key1</span></i>；</pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>你正联接许多表，并且<span>ORDER BY</span>中的列并不是全部来自第<span>1</span>个用于搜索行的非常量表。<span>(</span>这是<span>EXPLAIN</span>输出中的没有<span>const</span>联接类型的第<span>1</span>个表）<span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>有不同的<span>ORDER 
			BY</span>和<span>GROUP 
			BY</span>表达式。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用的表索引的类型不能按顺序保存行。例如，对于<span>HEAP</span>表的<span>HASH</span>索引情况即如此。</p>
			<p>
			通过<span>EXPLAIN 
			SELECT ...ORDER BY</span>，可以检查<span>MySQL</span>是否可以使用索引来解决查询。如果<span>Extra</span>列内有<span>Using 
			filesort</span>，则不能解决查询。参见<a href="optimization.html#explain" title="7.2.1. EXPLAIN Syntax (Get Information About a SELECT)">7.2.1节，“EXPLAIN语法（获取关于SELECT的信息）<code class="literal"></code>”</a>。</p>
			<p>
			文件排序优化不仅用于记录排序关键字和行的位置，并且还记录查询需要的列。这样可以避免两次读取行。文件排序算法的工作象这样：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>读行匹配<span>WHERE</span>子句的行，如前面所示。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>对于每个行，记录构成排序关键字和行位置的一系列值，并且记录查询需要的列。</p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>根据排序关键字排序元组</p>
			<p>
			<span>4.<span>&nbsp;&nbsp;&nbsp;
			</span></span>按排序的顺序检索行，但直接从排序的元组读取需要的列，而不是再一次访问表。</p>
			<p>
			该算法比以前版本的<span>Mysql</span>有很大的改进。</p>
			<p>
			为了避免速度变慢，该优化只用于排序元组中的<span>extra</span>列的总大小不超过<span>max_length_for_sort_data</span>系统变量值的时候。<span>(</span>将该变量设置得太高的的迹象是将看到硬盘活动太频繁而<span>CPU</span>活动较低）<span>。
			</span></p>
			<p>
			如果想要增加<span>ORDER BY</span>的速度，首先看是否可以让<span>MySQL</span>使用索引而不是额外的排序阶段。如果不能，可以尝试下面的策略：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>增加<span>sort_buffer_size</span>变量的大小。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>增加<span>read_</span><span>rnd_buffer_size</span>变量的大小。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>更改<span>tmpdir</span>指向具有大量空闲空间的专用文件系统。该选项接受几个使用<span>round-robin(</span>循环<span>)</span>模式的路径。在<span>Unix</span>中路径应用冒号<span>(</span>‘<span>:</span>’<span>)</span>区间开，在<span>Windows</span>、<span>NetWare</span>和<span>OS/2</span>中用分号<span>(</span>‘<span>；</span>’<span>)</span>。可以使用该特性将负载均分到几个目录中。<em><span>注释：</span></em>路径应为位于不同<em><span>物理</span></em>硬盘上的文件系统的目录，而不是同一硬盘的不同的分区。</p>
			<p>
			默认情况下，<span>MySQL</span>排序所有<span><span>GROUP 
			BY <i>col1</i></span><span>，<i><span>col2</span></i>，<span>...</span></span></span>查询的方法如同在查询中指定<span>ORDER 
			BY</span><span><span>
			<i>col1</i></span><span>，<i><span>col2</span></i>，<span>...</span></span></span>。如果显式包括一个包含相同的列的<span>ORDER 
			BY</span>子句，<span>MySQL</span>可以毫不减速地对它进行优化，尽管仍然进行排序。如果查询包括<span>GROUP 
			BY</span>但你想要避免排序结果的消耗，你可以指定<span>ORDER BY</span><span> 
			NULL</span>禁止排序。例如：</p>
			<p><span>INSERT INTO foo</span></p>
			<p><span>SELECT a, COUNT(*) FROM bar 
			GROUP BY a ORDER BY NULL;</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-by-optimization"></a>
			7.2.13.&nbsp;MySQL如何优化GROUP BY<code class="literal"></code></h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#loose-index-scan">
				7.2.13.1. 松散索引扫描</a></span></dt><dt><span class="section"><a href="optimization.html#tight-index-scan">
				7.2.13.2. 紧凑索引扫描</a></span></dt></dl></div><a class="indexterm" name="id2807303"></a><a class="indexterm" name="id2807312"></a>
			<p>
			满足<span>GROUP 
			BY</span>子句的最一般的方法是扫描整个表并创建一个新的临时表，表中每个组的所有行应为连续的，然后使用该临时表来找到组并应用累积函数<span>(</span>如果有<span>)</span>。在某些情况中，<span>MySQL</span>能够做得更好，通过索引访问而不用创建临时表。</p>
			<p>
			为<span>GROUP 
			BY</span>使用索引的最重要的前提条件是 所有<span>GROUP 
			BY</span>列引用同一索引的属性，并且索引按顺序保存其关键字<span>(</span>例如，这是<span>B-</span>树索引，而不是<span>HASH</span>索引<span>)</span>。是否用索引访问来代替临时表的使用还取决于在查询中使用了哪部分索引、为该部分指定的条件，以及选择的累积函数。</p>
			<p>
			有两种方法通过索引访问执行<span>GROUP 
			BY</span>查询，如下面的章节所描述。在第<span>1</span>个方法中，组合操作结合所有范围判断式使用<span>(</span>如果有<span>)</span>。第<span>2</span>个方法首先执行范围扫描，然后组合结果元组。</p>
			<div class="section">
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="loose-index-scan"></a>
							7.2.13.1.&nbsp;松散索引扫描</h4></div></div></div>
				<p>
				使用索引时最有效的途径是直接搜索组域。通过该访问方法，<span>MySQL</span>使用某些关键字排序的索引类型<span>(</span>例如，<span>B-</span>树<span>)</span>的属性。该属性允许使用 
				索引中的查找组而不需要考虑满足所有<span>WHERE</span>条件的索引中的所有关键字。既然该访问方法只考虑索引中的关键字的一小部分，它被称为<em><span>松散索引扫描</span></em>。如果没有<span>WHERE</span>子句，
				松散索引扫描读取的关键字数量与组数量一样多，可以比所有关键字数小得多。如果<span>WHERE</span>子句包含范围判断式<span>(</span>关于<span>range</span>联接类型的讨论参见<a href="optimization.html#explain" title="7.2.1. EXPLAIN Syntax (Get Information About a SELECT)">7.2.1节，“EXPLAIN语法（获取关于SELECT的信息）<code class="literal"></code>”</a><span>)</span>，
				松散索引扫描查找满足范围条件的每个组的第<span>1</span>个关键字，并且再次读取尽可能最少数量的关键字。在下面的条件下是可以的：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>查询针对一个单表。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>GROUP BY</span>包括索引的第<span>1</span>个连续部分<span>(</span>如果对于<span>GROUP 
				BY</span>，查询有一个<span>DISTINCT</span>子句，则所有显式属性指向索引开头<span>)</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>只使用累积函数<span>(</span>如果有<span>)</span><span>MIN()</span>和<span>MAX()</span>，并且它们均指向相同的列。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>索引的任何其它部分（除了那些来自查询中引用的<span>GROUP 
				BY</span>）必须为常数<span>(</span>也就是说，必须按常量数量来引用它们<span>)</span>，但<span>MIN()</span>或<span>MAX()</span><span>
				</span>函数的参数例外。</p>
				<p>
				此类查询的<span>EXPLAIN</span>输出显示<span>Extra</span>列的<span>Using 
				indexforgroup-by</span>。</p>
				<p>
				下面的查询提供该类的几个例子，假定表<span>t1(c1,c2,c3,c4)</span>有一个索引<span><span>idx(c1</span><span>，<span>c2</span>，<span>c3)</span></span></span>：</p>
				<p><span>SELECT c1, c2 FROM t1 GROUP 
				BY c1, c2;</span></p>
				<p><span>SELECT DISTINCT c1, c2 FROM 
				t1;</span></p>
				<p><span>SELECT c1, MIN(c2) FROM t1 
				GROUP BY c1;</span></p>
				<p><span>SELECT c1, c2 FROM t1 WHERE 
				c1 &lt; <i>const</i> GROUP BY c1, c2;</span></p>
				<p><span>SELECT MAX(c3), MIN(c3), 
				c1, c2 FROM t1 WHERE c2 &gt; <i>const</i> GROUP BY c1, c2;</span></p>
				<p><span>SELECT c2 FROM t1 WHERE c1 
				&lt; <i>const</i> GROUP BY c1, c2;</span></p>
				<p><span>SELECT c1, c2 FROM t1 WHERE 
				c3 = <i>const</i> GROUP BY c1, c2</span>；</p>
				<p>
				由于上述原因，不能用该快速选择方法执行下面的查询：</p>
				<p>
				<span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>除了<span>MIN()</span>或<span><span>MAX()</span><span>，</span></span>还有其它累积函数，例如：</p>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; SELECT c1, SUM(c2) FROM t1 GROUP BY c1;</span></pre>
				<p>
				<span>2.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>GROUP BY</span>子句中的域不引用索引开头，如下所示：</p>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; SELECT c1,c2 FROM t1 GROUP BY c2, c3;</span></pre>
				<p>
				<span>3.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>查询引用了<span>GROUP 
				BY</span>部分后面的关键字的一部分，并且没有等于常量的等式，例如：</p>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; SELECT c1,c3 FROM t1 GROUP BY c1, c2</span>；</pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="tight-index-scan"></a>
				7.2.13.2.&nbsp;紧凑索引扫描</h4></div></div></div>
				<p>紧凑式索引扫描可以为索引扫描或一个范围索引扫描，取决于查询条件。</p>
				<p>如果不满足松散索引扫描条件，<span >GROUP 
				BY</span>查询仍然可以不用创建临时表。如果<span >WHERE</span>子句中有范围条件，该方法只读取满足这些条件的关键字。否则，进行索引扫描。该方法读取由<span >WHERE</span>子句定义的每个范围的所有关键字，或没有范围条件式扫描整个索引，我们将它定义为紧凑式索引扫描。请注意对于紧凑式索引扫描，只有找到了满足范围条件的所有关键字后才进行组合操作。</p>
				<p>要想让该方法工作，对于引用<span >GROUP 
				BY</span>关键字元素的前面、中间关键字元素的查询中的所有列，有一个常量等式条件即足够了。等式条件中的常量填充了搜索关键字中的“差距”，可以形成完整的索引前缀。这些索引前缀可以用于索引查找。如果需要排序<span >GROUP 
				BY</span>结果，并且能够形成索引前缀的搜索关键字，<span>MySQL</span>还可以避免额外的排序操作，因为使用有顺序的索引的前缀进行搜索已经按顺序检索到了所有关键字。</p>
				<p>上述的第一种方法不适合下面的查询，但第<span>2</span>种索引访问方法可以工作<span>(</span>假定我们已经提及了表<span >t1</span>的索引<span >idx</span><span>)</span>：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span >
				GROUP BY</span>中有一个差距，但已经由条件<span >c2 
				= &#39;a&#39;</span>覆盖。</p>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; SELECT c1</span>，<span>c2</span>，<span>c3 FROM t1 WHERE c2 = &#39;a&#39; GROUP BY c1</span>，<span>c3;</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span >
				GROUP BY</span>不以关键字的第<span>1</span>个元素开始，但是有一个条件提供该元素的常量：</p>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; SELECT c1</span>，<span>c2</span>，<span>c3 FROM t1 WHERE c1 = &#39;a&#39; GROUP BY c2</span>，<span>c3;</span></pre>
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="limit-optimization"></a>
			7.2.14.&nbsp;MySQL如何优化LIMIT<code class="literal"></code></h3></div></div></div><a class="indexterm" name="id2807761"></a><a class="indexterm" name="id2807770"></a>
			<p>
			在一些情况中，当你使用<span>LIMIT <i>row_count</i></span>而不使用<span>HAVING</span>时，<strong><span>MySQL</span></strong>将以不同方式处理查询。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果你用<span>LIMIT</span>只选择一些行，当<strong><span>MySQL</span><span>选择</span></strong>做完整的表扫描时，它将在一些情况下使用索引。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果你使用<span>LIMIT <i>row_count</i></span>与<span>ORDER 
			BY</span>，<strong><span>MySQL</span></strong>一旦找到了排序结果的第一个<i><span>row_count</span></i>行，将结束排序而不是排序整个表。如果使用索引，将很快。如果必须进行文件排序（<span>filesort</span>），必须选择所有匹配查询没有<span>LIMIT</span>子句的行，并且在确定已经找到第<span>1</span>个<span><i><span>row_count</span></i></span>行前，必须对它们的大部分进行排序。在任何一种情况下，一旦找到了行，则不需要再排序结果的其它部分，并且<span>MySQL</span>不再进行排序。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当结合<span>LIMIT <i>row_count</i></span>和<span>DISTINCT</span>时，<strong><span style="font-family:
宋体;">MySQL</span></strong>一旦找到<i><span>row_count</span></i>个唯一的行，它将停止。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一些情况下，<span>GROUP 
			BY</span>能通过顺序读取键<span>(</span>或在键上做排序<span>)</span>来解决，然后计算摘要直到关键字的值改变。在这种情况下，<span>LIMIT
			<i>row_count</i></span>将不计算任何不必要的<span>GROUP 
			BY</span>值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只要<span>MySQL</span>已经发送了需要的行数到客户，它将放弃查询，除非你正使用<span>SQL_CALC_FOUND_ROWS</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>LIMIT 
			0</span>将总是快速返回一个空集合。这对检查查询的有效性是有用的。当使用<span>MySQL 
			API</span>时，它也可以用来得到结果列的列类型。<span>(</span>该技巧在<span>MySQL 
			Monitor</span>中不工作，只显示<span>Empty set</span>；应使用<span>SHOW 
			COLUMNS</span>或<span>DESCRIBE</span>）<span>。
			</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当服务器使用临时表来进行查询时，使用<span>LIMIT
			<i>row_count</i></span>子句来计算需要多少空间。</p>
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title"><a name="how-to-avoid-table-scan"></a>7.2.15.&nbsp;如何避免表扫描</h3>
					</div></div></div><a class="indexterm" name="id2807970"></a>
			<p>
			<span>EXPLAIN</span>的输出显示了当<span>MySQL</span>使用表扫描来解决查询时使用的所有类型列。这通常在如下条件下发生：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>表很小，扫描表比查找关键字速度快。这对于少于<span>10</span>行并且行较短的表比较普遍。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>ON</span>或<span>WHERE</span>子句中没有适用的索引列的约束。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>正用常量值比较索引列，并且<span>MySQL</span>已经计算到<span>(</span>基于索引树<span>)</span>常数覆盖了表的很大部分并且表扫描将会比较快。参见<a href="optimization.html#where-optimizations" title="7.2.4. How MySQL Optimizes WHERE Clauses">7.2.4节，“MySQL怎样优化WHERE子句<code class="literal"></code>”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>你正通过另一个列使用一个低的集的势的关键字<span>(</span>许多行匹配关键字<span>)</span>。在这种情况下，<span>MySQL</span>假设通过使用关键字它可能会进行许多关键字查找，表扫描将会更快。</p>
			<p>
			对于小表，表扫描通常合适。对于大表，尝试下面的技巧以避免优化器错选了表扫描：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>ANALYZE TABLE <i>tbl_name</i></span>为扫描的表更新关键字分布。参见<a href="sql-syntax.html#analyze-table" title="13.5.2.1. ANALYZE TABLE Syntax">13.5.2.1节，“ANALYZE 
			TABLE语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对扫描的表使用<span>FORCE</span><span>
			</span><span>INDEX</span>告知<span>MySQL</span>，相对于使用给定的索引表扫描将非常耗时。参见<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >SELECT * FROM t1, t2 FORCE INDEX (</span><i><span >index_for_column</span></i><span >)</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE t1.</span><span><i><span>col_name</span></i></span><span>=t2.</span><span><i><span>col_name</span></i></span>；</pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>用<span>--max-seeks-for-key=1000</span>选项启动<strong><span>mysqld</span></strong>或使用<span>SET 
			max_seeks_for_key=1000</span>告知优化器假设关键字扫描不会超过<span>1,000</span>次关键字搜索。参见<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="insert-speed"></a>
			7.2.16.&nbsp;INSERT语句的速度</h3></div></div></div><a class="indexterm" name="id2808156"></a><a class="indexterm" name="id2808165"></a><a class="indexterm" name="id2808175"></a>
			<p>
			<span>插入一个记录需要的时间由下列因素组成</span><span>，其中的数字表示大约比例：</span></p>
			<ul type="disc">
				<li>
				连接：<span>(3)</span></li>
				<li>
				发送查询给服务器：<span>(2)</span></li>
				<li>
				分析查询：<span>(2)</span></li>
				<li>
				插入记录：（<span>1x</span>记录大小）</li>
				<li>
				插入索引：（<span>1x</span>索引）</li>
				<li>
				关闭：<span>(1)</span></li>
			</ul>
			<p>
			<span>这不考虑打开表的初始开销，每个并发运行的查询打开</span><span>。</span></p>
			<p>
			<span>表的大小以<span>log<i>N</i> 
			(B</span>树<span>)</span>的速度减慢索引的插入。</span></p>
			<p>
			加快插入的一些方法：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果同时从同一个客户端插入很多行，使用含多个<span>VALUE</span>的<span>INSERT</span>语句同时插入几行。这比使用单行<span>INSERT</span>语句快<span>(</span>在某些情况下快几倍<span>)</span>。如果你正向一个非空表添加数据，可以调节<span>bulk_insert_buffer_size</span>变量，使数据插入更快。参见<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果你从不同的客户端插入很多行，能通过<span>INSERT 
			DELAYED</span>语句加快速度。参见<a href="sql-syntax.html#insert" title="13.2.4. INSERT Syntax">13.2.4节，“INSERT语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>用<span>MyISAM</span>，如果在表中没有删除的行，能在<span>SELECT</span>语句正在运行的同时插入行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当从一个文本文件装载一个表时，使用<span>LOAD 
			DATA INFILE</span>。这通常比使用很多<span>INSERT</span>语句快<span>20</span>倍。参见<a href="sql-syntax.html#load-data" title="13.2.5. LOAD DATA INFILE Syntax">13.2.5节，“LOAD 
			DATA INFILE语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当表有很多索引时，有可能要多做些工作使得<span>LOAD 
			DATA INFILE</span>更快些。使用下列过程：</p>
			<ul type="disc">
				<ol start="1" type="1">
					<li>
					有选择地用<span>CREATE 
					TABLE</span>创建表。</li>
					<li>
					执行<span>FLUSH 
					TABLES</span>语句或命令<strong><span>mysqladmin 
					flush-tables</span></strong>。</li>
					<li>
					使用<b><span>myisamchk --keys-used=0 -rq <i>
					/path/to/db/tbl_name</i></span></b>。这将从表中取消所有索引的使用。</li>
					<li>
					用<span>LOAD DATA 
					INFILE</span>把数据插入到表中，因为不更新任何索引，因此很快。</li>
					<li>
					如果只想在以后读取表，使用<strong><span>myisampack</span></strong>压缩它。参见<a href="storage-engines.html#compressed-format" title="15.1.3.3. Compressed Table Characteristics">15.1.3.3节，“压缩表特性”</a>。</li>
					<li>
					用<strong><span>myisamchk -r 
					-q </span></strong><span><b><i>
					<span>/path/to/db/tbl_name</span></i></b></span>重新创建索引。这将在写入磁盘前在内存中创建索引树，并且它更快，因为避免了大量磁盘搜索。结果索引树也被完美地平衡。</li>
					<li>
					执行<span>FLUSH TABLES</span>语句或<strong><span>mysqladmin 
					flush-tables</span></strong>命令。</li>
				</ol>
			</ul>
			<p>
			请注意如果插入一个空<span>MyISAM</span>表，<span>LOAD 
			DATA INFILE</span>也可以执行前面的优化；主要不同处是可以让<strong><span>myisamchk</span></strong>为创建索引分配更多的临时内存，比执行<span>LOAD 
			DATA INFILE</span>语句时为服务器重新创建索引分配得要多。</p>
			<p>
			也可以使用<span>ALTER TABLE <i>tbl_name</i> DISABLE KEYS</span>代替<b><span>myisamchk 
			--keys-used=0 -rq <i>/path/to/db/tbl_name</i></span></b>，使用<span>ALTER 
			TABLE <i>tbl_name</i> ENABLE KEYS</span>代替<strong><span>myisamchk 
			-r -q </span></strong><span><b><i>
			<span>/path/to/db/tbl_name</span></i></b></span>。使用这种方式，还可以跳过<span>FLUSH 
			TABLES</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>锁定表可以加速用多个语句执行的<span>INSERT</span>操作：</p>
			<ul style=" margin-bottom: 0cm" type="disc">
				<li><span>LOCK TABLES a WRITE;</span></li>
				<li><span>INSERT INTO a VALUES 
				(1,23),(2,34),(4,33);</span></li>
				<li><span>INSERT INTO a VALUES 
				(8,26),(6,29);</span></li>
				<li><span>UNLOCK TABLES;</span></li>
			</ul>
			<p>
			这样性能会提高，因为索引缓存区仅在所有<span>INSERT</span>语句完成后刷新到磁盘上一次。一般有多少<span>INSERT</span>语句即有多少索引缓存区刷新。如果能用一个语句插入所有的行，就不需要锁定。</p>
			<p>
			对于事务表，应使用<span>BEGIN</span>和<span>COMMIT</span>代替<span>LOCK 
			TABLES</span>来加快插入。</p>
			<p>
			锁定也将降低多连接测试的整体时间，尽管因为它们等候锁定最大等待时间将上升。例如：</p>
			<p><span>
			Connection 1 does 1000 inserts</span></p>
			<p><span>
			Connections 2, 3, and 4 do 1 insert</span></p>
			<p><span>
			Connection 5 does 1000 inserts</span></p>
			<p>
			如果不使用锁定，<span>2</span>、<span>3</span>和<span>4</span>将在<span>1</span>和<span>5</span>前完成。如果使用锁定，<span>2</span>、<span>3</span>和<span>4</span>将可能不在<span>1</span>或<span>5</span>前完成，但是整体时间应该快大约<span>40%</span>。</p>
			<p>
			<span>INSERT</span>、<span>UPDATE</span>和<span>DELETE</span>操作在<strong><span>MySQL</span></strong>中是很快的，通过为在一行中多于大约<span>5</span>次连续不断地插入或更新的操作加锁，可以获得更好的整体性能。如果在一行中进行多次插入，可以执行<span>LOCK 
			TABLES</span>，随后立即执行<span>UNLOCK 
			TABLES</span><span>(</span>大约每<span>1000</span>行<span>)</span>以允许其它的线程访问表。这也会获得好的性能。</p>
			<p>
			<span>INSERT</span>装载数据比<span>LOAD 
			DATA INFILE</span>要慢得多，即使是使用上述的策略。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>为了对<span>LOAD 
			DATA INFILE</span>和<span>INSERT</span>在<span>MyISAM</span>表得到更快的速度，通过增加<span>key_</span><span>buffer_size</span>系统变量来扩大
			键高速缓冲区。参见<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2节，“调节服务器参数”</a>。</p>
			<div class="itemizedlist">&nbsp;</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="update-speed"></a>
			7.2.17.&nbsp;UPDATE语句的速度</h3></div></div></div>
		<p>
		更新查询的优化同<span>SELECT</span>查询一样，需要额外的写开销。写速度依赖于更新的数据大小和更新的索引的数量。没有更改的索引不被更新。</p>
		<p>
		使更改更快的另一个方法是推迟更改然后在一行内进行多次更新。如果锁定表，同时做多个更新比一次做一个快得多。</p>
		<p>
		请注意对使用动态记录格式的<span>MyISAM</span>表，更新一个较长总长的记录可能会切分记录。如果经常这样该，偶尔使用<span>OPTIMIZE 
		TABLE</span>很重要。参见<a href="sql-syntax.html#optimize-table" title="13.5.2.5. OPTIMIZE TABLE Syntax">13.5.2.5节，“OPTIMIZE 
		TABLE语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delete-speed"></a>
			7.2.18.&nbsp;DELETE语句的速度</h3></div></div></div>
			<p>
			删除一个记录的时间与索引数量确切成正比。为了更快速地删除记录，可以增加键高速缓冲的大小。参见<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2节，“调节服务器参数”</a>。</p>
			<p>
			如果想要删除一个表的所有行，使用<span>TRUNCATE TABLE <i>tbl_name</i>
			</span>而不要用<span>DELETE FROM <i>tbl_name</i></span>。参见<a href="sql-syntax.html#truncate" title="13.2.9. TRUNCATE Syntax">13.2.9节，“TRUNCATE语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="tips"></a>
			7.2.19.&nbsp;其它优化技巧</h3></div></div></div><a class="indexterm" name="id2808794"></a><a class="indexterm" name="id2808805"></a>
			<p>
			该节列出了提高查询速度的各种技巧：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用持久的连接数据库以避免连接开销。如果不能使用持久的连接并且你正启动许多新的与数据库的连接，可能要更改<span>thread_cache_size</span>变量的值。参见<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2节，“调节服务器参数”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>总是检查所有查询确实使用已经在表中创建了的索引。在<strong><span>MySQL</span></strong>中，可以用<span>EXPLAIN</span>命令做到。参见<a href="optimization.html#explain" title="7.2.1. EXPLAIN Syntax (Get Information About a SELECT)">7.2.1节，“EXPLAIN语法（获取关于SELECT的信息）<code class="literal"></code>”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>尝试避免在频繁更新的表上执行复杂的<span>SELECT</span>查询，以避免与锁定表有关的由于读、写冲突发生的问题。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于没有删除的行的<span>MyISAM</span>表，可以在另一个查询正从表中读取的同时在末尾插入行。如果这很重要，应考虑按照避免删除行的方式使用表。另一个可能性是在删除大量行后运行<span>OPTIMIZE 
			TABLE</span>。参见<a href="storage-engines.html#myisam-storage-engine" title="15.1. The MyISAM Storage Engine">15.1节，“MyISAM存储引擎”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>要修复任何<span>ARCHIVE</span>表可以发生的压缩问题，可以执行<span>OPTIMIZE 
			TABLE</span>。参见<a href="storage-engines.html#archive-storage-engine" title="15.8. The ARCHIVE Storage Engine">15.8节，“ARCHIVE存储引擎”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果你主要按<span><i><span>expr1</span></i><span>，<i><span>expr2</span></i>，<span>...</span></span></span>顺序检索行，使用<span >ALTER 
			TABLE ... ORDER BY <i>expr1</i>, <i>expr2</i>, ...</span>。对表大量更改后使用该选项，可以获得更好的性能。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一些情况下，使得基于来自其它表的列的信息引入一个“ 
			哈希”的列有意义。如果该列较短并且有合理的唯一值，它可以比在许多列上的一个大索引快些。在<strong><span>MySQL</span></strong>中，很容易使用这个额外列：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE </span><span><i><span>hash_col</span></i></span><span>=MD5(CONCAT(</span><span><i><span>col1</span></i></span><span>,</span><span><i><span>col2</span></i></span><span>))</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;AND </span><span><i><span>col1</span></i></span><span>=&#39;</span><span><i><span>constant</span></i></span><span>&#39; AND </span><span><i><span>col2</span></i></span><span>=&#39;</span><span><i><span>constant</span></i></span><span>&#39;;</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于频繁更改的<span >MyISAM</span>表，应试图避免所有变长列<span>(</span><span>VARCHAR</span>、<span>BLOB</span>和<span>TEXT</span><span>)</span>。如果表包括单一的变长列则使用动态记录格式。参见<a href="storage-engines.html">第15章：</a><a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types"><i>存储引擎和表类型</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			只是因为行太大，将一张表分割为不同的表一般没有什么用处。为了访问行，最大的性能冲击是磁盘搜索以找到行的第一个字节。在找到数据后，大多数新型磁盘对大多数应用程序来说足够快，能读入整个行。确实有必要分割的唯一情形是如果它是使用动态记录格式使之变为固定的记录大小的<span >MyISAM</span>表<span>(</span>见上述<span>)</span>，或如果你需要很频繁地扫描表而不需要大多数列。参见<a href="storage-engines.html">第15章：</a><a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types"><i>存储引擎和表类型</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			如果你需要很经常地计算结果，例如基于来自很多行的信息的计数，引入一个新表并实时更新计数器可能更好一些。下面形式的更新会更快一些：</p>
			<pre><span>UPDATE </span><span><i><span>tbl_name</span></i></span><span> SET </span><span><i><span>count_col</span></i></span><span>=</span><span><i><span>count_col</span></i></span><span>+1 WHERE </span><span><i><span>key_col</span></i></span><span>=</span><span><i><span>constant</span></i></span><span>;</span></pre>
			<p>
			当你使用象<span >MyISAM</span>那样的只有表级锁定的<strong><span>MySQL</span><span>存储引擎</span></strong><span>(</span>多重读<span>/</span>单个写<span>)</span>时，这确实很重要。这也给大多数数据库较好的性能，因为行锁定管理器在这种情况下有较少的事情要做。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			如果你需要从大的记录文件表中收集统计信息，使用总结性的表而不是扫描整个表。维护总结应该比尝试做“实时”统计要快些。当有变化时从日志重新生成新的总结表比改变运行的应用<span>(</span>取决于业务决策<span>)</span>要快得多。</p>
			<ul type="disc">
				<li>
				如果可能，应该将报告分类为“实时”或“统计”，这里统计报告所需的数据仅仅基于从实际数据定期产生的总结表中产生。</li>
				<li>充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减少<span>MySQL</span>需要做的语法分析从而提高插入速度。</li>
				<li>
				<span>在一些情况下，包装并存储数据到一个<span>BLOB</span>列中是很方便的。在这种情况下，必须在你的应用中增加额外的代码来打包<span>/</span>解包信息，但是这种方法可以在某些阶段节省很多访问。当有不符合行和列表结构的数据时，这很实用。</span></li>
				<li><span>
				在一般情况下，应该尝试以非冗余方式<span>(</span>查看数据库理论中的<i>第三正则形式</i><span>)</span>保</span>存数据，但是为了获得更快的速度，可以复制信息或创建总结表。</li>
				<li>存储过程或<span>UDF(</span>用户定义函数<span>)</span>可能是获得更好性能的一个好方法，详细信息参见<a href="stored-procedures.html">第20章：</a><a href="stored-procedures.html" title="Chapter 20. Stored Procedures and Functions"><i>存储程序和函数</i></a>和<a href="extending-mysql.html#adding-functions" title="27.2. Adding New Functions to MySQL">27.2节，“为MySQL添加新函数”</a>。 </li>
				<li>总是能通过在应用程序中缓存查询<span>/</span>答案并尝试同时执行很多插入<span>/</span>更新来获得一些好处。如果数据库支持锁定表<span>(</span>象<strong><span>MySQL</span></strong>和<span>Oracle)</span>，这应该有助于确保索引缓存只在所有更新后刷新一次。还可以利用<span>MySQL</span>的查询缓存来获得类似的结果；参见<a href="database-administration.html#query-cache" title="5.13. The MySQL Query Cache">5.13节，“MySQL查询高速缓冲”</a>。</li>
				<li>当不需要知道何时写入数据时，使用<span >INSERT 
				DELAYED</span>。这样可以加快处理，因为很多记录可以通过一次磁盘写入被写入。</li>
				<li>当你想要让选择显得更重要时，使用<span>INSERT 
				/*! LOW_PRIORITY */</span>。</li>
				<li>使用<span >INSERT 
				LOW_PRIORITY</span>来取得插入队列的检索，也就是即使有另一个客户等待写入也要执行<span >SELECT</span>。</li>
				<li>使用多行<span>INSERT</span>语句通过一个<span>SQL</span>命令来存储很多行<span>(</span>许多<span>SQL</span>服务器支持它，包括<span>MySQL</span><span>)</span>。</li>
				<li>使用<span>LOAD 
				DATA INFILE</span>装载较大数量的数据。这比使用<span >INSERT</span>要快得多。</li>
				<li>使用<span>AUTO_INCREMENT</span>列构成唯一值。</li>
				<li>当<span >MyISAM</span>使用动态表格式时，偶尔使用<span>OPTIMIZE 
				TABLE</span>可以避免碎片。参见<a href="storage-engines.html#myisam-table-formats" title="15.1.3. MyISAM Table Storage Formats">15.1.3节，“MyISAM表的存储格式”</a>。</li>
				<li>可能时使用<span >MEMORY</span>表以得到更快的速度。<span><a  href="../../../澶╂渤/2006.1/1/IT/IT/wwn/manual_Server.html#Table_types"><span>参见</span></a></span><a href="storage-engines.html#memory-storage-engine" title="15.4. The MEMORY (HEAP) Storage Engine">15.4节，“MEMORY (HEAP)存储引擎”</a>。</li>
				<li>在<span>Web</span>服务器中，图象和其它二进制资产应该作为文件存储。也就是仅在数据库中存储的本文件的引用而不是文件本身。大多数<span>Web</span>服务器在缓存文件方面比数据库内容要好得多，因此使用文件一般要快得多。</li>
				<li>对经常访问的不重要数据<span>(</span>如为没有在<span>Web
				</span>浏览器中启用<span>cookie</span>的用户最后显示的标语的相关信息<span>)</span>使用内存表。在许多<span>Web</span>应用程序环境中也可以使用用户会话来处理可变状态数据。</li>
				<li>
				在不同表中具有相同信息的列应该被声明为相同的并有相同的名字。尝试使名字简单化。例如，在<span >customer</span>表中使用<span>name</span>而不是<span>customer_name</span>。为了使名字能移植到其它<span>SQL</span>服务器，应该使名字短于<span>18</span>个字符。</li>
				<li>如果确实需要很高的速度，应该研究一下不同<span>SQL</span>服务器支持的数据存储的低层接口！例如直接访问<strong><span>MySQL</span></strong><span>
				</span><span>MyISAM</span>存储引擎，比起使用<span>SQL</span>接口，速度可以提高<span>2-5</span>倍。为了能实现，数据必须与应用程序在同一台服务器上，并且通常只应该被一个进程访问<span>(</span>因为外部文件锁定确实很慢<span>)</span>。通过在<strong><span>MySQL</span></strong>服务器中引进低层<span>MyISAM</span>命令能消除以上问题<span>(</span>如果需要，这可能是获得更好性能的一个简单的方法<span>)</span>。通过精心设计数据库接口，应该能相当容易地支持这类优化。</li>
				<li>如果正使用数字数据，在许多情况下，从一个数据库访问信息<span>(</span>使用实时连接<span>)</span>比访问一个文本文件快些。这是因为数据库中的信息比文本文件更紧凑，因此这将涉及更少的磁盘访问。还可以在应用程序中节省代码，因为不须分析文本文件来找出行和列的边界。</li>
			</ul>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份时主服务器变慢，可以使用一个从服务器来备份。参见<a href="replication.html">第6章：</a><a href="replication.html" title="Chapter 6. Replication in MySQL"><i>MySQL中的复制</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>用<span>DELAY_KEY_WRITE=1</span>选项声明<span>MyISAM</span>表可以使索引更新更快，因为在表关闭之前它们不刷新到硬盘上。不利之处是当表打开时如果杀掉服务器，应确保用<span>--myisam-recover</span>选项运行服务器保证没有问题，或者在重启服务器之前运行<strong><span>myisamchk</span></strong>。<span>(</span>然而，即使在这种情况下，应通过使用<span>DELAY_KEY_WRITE</span>保证不丢失数据，因为关键字信息总是可以从数据行产生）<span>。</span></p>
			<div class="itemizedlist">&nbsp;</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="locking-issues"></a>
		7.3.&nbsp;锁定事宜</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#internal-locking">
			7.3.1. 锁定方法</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">
			7.3.2. 表锁定事宜</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="internal-locking"></a>
			7.3.1.&nbsp;锁定方法</h3></div></div></div><a class="indexterm" name="id2809544"></a><a class="indexterm" name="id2809550"></a><a class="indexterm" name="id2809557"></a><a class="indexterm" name="id2809567"></a><a class="indexterm" name="id2809574"></a><a class="indexterm" name="id2809581"></a><a class="indexterm" name="id2809588"></a><a class="indexterm" name="id2809598"></a><a class="indexterm" name="id2809608"></a></div><div class="section"><div class="titlepage"><div><div>
		<p>
		<span>MySQL 5.1</span>支持对<span>MyISAM</span>和<span>MEMORY</span>表进行表级锁定，对<span>BDB</span>表进行页级锁定，对<span>InnoDB</span>表进行行级锁定。</p>
		<p>
		在许多情况下，可以根据培训猜测应用程序使用哪类锁定类型最好，但一般很难说出某个给出的锁类型就比另一个好。一切取决于应用程序，应用程序的不同部分可能需要不同的锁类型。</p>
		<p>
		为了确定是否想要使用行级锁定的存储引擎，应看看应用程序做什么并且混合使用什么样的选择和更新语句。例如，大多数<span>Web</span>应用程序执行许多选择，而很少进行删除，只对关键字的值进行更新，并且只插入少量具体的表。基本<span>MySQL
		</span>
		<span>MyISAM</span>设置已经调节得很好。</p>
		<p>
		在<span>MySQL</span>中对于使用表级锁定的存储引擎，表锁定时不会死锁的。这通过总是在一个查询开始时立即请求所有必要的锁定并且总是以同样的顺序锁定表来管理。</p>
		<p>
		对<span>WRITE</span>，<strong><span style="font-family:
宋体;">MySQL</span></strong>使用的表锁定方法原理如下：</p>
		<ul type="disc">
			<li>
			如果在表上没有锁，在它上面放一个写锁。</li>
			<li>
			否则，把锁定请求放在写锁定队列中。</li>
		</ul>
		<p>
		对<span>READ</span>，<strong><span style="
">MySQL</span></strong>使用的锁定方法原理如下：</p>
		<ul type="disc">
			<li>
			如果在表上没有写锁定，把一个读锁定放在它上面。</li>
			<li>
			否则，把锁请求放在读锁定队列中。</li>
		</ul>
		<p>
		当一个锁定被释放时，锁定可被写锁定队列中的线程得到，然后是读锁定队列中的线程。</p>
		<p>
		这意味着，如果你在一个表上有许多更新，<span>SELECT</span>语句将等待直到没有更多的更新。</p>
		<p>
		可以通过检查<span>table_locks_waited</span>和<span>table_locks_immediate</span>状态变量来分析系统上的表锁定争夺：</p>
		<p><span>mysql&gt; <b>SHOW STATUS LIKE 
		&#39;Table%&#39;;</b></span></p>
		<p><span>+-----------------------+---------+</span></p>
		<p><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp; |</span></p>
		<p><span>+-----------------------+---------+</span></p>
		<p><span>| Table_locks_immediate | 1151552 |</span></p>
		<p><span>| Table_locks_waited&nbsp;&nbsp;&nbsp; | 15324&nbsp;&nbsp; |</span></p>
		<p><span>+-----------------------+---------+</span></p>
		<p>
		如果<span>INSERT</span>语句不冲突，可以自由为<span>MyISAM</span>表混合并行的<span>INSERT</span>和<span>SELECT</span>语句而不需要锁定。也就是说，你可以在其它客户正读取<span>MyISAM</span>表的时候插入行。如果数据文件中间不包含空闲块，不会发生冲突，因为在这种情况下，记录总是插入在数据文件的尾部。<span>(</span>从表的中部删除或更新的行可能导致空洞）<span>。</span>如果有空洞，当所有空洞填入新的数据时，并行的插入能够重新自动启用。</p>
		<p>
		如果不能同时插入，为了在一个表中进行多次<span>INSERT</span>和<span>SELECT</span>操作，可以在临时表中插入行并且立即用临时表中的记录更新真正的表。</p>
		<p>
		这可用下列代码做到：</p>
		<p><span>mysql&gt; <b>LOCK TABLES real_table 
		WRITE, insert_table WRITE;</b></span></p>
		<p><span>mysql&gt; <b>INSERT INTO real_table 
		SELECT * FROM insert_table;</b></span></p>
		<p><span>mysql&gt; <b>TRUNCATE TABLE 
		insert_table;</b></span></p>
		<p><span>mysql&gt; <b>UNLOCK TABLES;</b></span></p>
		<pre><span>&nbsp;</span></pre>
		<p>
		<span>
		InnoDB</span>使用行锁定，<span>BDB</span>使用页锁定。对于这两种存储引擎，都可能存在死锁。这是因为，在<span>SQL</span>语句处理期间，<span>InnoDB</span>自动获得行锁定和<span>BDB</span>获得页锁定，而不是在事务启动时获得。</p>
		<p>
		行级锁定的优点：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>当在许多线程中访问不同的行时只存在少量锁定冲突。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>回滚时只有少量的更改。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以长时间锁定单一的行。</p>
		<p>
		行级锁定的缺点：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>比页级或表级锁定占用更多的内存。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果你在大部分数据上经常进行<span>GROUP 
		BY</span>操作或者必须经常扫描整个表，比其它锁定明显慢很多。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</p>
		<p>
		在以下情况下，表锁定优先于页级或行级锁定：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>表的大部分语句用于读取。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>对严格的关键字进行读取和更新，你可以更新或删除可以用单一的读取的关键字来提取的一行：</p>
		<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >UPDATE </span><i><span >tbl_name</span></i><span > SET </span><i><span >column</span></i><span >=</span><i><span >value</span></i><span > WHERE </span><i><span >unique_key_col</span></i><span >=</span><i><span >key_value</span></i><span >;</span></pre>
		<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >DELETE FROM </span><i><span >tbl_name</span></i><span > WHERE </span><i><span >unique_key_col</span></i><span >=</span><i><span >key_value</span></i><span >;</span></pre>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>
		<span>SELECT</span><span>
		</span>结合并行的<span>INSERT</span>语句，并且只有很少的<span>UPDATE</span>或<span>DELETE</span>语句。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>在整个表上有许多扫描或<span>GROUP 
		BY</span>操作，没有任何写操作。</p>
		<p>
		不同于行级或页级锁定的选项：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>版本<span>(</span>例如，为并行的插入在<span>MySQL</span>中使用的技术<span>)</span>，其中可以一个写操作，同时有许多读取操作。这说明数据库或表支持数据依赖的不同视图，取决于访问何时开始。其它共同的术语是“<span class="quote">时间跟踪</span>”、“<span class="quote">写复制</span>”或者“按需<span class="quote">复制</span>”。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>按需复制在许多情况下优先于页级或行级锁定。然而，在最坏的情况下，它可能比使用常规锁定使用更多的内存。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>除了行级锁定外，你可以使用应用程序级锁定，例如在<span>MySQL</span>中使用<span>GET_LOCK()</span>和<span>RELEASE_LOCK()</span>。这些是建议性锁定，它们只能在运行良好的应用程序中工作。</p>
		<h3 class="title"><a name="table-locking"></a>
			7.3.2.&nbsp;表锁定事宜</h3></div></div></div><a class="indexterm" name="id2810105"></a>
		<p>
		为达到最高锁定速度，除<span>InnoDB</span>和<span>BDB</span>之外，对所有存储引擎，<span>MySQL</span>使用表锁定<span>(</span>而不是页、行或者列锁定<span>)</span>。</p>
		<p>
		对于<span>InnoDB</span>和<span>BDB</span>表，如果你用<span>LOCK 
		TABLES</span>显式锁定表，<span>MySQL</span>只使用表锁定。对于这些表类型，我们建议你根本不要使用<span>LOCK 
		TABLES</span>，因为<span>InnoDB</span>使用自动行级锁定而<span>BDB</span>使用页级锁定来保证事务隔离。</p>
		<p>
		对于大表，对于大多数应用程序，表锁定比行锁定更好，但存在部分缺陷。</p>
		<p>
		表锁定使许多线程同时从一个表中进行读取操作，但如果一个线程想要对表进行写操作，它必须首先获得独占访问。更新期间，所有其它想要访问该表的线程必须等待直到更新完成。</p>
		<p>
		表更新通常情况认为比表检索更重要，因此给予它们更高的优先级。这应确保更新一个表的活动不能“<span class="quote">饿死</span>”，即使该表上有很繁重的<span>SELECT</span>活动。</p>
		<p>
		表锁定在这种情况下会造成问题，例如当线程正等待，因为硬盘已满并且在线程可以处理之前必须有空闲空间。在这种情况下，所有想要访问出现问题的表的线程也被设置成等待状态，直到有更多的硬盘空间可用。</p>
		<p>
		表锁定在下面的情况下也存在问题：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>一个客户发出长时间运行的查询。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>然后，另一个客户对同一个表进行更新。该客户必须等待直到<span>SELECT</span>完成。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>另一个客户对同一个表上发出了另一个<span>SELECT</span>语句。因为<span>UPDATE</span>比<span>SELECT</span>优先级高，该<span>SELECT</span>语句等待<span>UPDATE</span>完成，并且等待第<span>1</span>个<span>SELECT</span>完成。</p>
		<p>
		下面描述了一些方法来避免或减少表锁定造成的竞争：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>试图使<span>SELECT</span>语句运行得更快。你可能必须创建一些摘要<span>(summary)</span>表做到这点。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>用<span>--low-priority-updates</span>启动<span><b><span>mysqld</span></b></span>。这将给所有更新<span>(</span>修改<span>)</span>一个表的语句以比<span>SELECT</span>语句低的优先级。在这种情况下，在先前情形的第<span>2</span>个<span>SELECT</span>语句将在<span>UPDATE</span>语句前执行，而不需要等候第<span>1</span>个<span>SELECT</span>完成。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以使用<span>SET LOW_PRIORITY_UPDATES=1</span>语句指定具体连接中的所有更新应使用低优先级。参见<a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3节，“SET语法”</a></p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以用<span>LOW_PRIORITY</span>属性给与一个特定的<span>INSERT</span>、<span>UPDATE</span>或<span>DELETE</span>语句较低优先级。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以用<span>HIGH_PRIORITY</span>属性给与一个特定的<span>SELECT</span>语句较高优先级。参见<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>为<strong><span style="font-family:
宋体;">max_write_lock_count</span></strong>系统变量指定一个低值来启动<span><b><span>mysqld</span></b></span>来强制<span>MySQL</span>在具体数量的插入完成后临时提高所有等待一个表的<span>SELECT</span>语句的优先级。这样允许在一定数量的<span>WRITE</span>锁定后给出<span>READ</span>锁定。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果你有关于<span>INSERT</span>结合<span>SELECT</span>的问题，切换到使用新的<span>MyISAM</span>表，因为它们支持并发的<span>SELECT</span>和<span>INSERT</span>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果你对同一个表混合插入和删除，<span>INSERT DELAYED</span>将会有很大的帮助。参见<a href="sql-syntax.html#insert-delayed" title="13.2.4.2. INSERT DELAYED Syntax">13.2.4.2节，“INSERT 
			DELAYED语法”</a>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果你对同一个表混合使用<span>SELECT</span>和<span>DELETE</span>语句出现问题，<span>DELETE</span>的<span>LIMIT</span>选项可以有所帮助。参见<a href="sql-syntax.html#delete" title="13.2.1. DELETE Syntax">13.2.1节，“DELETE语法”</a>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>对<span>SELECT</span>语句使用<span>SQL_BUFFER_RESULT</span>可以帮助使表锁定时间变短。参见<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以更改<span>mysys/thr_lock.c</span>中的锁代码以使用单一的队列。在这种情况下，写锁定和读锁定将具有相同的优先级，对一些应用程序会有帮助。</p>
		<p>
		这里是一些<span>MySQL</span>中表锁定相关的技巧：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果不混合更新与需要在同一个表中检查许多行的选择，可以进行并行操作。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以使用<span>LOCK 
		TABLES</span>来提高速度，因为在一个锁定中进行许多更新比没有锁定的更新要快得多。将表中的内容切分为几个表也可以有所帮助。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果在<span>MySQL</span>中表锁定时遇到速度问题，可以将你的表转换为<span>InnoDB</span>或<span>BDB</span>表来提高性能。参见<a href="storage-engines.html#innodb" title="15.2. The InnoDB Storage Engine">15.2节，“InnoDB存储引擎”</a>和<a href="storage-engines.html#bdb-storage-engine" title="15.5. The BDB (BerkeleyDB) Storage Engine">15.5节，“BDB (BerkeleyDB)存储引擎”</a>。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="optimizing-database-structure"></a>
		7.4.&nbsp;优化数据库结构</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#design">
			7.4.1. 设计选择</a></span></dt><dt><span class="section"><a href="optimization.html#data-size">
			7.4.2. 使你的数据尽可能小</a></span></dt><dt><span class="section"><a href="optimization.html#indexes">
			7.4.3. 列索引</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">
			7.4.4. 多列索引</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-indexes">
			7.4.5. MySQL如何使用索引</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">
			7.4.6. MyISAM键高速缓冲</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-index-statistics">7.4.7. 
			MyISAM索引统计集合</a></span></dt><dt><span class="section"><a href="optimization.html#open-tables">
			7.4.8. MySQL如何计算打开的表</a></span></dt><dt><span class="section"><a href="optimization.html#table-cache">
			7.4.9. MySQL如何打开和关闭表</a></span></dt><dt><span class="section"><a href="optimization.html#creating-many-tables">
			7.4.10. 在同一个数据库中创建多个表的缺陷</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="design"></a>
			7.4.1.&nbsp;设计选择</h3></div></div></div><a class="indexterm" name="id2810606"></a><a class="indexterm" name="id2810616"></a><a class="indexterm" name="id2810623"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			<span>MySQL</span>将行数据和索引数据保存在不同的文件中。许多<span>(</span>几乎所有<span>)</span>其它数据库将行数据和索引数据混合保存在用一个文件中。我们认为<span>MySQL
			</span>选择对广范围的现代系统更好一些。</p>
			<p>
			保存行数据的另一种方式是将每个列的信息保存在单独的区域<span>(</span>例如<span>SDBM</span>和<span>Focus)</span>。这样会对每个访问多个列的查询造成性能问题。因为当访问多个列时退化得很快，我们认为该模型对一般数据库不合适。</p>
			<p>
			更常见的情形是索引和数据保存在一起<span>(</span>例如<span>Oracle/Sybase)</span>。在这种情况下，你可以在索引的叶级页找到行的信息。该布局比较好的事情是在许多情况下，根据索引缓存得怎样，可以保存一个硬盘读取。该布局的不利之处表现在：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>表扫描要慢得多，因为你必须通读索引以获得数据。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>你不能只使用表来检索查询的数据。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>你需要使用更多的空间，因为你必须从节点复制索引<span>(</span>你不能保存节点上的行<span>)</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>删除要经过一段时间后才退化表<span>(</span>因为删除时通常不会更新节点上的索引<span>)</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只缓存索引数据会更加困难。</p>
			<h3 class="title"><a name="data-size"></a>
			7.4.2.&nbsp;使你的数据尽可能小</h3></div></div></div><a class="indexterm" name="id2810729"></a><a class="indexterm" name="id2810739"></a><a class="indexterm" name="id2810749"></a><a class="indexterm" name="id2810760"></a><a class="indexterm" name="id2810770"></a>
			<p>
			最基本的优化之一是使表在磁盘上占据的空间尽可能小。这能给出巨大的改进，因为磁盘读入较快，并且在查询执行过程中小表的内容被处理时占用较少的主存储器。如果在更小的列上做索引，索引也占据较少的资源。</p>
			<p>
			<span>MySQL</span>支持许多不同的存储引擎<span>(</span>表类型<span>)</span>和行格式。对于每个表，可以确定使用哪个存储引擎和索引方法。为应用程序选择合适的表格式可以大大提高性能。参见<a href="storage-engines.html">第15章：</a><a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types"><i>存储引擎和表类型</i></a>。</p>
			<p>
			可以使用下面的技术可以使表的性能更好并且使存储空间最小：</p>
			<ul type="disc">
				<li>尽可能地使用最有效<span>(</span>最小<span>)</span>的数据类型。<strong><span>MySQL</span></strong>有很多节省磁盘空间和内存的专业化类型。</li>
				<li>尽可能使用较小的整数类型使表更小。例如，<span>MEDIUMINT</span>经常比<span>INT</span>好一些，因为<span>MEDIUMINT</span>列使用的空间要少<span>25%</span>。</li>
				<li>如果可能，声明列为<span>NOT 
				NULL</span>。它使任何事情更快而且每列可以节省一位。注意如果在应用程序中确实需要<span>NULL</span>，应该毫无疑问使用它，只是避免
				默认地在所有列上有它。</li>
				<li>对于<span >MyISAM</span>表，如果没有任何变长列<span>(</span><span>VARCHAR</span>、<span>TEXT</span>或<span>BLOB</span>列<span>)</span>，使用固定尺寸的记录格式。这比较快但是不幸地可能会浪费一些空间。参见<a href="storage-engines.html#myisam-table-formats" title="15.1.3. MyISAM Table Storage Formats">15.1.3节，“MyISAM表的存储格式”</a>。即使你已经用<span >CREATE</span>选项让<span>VARCHAR</span>列<span >ROW_FORMAT=fixed</span>，也可以提示想使用固定长度的行。</li>
				<li>在<span>MySQL/InnoDB</span>中，<span>InnoDB</span>表使用更紧凑的存储格式。在以前版本的<span>MySQL</span>中，<span>InnoDB</span>记录包含一些冗余信息，例如列数目和每个列的长度，即使对于固定大小的列。默认情况，创建的表为紧凑格式<span>(ROW_FORMAT=COMPACT)</span>。如果想要降级旧版本的<span>MySQL/InnoDB</span>，可以用<span>ROW_FORMAT=REDUNDANT</span>要求旧的格式。</li>
				<li>紧凑<span>的<span>InnoDB</span>格式也改变了包含<span>UTF-8</span>数据的</span><span  >CHAR</span><span>列的保存方式。在</span><span  >ROW_FORMAT=REDUNDANT</span><span>格式中</span><span>，</span><span >UTF-8
				</span>
				<span  >
				CHAR(<i>n</i>)</span><span>占用<span>3*</span></span><span><i><span  >n</span></i></span><span>字节</span><span>，</span><span>假</span>定<span>UTF-8</span>编码的字符的最大长度是<span>3</span>字节。许多语言可以主要用单字节<span>UTF-8</span>字符来编写，固定的存储长度通常会浪费空间。通过根据需要剥离尾部的空格，<span>ROW_FORMAT=COMPACT</span>格式为这些列分配可变数量的<span>n..3*n</span>字节。最小存储长度按顺序保存为<span>n</span>字节，以在典型情况下帮助更新。</li>
				<li>每张表的主索引应该尽可能短。这使一行的识别容易而有效。</li>
				<li>
				只创建你确实需要的索引。索引对检索有好处，但是当你需要快速存储东西时就变得糟糕。如果主要通过搜索列的组合来存取一个表，对它们做一个索引。第一个索引部分应该是最常用的列。如果从表中选择时总是使用许多列，应该首先以更多的副本使用列以获得更好的索引压缩。</li>
				<li>如果很可能一个索引在头几个字符上有唯一的前缀，仅仅索引该前缀比较好。<strong><span>MySQL</span></strong>支持对一个字符列的最左边部分创建一个索引<span>(</span>参见<a href="sql-syntax.html#create-index" title="13.1.4. CREATE INDEX Syntax">13.1.4节，“CREATE 
			INDEX语法”</a><span>)</span>。更短的索引会更快，不仅因为它们占较少的磁盘空间，而且因为它们将在索引缓存中提供更多的访问，因此磁盘搜索更少。参见<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2节，“调节服务器参数”</a>。</li>
			</ul>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一些情形下，将一个经常被扫描的表分割为<span>2</span>个表是有益的。特别是如果它是一个动态格式的表，并且可能使用一个扫描表时能用来找出相关行的较小静态格式的表。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="indexes"></a>
			7.4.3.&nbsp;列索引</h3></div></div></div><a class="indexterm" name="id2811058"></a><a class="indexterm" name="id2811068"></a><a class="indexterm" name="id2811078"></a>
			<p>
			所有<span>MySQL</span>列类型可以被索引。对相关列使用索引是提高<span>SELECT</span>操作性能的最佳途径。</p>
			<p>
			根据存储引擎定义每个表的最大索引数和最大索引长度。参见<a href="storage-engines.html">第15章：</a><a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types"><i>存储引擎和表类型</i></a>。所有存储引擎支持每个表至少<span>16</span>个索引，总索引长度至少为<span>256</span>字节。大多数存储引擎有更高的限制。</p>
			<p>
			在索引定义中用<span><i><span>col_name</span></i><span>(<i>length</i>)</span></span>语法，你可以创建一个只使用<span>CHAR</span>或<span>VARCHAR</span>列的第<span>1</span>个<span><i><span>length</span></i></span>字符的索引。按这种方式只索引列值的前缀可以使索引文件小得多。</p>
			<p>
			<span>MyISAM</span>和<span>InnoDB</span>存储引擎还支持对<span>BLOB</span>和<span>TEXT</span>列的索引。当索引一个<span>BLOB</span>或<span>TEXT</span>列时，你<em><span>必须</span></em>为索引指定前缀长度。例如：</p>
			<pre><span>CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));</span></pre>
			<p>
			在<span>MySQL 5.1</span>中，对于<span >MyISAM</span>和<span>InnoDB</span>表，前缀可以达到<span>1000</span>字节长。请注意前缀的限制应以字节为单位进行测量，而<span>CREATE 
			TABLE</span>语句中的前缀长度解释为字符数。<em><span>当为使用多字节字符集的列指定前缀长度时一定要加以考虑</span></em>。</p>
			<p>
			还可以创建<span>FULLTEXT</span>索引。该索引可以用于全文搜索。只有<span>MyISAM</span>存储引擎支持<span>FULLTEXT</span>索引，并且只为<span>CHAR</span>、<span>VARCHAR</span>和<span>TEXT</span>列。索引总是对整个列进行，不支持局部<span>(</span>前缀<span>)</span>索引。详情参见<a href="functions.html#fulltext-search" title="12.7. Full-Text Search Functions">12.7节，“全文搜索功能”</a>。</p>
			<p>
			也可以为空间列类型创建索引。只有<span>MyISAM</span>存储引擎支持空间类型。空间索引使用<span>R-</span>树。</p>
			<p>默认情况<span >MEMORY</span><span>(</span><span >HEAP</span><span>)</span>存储引擎使用<span>hash</span>索引，但也支持<span>B-</span>树索引。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="multiple-column-indexes"></a>
			7.4.4.&nbsp;多列索引</h3></div></div></div><a class="indexterm" name="id2811319"></a><a class="indexterm" name="id2811326"></a><a class="indexterm" name="id2811336"></a>
			<p>
			<span>MySQL</span>可以为多个列创建索引。一个索引可以包括<span>15</span>个列。对于某些列类型，可以索引列的前缀<span>(</span>参见<a href="optimization.html#indexes" title="7.4.3. Column Indexes">7.4.3节，“列索引”</a><span>)</span>。</p>
			<p>
			多列索引可以视为包含通过连接索引列的值而创建的值的排序的数组。</p>
			<p>
			<span>MySQL</span>按这样的方式使用多列索引：当你在<span>WHERE</span>子句中为索引的第<span>1</span>个列指定已知的数量时，查询很快，即使你没有指定其它列的值。</p>
			<p>
			假定表具有下面的结构：</p>
			<pre><span>CREATE TABLE test (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; id INT NOT NULL,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; last_name CHAR(30) NOT NULL,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; first_name CHAR(30) NOT NULL,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PRIMARY KEY (id),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; INDEX name (last_name,first_name)</span></pre>
			<pre><span>);</span></pre>
			<p>
			<span >name</span>索引是一个对<span>last_name</span>和<span >first_name</span>的索引。索引可以用于为<span>last_name</span>，或者为<span>last_name</span>和<span>first_name</span>在已知范围内指定值的查询。因此，<span >name</span>索引用于下面的查询：</p>
			<pre><span>SELECT * FROM test WHERE last_name=&#39;Widenius&#39;;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM test</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE last_name=&#39;Widenius&#39; AND first_name=&#39;Michael&#39;;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM test</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE last_name=&#39;Widenius&#39;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; AND (first_name=&#39;Michael&#39; OR first_name=&#39;Monty&#39;);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM test</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE last_name=&#39;Widenius&#39;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; AND first_name &gt;=&#39;M&#39; AND first_name &lt; &#39;N&#39;;</span></pre>
			<p>
			然而，<span >name</span>索引<em><span>不</span></em>用于下面的查询：</p>
			<pre><span>SELECT * FROM test WHERE first_name=&#39;Michael&#39;;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM test</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE last_name=&#39;Widenius&#39; OR first_name=&#39;Michael&#39;;</span></pre>
			<p><span>MySQL</span>使用索引提高查询性能的方式将在<a href="optimization.html#mysql-indexes" title="7.4.5. How MySQL Uses Indexes">7.4.5节，“MySQL如何使用索引”</a>中讨论。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-indexes"></a>
			7.4.5.&nbsp;MySQL如何使用索引</h3></div></div></div><a class="indexterm" name="id2811470"></a>
			<p>
			索引用于快速找出在某个列中有一特定值的行。不使用索引，<span>MySQL</span>必须从第<span>1</span>条记录开始然后读完整个表直到找出相关的行。表越大，花费的时间越多。如果表中查询的列有一个索引，<span>MySQL</span>能快速到达一个位置去搜寻到数据文件的中间，没有必要看所有数据。如果一个表有<span>1000</span>行，这比顺序读取至少快<span>100</span>倍。注意如果你需要访问大部分行，顺序读取要快得多，因为此时我们避免磁盘搜索。</p>
			<p>
			大多数<span>MySQL</span>索引<span>(</span><span >PRIMARY 
			KEY</span>、<span><span>UNIQUE</span>、<span>INDEX</span></span>和<span >FULLTEXT</span><span>)</span>在<span>B</span>树中存储。只是空间列类型的索引使用<span>R-</span>树，并且<span >MEMORY</span>表还支持<span>hash</span>索引。</p>
			<p>
			字符串自动地压缩前缀和结尾空格。参见<a href="sql-syntax.html#create-index" title="13.1.4. CREATE INDEX Syntax">13.1.4节，“CREATE 
		INDEX语法”</a>。</p>
			<p>
			总的来说，按后面的讨论使用索引。本节最后描述<span>hash</span>索引<span>(</span>用于<span >MEMORY</span>表<span>)</span>的特征。</p>
			<p>
			索引用于下面的操作：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>快速找出匹配一个<span>WHERE</span>子句的行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>删除行。如果可以在多个索引中进行选择，<span>MySQL</span>通常使用找到最少行的索引。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当执行联接时，从其它表检索行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对具体有索引的列<span><i><span>key_col</span></i></span>找出<span>MAX()</span>或<span>MIN()</span>值。由预处理器进行优化，检查是否对索引中在<span>key_</span><span><i><span>col</span></i></span>之前发生所有关键字元素使用了<span >WHERE
			<i>key_part_#</i> = <i>constant</i></span>。在这种情况下，<span>MySQL</span>为每个<span>MIN()</span>或<span>MAX()</span>表达式执行一次关键字查找，并用常数替换它。如果所有表达式替换为常量，查询立即返回。例如：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT MIN(</span><span><i><span>key_part2</span></i></span><span>),MAX(</span><span><i><span>key_part2</span></i></span><span>)</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_part1</span></i></span><span>=10;</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果对一个可用关键字的最左面的前缀进行了排序或分组<span>(</span>例如，<span>ORDER 
			BY key_part_1,key_part_2</span><span>)</span>，排序或分组一个表。如果所有关键字元素后面有<span>DESC</span>，关键字以倒序被读取。参见<a href="optimization.html#order-by-optimization" title="7.2.12. How MySQL Optimizes ORDER BY">7.2.12节，“MySQL如何优化ORDER BY<code class="literal"></code>”</a>。</p>
			<p>
			<span  >
			·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一些情况中，可以对一个查询进行优化以便不用查询数据行即可以检索值。<span>如果查询只使用来自某个表的数字型并且构成某些关键字的最左面前缀的列，为了更快，可以从索引树检索出值。</span></p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT </span><span><i><span>key_part3</span></i></span><span> FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE </span><span><i><span>key_part1</span></i></span><span>=1</span></pre>
			<p>
			假定你执行下面的<span>SELECT</span>语句：</p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT * FROM <i>tbl_name</i> WHERE col1=val1 AND col2=val2;</span></b></span></pre>
			<p>
			如果<span>col1</span>和<span>col2</span>上存在一个多列索引，可以直接取出相应行。如果<span>col1</span>和<span>col2</span>上存在单列索引，优化器试图通过决定哪个索引将找到更少的行来找出更具限制性的索引并且使用该索引取行。</p>
			<p>
			如果表有一个多列索引，优化器可以使用最左面的索引前缀来找出行。例如，如果有一个<span>3</span>列索引<span>(col1,col2,col3)</span>，则已经对<span>(col1)</span>、<span>(col1,col2)</span>和<span>(col1,col2,col3)</span>上的搜索进行了索引。</p>
			<p>
			如果列不构成索引最左面的前缀，<strong><span>MySQL</span></strong>不能使用局部索引。假定有下面显示的<span>SELECT</span>语句。</p>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE col1=val1;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE col1=val1 AND col2=val2;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE col2=val2;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE col2=val2 AND col3=val3;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			如果<span><span> 
			(col1</span><span>，<span>col2</span>，<span>col3)</span></span></span>有一个索引，只有前<span>2</span>个查询使用索引。第<span>3</span>个和第<span>4</span>个查询确实包括索引的列，但<span>(col2)</span>和<span><span>(col2</span><span>，<span>col3)</span></span></span>不是 
			<span>
			<span>(col1</span><span>，<span>col2</span>，<span>col3)</span></span></span>的最左边的前缀。</p>
			<p>
			也可以在表达式通过<span><span>=</span><span>、<span>&gt;</span>、<span>&gt;=</span>、<span>&lt;</span>、<span>&lt;=</span></span></span>或者<span>BETWEEN</span>操作符使用<span>B-</span>树索引进行列比较。如果<span>LIKE</span>的参数是一个不以通配符开头的常量字符串，索引也可以用于<span>LIKE</span>比较。例如，下面的<span>SELECT</span>语句使用索引：</p>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> LIKE &#39;Patrick%&#39;;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> LIKE &#39;Pat%_ck%&#39;;</span></pre>
			<p>
			在第<span>1</span>个语句中，只考虑带<span>&#39;Patrick&#39; 
			&lt;=key_<i>col</i> &lt; &#39;Patricl&#39;</span>的行。在第<span>2</span>个语句中，只考虑带<span>&#39;Pat&#39; 
			&lt;=key_<i>col</i> &lt; &#39;Pau&#39;</span>的行。</p>
			<p>
			下面的<span>SELECT</span>语句不使用索引：</p>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> LIKE &#39;%Patrick%&#39;;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> LIKE </span><span><i><span>other_col</span></i></span><span>;</span></pre>
			<p>
			在第一条语句中，<span>LIKE</span>值以一个通配符字符开始。在第二条语句中，<span>LIKE</span>值不是一个常数。</p>
			<p>
			如果使用<span >... LIKE &#39;%<i>string</i>%&#39;</span>并且<span><i><span>string</span></i></span>超过<span>3</span>个字符，<span>MySQL</span>使用<em><span>Turbo 
			Boyer-Moore</span><span>算法</span></em>初始化字符串的模式然后使用该模式来更快地进行搜索。</p>
			<p>
			如果<span><i><span>col_name</span></i></span>被索引，使用<span><i><span>col_name</span></i><span> 
			IS NULL</span></span>的搜索将使用索引。</p>
			<p>
			任何不跨越<span>WHERE</span>子句中的所有<span >AND</span>级的索引不用于优化查询。换句话说，为了能够使用索引，必须在每个<span >AND</span>组中使用索引前缀。</p>
			<p>
			下面的<span>WHERE</span>子句使用索引：</p>
			<pre><span>... WHERE </span><span><i><span>index_part1</span></i></span><span>=1 AND </span><span><i><span>index_part2</span></i></span><span>=2 AND </span><span><i><span>other_column</span></i></span><span>=3</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; /* </span><span><i><span>index</span></i></span><span> = 1 OR </span><span><i><span>index</span></i></span><span> = 2 */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index</span></i></span><span>=1 OR A=10 AND </span><span><i><span>index</span></i></span><span>=2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; /* optimized like &quot;</span><span><i><span>index_part1</span></i></span><span>=&#39;hello&#39;&quot; */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index_part1</span></i></span><span>=&#39;hello&#39; AND </span><span><i><span>index_part3</span></i></span><span>=5</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; /* Can use index on </span><span><i><span>index1</span></i></span><span> but not on </span><span><i><span>index2</span></i></span><span> or </span><span><i><span>index3</span></i></span><span> */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index1</span></i></span><span>=1 AND </span><span><i><span>index2</span></i></span><span>=2 OR </span><span><i><span>index1</span></i></span><span>=3 AND </span><span><i><span>index3</span></i></span><span>=3;</span></pre>
			<p>
			下面的<span>WHERE</span>子句不使用索引：</p>
			<pre><span>&nbsp;&nbsp;&nbsp; /* </span><span><i><span>index_part1</span></i></span><span> is not used */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index_part2</span></i></span><span>=1 AND </span><span><i><span>index_part3</span></i></span><span>=2</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; /*&nbsp; Index is not used in both parts of the WHERE clause&nbsp; */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index</span></i></span><span>=1 OR A=10</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; /* No index spans all rows&nbsp; */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index_part1</span></i></span><span>=1 OR </span><span><i><span>index_part2</span></i></span><span>=10</span></pre>
			<p>
			有时<span>MySQL</span>不使用索引，即使有可用的索引。一种情形是当优化器估计到使用索引将需要<span>MySQL</span>访问表中的大部分行时。<span>(</span>在这种情况下，表扫描可能会更快些，因为需要的搜索要少）<span>。</span>然而，如果此类查询使用<span>LIMIT</span>只搜索部分行，<span>MySQL</span>则使用索引，因为它可以更快地找到几行并在结果中返回。</p>
			<p>
			<span>Hash</span>索引还有一些其它特征：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>它们只用于使用<span>=</span>或<span>&lt;=&gt;</span>操作符的等式比较<span>(</span>但<em><span>很快</span></em><span>)</span>。它们用于比较
			操作符，例如发现范围值的<span>&lt;</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>优化器不能使用<span>hash</span>索引来加速<span>ORDER 
			BY</span>操作。<span>(</span>该类索引不能用来按顺序搜索下一个条目）<span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MySQL</span>不能确定在两个值之间大约有多少行<span>(</span>这被范围优化器用来确定使用哪个索引<span>)</span>。如果你将一个<span>MyISAM</span>表改为<span>hash-</span>索引的<span >MEMORY</span>表，会影响一些查询。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只能使用整个关键字来搜索一行。<span>(</span>用<span>B-</span>树索引，任何关键字的最左面的前缀可用来找到行）<span>。</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-key-cache"></a>
			7.4.6.&nbsp;MyISAM键高速缓冲</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#shared-key-cache">
				7.4.6.1. 共享键高速缓冲访问</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-key-caches">
				7.4.6.2. 多键高速缓冲</a></span></dt><dt><span class="section"><a href="optimization.html#midpoint-insertion">
				7.4.6.3. 中点插入策略</a></span></dt><dt><span class="section"><a href="optimization.html#index-preloading">
				7.4.6.4. 索引预加载</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-block-size">
				7.4.6.5. 键高速缓冲块大小</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-restructuring">
				7.4.6.6. 重构键高速缓冲</a></span></dt></dl></div><a class="indexterm" name="id2812335"></a><a class="indexterm" name="id2812342"></a>
			<p>
			为了使硬盘<span>I/O</span>最小化，<span>MyISAM</span>存储引擎使用一个被许多数据库管理系统使用的策略。它使用一个缓存机制将经常访问的表锁在内存中：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于索引块，维护一个称之为<i>键高速<em><span>缓冲</span></em></i><span>(</span>或<em><span>键高速缓冲区</span></em><span>)</span>的特殊结构。该结构包含大量块缓存区，其中放置了最常用的索引块。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于数据块，<span>MySQL</span>不使用特殊缓存。而使用原生的操作系统文件系统的缓存。</p>
			<p>
			本节首先描述了<span>MyISAM</span>键高速缓冲的基本操作。然后讨论了提高
			键高速缓冲性能并使你更好地控制缓存操作的最新的更改：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>多个线程可以并行访问缓存。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>可以设置多个键高速缓冲，并将表索引指定给具体缓存。</p>
			<p>
			可以使用<span>key_</span><span>buffer_size</span>系统变量控制
			键高速缓冲的大小。如果该变量设置为零，不使用键高速缓冲。如果<span>key_buffer_size</span>值太小不能分配最小数量的块缓存区<span>(8)</span>，也不使用
			键高速缓冲。</p>
			<p>
			如果键高速缓冲不工作，只使用操作系统提供的原生文件系统缓存区访问索引文件。<span>(</span>换句话说，使用与表数据块相同的策略表来访问索引块）<span>。
			</span></p>
			<p>
			索引块是一个连续的访问<span>MyISAM</span>索引文件的单位。通常一个索引块的大小等于索引<span>B-</span>树节点的大小。<span>(</span>在硬盘上使用<span>B-</span>树数据结构表示索引。树底部的节点为叶子节点。叶子节点上面的节点为非叶子节点）<span>。</span></p>
			<p>
			键高速缓冲结构中的所有块缓存区大小相同。该大小可以等于、大于或小于表索引块的大小。通常这两个值中的一个是另一个的几倍。</p>
			<p>
			当必须访问表索引块中的数据时，服务器首先检查是否它可以用于键高速缓冲中的某些块缓存区。如果适用，服务器访问键高速缓冲中的数据而不是硬盘上的数据。也就是说，从缓存读取或写入缓存，而不是从硬盘读写。否则，服务器选择一个包含一个不同的表索引块的缓存块缓存区，并用需要的表索引块的拷贝替换那里的数据。一旦新的索引块位于缓存中，可以访问索引数据。</p>
			<p>
			如果用于替换的块已经被修改了，块被视为“脏了”。在这种情况下，在替换前，其内容被刷新到它来自的表索引。</p>
			<p>通常服务器遵从<em><span>LRU(</span><span>最近最少使用</span><span>)</span></em>策略：当选择一个块用于替换时，它选择最近最少使用的索引块。为了使该选择更容易，
			键高速缓冲模块维护所有使用的块的专门队列<span>(<em><span>LRU</span></em></span><em><span>链</span></em><span>)</span>。当访问块时，它被放到队列最后。当块需要替换时，队列开头的块是最近最少使用的块，并成为第<span>1</span>个候选者。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="shared-key-cache"></a>
				7.4.6.1.&nbsp;共享键高速缓冲访问</h4></div></div></div>
				<p>
				在以下条件下，线程可以同时访问键高速缓冲缓存区：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>没有被更新的缓存区可以被多个线程访问。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>正被更新的缓存区让需要使用它的线程等待直到更新完成。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>多个线程可以发起请求替换缓存块，只要它们不彼此干扰<span>(</span>也就是说，只要它们需要不同的索引块，并且使不同的缓存块被替换<span>)</span>。</p>
				<p>
				对键高速缓冲的共享访问允许服务器大大提高吞吐量。</p>
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="multiple-key-caches"></a>
							7.4.6.2.&nbsp;多键高速缓冲</h4></div></div></div>
				<p>
				对键高速缓冲的共享访问可以提高性能但不能完全消除线程之间的竟争。它们仍然竞争对键高速缓冲缓存区的访问进行管理的控制结构。为了进一步降低
				键高速缓冲访问竟争，<span>MySQL 
				5.1</span>还提供了多个键高速缓冲，允许你为不同的键高速缓冲分配不同的表索引。</p>
				<p>
				有多个键高速缓冲时，当为给定的<span>MyISAM</span>表处理查询时，服务器必须知道使用哪个缓存。默认情况，所有<span>MyISAM</span>表索引被缓存到默认
				键高速缓冲中。要想为具体键高速缓冲分配表索引，应使用<span>CACHE 
				INDEX</span>语句<span>(</span>参见<a href="sql-syntax.html#cache-index" title="13.5.5.1. CACHE INDEX Syntax">13.5.5.1节，“CACHE 
			INDEX语法”</a><span>)</span>。</p>
				<p>
				例如，下面的语句将表<span>t1</span>、<span>t2</span>和<span>t3</span>的索引分配给名为<span >hot_cache</span>的
				键高速缓冲：</p>
				<pre><span>mysql&gt; </span><span><b><span>CACHE INDEX t1, t2, t3 IN hot_cache;</span></b></span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<pre><span>| Table&nbsp;&nbsp; | Op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Msg_type | Msg_text |</span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<pre><span>| test.t1 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| test.t2 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| test.t3 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<pre><span>&nbsp;</span></pre>
				<p>
				可以用<span>SET 
				GLOBAL</span>参数设置语句或使用服务器启动选项设置在<span>CACHE 
				INDEX</span>语句中引用的键高速缓冲的大小来创建键高速缓冲。例如：</p>
				<pre><span>mysql&gt; </span><span><b><span>SET GLOBAL keycache1.key_buffer_size=128*1024;</span></b></span></pre>
				<p>
				要想删除键高速缓冲，将其大小设置为零：</p>
				<pre><span>mysql&gt; </span><span><b><span>SET GLOBAL keycache1.key_buffer_size=0;</span></b></span></pre>
				<p>
				请注意不能删除默认键高速缓冲。删除默认键高速缓冲的尝试将被忽略：</p>
				<pre><span>mysql&gt; </span><span><b><span>set global key_buffer_size = 0;</span></b></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; </span><span><b><span>show variables like &#39;key_buffer_size&#39;;</span></b></span></pre>
				<pre><span>+-----------------+---------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp; | Value&nbsp;&nbsp; |</span></pre>
				<pre><span>+-----------------+---------+</span></pre>
				<pre><span>| key_buffer_size | 8384512 |</span></pre>
				<pre><span>+-----------------+---------+</span></pre>
				<pre><span>&nbsp;</span></pre>
				<p>
				键高速缓冲变量是结构式系统变量，有一个名和组件。对于<span >keycache1.key_buffer_size</span>，<span >keycache1</span>是缓存变量名，<span>key_buffer_size</span>是缓存组件。关于引用结构式
				键高速缓冲系统变量所使用的语法的描述，参见<a href="language-structure.html#structured-system-variables" title="9.4.1. Structured System Variables">9.4.1节，“结构式系统变量”</a></p>
				<p>
				默认情况下，表索引被分配给服务器启动时创建的主要<span>(</span>默认<span>)</span>键高速缓冲。当
				键高速缓冲被删除后，所有分配给它的索引被重新分配给默认键高速缓冲。</p>
				<p>
				对于一个忙的服务器，我们建议采用使用三个键高速缓冲的策略：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>占用为所有键高速缓冲分配的空间的<span>20%</span>的“热”键高速缓冲。该缓存用于频繁用于搜索但没有更新的表。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>占用为所有键高速缓冲分配的空间的<span>20%</span>的“冷”键高速缓冲。该缓存用于中等大小、大量修改的表，例如临时表。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>占用键高速缓冲空间的<span>20%</span>的“温”键高速缓冲。使用它作为默认
				键高速缓冲，默认情况被所有其它表使用。</p>
				<p>
				使用<span>3</span>个键高速缓冲有好处的一个原因是对一个键高速缓冲结构的访问不会阻挡对其它的访问。访问分配给一个缓存的表的查询不会与访问分配给其它缓存的表的查询竞争。由于其它原因也会提高性能：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				热缓存只用于检索查询，因此其内容决不会被修改。结果是，无论何时需要从硬盘上拉入索引块，选择用于替换的缓存块的内容不需要先刷新。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于分配给热缓存的索引，如果没有查询需要索引扫描，很有可能对应索引<span>B-</span>树的非叶子节点的索引块仍然在缓存中。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				当更新的节点位于缓存中并且不需要先从硬盘读入时，为临时表频繁执行的更新操作会执行得更快。如果临时表的索引的大小可以与冷键高速缓冲相比较，很可能更新的节点位于缓存中。</p>
				<p>
				<span>CACHE INDEX</span>在一个表和
				键高速缓冲之间建立一种联系，但每次服务器重启时该联系被丢失。如果你想要每次服务器重启时该联系生效，一个发办法是使用选项文件：包括配置
				键高速缓冲的变量设定值，和一个<span >init-file</span>选项用来命名包含待执行的<span>CACHE 
				INDEX</span>语句的一个文件。例如：</p>
				<pre><span>key_buffer_size = 4G</span></pre>
				<pre><span>hot_cache.key_buffer_size = 2G</span></pre>
				<pre><span>cold_cache.key_buffer_size = 2G</span></pre>
				<pre><span>init_file=/path/to/data-directory/mysqld_init.sql</span></pre>
				<p>
				每次服务器启动时执行<span >mysqld_init.sql</span>中的语句。该文件每行应包含一个<span>SQL</span>语句。下面的例子分配几个表，分别对应<span >hot_cache</span>和<span >cold_cache</span>：</p>
				<pre><span>CACHE INDEX a.t1, a.t2, b.t3 IN hot_cache</span></pre>
				<pre><span>CACHE INDEX a.t4, b.t5, b.t6 IN cold_cache</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="midpoint-insertion"></a>
				7.4.6.3.&nbsp;中点插入策略</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<p>
				默认情况，键高速缓冲管理系统采用<span>LRU</span>策略选择要收回的键高速缓冲块，但它也支持更复杂的方法，称之为“<span class="quote">中点插入策略</span>”。</p>
				<p>
				当使用中点插入策略时，<span>LRU</span>链被分为两个部分：一条热子链和一条温子链。两部分之间的划分点不固定，但
				键高速缓冲管理系统关注温部分不“<span class="quote">太短</span>”，总是包含至少<span >key_cache_division_limit</span>比例的
				键高速缓冲块。<span>key_cache_division_limit</span>是结构式
				键高速缓冲变量的一个组件，因此其值是一个可以根据每个缓存进行设置的参数。</p>
				<p>
				当一个索引块从表中读入键高速缓冲，它被放入温子链的末端。经过一定量的访问后<span>(</span>访问块<span>)</span>，它被提升给热子链。目前，需要用来提升一个块<span>(3)</span>的访问次数与所有索引块的相同。</p>
				<p>
				提升到热子链的块被放到子链的末端。块然后在该子链中循环。如果块在子链的开头停留足够长的时间，它被降到温链。该时间由键高速缓冲<span>key_cache</span><span>_age_threshold</span>组件的值确定。</p>
				<p>
				对于包含<span><i><span>N</span></i></span>个块的
				键高速缓冲，阈值表示，热子链开头的没有在最后<span><i><span>N</span></i><span> 
				*key_cache_age_threshold/100</span></span>次访问中被访问的块将被移动到温子链开头。该块然后变为第<span>1</span>个挤出的候选者，因为替换的块总是来自温子链的开头。</p>
				<p>
				中点插入策略允许你将更有价值的块总是在缓存中。如果你想使用简单的<span>LRU</span>策略，使<span>key_cache_division_limit</span>值保持其默认值<span>100</span>。</p>
				<p>
				若执行的查询要求索引扫描有效推出所有索引块对应有数值的高级<span>B-</span>树节点的缓存，中点插入策略可以帮助提高性能。要想避免，必须使用中点插入策略，而<span>key_cache_division_limit</span>设置为远小于<span>100</span>。然后在索引扫描操作过程中，有数值的经常访问的节点被保留在热子链中。</p>
				<h4 class="title"><a name="index-preloading"></a>7.4.6.4.&nbsp;索引预加载</h4></div></div></div>
				<p>
				如果键高速缓冲内有足够的块以容纳整个索引的块，或者至少容纳对应其非叶节点的块，则在使用前，预装含索引块的键高速缓冲很有意义。预装可以以更有效的方式将表索引块放入
				键高速缓冲缓存区中：通过顺序地从硬盘读取索引块。</p>
				<p>
				不进行预装，块仍然根据查询需要放入键高速缓冲中。尽管块将仍然在缓存中（因为有足够的缓存区保存它们），它们以随机方式从硬盘上索取，而不是以顺序方式。</p>
				<p>
				要想将索引预装到缓存中，使用<span >LOAD 
				INDEX INTO CACHE</span>语句。例如，下面的语句可以预装表<span>t1</span>和<span>t2</span>索引的节点<span>(</span>索引块<span>)</span>：</p>
				<pre><span>mysql&gt; </span><span><b><span>LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</span></b></span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<pre><span>| Table&nbsp;&nbsp; | Op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Msg_type | Msg_text |</span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<pre><span>| test.t1 | preload_keys | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| test.t2 | preload_keys | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<p>
				<span >IGNORE LEAVES</span>修改器只允许预装索引非叶节点所用的块。这样，上述的语句预装<span>t1</span>中的所有索引块，但只预装<span>t2</span>中的非叶节点对应的块。</p>
				<p>如果已经使用<span>CACHE 
				INDEX</span>语句为一个索引分配了一个键高速缓冲，预装可以将索引块放入该缓存。否则，索引被装入默认键高速缓冲。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="key-cache-block-size"></a>
				7.4.6.5.&nbsp;键高速缓冲块大小</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<p>
				可以使用<span>key_cache_block_size</span>变量为具体的
				键高速缓冲指定块缓存区的大小。这样允许为索引文件调节<span>I/O</span>操作的性能。</p>
				<p>
				当读缓存区的大小等于原生操作系统<span>I/O</span>缓存区的大小时，可以获得<span>I/O</span>操作的最佳性能。但是将关键字节点的大小设置为等于<span>I/O</span>缓存区的大小并不总是能保证最佳整体性能。当读取大的叶节点时，服务器读入大量的不需要的数据，结果防止读入其它叶子的节点。</p>
				<p>
				目前，你不能控制表内索引块的大小。该大小由服务器在创建<span>.MYI</span>索引文件时设置，取决于表定义中索引的关键字大小。在大多数情况下，它被设置为与<span>I/O</span>缓存区大小相等。</p>
				<h4 class="title"><a name="key-cache-restructuring"></a>
				7.4.6.6.&nbsp;重构键高速缓冲</h4></div></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			<p>
			键高速缓冲可以通过更新其参数值随时重新构建。例如：</p>
			<pre><span>mysql&gt; </span><span><b><span>SET GLOBAL cold_cache</span><span>。<span>key_buffer_size=4*1024*1024</span>；</span></b></span></pre>
			<p>
			如果你为<span>key_</span><span>buffer_size</span>或<span>key_cache_block_size</span>键高速缓冲组件分配的值与组件当前的值不同，服务器将毁掉缓存的旧结构并根据新值创建一个新的。如果缓存包含任何脏的块，服务器在销毁前将它们保存到硬盘上并重新创建缓存。如果你设置其它
			键高速缓冲参数，则不会发生重新构建。</p>
			<p>
			当重新构建键高速缓冲时，服务器首先将任何脏缓存区的内容刷新到硬盘上。之后，缓存内容不再需要。然而，重新构建并不阻塞需要使用分配给缓存的索引的查询。相反，服务器使用原生文件系统缓存直接访问表索引。文件系统缓存不如使用
			键高速缓冲有效，因此尽管查询可以执行，但速度会减慢。缓存被重新构建后，它又可以缓存分配给它的索引了，并且索引不再使用文件系统缓存。</p>
			<h3 class="title"><a name="myisam-index-statistics"></a>7.4.7. MyISAM索引统计集合</h3></div></div></div>
			<p>
			存储引擎搜集优化器使用的表的统计信息。表统计基于数数值组，其中数数值组是一系列有相同的关键字前缀值的记录。对于优化器，重要的统计即为数数值组的平均大小。</p>
			<p>
			<span>MySQL</span>用下述方式使用平均数数值组：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>估计必须为每个<span>ref</span>访问读取多少行</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>估计部分联接将产生多少行；也就是说，下述形式的操作将产生的行数：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp; </span><span>(...) JOIN </span><span><i><span>tbl_name</span></i></span><span> ON </span><span><i><span>tbl_name</span></i></span><span>.</span><span><i><span>key</span></i></span><span> = </span><span><i><span>expr</span></i></span></pre>
			<p>
			随着索引的平均数数值组大小的增加，索引将更没有用，因为每个查找的平均行数增加：为了让索引有利于优化目的，最好是每个索引值对应表内的少量行数。当某个给定的索引值产生较多行时，索引更加没有用，<span>MySQL</span>更不可能使用它。</p>
			<p>
			平均数数值组大小与表的集的势相关，即数数值组的数目。<span>SHOW 
			INDEX</span>语句显示集的势值（基于<span><i><span>N</span></i></span><span>/</span><span><i><span>S</span></i></span>），其中<span><i><span>N</span></i></span>是表内的记录数，<span><i><span>S</span></i></span>是平均数数值组大小。该比例产生表内数数值组的大约数。</p>
			<p>
			对于基于<span>&lt;=&gt;</span>比较
			操作符的联接，<span>NULL</span>并不视为与任何其它值不同：<span>NULL 
			&lt;=&gt; NULL</span>，正如对于其它<span><i><span>N</span></i></span><span>
			</span>，<span><i><span>N</span></i><span> 
			&lt;=&gt; <i>N</i></span></span>。</p>
			<p>
			然而，对于基于<span>=</span>操作符的联接，<span>NULL</span>与非<span>NULL</span>值不同：当<span><i><span>expr1</span></i></span>或<span><i><span>expr2</span></i></span><span>(</span>或两者<span>)</span>为<span>NULL</span>时，<span><i><span>expr1</span></i><span> 
			= <i>expr2</i></span></span>不为真。这样影响比较形式<span><i><span>tbl_name.key</span></i><span> 
			= <i>expr</i></span></span>的<span>ref</span>访问：如果<span><i><span>expr</span></i></span>当前的值为<span>NULL</span>，<span>MySQL</span>不会访问表，因为比较不能为真。</p>
			<p>
			<span>对于<span>=</span></span>比较，表内有多少<span>NULL</span>值并不重要。为了优化目的，相关值为非<span>NULL</span>数值组的平均大小。然而，<span>MySQL</span>目前不允许搜集或使用该平均大小。</p>
			<p>
			<span>对于<span>MyISAM</span>表，你可以使用</span><span  >myisam_stats_method</span><span>系统变量部分控制表统计信息的搜集。该变量有两个可能的不同值，如下所示：</span></p>
			<p>
			<span  >
			·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>当</span><span  >myisam_stats_method</span><span>为</span><span  >nulls_equal</span><span>时，所有</span><span  >NULL</span><span>值被视为相等的<span>(</span>也就是说，它们都形成一个数值组<span>)</span>。</span></p>
			<p>
			<span>如果</span><span  >NULL</span><span>数值组大小远大于平均非</span><span  >NULL</span><span>数值组大小，该方法向上倾斜平均数数值组大小。这样使索引对于优化器来说比它实际为查找非</span><span  >NULL</span><span>值的联接更加没有用。结果是，</span><span  >nulls_equal</span><span>方法会使优化器进行</span><span  >ref</span><span>访问时本应使用索引而没有使用。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当<span>myisam_stats_method</span>为<span>nulls_unequal</span>时，<span>NULL</span>值不视为相同。相反，每个<span>NULL</span>值形成一个单独的数值组，大小为<span>1</span>。</p>
			<p>
			如果你有许多<span>NULL</span>值，该方法向下倾斜平均数数值组大小。如果平均非<span>NULL</span>数值组较大，统计大小为<span>1</span>的每个组的<span>NULL</span>值会使优化器过高估计查找非<span>NULL</span>值的联接的索引值。结果是，当其它方法会更好时，<span>nulls_unequal</span>方法会使优化器为<span>ref</span>查找使用该索引。</p>
			<p>
			如果你要使用许多使用<span>&lt;=&gt;</span>而不是<span>=</span>的联接，在比较过程中<span>NULL</span>值并不特殊，一个<span>NULL</span>等于另一个<span>NULL</span>。在这种情况下，<span>nulls_equal</span>是合适的统计方法。</p>
			<p>
			<span>myisam_stats_method</span>系统变量有全局和会话值。设置全局值会影响<span>MyISAM</span><span>
			</span>为所有<span>MyISAM</span>表的统计的搜集。设置会话值只影响当前客户连接的统计的搜集。这说明你可以强制用给定的方法重新生成表的统计的搜集，而不需要因为设置<span>myisam_stats_method</span>的会话值而影响其它客户。</p>
			<p>
			可以使用下面任一方法来重新生成表的统计信息：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>设置<span>myisam_stats_method</span>，然后执行<span>CHECK 
			TABLE</span>语句</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>执行<strong><span>myisamchk 
			--stats_method=method_name --analyze</span></strong></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>更改表，使其统计信息不为最新<span>(</span>例如，插入一行然后删除它<span>)</span>，然后设置<span>myisam_stats_method</span>并执行<span>ANALYZE 
			TABLE</span>语句</p>
			<p>
			使用<span>myisam_stats_method</span>的一些警告：</p>
			<p>
			你可以强制显式搜集表的统计信息，如上所述。然而，<span>MySQL</span>也可以自动搜集统计信息。例如，如果在为表执行语句的过程中，一些语句修改了表，<span>MySQL</span>可以搜集统计信息。<span>(</span>例如，大批插入或删除，或者执行<span>ALTER 
			TABLE</span>语句时可能发生）<span>。</span>如果发生，使用<span>myisam_stats_method</span>此时所有的值搜集统计信息。这样，如果你使用一个方法搜集统计信息，但当后面自动搜集一个表的统计信息时<span>myisam_stats_method</span>被设置为另一个方法，将使用其它方法。</p>
			<p>
			对于给定的<span>MyISAM</span>表，还不能说出使用哪个方法来产生统计信息。</p>
			<p>
			<span>myisam_stats_method</span>只适合<span>MyISAM</span>表。其它存储引擎只有一个方法来搜集表的统计信息。通常它接近于<span>nulls_equal</span>方法。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="open-tables"></a>
			7.4.8.&nbsp;MySQL如何计算打开的表</h3></div></div></div><a class="indexterm" name="id2813747"></a><a class="indexterm" name="id2813757"></a>
			<p>
			当运行<strong><span>mysqladmin status</span></strong>时，将看见象这样的一些东西：</p>
			<pre><span>Uptime: 426 Running threads: 1 Questions: 11082</span></pre>
			<pre><span>Reloads: 1 Open tables: 12</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			如果你仅有<span>6</span>个表，<span >Open 
			tables</span>值为<span>12</span>可能有点令人困惑。</p>
			<p>
			<strong>
			<span>
			MySQL</span></strong>是多线程的，因此许多客户可以同时在同一个表上进行查询。为了使多个客户线程在同一个表上有不同状态的问题减到最小，表被每个并发进程独立地打开。这样需要额外的内存但一般会提高性能。对于<span>MyISAM</span>表，数据文件需要为每个打开表的客户提供一个额外的文件描述符。<span>(</span>索引文件描述符在所有线程之间共享<span>)</span>。</p>
			<p>
			下一节中提供了该主题的更多的信息。参见<a href="optimization.html#table-cache" title="7.4.9. How MySQL Opens and Closes Tables">7.4.9节，“MySQL如何打开和关闭表”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="table-cache"></a>
			7.4.9.&nbsp;MySQL如何打开和关闭表</h3></div></div></div><a class="indexterm" name="id2813823"></a><a class="indexterm" name="id2813832"></a><a class="indexterm" name="id2813842"></a><a class="indexterm" name="id2813853"></a><a class="indexterm" name="id2813863"></a><a class="indexterm" name="id2813873"></a>
			<p>
			<span>table_cache</span>、<span>max_connections</span>和<span>max_tmp_tables</span>系统变量影响服务器保持打开的文件的最大数量。如果你增加这些值其中的一个或两个，会遇到操作系统为每个进程打开文件描述符的数量强加的限制。许多操作系统允许你增加打开的文件的限制，尽管该方法随系统的不同而不同。查阅操作系统文档以确定是否可以增加限制以及如何操作。</p>
			<p>
			<span>table_cache</span>与<span>max_connections</span>有关。例如，对于<span>200</span>个并行运行的连接，应该让表的缓存至少有<span><span>200 
			* </span><i><span>N</span></i></span>，这里<span><i><span>N</span></i></span>是可以执行的查询的一个联接中表的最大数量。还需要为临时表和文件保留一些额外的文件描述符。</p>
			<p>
			确保操作系统可以处理<span>table_cache</span>设置所指的打开的文件描述符的数目。如果<span>table_cache</span><span>is</span>设得太高，<span>MySQL</span>可能为文件描述符耗尽资源并拒绝连接，不能执行查询，并且很不可靠。还必须考虑到<span>MyISAM</span>存储引擎需要为每个打开的表提供两个文件描述符。可以在<strong><span>mysqld_safe</span></strong>中使用<span>--open-files-limit</span>启动选项来增加<span>MySQL</span>适用的文件描述符的数量。参见<a href="problems.html#not-enough-file-handles" title="A.2.17. File Not Found">A.2.17节，“文件未找到”</a>。</p>
			<p>
			打开表的缓存可以保持在<span>table_cache</span>条。
			默认为<span>64</span>；可以用<strong><span>mysqld</span></strong>的<span >--table_cache</span>选项来更改。请注意<span> 
			MySQL</span>可以临时打开更多的 表以执行查询。</p>
			<p>
			在下面的条件下，未使用的表将被关闭并从表缓存中移出：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当缓存满了并且一个线程试图打开一个不在缓存中的表时。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当缓存包含超过<span>table_cache</span>个条目，并且缓存中的表不再被任何线程使用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当表刷新操作发生。当执行<span>FLUSH 
			TABLES</span>语句或执行<strong><span  style="font-family:
宋体">mysqladmin flush-tables</span></strong>或<strong><span>mysqladmin 
			refresh</span></strong>命令时会发生。</p>
			<p>
			当表缓存满时，服务器使用下列过程找到一个缓存入口来使用：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当前未使用的表被释放，以最近最少使用顺序。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果缓存满了并且没有表可以释放，但是一个新表需要打开，缓存必须临时被扩大。</p>
			<p>
			如果缓存处于一个临时扩大状态并且一个表从在用变为不在用状态，它被关闭并从缓存中释放。</p>
			<p>
			对每个并发访问打开一个表。这意味着，如果<span>2</span>个线程访问同一个表或在同一个查询中访问表两次<span>(</span>例如，将表连接为自身时<span>)</span>，表需要被打开两次。每个并行的打开要求在表缓存中有一个条目。任何表的第一次打开占<span>2</span>个文件描述符：一个用于数据文件另一个用于索引文件。表的每一次额外使用仅占一个数据文件的文件描述符。索引文件描述符在所有线程之间共享。</p>
			<p>
			如果你正用<span>HANDLER
			<i>tbl_name</i> OPEN</span>语句打开一个表，将为该线程专门分配一个表。该表不被其它线程共享，只有线程调用<span >HANDLER
			<i>tbl_name</i> CLOSE</span>或线程终止后才被关闭。表关闭后，被拉回表缓存中<span>(</span>如果缓存不满<span>)</span>。参见<a href="sql-syntax.html#handler" title="13.2.3. HANDLER Syntax">13.2.3节，“HANDLER语法”</a>。</p>
			<p>
			可以通过检查<strong><span  style="font-family:
宋体">mysqld</span></strong>的状态变量<span>Opened_tables</span>确定表缓存是否太小：</p>
			<pre><span>mysql&gt; </span><span><b><span>SHOW STATUS LIKE &#39;Opened_tables&#39;;</span></b></span></pre>
			<pre><span>+---------------+-------+</span></pre>
			<pre><span>| Variable_name | Value |</span></pre>
			<pre><span>+---------------+-------+</span></pre>
			<pre><span>| Opened_tables | 2741&nbsp; |</span></pre>
			<pre><span>+---------------+-------+</span></pre>
			<p>如果值很大，即使你没有发出许多<span>FLUSH 
			TABLES</span>语句，也应增加表缓存的大小。参见<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a>和<a href="database-administration.html#server-status-variables" title="5.3.4. Server Status Variables">5.3.4节，“服务器状态变量”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="creating-many-tables"></a>
			7.4.10.&nbsp;在同一个数据库中创建多个表的缺陷</h3></div></div></div><a class="indexterm" name="id2814177"></a></div></div><div class="section"><div class="titlepage"><div><div>
		如果在同一个数据库目录中有许多<span>MyISAM</span>表，打开、关闭和创建操作将会很慢。如果对许多不同的表执行<span>SELECT</span>语句，当表缓存满时，将有一点开销，因为对每个必须打开的表，另外一个必须被关闭。可以通过使表缓存更大些来减少这个开销。<h2 class="title"><a name="optimizing-the-server"></a>
		7.5.&nbsp;优化MySQL服务器</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#system">
			7.5.1. 系统因素和启动参数的调节</a></span></dt><dt><span class="section"><a href="optimization.html#server-parameters">
			7.5.2. 调节服务器参数</a></span></dt><dt><span class="section"><a href="optimization.html#controlling-optimizer">
			7.5.3. 控制查询优化器的性能</a></span></dt><dt><span class="section"><a href="optimization.html#compile-and-link-options">
			7.5.4. 编译和链接怎样影响MySQL的速度</a></span></dt><dt><span class="section"><a href="optimization.html#memory-use">
			7.5.5. MySQL如何使用内存</a></span></dt><dt><span class="section"><a href="optimization.html#dns">
			7.5.6. MySQL如何使用DNS</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="system"></a>
			7.5.1.&nbsp;系统因素和启动参数的调节</h3></div></div></div><a class="indexterm" name="id2814234"></a><a class="indexterm" name="id2814245"></a><a class="indexterm" name="id2814251"></a>
			<p>
			我们从系统级因素开始，因为必须尽早地进行部分决策以获得较大性能。在其它情况下，快速浏览该节就足够了。但是，了解一下更改该层次的参数能够获得多少性能提高是很有意义的。</p>
			<p>
			使用的操作系统很重要。为了更好地使用多<span>CPU</span>机器，应使用<span>Solaris(</span>因为其线程工作得很好<span>)</span>或<span>Linux(</span>因为<span>2.4</span>和以后的内核有很好的<span>SMP</span>支持<span>)</span>。请注意默认情况旧的<span>Linux</span>内核有一个<span>2GB</span>的文件大小限制。如果有这样的一个内核并且需要文件大于<span>2GB</span>，应得到<span>ext2</span>文件系统的大文件支持<span>(LFS)</span>补丁。其它文件系统例如<span>ReiserFS</span>和<span>XFS</span>没有此<span>2GB</span>限制。</p>
			<p>
			将<span>MySQL</span>用于生产前，我们建议你在想用的平台上对它进行测试。</p>
			<p>
			其它技巧：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果有足够的<span>RAM</span>，可以移除所有的交换设备。有些操作系统即使有自由内存也使用交换设备。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>--skip-external-locking</span><span> 
			MySQL</span>选项以避免外部锁定。该选项默认开启。</p>
			<p>
			请注意只要你只运行一个服务器，<span>--skip-external-locking</span>选项不影响<span>MySQL</span>的功能。只要记住运行<strong><span>myisamchk</span></strong>之前关闭服务器<span>(</span>或锁定并刷新相关表<span>)</span>。在一些系统上该选项是强制的，因为在任何情况下外部锁定均不工作。</p>
			<p>
			不能使用<span>--skip-external-locking</span>的唯一情况是对相同的数据运行多个<span>MySQL</span>服务器<span>(</span>非客户<span>)</span>的情况，或者如果没有事先告诉服务器刷新并锁定一个表即运行<strong><span>myisamchk</span></strong>来检查<span>(</span>非修复<span>)</span>该表。请注意一般不建议使用多个<span>MySQL</span>服务器来并行访问相同的数据，除了使用<span>MySQL 
			Cluster</span>时。</p>
			<p>
			即使使用<span>--skip-external-locking</span>，仍然可以使用<span>LOCK 
			TABLES</span>和<span>UNLOCK 
			TABLES</span>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="server-parameters"></a>
			7.5.2.&nbsp;调节服务器参数</h3></div></div></div><a class="indexterm" name="id2814396"></a><a class="indexterm" name="id2814406"></a><a class="indexterm" name="id2814418"></a><a class="indexterm" name="id2814431"></a>
			<p>
			可以用这个命令得到<strong><span>mysqld</span></strong>服务器
			默认缓存区的大小：</p>
			<pre><span>shell&gt; </span><span><b><span>mysqld --verbose --help</span></b></span></pre>
			<p>这个命令生成所有<span><b><span>mysqld</span></b></span>选项和可配置变量的列表。输出包括
			默认值并且看上去象这样：</p>
			<pre><span>help&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>abort-slave-event-count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>allow-suspicious-udfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>auto-increment-increment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>auto-increment-offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></pre>
			<pre><span>automatic-sp-privileges&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>basedir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/</span></pre>
			<pre><span>bdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>bind-address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>character-set-client-handshake&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>character-set-server &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;latin1</span></pre>
			<pre><span>character-sets-dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/share/mysql/charsets/</span></pre>
			<pre><span>chroot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>collation-server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; latin1_swedish_ci</span></pre>
			<pre><span>completion-type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>concurrent-insert&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></pre>
			<pre><span>console&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>datadir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/var/</span></pre>
			<pre><span>default-character-set&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; latin1</span></pre>
			<pre><span>default-collation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; latin1_swedish_ci</span></pre>
			<pre><span>default-time-zone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>disconnect-slave-event-count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>enable-locking&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>enable-pstack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>engine-condition-pushdown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>external-locking&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>gdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>large-pages&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FALSE</span></pre>
			<pre><span>init-connect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>init-file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>init-slave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>innodb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>innodb_checksums&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;TRUE</span></pre>
			<pre><span>innodb_data_home_dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>innodb_doublewrite&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>innodb_fast_shutdown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>innodb_file_per_table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>innodb_flush_log_at_trx_commit&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>innodb_flush_method&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>innodb_locks_unsafe_for_binlog&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>innodb_log_arch_dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>innodb_log_group_home_dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>innodb_max_dirty_pages_pct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 90</span></pre>
			<pre><span>innodb_max_purge_lag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>innodb_status_file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FALSE</span></pre>
			<pre><span>innodb_table_locks&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>innodb_support_xa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>isam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>language&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/share/mysql/english</span></pre>
			<pre><span>local-infile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/home/jon/bin/mysql/var/master1.log</span></pre>
			<pre><span>log-bin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/var/master1</span></pre>
			<pre><span>log-bin-index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>log-bin-trust-routine-creators&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>log-error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/var/master1.err</span></pre>
			<pre><span>log-isam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myisam.log</span></pre>
			<pre><span>log-queries-not-using-indexes&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>log-short-format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>log-slave-updates&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>log-slow-admin-statements&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>log-slow-queries&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>log-tc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tc.log</span></pre>
			<pre><span>log-tc-size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24576</span></pre>
			<pre><span>log-update&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>log-warnings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>low-priority-updates&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>master-connect-retry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 60</span></pre>
			<pre><span>master-host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-info-file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; master.info</span></pre>
			<pre><span>master-password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3306</span></pre>
			<pre><span>master-retry-count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 86400</span></pre>
			<pre><span>master-ssl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>master-ssl-ca&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-ssl-capath&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-ssl-cert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-ssl-cipher&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-ssl-key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-user&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test</span></pre>
			<pre><span>max-binlog-dump-events&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>memlock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>myisam-recover&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OFF</span></pre>
			<pre><span>ndbcluster&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>ndb-connectstring&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>ndb-mgmd-host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>ndb-nodeid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>ndb-autoincrement-prefetch-sz&nbsp;&nbsp;&nbsp;&nbsp; 32</span></pre>
			<pre><span>ndb-distibution&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KEYHASH</span></pre>
			<pre><span>ndb-force-send&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb_force_send&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb-use-exact-count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb_use_exact_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb-shm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>ndb-optimized-node-selection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb-cache-check-time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>ndb-index-stat-enable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb-index-stat-cache-entries&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32</span></pre>
			<pre><span>ndb-index-stat-update-freq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</span></pre>
			<pre><span>new&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>old-alter-table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>old-passwords&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>old-style-user-limits&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>pid-file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/var/hostname.pid1</span></pre>
			<pre><span>port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3306</span></pre>
			<pre><span>relay-log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>relay-log-index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>relay-log-info-file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relay-log.info</span></pre>
			<pre><span>replicate-same-server-id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>report-host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>report-password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>report-port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3306</span></pre>
			<pre><span>report-user&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>rpl-recovery-rank&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>safe-user-create&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>secure-auth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>server-id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>show-slave-auth-info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>skip-grant-tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>skip-slave-start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FALSE</span></pre>
			<pre><span>slave-load-tmpdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /tmp/</span></pre>
			<pre><span>socket&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /tmp/mysql.sock</span></pre>
			<pre><span>sporadic-binlog-dump-fail&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>sql-mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OFF</span></pre>
			<pre><span>symbolic-links&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>tc-heuristic-recover&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;(No default value)</span></pre>
			<pre><span>temp-pool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>timed_mutexes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>tmpdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>use-symbolic-links&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>verbose&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>warnings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></pre>
			<pre><span>back_log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50</span></pre>
			<pre><span>binlog_cache_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32768</span></pre>
			<pre><span>bulk_insert_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8388608</span></pre>
			<pre><span>connect_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5</span></pre>
			<pre><span>date_format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>datetime_format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>default_week_format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>delayed_insert_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100</span></pre>
			<pre><span>delayed_insert_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 300</span></pre>
			<pre><span>delayed_queue_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1000</span></pre>
			<pre><span>expire_logs_days&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>flush_time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>ft_max_word_len&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;84</span></pre>
			<pre><span>ft_min_word_len&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</span></pre>
			<pre><span>ft_query_expansion_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</span></pre>
			<pre><span>ft_stopword_file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>group_concat_max_len&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024</span></pre>
			<pre><span>innodb_additional_mem_pool_size&nbsp;&nbsp; 1048576</span></pre>
			<pre><span>innodb_autoextend_increment&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;8</span></pre>
			<pre><span>innodb_buffer_pool_awe_mem_mb&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>innodb_buffer_pool_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8388608</span></pre>
			<pre><span>innodb_concurrency_tickets&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 500</span></pre>
			<pre><span>innodb_file_io_threads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</span></pre>
			<pre><span>innodb_force_recovery&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>innodb_lock_wait_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50</span></pre>
			<pre><span>innodb_log_buffer_size&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1048576</span></pre>
			<pre><span>innodb_log_file_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5242880</span></pre>
			<pre><span>innodb_log_files_in_group&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</span></pre>
			<pre><span>innodb_mirrored_log_groups&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>innodb_open_files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 300</span></pre>
			<pre><span>innodb_sync_spin_loops&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</span></pre>
			<pre><span>innodb_thread_concurrency&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</span></pre>
			<pre><span>innodb_commit_concurrency&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>innodb_thread_sleep_delay&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10000</span></pre>
			<pre><span>interactive_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28800</span></pre>
			<pre><span>join_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 131072</span></pre>
			<pre><span>key_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8388600</span></pre>
			<pre><span>key_cache_age_threshold&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 300</span></pre>
			<pre><span>key_cache_block_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;1024</span></pre>
			<pre><span>key_cache_division_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100</span></pre>
			<pre><span>long_query_time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>lower_case_table_names&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>max_allowed_packet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1048576</span></pre>
			<pre><span>max_binlog_cache_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4294967295</span></pre>
			<pre><span>max_binlog_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1073741824</span></pre>
			<pre><span>max_connect_errors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>max_connections&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100</span></pre>
			<pre><span>max_delayed_threads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</span></pre>
			<pre><span>max_error_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64</span></pre>
			<pre><span>max_heap_table_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16777216</span></pre>
			<pre><span>max_join_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4294967295</span></pre>
			<pre><span>max_length_for_sort_data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024</span></pre>
			<pre><span>max_relay_log_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>max_seeks_for_key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4294967295</span></pre>
			<pre><span>max_sort_length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024</span></pre>
			<pre><span>max_tmp_tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32</span></pre>
			<pre><span>max_user_connections&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>max_write_lock_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4294967295</span></pre>
			<pre><span>multi_range_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 256</span></pre>
			<pre><span>myisam_block_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024</span></pre>
			<pre><span>myisam_data_pointer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6</span></pre>
			<pre><span>myisam_max_extra_sort_file_size&nbsp;&nbsp; 2147483648</span></pre>
			<pre><span>myisam_max_sort_file_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2147483647</span></pre>
			<pre><span>myisam_repair_threads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>myisam_sort_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8388608</span></pre>
			<pre><span>myisam_stats_method&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nulls_unequal</span></pre>
			<pre><span>net_buffer_length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16384</span></pre>
			<pre><span>net_read_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30</span></pre>
			<pre><span>net_retry_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>net_write_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 60</span></pre>
			<pre><span>open_files_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;0</span></pre>
			<pre><span>optimizer_prune_level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>optimizer_search_depth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 62</span></pre>
			<pre><span>preload_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32768</span></pre>
			<pre><span>query_alloc_block_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192</span></pre>
			<pre><span>query_cache_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1048576</span></pre>
			<pre><span>query_cache_min_res_unit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096</span></pre>
			<pre><span>query_cache_size &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0</span></pre>
			<pre><span>query_cache_type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>query_cache_wlock_invalidate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>query_prealloc_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192</span></pre>
			<pre><span>range_alloc_block_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2048</span></pre>
			<pre><span>read_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 131072</span></pre>
			<pre><span>read_only&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>read_rnd_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 262144</span></pre>
			<pre><span>div_precision_increment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</span></pre>
			<pre><span>record_buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 131072</span></pre>
			<pre><span>relay_log_purge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>relay_log_space_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>slave_compressed_protocol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>slave_net_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3600</span></pre>
			<pre><span>slave_transaction_retries&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>slow_launch_time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</span></pre>
			<pre><span>sort_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2097144</span></pre>
			<pre><span>sync-binlog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>sync-frm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>sync-replication&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>sync-replication-slave-id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>sync-replication-timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>table_cache&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64</span></pre>
			<pre><span>table_lock_wait_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50</span></pre>
			<pre><span>thread_cache_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>thread_concurrency&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>thread_stack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 196608</span></pre>
			<pre><span>time_format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>tmp_table_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 33554432</span></pre>
			<pre><span>transaction_alloc_block_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192</span></pre>
			<pre><span>transaction_prealloc_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096</span></pre>
			<pre><span>updatable_views_with_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>wait_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28800</span></pre>
			<p>
			如果有一个<span><b><span>mysqld</span></b></span>服务器正在运行，通过连接它并执行这个命令，可以看到实际上使用的变量的值：</p>
			<pre><span>mysql&gt; </span><span><b><span>SHOW VARIABLES;</span></b></span></pre>
			<p>
			还可以通过下面的语句看到运行服务器的统计和状态指标：</p>
			<pre><span>mysql&gt;SHOW STATUS</span><span >；</span></pre>
			<p>
			使用<strong><span>mysqladmin</span></strong>还可以获得系统变量和状态信息：</p>
			<pre><span>shell&gt; </span><span><b><span>mysqladmin variables</span></b></span></pre>
			<pre><span>shell&gt; </span><span><b><span>mysqladmin extended-status</span></b></span></pre>
			<p>
			关于所有系统和状态变量的完全描述参见<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a>和<a href="database-administration.html#server-status-variables" title="5.3.4. Server Status Variables">5.3.4节，“服务器状态变量”</a>。</p>
			<p>
			<span>MySQL</span>使用完全可以升级的算法，因此通常运行时可以用很少的内存。然而，通常情况若给<span>MySQL</span>更多的内存性能会更好。</p>
			<p>
			当调节<span>MySQL</span>服务器时，要配置的两个最重要的变量是<span>key_</span><span>buffer_size</span>和<span>table_cache</span>。在试图更改其它变量前你应先确信已经适当地配置了这些变量。</p>
			<p>
			下面的例子显示了部分典型的不同的运行时配置的变量值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果至少有<span>256MB</span>内存和许多表，想要在中等数量的客户时获得最大性能，应使用：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>mysqld_safe --key_buffer_size=64M --table_cache=256 \</span></b></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><b><span>--sort_buffer_size=4M --read_buffer_size=1M &amp;</span></b></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果只有<span>128MB</span>内存和少量表，但仍然要进行大量的排序，可以使用：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>mysqld_safe --key_buffer_size=16M --sort_buffer_size=1M</span></b></span></pre>
			<p>
			如果有许多并行连接，交换问题会发生，除非<strong><span>mysqld</span></strong>已经配置成为每个连接分配很少的内存。如果有足够的内存用于所有连接，<strong><span>mysqld</span></strong>会执行得更好。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于少量内存和大量连接，应使用：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>mysqld_safe --key_buffer_size=512K --sort_buffer_size=100K \</span></b></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><b><span>--read_buffer_size=100K &amp;</span></b></span></pre>
			<p>
			或甚至为：</p>
			<pre ><span>shell&gt; </span><span><b><span>mysqld_safe --key_buffer_size=512K --sort_buffer_size=16K \</span></b></span></pre>
			<pre ><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>--table_cache=32 --read_buffer_size=8K \</span></b></span></pre>
			<pre ><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>--net_buffer_length=1K &amp;</span></b></span></pre>
			<p>
			如果正对远远大于可用内存的表执行<span>GROUP 
			BY</span>或<span>ORDER 
			BY</span>操作，应增加<span>read_</span><span>rnd_buffer_size</span>的值以加速排序操作后面的行读取。</p>
			<p>
			如果已经安装了<span>MySQL</span>，<span>support-files</span>目录包含一些不同的<span>my.cnf</span>示例文件：<span><span>my-huge.cnf</span><span>、<span>my-</span>大<span>.cnf</span>、<span>my-medium.cnf</span></span></span>和<span>my-small.cnf</span>。可以使用这些文件来优化系统。</p>
			<p>
			请注意如果在命令行中为<strong><span>mysqld</span></strong>或<strong><span>mysqld_safe</span></strong>指定一个选项，它只在该次服务器调用中保持有效。要想每次服务器运行时使用该选项，将它放在选项文件中。</p>
			<p>
			要想看参数更改的效果，应执行：</p>
			<pre><span>shell&gt; </span><span><b><span>mysqld --key_buffer_size=32M --verbose ---help</span></b></span></pre>
			<p>
			变量值列于输出的最后。确保<span>--verbose</span>和<span>---help</span>选项在最后。否则，在命令行中列于它们后面的选项的效果不会反映到输出中。</p>
			<p>关于调节<span>InnoDB</span>存储引擎的信息，参见<a href="storage-engines.html#innodb-tuning" title="15.2.11. InnoDB Performance Tuning Tips">15.2.11节，“InnoDB性能调节提示”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="controlling-optimizer"></a>
			7.5.3.&nbsp;控制查询优化器的性能</h3></div></div></div><a class="indexterm" name="id2815057"></a>
			<p>
			查询优化器的任务是发现执行<span>SQL</span>查询的最佳方案。因为“<span class="quote">好</span>”方案和“<span class="quote">坏</span>”方案之间的性能差别会巨大<span>(</span>也就是说，秒相对于小时或甚至天<span>)</span>，大多数查询优化器，包括<span>MySQL</span>的查询优化器，总或多或少地在所有可能的查询评估方案中搜索最佳方案。对于联接查询，<span>MySQL</span>优化器所调查的可能的方案数随查询中所引用的表的数目呈指数增长。对于小数量的表<span>(</span>典型小于<span>7-10)</span>，这不是一个问题。然而，当提交的查询更大时，查询优化所花的时间会很容易地成为服务器性能的主要瓶颈。</p>
			<p>
			查询优化的一个更加灵活的方法是允许用户控制优化器详尽地搜索最佳查询评估方案。一般思想是优化器调查的方案越少，它编译一个查询所花费的时间越少。另一方面，因为优化器跳过了一些方案，它可能错过一个最佳方案。</p>
			<p>
			优化器关于方案数量评估的行为可以通过两个系统变量来控制：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>optimizer_prune_level</span>变量告诉优化器根据对每个表访问的行数的估计跳过某些方案。我们的试验显示该类“<span class="quote">有根据的猜测</span>”很少错过最佳方案，并且可以大大降低查询编辑次数。这就是为什么默认情况该选项为<span>on(</span><span>optimizer_prune_level</span><span>=1)</span>。然而，如果你认为优化器错过了一个更好的查询方案，则该选项可以关闭<span>(</span><span>optimizer_prune_level</span><span>=0)</span>，风险是查询编辑花费的时间更长。请注意即使使用该启发，优化器仍然可以探测呈指数数目的方案。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>optimizer_search_depth</span>变量告诉优化器对于每个未完成的“未来的”方案，应查看多深，以评估是否应对它进一步扩大。<span>optimizer_search_depth</span>值较小会使查询编辑次数大大减小。例如，如果<span>optimizer_search_depth</span>接近于查询中表的数量，对<span>12</span>、<span>13</span>或更多表的查询很可能需要几小时甚至几天的时间来编译。同时，如果用<span>optimizer_search_depth</span>等于<span>3</span>或<span>4</span>编辑，对于同一个查询，编译器编译时间可以少于<span>1</span>分钟。如果不能确定合理的<span>optimizer_search_depth</span>值，该变量可以设置为<span>0</span>，告诉优化器自动确定该值。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="compile-and-link-options"></a>
			7.5.4.&nbsp;编译和链接怎样影响MySQL的速度</h3></div></div></div><a class="indexterm" name="id2815202"></a><a class="indexterm" name="id2815212"></a><a class="indexterm" name="id2815222"></a><a class="indexterm" name="id2815232"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			下列大多数测试是在<span>Linux</span>上并用<strong><span>MySQL</span></strong>基准进行的，但是它们能对其它操作系统和工作负载给出一些指示。</p>
			<p>
			当你用<span>-static</span>链接时，可以得到最快的可执行文件。</p>
			<p>
			在<span>Linux</span>上，最好用<strong><span>pgcc</span></strong>和<span >-O3</span>编译服务器。为了用这些选项编译<tt ><span>“sql_yacc.cc”</span></tt>，需要大约<span>200M</span>内存，因为<strong><span>gcc</span></strong>或<strong><span>pgcc</span></strong>需要大量的内存使所有函数嵌入（<span>inline</span>）。在配置<strong><span>MySQL</span></strong>时，也应该设定<span>CXX=gcc</span>以避免包括<span>libstdc++</span>库<span>(</span>它不需要<span>)</span>。请注意对于某些版本的<strong><span>pgcc</span></strong>，生成的二进制只能运行在真<span>Pentium</span>处理器上，即使你使用编译器选项说明你想让最终的代码在所有<span>x586-</span>类处理器上工作<span>(</span>例如<span>AMD)</span>。</p>
			<p>
			只通过使用一个较好的编译器或较好的编译器选项，在应用中能得到<span>10-30%</span>的加速。如果你自己编译<span>SQL</span>服务器，这特别重要！</p>
			<p>
			当我们测试<span>Cygnus CodeFusion</span>或<span>Fujitsu</span>编译器时，二者均还没足够不出错来让<span>MySQL</span>启用优化进行编译。</p>
			<p>
			标准<span>MySQL</span>二进制分发编译为支持所有字符集。当你自己编译<span>MySQL</span>时，应只包括将使用的字符集的支持。通过<strong><span>configure</span></strong>的<span>--with-charset</span>选项来控制。</p>
			<p>
			这里是我们做过的一些测量表：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果你使用<strong><span>pgcc</span></strong>并用<span>-O6</span>编译，<strong><span>mysqld</span></strong>服务器比用<strong><span>gcc</span></strong><span> 
			2.95.2</span>快<span>11%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果你动态地链接<span>(</span>没有<span>-static</span><span>)</span>，在<span>Linux</span>中结果慢了<span>13%</span>。注意你仍能在客户应用程序中使用动态链接<span>MySQL</span>库。只有服务器对性能是关键的。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果你用<span>strip 
			mysqld</span>剥离<strong><span>mysqld</span></strong>二进制，生成的二进制可以快<span>4%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于在同一主机上运行的客户与服务器之间的连接，如果你使用<span>TCP/IP</span>而非<span>Unix</span>套接字文件进行连接，结果慢<span>7.5%</span>。<span>(</span>在<span>Unix</span>中，如果你连接<span>localhost</span>主机，<span>MySQL</span>默认使用一个套接字文件）<span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于从客户到服务器的<span>TCP/IP</span>连接，从另一台主机连接一台远程服务器要比连接同一主机上的服务器慢<span>8-11%</span>，即使通过<span>100Mb/s</span>以太网进行连接。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当使用安全连接运行我们的基准测试时<span>(</span>所有数据用内部<span>SSL</span>支持进行加密<span>)</span>，性能比未加密连接慢<span>55%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果你用<span>--with-debug=full</span>编译，大多数查询慢<span>20%</span>。部分查询时间会很长；例如，<span>MySQL</span>基准的运行要慢<span>35%</span>。如果你使用<span>--with-debug</span><span>(</span>没有<span>=full</span><span>)</span>，速度只下降<span>15%</span>。对于用<span>--with-debug=full</span>编译的<strong><span>mysqld</span></strong>版本，可以用<span>--skip-safemalloc</span>选项启动以便在运行时禁用内存检查。执行速度则接近用<span>--with-debug</span>配置的时候。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>Sun UltraSPARC-Iie</span>上，用<span>Forte 
			5.0</span>编译的服务器比用<strong><span>gcc</span></strong><span> 
			3.2</span>编译的要快<span>4%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>Sun UltraSPARC-Iie</span>上，用<span>Forte 
			5.0</span>编译的<span>32</span>位模式服务器比<span>64</span>位模式服务器要快<span>4%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>用<strong><span>gcc</span></strong><span> 
			2.95.2</span>编译带<span>-mcpu=v8 
			-Wa</span>的<span>UltraSPARC</span>，使用<span>-xarch=v8plusa</span>选项性能会提高<span>4%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>Solaris 2.5.1</span>上，在单个处理器上<span>MIT-pthreads</span>比带原生线程的<span>Solaris</span>慢<span>8-12%</span>。如果有更大的负载<span>/cpus</span>，差别应该更大。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>Linux-x86</span>上使用<strong><span>gcc</span></strong>编译而不用帧指针<span>(</span><span >-fomit-frame-pointer</span><span> 
			or </span><span >-fomit-frame-pointer 
			-ffixed-ebp</span><span>)</span>，可以使<strong><span>mysqld</span></strong>快<span>1-4%</span>。</p>
			<p><span>MySQL AB</span>提供的<span>Linux</span>上的二进制<span>MySQL</span>分发一般用<strong><span>pgcc</span></strong>编译。我们必须返回到常规<strong><span>gcc</span></strong>，因为<strong><span>pgcc</span></strong>中有一个<span>bug</span>，使生成的二进制不能在<span>AMD</span>上运行。我们将继续使用<strong><span>gcc</span></strong>直到该<span>bug</span>被解决。同时，如果你有一个非<span>AMD</span>机，你可以用<strong><span>pgcc</span></strong>编译构建一个更快的二进制。标准<span>MySQL 
			Linux</span>二进制是通过静态链接，以使它更快并且更加易于移植。</p>
			<h3 class="title"><a name="memory-use"></a>
			7.5.5.&nbsp;MySQL如何使用内存</h3></div></div></div><a class="indexterm" name="id2815594"></a>
			<p>下面的列表中列出了<strong><span  style="font-family:
宋体">mysqld</span></strong>服务器使用内存的一些方法。在适用的地方，给出了内存相关的系统变量名：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>键缓存<span>(</span>变量<span >key_buffer_size</span><span>)</span>被所有线程共享；服务器使用的其它缓存则根据需要分配。参见<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2节，“调节服务器参数”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>每个连接使用具体线程的空间：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>堆栈<span>(</span>默认<span>64KB</span>，变量<span >thread_stack</span><span>)</span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>连接缓存区<span>(</span>变量<span >net_buffer_length</span><span>)</span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>结果缓存区<span>(</span>变量<span >net_buffer_length</span><span>)</span></p>
			<p>连接缓存区和结果缓存区可以根据需要动态扩充到<span >max_allowed_packet</span>。当某个查询运行时，也为当前查询字符串分配内存。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有线程共享相同的基本内存。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只有压缩<span >MyISAM</span>表映射到内存。这是因为<span>4GB</span>的<span>32</span>位内存空间不足以容纳大多数大表。当<span>64</span>位地址空间的系统变得越来越普遍后，我们可以增加常规的内存映射支持。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对表进行顺序扫描的请求将分配一个<em><span>缓存区</span></em><span>(</span>变量<span >read_buffer_size</span><span>)</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当按任意顺序读取行时<span>(</span>例如，按照排序顺序<span>)</span>，将分配一个随机读 
			<em><span>缓存区</span></em><span>(</span>变量<span >read_rnd_buffer_size</span><span>)</span>以避免硬盘搜索。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有联合在一个令牌内完成，并且大多数联合甚至可以不用临时表即可以完成。大多数临时表是基于内存的<span>(</span><span >HEAP</span><span>)</span>表。具有大的记录长度的临时表<span> 
			(</span>所有列的长度的和<span>)</span>或包含<span >BLOB</span>列的表存储在硬盘上。</p>
			<p>如果某个内部<span>heap</span>（堆积）表大小超过<span >tmp_table_size</span>，<span>MySQL</span>可以根据需要自动将内存中的<span>heap</span>表改为基于硬盘的<span >MyISAM</span>表。还可以通过设置<strong><span>mysqld</span></strong>的<span >tmp_table_size</span>选项来增加临时表的大小，或设置客户程序中的<span>SQL</span>选项<span >SQL_BIG_TABLE</span>。参见<a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3节，“SET语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>进行排序的大多数请求将分配一个排序缓存区，并根据结果集的大小为两个临时文件分配零。参见<a href="problems.html#temporary-files" title="A.4.4. Where MySQL Stores Temporary Files">A.4.4节，“MySQL将临时文件储存在哪里”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			几乎所有解析和计算在局部内存中完成。小项目不需要内存，因此避免了普通的慢内存分配和释放。只为不期望的大字符串分配内存；使用函数<span >malloc()</span>和<span >free()</span>来完成。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于每个打开的<span >MyISAM</span>表，索引文件打开一次；数据文件为每个并行运行的线程打开一次。对于每个并行线程，将分配一个表结构、一个每个列的列结构和大小为<span >3 
			* <i>N</i></span>的缓存区<span>(</span>其中<span><i><span>N</span></i></span>是最大行的长度，而不是计算<span >BLOB</span>列<span>)</span>。一个<span >BLOB</span>列需要<span>5</span>至<span>8</span>个字节加上<span >BLOB</span>数据的长度。<span >MyISAM</span><span>
			</span>存储引擎维护一个额外的行缓存区供内部应用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于每个具有<span >BLOB</span>列的表，将对缓存区进行动态扩大以读入大的<span >BLOB</span><span>
			</span>值。如果你扫描一个表，则分配一个与最大的<span >BLOB</span>值一样大的缓存区。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有使用的表的句柄结构保存在高速缓存中并以<span>FIFO</span>管理。默认情况，高速缓存有<span>64</span>个入口。如果某个表同时被两个运行的线程使用，高速缓存则为该提供两个入口。参见<a href="optimization.html#table-cache" title="7.4.9. How MySQL Opens and Closes Tables">7.4.9节，“MySQL如何打开和关闭表”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当并行执行的线程结束时，<span >FLUSH 
			TABLE</span>语句或<strong><span>mysqladmin 
			flush-table</span></strong>命令可以立即关闭所有不使用的表并将所有使用中的表标记为已经关闭。这样可以有效释放大多数使用中的内存。<span >FLUSH 
			TABLE</span>在关闭所有表之前不返回结果。</p>
			<p><span>ps</span>和其它系统状态程序可以报导<span>mysqld</span>使用很多内存。这可以是在不同的内存地址上的线程栈造成的。例如，<span>Solaris</span>版本的<span>ps</span>将栈间未用的内存算作已用的内存。你可以通过用<span>swap 
			-s</span>检查可用交换区来验证它。我们用商业内存漏洞探查器测试了<span>mysqld</span>，因此应该有没有内存漏洞。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dns"></a>
			7.5.6.&nbsp;MySQL如何使用DNS</h3></div></div></div><a class="indexterm" name="id2815983"></a><a class="indexterm" name="id2815989"></a></div></div><div class="section"><div class="titlepage"><div><div>
		<p>
		当新的客户连接<strong><span  style="font-family:
宋体">mysqld</span></strong>时，<strong><span>mysqld</span></strong>创建一个新的线程来处理请求。该线程先检查是否主机名在主机名缓存中。如果不在，线程试图解析主机名：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果操作系统支持线程安全<span><span>gethostbyaddr_r</span><span> 
		()</span></span>和<span><span>gethostbyname_r</span><span>()</span></span>调用，线程使用它们来执行主机名解析。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果操作系统不支持线程安全调用，线程锁定一个互斥体并调用<span >gethostbyaddr()</span>和<span >gethostbyname()</span>。在这种情况下，在第<span>1</span>个线程解锁互斥体前，没有其它线程可以解析不在主机名缓存中的主机名。</p>
		<p>
		你可以用<span >--skip-name-resolve</span>选项启动<strong><span>mysqld</span></strong>来禁用<span>DNS</span>主机名查找。然而，在这种情况下，你只可以使用<span>MySQL</span>中的授权表中的<span>IP</span>号。</p>
		<p>
		如果你有一个很慢的<span>DNS</span>和许多主机，你可以通过用<span >--skip-name-resolve</span>禁用<span>DNS</span>查找或增加<span>HOST_CACHE_SIZE</span>定义<span>(</span>默认值：<span>128)</span>并重新编译<strong><span>mysqld</span></strong>来提高性能。</p>
		<p>
		你可以用<span >--skip-host-cache</span>选项启动服务器来禁用主机名缓存。要想清除主机名缓存，执行<span >FLUSH 
		HOSTS</span>语句或执行<strong><span  style="font-family:
宋体">mysqladmin flush-hosts</span></strong>命令。</p>
		<p>
		如果你想要完全禁止<span>TCP/IP</span>连接，用<span >--skip-networking</span>选项启动<strong><span>mysqld</span></strong>。</p>
		<h2 class="title"><a name="disk-issues"></a>
		7.6.&nbsp;磁盘事宜</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#symbolic-links">
			7.6.1. 使用符号链接</a></span></dt>
			<dd>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			磁盘搜索是巨大的性能瓶颈。当数据量变得非常大以致于缓存性能变得不可能有效时，该问题变得更加明显。对于大数据库，其中你或多或少地随机访问数据，你可以确信对读取操作需要至少一次硬盘搜索，写操作需要多次硬盘搜索。要想使该问题最小化，应使用搜索次数较少的磁盘。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>通过链接文件到不同的磁盘或对硬盘分段来增加可用磁盘锭数量（因此降低搜索成本）：</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>使用符号链接</p>
			<p>
			这说明，对于<span>M</span><span>yISAM</span>表，你符号链接索引文件和<span>/</span>或数据文件，从它们数据目录内的通常位置到另一个硬盘（也可以被条纹化）。这将使搜索和读次数达到最好，假定硬盘不再为其它目的使用。参见<a href="optimization.html#symbolic-links" title="7.6.1. Using Symbolic Links">7.6.1节，“使用符号链接”</a>。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>分条</p>
			<p>
			分条意味着你有许多磁盘，将第<span>1</span>个块放到第<span>1</span>个硬盘，第<span>2</span>个块放到第<span>2</span>个磁盘，并且第<span><i><span>N</span></i></span>块在（<i><span>N</span></i><span> 
			mod number_of_disks</span>）磁盘上等等。这意味着如果正常数据大小小于分条大小（或完全匹配），能够得到最佳性能。分条完全取决于操作系统和分条大小，因此用不同的条纹大小对应用程序进行基准测试。参见<a href="optimization.html#custom-benchmarks" title="7.1.5. Using Your Own Benchmarks">7.1.5节，“使用自己的基准”</a>。</p>
			<p>
			分条的不同速度完全依赖于参数。依赖于怎样设置条纹参数和硬盘数量，可以根据不同数量级别得到不同的标准。你必须进行选择以便优化随机或顺序存取。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>为了高可靠性你可能想使用<span>RAID 0+1</span>（条纹加镜像），但在这种情况下，需要<span>2*N</span>块磁盘来保持<span>N</span>个磁盘的数据。如果你肯为它花钱，这可能是最好的选项。然而，你可能还必须投资一部分资金到卷管理软件中以便有效地管理它。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>一个较好的选择是根据数据类型的重要性程度改变<span>RAID</span>级别。例如，保存可以在<span>RAID 
			0</span>硬盘上重新生成的不太重要的数据，但保存 真正重要数据（例如主机信息和日志）到<span>RAID 
			0+1</span>或<span>RAID N</span>硬盘。如果你有许多写操作，<span>RAID 
			N</span>可能会存在问题，因为需要时间来更新校验位。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>Linux</span>上，通过配置磁盘接口时使用<span>hdparm</span>，你可以获得更多的性能。（在一般负载下达到<span>100%</span>并不困难。）下面的<span>hdparm</span>选项 
			应该非常适用于<span>MySQL</span>，并且可能适用于许多其它应用程序：</p>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; hdparm -m 16 -d 1</span></pre>
			<p>
			请注意，当使用该命令时，性能和可靠性依赖于硬件，因此我们强烈建议，使用<span>hdparm</span>后<span>，</span>完全测试你的系统。为获取更多详细信息，请查阅<span>hdparm</span>手册帮助页。如果<span>hdparm</span>使用的不好，会导致文件系统破坏，因此试验之前请做好每个备份<span>!
			</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>也可以设置数据库使用的文件系统参数：</p>
			<p>
			如果不需要知道文件最后一次访问的时间（这对数据库服务器并没有实际的用途），可以用<span>-o 
			noatime</span>选项安装文件系统。这将跳过对文件系统中的节点的最后一次访问时间的更新，从而能够避免一些硬盘搜索。</p>
			<p>
			在许多操作系统中，用<span>-o 
			async</span>选项安装，可以将文件系统设置为异步更新。如果电脑相当稳定，这应该给予你更高的性能而不需要牺牲太多的可靠性。（该标志是<span>Linux</span>中默认开启。）</dd>
			</dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="symbolic-links"></a>
			7.6.1.&nbsp;使用符号链接</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#symbolic-links-to-databases">7.6.1.1. 
				在Unix上使用针对数据库的符号链接</a></span></dt><dt><span class="section"><a href="optimization.html#symbolic-links-to-tables">7.6.1.2. 
				在Unix平台上使用表的符号链接<br>
				</a><a href="optimization.html#windows-symbolic-links">7.6.1.3. 
				在Windows平台上使用关于数据库的符号链接</a></span></dt></dl></div><a class="indexterm" name="id2816368"></a><a class="indexterm" name="id2816374"></a><div class="section"><div class="titlepage"><div><div>
				<p>
				你可以将表和数据库从数据库目录移动到其它的位置并且用指向新位置的符号链接进行替换。你可能需要这样作，例如，移动数据库到一个有更多空闲空间的文件系统中或通过将表分散到不同的磁盘上以增加系统的访问速度。</p>
				<p>
				推荐的方法值需要将数据库通过符号链接指到不同的磁盘。符号链接表仅作为是最后的办法。</p>
				<h4 class="title"><a name="symbolic-links-to-databases"></a>7.6.1.1. 在Unix上使用针对数据库的符号链接</h4></div></div></div><a class="indexterm" name="id2816411"></a>
				<p>
				在<span>Unix</span>中，符号链接一个数据库的方法是，首先在一些有空闲空间的硬盘上创建一个目录，然后从<span>MySQL</span>数据目录中创建它的一个符号链接。</p>
				<pre><span>shell&gt; </span><b><span >mkdir /dr1/databases/test</span></b></pre>
				<pre><span>shell&gt; </span><b><span >ln -s /dr1/databases/test <i>/path/to/datadir</i></span></b></pre>
				<p>
				<span>MySQL</span>不支持链接一个目录到多个数据库。用一个符号链接替换一个数据库目录，只要你不在数据库之间制作符号链接。假定你有一个数据库<span>db1</span>在<span>MySQL</span>数据目录下，然后生成一个符号链接<span>db2</span>指向 
				<span>db1</span>：</p>
				<pre><span>shell&gt; </span><b><span >cd <i>/path/to/datadir</i></span></b></pre>
				<pre><span>shell&gt; </span><span><b><span>ln -s db1 db2</span></b></span></pre>
				<p>
				对于<span>db1</span>中的任何表<span>tbl_a</span>，在<span>db2</span>也出现并且还是表<span>tbl_a</span>。如果一个客户更新<span>db1.tbl_a</span>并且另一个客户更新<span>db2.tbl_a</span>，可能会出现问题。</p>
				<p>
				然而，如果你真的需要这样做，可以通过改变源文件<span>mysys/my_symlink.c</span>来实现，在该文件中你应查找下面的语句：</p>
				<p><span>if (!(MyFlags &amp; 
				MY_RESOLVE_LINK) ||</span></p>
				<p><span>&nbsp;&nbsp;&nbsp; (!lstat(filename,&amp;stat_buff) 
				&amp;&amp; S_ISLNK(stat_buff.st_mode)))</span></p>
				<p>
				将该语句修改为：</p>
				<p><span>if (1)</span></p>
				<p>
				请注意，对于所有的<span>Windows</span>服务器，默认启用符号链接支持。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="symbolic-links-to-tables"></a>7.6.1.2. 在Unix平台上使用表的符号链接<br>
&nbsp;</h4></div></div></div><a class="indexterm" name="id2816545"></a>
				<p>
				你不应在没有完全可操作的<span>realpath()</span>调用的系统中对表进行符号链接。（<span>Linux</span>和<span>Solaris</span>支持<span>realpath()</span><span>)</span>。可以通过发出一个<span>SHOW 
				VARIABLES LIKE &#39;have_symlink&#39;</span>语句，检查系统是否支持符号链接。</p>
				<p>
				只有<span>M</span><span>yISAM</span>表完全支持符号链接。对于其它表类型，如果试图在操作系统中的文件上用前面的任何语句使用符号链接，可能会出现奇怪的问题。</p>
				<p>
				对于<span>M</span><span>yISAM</span>表的符号链接的处理如下：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				在数据目录指，一定会有表定义文件、数据文件和索引文件。数据文件和索引文件可以移到别处和在数据目录中符号链接替代。表定义文件不能进行符号链接替换。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>可以分别通过符号链接将数据文件和索引文件指到不同的目录。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果<strong><span>mysqld</span></strong>没有运行，符号链接可以从服务器命令行使用<span>ln 
				-s</span>手动完成。同样，通过使用<span>DATA DIRECTORY</span>和<span>INDEX 
				DIRECTORY</span>选项创建表，你可以指示运行的<span>MySQL</span>服务器执行符号链接。参见<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
				TABLE语法”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>
				myisamchk</span></strong>不用数据文件或索引文件替换符号链接。它直接工作在符号链接指向的文件。任何临时文件创建在数据文件或索引文件所处的目录中。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>注释：</span></strong>当你删掉一个表时，如果该表使用了符号链接，<em><span>符号链接和该符号链接指向的文件都被删除掉</span></em>。这就是你不应以系统<span>root</span>用户运行<strong><span>mysqld</span></strong>或允许系统用户对<span>MySQL</span>数据库目录有写访问权限的原因。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果你用<span>ALTER TABLE ... RENAME</span>重命名一个表并且不将表移到另一个数据库，数据库目录中的符号链接被重新命名为一个新名字并且数据文件和索引文件也相应地重新命名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果你用<span>ALTER TABLE ... RENAME</span>移动一个表到另一个数据库，表移动到另一个数据库目录。旧的符号链接和其所指向的文件被删除。换句话说，新表不再被链接。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果不使用符号链接，你应对<strong><span>mysqld</span></strong>使用<span>--skip-symbolic-links</span>选项以确保没有人能够使用<strong><span>mysqld</span></strong>来删除或重新命名数据目录之外的文件。</p>
				<p>
				表符号链接还不支持以下操作：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>ALTER TABLE</span>忽略<span>DATA 
				DIRECTORY </span>和<span>INDEX DIRECTORY</span>表选项。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>BACKUP TABLE </span>和<span>RESTORE 
				TABLE</span>不考虑符号链接。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>.frm</span>文件必须<em><span>绝不能是一个符号</span></em>链接（如前面所述，只有数据和索引文件可以是符号链接）。如果试图这样做（例如，生成符号链接）会产生不正确的结果。假定你在<span>MySQL</span>数据目录下有一个数据库<span>db1</span>，该数据库有一个表<span>tbl1</span>，并且在<span>db1</span>目录中你制作了一个符号链接<span>tbl2</span>指向<span>tbl1</span>：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><b><span >cd <i>/path/to/datadir</i>/db1</span></b></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>ln -s tbl1.frm tbl2.frm</span></b></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>ln -s tbl1.MYD tbl2.MYD</span></b></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>ln -s tbl1.MYI tbl2.MYI</span></b></span></pre>
				<p>
				如果一个线程读取<span>db1.tbl1</span>同时另一个线程更新 
				<span>db1.tbl2</span>会发生问题：</p>
				<p >
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>查询缓存将变为“傻瓜”<span> (</span>它没有办法知道<span>tbl1</span>是否被更新，因此它返回过时的结果<span>)</span>。</p>
				<p >
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>tbl2</span>上的<span>ALTER</span>语句也会失败。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="windows-symbolic-links"></a>7.6.1.3. 在Windows平台上使用关于数据库的符号链接</h4></div></div></div><a class="indexterm" name="id2816953"></a><a class="indexterm" name="id2816959"></a><a class="indexterm" name="id2816966"></a></div></div></div></div><div>
<p>
<span>Windows</span>的<strong><span>mysqld-max</span></strong>和<span>mysql-max-nt</span>服务器使用<span>-DUSE_SYMDIR</span>选项编译成。允许你放置数据库目录到一个不同的硬盘，通过设置一个符号链接指向它。这类似于<span>Unix</span>中的符号链接，尽管设置链接的过程不同。</p>
<p>
符号链接默认为启用。如果你不需要，使用<span>skip-symbolic-links</span>选项来禁用它：</p>
<pre><span>[mysqld]</span></pre>
<p><span>skip-symbolic-links</span></p>
<p>
在<span>Windows</span>中，通过在数据目录中创建一个文件，该文件包含目标目录的路径，你可以为<span>MySQL</span>数据库创建一个符号链接。该文件应该被命名为<span>db_name.sym</span>，其中<span><i><span>db_name</span></i></span>是数据库名。</p>
<p>
假定<span>MySQ</span>数据目录是<span>C:\mysql\data</span>并且你想要数据库<span>foo</span>放置在<span>D:\data\foo</span>。设置一个符号链接如下所示：</p>
<p>
<span>1.<span>&nbsp;&nbsp;&nbsp;
</span></span>确保<span>D:\data\foo</span>目录存在，如果必要创建它。如果你在数据目录内有一个命名为<span>foo</span>的数据库目录，你应移动它到<span>D:\data</span>目录。否则，符号链接无效。为避免出现问题，当你移动数据库目录时服务器不应该运行。</p>
<p>
<span>2.<span>&nbsp;&nbsp;&nbsp;
</span></span>创建一个文本文件<span>C:\mysql\data\foo.sym</span>，该本文文件包含路径名<span>D:\data\foo\</span>。</p>
<p>此后，数据库<span>foo</span>创建的所有表将创建在<span>D:\data\foo</span>文件中。<em><span>请注意，如果在<span>MySQL</span>数据目录中存在同名的数据库目录，不能使用符号链接</span></em>。</p>
<hr><p>
      这是MySQL参考手册的翻译版本，关于MySQL参考手册，<span class="GramE">请访问</span><a target="_top"  href="http://dev.mysql.com/doc/mysql/en">dev.mysql.com</a>。 
		原始参考手册为英文版，与英文版参考手册相比，本翻译版可能不是最新的。</p></div>
</body></html>
