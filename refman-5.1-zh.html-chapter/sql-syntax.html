<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Chapter 13. SQL Statement Syntax</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="up" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="prev" href="functions.html" title="Chapter 12. Functions and Operators"><link rel="next" href="pluggable-storage.html" title="Chapter 14. Pluggable Storage Engine Architecture">
<style>
<!--
 table.MsoNormalTable
	{mso-style-parent:"";
	font-size:10.0pt;
	
	}
span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
span.GramE
	{}
-->
</style>
</head><body><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="sql-syntax"></a>
	第13章：SQL语句语法</h2></div></div></div><div class="toc"><p><b>
	目录</b></p><dl><dt><span class="section"><a href="sql-syntax.html#data-definition">
			13.1. 数据定义语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#alter-database">13.1.1. 
				ALTER DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table">13.1.2. 
				ALTER TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-database">13.1.3. 
				CREATE DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-index">13.1.4. 
				CREATE INDEX语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table">13.1.5. 
				CREATE TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-database">13.1.6. 
				DROP DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-index">13.1.7. 
				DROP INDEX语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-table">13.1.8. 
				DROP TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-table">13.1.9. 
				RENAME TABLE语法</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#data-manipulation">
			13.2. 数据操作语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#delete">13.2.1. 
				DELETE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#do">13.2.2. 
				DO语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler">13.2.3. 
				HANDLER语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert">13.2.4. 
				INSERT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data">13.2.5. 
				LOAD DATA INFILE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replace">13.2.6. 
				REPLACE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#select">13.2.7. 
				SELECT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subqueries">
				13.2.8. Subquery语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#truncate">13.2.9. 
				TRUNCATE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#update">13.2.10. 
				UPDATE语法</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#basic-user-commands">
			13.3. MySQL实用工具语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#describe">13.3.1. 
				DESCRIBE语法（获取有关列的信息）</a></span></dt><dt><span class="section"><a href="sql-syntax.html#use">13.3.2. 
				USE语法</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#transactional-commands">
			13.4. MySQL事务处理和锁定语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#commit">13.4.1. 
				START TRANSACTION, COMMIT和ROLLBACK语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cannot-roll-back">
				13.4.2. 不能回滚的语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#implicit-commit">
				13.4.3. 会造成隐式提交的语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#savepoints">13.4.4. 
				SAVEPOINT和ROLLBACK TO SAVEPOINT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#lock-tables">13.4.5. 
				LOCK TABLES和UNLOCK TABLES语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-transaction">13.4.6. 
				SET TRANSACTION语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa">
				13.4.7. XA事务</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#database-administration-statements">
			13.5. 数据库管理语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#account-management-sql">
				13.5.1. 账户管理语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#table-maintenance-sql">
				13.5.2. 表维护语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-option">13.5.3. 
				SET语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show">13.5.4. 
				SHOW语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#other-administrative-sql">
				13.5.5. 其它管理语句</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#replication-sql">
			13.6. 复制语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#replication-master-sql">
				13.6.1. 用于控制主服务器的SQL语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replication-slave-sql">
				13.6.2. 用于控制从服务器的SQL语句</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sqlps">
			13.7. 用于预处理语句的SQL语法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div>
		本章介绍了<span>SQL</span>语句的语法。<h2 class="title"><a name="data-definition"></a>
		13.1.&nbsp;数据定义语句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#alter-database">13.1.1. 
			ALTER DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table">13.1.2. 
			ALTER TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-database">13.1.3. 
			CREATE DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-index">13.1.4. 
			CREATE INDEX语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table">13.1.5. 
			CREATE TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-database">13.1.6. 
			DROP DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-index">13.1.7. 
			DROP INDEX语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-table">13.1.8. 
			DROP TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-table">13.1.9. 
			RENAME TABLE语法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-database"></a>13.1.1. ALTER 
			DATABASE语法</h3></div></div></div><a class="indexterm" name="id2890117"></a><a class="indexterm" name="id2890126"></a><a class="indexterm" name="id2890135"></a><a class="indexterm" name="id2890145"></a><a class="indexterm" name="id2890156"></a><a class="indexterm" name="id2890166"></a><pre class="programlisting">ALTER {DATABASE | SCHEMA} [<em class="replaceable">db_name</em>]
    <em class="replaceable">alter_specification</em> [, <em class="replaceable">alter_specification</em>] ...

<em class="replaceable">alter_specification</em>:
    [DEFAULT] CHARACTER SET <em class="replaceable">charset_name</em>
  | [DEFAULT] COLLATE <em class="replaceable">collation_name</em>
</pre>
			<p><span>ALTER DATABASE</span>用于更改数据库的全局特性。这些特性储存在数据库目录中的<span>db.opt</span>文件中。要使用<span>ALTER 
			DATABASE</span>，您需要获得数据库<span>ALTER</span>权限。</p>
			<p><span>CHARACTER SET</span>子句用于更改默认的数据库字符集。<span>COLLATE</span>子句用于更改默认的数据库整序。在<a href="charset.html">第10章</a>：<a href="charset.html" title="Chapter 10. Character Set Support"><i>字符集支持</i></a>中对字符集和整序名称进行了讨论。</p>
			<p>数据库名称可以忽略，此时，语句对应于默认数据库。也可以使用<span>ALTER SCHEMA</span>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-table"></a>13.1.2. ALTER 
			TABLE语法</h3></div></div></div><a class="indexterm" name="id2890293"></a><a class="indexterm" name="id2890302"></a><a class="indexterm" name="id2890312"></a><pre class="programlisting">ALTER [IGNORE] TABLE <em class="replaceable">tbl_name</em>
    <em class="replaceable">alter_specification</em> [, <em class="replaceable">alter_specification</em>] ...

<em class="replaceable">alter_specification</em>:
    ADD [COLUMN] <em class="replaceable">column_definition</em> [FIRST | AFTER <em class="replaceable">col_name</em> ]
  | ADD [COLUMN] (<em class="replaceable">column_definition</em>,...)
  | ADD INDEX [<em class="replaceable">index_name</em>] [<em class="replaceable">index_type</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [CONSTRAINT [<em class="replaceable">symbol</em>]]
        PRIMARY KEY [<em class="replaceable">index_type</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [CONSTRAINT [<em class="replaceable">symbol</em>]]
        UNIQUE [<em class="replaceable">index_name</em>] [<em class="replaceable">index_type</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [FULLTEXT|SPATIAL] [<em class="replaceable">index_name</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [CONSTRAINT [<em class="replaceable">symbol</em>]]
        FOREIGN KEY [<em class="replaceable">index_name</em>] (<em class="replaceable">index_col_name</em>,...)
        [<em class="replaceable">reference_definition</em>]
  | ALTER [COLUMN] <em class="replaceable">col_name</em> {SET DEFAULT <em class="replaceable">literal</em> | DROP DEFAULT}
  | CHANGE [COLUMN] <em class="replaceable">old_col_name</em> <em class="replaceable">column_definition</em>
        [FIRST|AFTER <em class="replaceable">col_name</em>]
  | MODIFY [COLUMN] <em class="replaceable">column_definition</em> [FIRST | AFTER <em class="replaceable">col_name</em>]
  | DROP [COLUMN] <em class="replaceable">col_name</em>
  | DROP PRIMARY KEY
  | DROP INDEX <em class="replaceable">index_name</em>
  | DROP FOREIGN KEY <em class="replaceable">fk_symbol</em>
  | DISABLE KEYS
  | ENABLE KEYS
  | RENAME [TO] <em class="replaceable">new_tbl_name</em>
  | ORDER BY <em class="replaceable">col_name</em>
  | CONVERT TO CHARACTER SET <em class="replaceable">charset_name</em> [COLLATE <em class="replaceable">collation_name</em>]
  | [DEFAULT] CHARACTER SET <em class="replaceable">charset_name</em> [COLLATE <em class="replaceable">collation_name</em>]
  | DISCARD TABLESPACE
  | IMPORT TABLESPACE
  | <em class="replaceable">table_options</em>
  | <em class="replaceable">partition_options</em>
  | ADD PARTITION <em class="replaceable">partition_definition</em>
  | DROP PARTITION <em class="replaceable">partition_names</em>
  | COALESCE PARTITION <em class="replaceable">number</em>
  | REORGANIZE PARTITION <em class="replaceable">partition_names</em> INTO (<em class="replaceable">partition_definitions</em>)
  | ANALYZE PARTITION <em class="replaceable">partition_names</em>
  | CHECK PARTITION <em class="replaceable">partition_names</em>
  | OPTIMIZE PARTITION <em class="replaceable">partition_names</em>
  | REBUILD PARTITION <em class="replaceable">partition_names</em>
  | REPAIR PARTITION <em class="replaceable">partition_names</em>
</pre>
			<p><span>ALTER TABLE</span>用于更改原有表的结构。例如，您可以增加或删减列，创建或取消索引，更改原有列的类型，或重新命名列或表。您还可以更改表的评注和表的类型。</p>
			<p>允许进行的变更中，许多子句的语法与<span>CREATE TABLE</span>中的子句的语法相近。其中包括<span><i><span>table_options</span></i>修改，选项有<span>ENGINE, 
			AUTO_INCREMENT</span>和<span>AVG_ROW_LENGTH</span>等。请见</span><a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
		TABLE语法”</a>。</p>
			<p>存储引擎不支持有些操作，如果进行这些操作，会出现警告。使用<span>SHOW WARNINGS</span>可以显示出这些警告。请参见<a href="sql-syntax.html#show-warnings" title="13.5.4.22. SHOW WARNINGS Syntax">13.5.4.22节，“SHOW 
		WARNINGS语法”</a>。</p>
			<p>如果您使用<span>ALTER TABLE</span>更改列规约，但是<span>DESCRIBE<span>
			<i>tbl_name</i></span></span><span>提示您列规约并没有改变，则可能是因为<span>MySQL</span>忽略了您所做的更改。忽略更改的原因见</span><a href="sql-syntax.html#silent-column-changes" title="13.1.5.1. Silent Column Specification Changes">13.1.5.1节，“沉寂的列规格变更”</a><span>。例如，如果您试图把<span>VARCHAR</span>列更改为<span>CHAR</span>列，此时，如果表包含其它长度可变的列，则<span>MySQL</span>仍会使用<span>VARCHAR</span>。</span></p>
			<p><span>ALTER TABLE</span>运行时会对原表进行临时复制，在副本上进行更改，然后删除原表，再对新表进行重命名。在执行<span>ALTER 
			TABLE</span>时，其它用户可以阅读原表，但是对表的更新和修改的操作将被延迟，直到新表生成为止。新表生成后，这些更新和修改信息会自动转移到新表上。</p>
			<p>注意，如果您在执行<span>ALTER TABLE</span>时使用除了<span>RENAME</span>以外的选项，则<span>MySQL</span>会创建一个临时表。即使数据并不需要进行复制（例如当您更改列的名称时），<span>MySQL</span>也会这么操作。对于<span>MyISAM</span>表，您可以通过把<span><span>myisam_sort_buffer_size</span>系统变量设置到一个较高的值，来加快重新创建索引（该操作是变更过程中速度最慢的一部分）的速度。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>要使用<span>ALTER TABLE</span>，您需要获得表的<span>ALTER, 
			INSERT</span>和<span>CREATE</span>权限。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>IGNORE</span>是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。如果在新表中有重复关键字，或者当<span>STRICT</span>模式启动后出现警告，则使用<span>IGNORE</span>控制<span>ALTER 
			TABLE</span>的运行。如果没有指定<span>IGNORE</span>，当重复关键字错误发生时，复制操作被放弃，返回前一步骤。如果指定了<span>IGNORE</span>，则对于有重复关键字的行，只使用第一行，其它有冲突的行被删除。并且，对错误值进行修正，使之尽量接近正确值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以在一个<span>ALTER TABLE</span>语句里写入多个<span>ADD, 
			ALTER, DROP</span>和<span>CHANGE</span>子句，中间用逗号分开。这是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。在标准<span>SQL</span>中，每个<span>ALTER 
			TABLE</span>语句中每个子句只允许使用一次。例如，在一个语句中取消多个列：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>CHANGE
			<i>col_name</i></span><span>,
			<span>DROP <i>col_name</i></span></span>和<span><span>DROP 
			INDEX</span>是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MODIFY</span>是<span>Oracle</span>对<span>ALTER 
			TABLE</span>的扩展。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>COLUMN</span>只是自选项目，可以忽略。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span><span>ALTER 
			TABLE <i>tbl_name</i> RENAME TO <i>new_tbl_name</i></span>并且没有其它选项，则<span>MySQL</span>只对与</span><span>table
			<span><i>tbl_name</i></span></span><span>相对应的文件进行重命名。不需要创建一个临时表。（您也可以使用<span>RENAME 
			TABLE</span>语句对表进行重命名。请参见</span><a href="sql-syntax.html#rename-table" title="13.1.9. RENAME TABLE Syntax">13.1.9节，“RENAME 
			TABLE语法”</a><span>。）</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><i><span>
			column_definition</span></i></span>子句使用与<span>CREATE TABLE</span>中的<span>ADD</span>和<span>CHANGE</span>子句相同的语法。注意，此语法包括列名称，而不只是列类型。请参见<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以使用<span><span>CHANGE
			<i>old_col_name</i> <i>column_definition</i></span>子句对列进行重命名。重命名时，需给定旧的和新的列名称和列当前的类型。例如：要把一个<span>INTEGER</span>列的名称从<span>a</span>变更到<span>b</span>，您需要如下操作：</span></p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>ALTER TABLE t1 CHANGE a b INTEGER;</b></span></span></pre>
			<p>如果您想要更改列的类型而不是名称，<span> 
			CHANGE</span>语法仍然要求旧的和新的列名称，即使旧的和新的列名称是一样的。例如：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t1 CHANGE b b BIGINT NOT NULL;</b></span></span></pre>
			<p>您也可以使用<span>MODIFY</span>来改变列的类型，此时不需要重命名：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t1 MODIFY b BIGINT NOT NULL;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>CHANGE</span>或<span>MODITY</span>缩短列长时，列中存在有索引，并且缩短后的列长小于索引长度，则<span>MySQL</span>会自动缩短索引的长度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当您使用<span>CHANGE</span>或<span>MODIFY</span>更改列的类型时，<span>MySQL</span>会尽量把原有的列值转化为新的类型。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以使用<span>FIRST</span>或<span>AFTER
			<span><i>col_name</i></span></span><span>在一个表行中的某个特定位置添加列。默认把列添加到最后。您也可以在<span>CHANGE</span>或<span>MODIFY</span>语句中使用<span>FIRST</span>和<span>AFTER</span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>AFTER COLUMN</span>用于指定列的新默认值，或删除旧的默认值。如果旧的默认值被删除同时列值为<span>NULL</span>，则新的默认值为<span>NULL</span>。如果列值不能为<span>NULL</span>，<span>MySQL</span>会指定一个默认值，请参见<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DROP INDEX</span>用于取消索引。这是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。请参见<a href="sql-syntax.html#drop-index" title="13.1.7. DROP INDEX Syntax">13.1.7节，“DROP 
			INDEX语法”</a>。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果列从表中被取消了，则这些列也从相应的索引中被取消。如果组成一个索引的所有列均被取消，则该索引也被取消。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果一个表只包含一列，则此列不能被取消。如果您想要取消表，应使用<span>DROP 
			TABLE</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DROP PRIMAY DEY</span>用于取消主索引。注释：在<span>MySQL</span>较早的版本中，如果没有主索引，则<span>DROP 
			PRIMARY KEY</span>会取消表中的第一个<span>UNIQUE</span>索引。在<span>MySQL 
			5.1</span>中不会出现这种情况。如果在<span>MySQL 5.1</span>中对没有主键的表使用<span>DROP 
			PRIMARY KEY</span>，则会出现错误信息。</p>
			<p>如果您向表中添加<span>UNIQUE KEY</span>或<span>PRIMARY 
			KEY</span>，则<span>UNIQUE KEY</span>或<span>PRIMARY 
			KEY</span>会被储存在非唯一索引之前，这样<span>MySQL</span>就可以尽早地检查出重复关键字。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ORDER BY</span>用于在创建新表时，让各行按一定的顺序排列。注意，在插入和删除后，表不会仍保持此顺序。当您知道多数情况下您会按照特定的顺序查询各行时，可以使用这个选项；在对表进行了大的改动后，通过使用此选项，您可以提高查询效率。在有些情况下，如果表按列排序，对于<span>MySQL</span>来说，排序可能会更简单。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您对一个<span>MyISAM</span>表使用<span>ALTER 
			TABLE</span>，则所有非唯一索引会被创建到一个单独的批里（和<span>REPAIR TABLE</span>相同）。当您有许多索引时，这样做可以使<span>ALTER 
			TABLE</span>的速度更快。</p>
			<p>这项功能可以明确激活。<span>ALTER 
			TABLE...DISABLE KEYS</span>让<span>MySQL</span>停止更新<span>MyISAM</span>表中的非唯一索引。然后使用<span><span>ALTER 
			TABLE ... ENABLE KEYS</span>重新创建丢失的索引。进行此操作时，<span>MySQL</span>采用一种特殊的算法，比一个接一个地插入关键字要快很多。因此，在进行成批插入操作前先使关键字禁用可以大大地加快速度。使用<span>ALTER 
			TABLE ... DISABLE KEYS</span>除了需要获得以前提到的权限以外，还需要获得<span>INDEX</span>权限。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>Innodb</span>存储引擎支持<span>FOREIGN 
			KEY</span>和<span>REFERENCES</span>子句。<span>Innodb</span>存储引擎执行<span>ADD 
			[CONSTRAINT [<i>symbol</i>]] FOREIGN KEY (...) REFERENCES ... (...)</span>。请参见<a href="storage-engines.html#innodb-foreign-key-constraints" title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4节，“FOREIGN 
			KEY约束”</a>。对于其它存储引擎，这些子句会被分析，但是会被忽略。对于所有的存储引擎，<span>CHECK</span>子句会被分析，但是会被忽略。请参见<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>。接受这些子句但又忽略子句的原因是为了提高兼容性，以便更容易地从其它<span>SQL</span>服务器中导入代码，并运行应用程序，创建带参考数据的表。请参见<a href="introduction.html#differences-from-ansi" title="1.8.5. MySQL Differences from Standard SQL">1.8.5节，“MySQL与标准SQL的差别”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><span>InnoDB</span>支持使用<span>ALTER 
			TABLE</span>来取消外键：</span></p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ALTER TABLE <span><i>yourtablename</i></span> DROP FOREIGN KEY <span><i>fk_symbol</i></span>;</span></pre>
			<p>要了解更多信息，请参见<a href="storage-engines.html#innodb-foreign-key-constraints" title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4节，“FOREIGN 
			KEY约束”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ALTER TABLE</span>忽略<span>DATA 
			DIRECTORY</span>和<span>INDEX DIRECTORY</span>表选项。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您想要把表默认的字符集和所有字符列（<span>CHAR, VARCHAR, 
			TEXT</span>）改为新的字符集，应使用如下语句：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ALTER TABLE <span><i>tbl_name</i></span> CONVERT TO CHARACTER SET <span><i>charset_name</i></span>;</span></pre>
			<p>警告：前面的操作转换了字符集之间的列类型。如果您有一列使用一种字符集（如<span>latin1</span>），但是存储的值实际上使用了其它的字符集（如<span>utf8</span>），这种情况不是您想要的。此时，您必须对这样的列进行以下操作。</p>
			<pre><span>ALTER TABLE t1 CHANGE c1 c1 BLOB;</span></pre>
			<pre><span>ALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8;</span></pre>
			<p>这种方法能够实现此功能的原因是，当您转换到<span>BLOB</span>列或从<span>BLOB</span>列转换过来时，并没有发生转换。</p>
			<p>如果您指定<span>CONVERT TO 
			CHARACTER SET</span>为二进制，则<span>TEXT</span>列被转换到相应的二进制字符串类型（<span>BINARY, 
			VARBINARY, BLOB</span>）。这意味着这些列将不再有字符集，接下来的<span>CONVERT 
			TO</span>操作也将不适用于这些列。</p>
			<p>要仅仅改变一个表的默认字符集，应使用此语句：</p>
			<pre><span>ALTER TABLE <span><i>tbl_name</i></span> DEFAULT CHARACTER SET <span><i>charset_name</i></span>;</span></pre>
			<p>词语<span>DEFAULT</span>为自选项。如果您在向表中添加一个新列时（例如，使用<span>ALTER 
			TABLE...ADD column</span>）没有指定字符集，则此时使用的字符集为默认字符集。</p>
			<p>警告：<span>ALTER 
			TABLE...DEFAULT CHARACTER SET</span>和<span>ALTER 
			TABLE...CHARACTER SET</span>是等价的，只用于更改默认的表字符集。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>InnoDB</span>表在创建时，使用了<span>.ibd</span>文件中的自己的表空间，则这样的文件可以被删除和导入。使用此语句删除<span>.ibd</span>文件：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ALTER TABLE <span><i>tbl_name</i></span> DISCARD TABLESPACE;</span></pre>
			<p>此语句用于删除当前的<span>.ibd</span>文件，所以应首先确认您有一个备份。如果在表空间被删除后尝试打开表格，则会出现错误。</p>
			<p>要把备份的<span>.ibd</span>文件还原到表中，需把此文件复制到数据库目录中，然后书写此语句：</p>
			<pre><span>ALTER TABLE <span><i>tbl_name</i></span> IMPORT TABLESPACE;</span></pre>
			<p>见<a href="storage-engines.html#multiple-tablespaces" title="15.2.6.6. Using Per-Table Tablespaces">15.2.6.6节，“使用按表的表空间”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>mysql_info()</span><span> 
			C API</span>函数，您可以了解有多少记录已被复制，以及（当使用<span>IGNORE</span>时）有多少记录由于重复关键字的原因已被删除。请参见<a href="apis.html#mysql-info" title="25.2.3.34. mysql_info()">25.2.3.34节，“mysql_info()”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ALTER TABLE</span>也可以用于对带分区的表进行重新分区，功能包括添加、取消、合并和拆分各分区，还可以用于进行分区维护。</p>
			<p>对带分区的表使用<span><i><span>partition_options</span></i></span>子句和<span>ALTER 
			TABLE</span>可以对表进行重新分区，使用时依据<span><i><span>partition_options</span></i>定义的分区方法。本子句以<span>PARTITION 
			BY</span>为开头，然后使用与用于<span>CREATE TABLE</span>的<i><span>partition_options</span></i></span>子句一样的语法和规则（要了解详细信息，请参见<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>）。注释：<span>MySQL 5.1</span>服务器目前接受此语法，但是不实际执行；等<span>MySQL 
			5.1</span>开发出来后，将执行此语法。</p>
			<p>用于<span>ALTER TABLE ADD 
			PARTITION</span>的<span><i><span>partition_definition</span></i></span>子句支持用于<span>CREATE 
			TABLE</span>语句的<span><i><span>partition_definition</span></i></span>子句的同样名称的选项。（要了解语法和介绍，请参见<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>。）例如，假设您有一个按照以下方式创建的带分区的表：</p>
			<pre><span>CREATE TABLE t1 (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; id INT,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; year_col INT</span></pre>
			<pre><span>)</span></pre>
			<pre><span>PARTITION BY RANGE (year_col) (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p0 VALUES LESS THAN (1991),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p1 VALUES LESS THAN (1995),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p2 VALUES LESS THAN (1999)</span></pre>
			<pre><span>);&nbsp;&nbsp;&nbsp; </span></pre>
			<p>您可以在表中增加一个新的分区<span>p3</span>，该分区用于储存小于<span>2002</span>的值。添加方法如下：</p>
			<pre><span>ALTER TABLE t1 ADD PARTITION p3 VALUES LESS THAN (2002);</span></pre>
			<p>注释：您不能使用<span>ALTER TABLE</span>向一个没有进行分区的表添加分区。</p>
			<p><span>DROP PARTITION</span>用于取消一个或多个<span>RANGE</span>或<span>LIST</span>分区。此命令不能用于<span>HASH</span>或<span>KEY
			</span>分区；用于这两个分区时，应使用<span>COALESCE PARTITION</span>（见后）。如果被取消的分区其名称列于<span><i><span>partition_names</span></i></span>清单中，则储存在此分区中的数据也被取消。例如，如果以前已定义的表<span>t1</span>，您可以采用如下方法取消名称为<span>p0</span>和<span>p1</span>的分区：</p>
			<pre><span>ALTER TABLE DROP PARTITION p0, p1;</span></pre>
			<p><span>ADD PARTITION</span>和<span>DROP 
			PARTITION</span>目前不支持<span>IF [NOT] EXISTS</span>。也不可能对一个分区或一个已分区的表进行重命名。如果您希望对一个分区进行重命名，您必须取消分区，再重新建立；如果您希望对一个已分区的表进行重新命名，您必须取消所有分区，然后对表进行重命名，再添加被取消的分区。</p>
			<p><span>COALESCE PARTITION</span>可以用于使用<span>HASH</span>或<span>KEY</span>进行分区的表，以便使用<span><i><span>number</span></i></span>来减少分区的数目。例如，假设您使用下列方法创建了表<span>t2</span>：</p>
			<pre><span>CREATE TABLE t2 (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; name VARCHAR (30),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; started DATE</span></pre>
			<pre><span>)</span></pre>
			<pre><span>PARTITION BY HASH(YEAR(started))</span></pre>
			<pre><span>PARTITIONS (6);</span></pre>
			<p>您可以使用以下命令，把<span>t2</span>使用的分区的数目由<span>6</span>个减少到<span>4</span>个：</p>
			<pre><span>ALTER TABLE t2 COALESCE PARTITION 2;</span></pre>
			<p>包含在最后一个<span><i><span>number</span></i></span>分区中的数据将被合并到其余的分区中。在此情况下，分区<span>4</span>和分区<span>5</span>将被合并到前<span>4</span>个分区中（编号为<span>0</span>、<span>1</span>、<span>2</span>和<span>3</span>的分区）。</p>
			<p>如果要更改部分分区，但不更改所有的分区，您可以使用<span>REORGANIZE 
			PARTITION</span>。这个命令有多种使用方法：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>把多个分区合并为一个分区。通过把多个分区的名称列入<span><i><span>partition_names</span></i></span>清单，并为<span><i><span>partition_definition</span></i></span>提供一个单一的定义，可以实现这个功能。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>把一个原有的分区拆分为多个分区。通过为<span><i><span>partition_names</span></i></span>命名一个分区，并提供多个<span><i><span>partition_definitions</span></i></span>，可以实现这个功能。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>更改使用<span>VALUES LESS THAN</span>定义的分区子集的范围或更改使用<span>VALUES 
			IN</span>定义的分区子集的值清单。</p>
			<p>注释：对于没有明确命名的分区，<span>MySQL</span>会自动提供默认名称<span>p0, 
			p1, p2</span>等。</p>
			<p>要了解有关<span>ALTER TALBE...REORANIZE 
			PARTITION</span>命令的详细信息，请参见<a href="partitioning.html#partitioning-management" title="18.3. Partition Management">18.3节，“分区管理”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>多个附加子句用于提供分区维护和修补功能。这些功能与用于非分区表的功能类似。这些功能由<span>CHECK 
			TABLE</span>和<span>REPAIR TABLE</span>等命令（这些命令不支持用于分区表）执行。这些子句包括<span>ANALYZE 
			PARTITION</span><span>,
			<span>CHECK PARTITION</span>,
			<span>OPTIMIZE PARTITION</span>,
			<span>REBUILD PARTITION</span></span>和<span>REPAIR 
			PARTITION</span><span>.</span>每个选项均为一个<span><i><span>partition_names</span></i></span>子句，包括一个或多个分区名称。需要更改的表中必须已存在这些分区。多个分区名称用逗号分隔。要了解更多信息，或要了解举例说明，请参见<a href="partitioning.html#partitioning-maintenance" title="18.3.3. Maintenance of Partitions">18.3.3节，“分区维护”</a>。</p>
			<p>以下例子展示了<span>ALTER TABLE</span>的使用。首先展示表<span>t1</span>。表<span>t1</span>采用如下方法创建：</p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE t1 (a INTEGER,b CHAR(10));</b></span></span></pre>
			<p>把表<span>t1</span>重新命名为<span>t2</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t1 RENAME t2;</b></span></span></pre>
			<p>把列<span>a</span>从<span>INTERGER</span>更改为<span>TINYINT 
			NOT NULL</span>（名称保持不变），并把列<span>b</span>从<span>CHAR(10)</span>更改为<span>CHAR(20)</span>，同时把列<span>b</span>重新命名为列<span>c</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);</b></span></span></pre>
			<p>添加一个新的<span>TIMESTAMP</span>列，名称为<span>d</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 ADD d TIMESTAMP;</b></span></span></pre>
			<p>在列<span>d</span>和列<span>a</span>中添加索引：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 ADD INDEX (d), ADD INDEX (a);</b></span></span></pre>
			<p>删除列<span>c</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 DROP COLUMN c;</b></span></span></pre>
			<p>添加一个新的<span>AUTO_INCREMENT</span>整数列，名称为<span>c</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ADD PRIMARY KEY (c);</b></span></span></pre>
			<p>注意我们为<span>c</span>编制了索引（作为<span>PRIMARY KEY</span>），因为<span>AUTO_INCREMENT</span>列必须编制索引。同时我们定义<span>c</span>为<span>NOT 
			NULL</span>，因为主键列不能为<span>NULL</span>。</p>
			<p>当您添加一个<span>AUTO_INCREMENT</span>列时，列值被自动地按序号填入。对于<span>MyISAM</span>表，您可以在<span>ALTER 
			TABLE</span>之前执行<span>SET INSERT_ID<span>=<i>value</i></span></span><span>来设置第一个序号，也可以使用<span>AUTO_INCREMENT=<i>value</i></span></span>表选项来设置。请参见<a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3节，“SET语法”</a>。</p>
			<p>如果值大于<span>AUTO_INCREMENT</span>列中的最大值，则您可以使用用于<span>InnoDB</span>表的<span>ALTER 
			TALBE...AUTO_INCREMENT<span>=<i>value</i></span></span>表选项，来为新行设置序号。如果值小于列中当前的最大值，不会出现错误信息，当前的序列值也不改变。</p>
			<p>使用<span>MyISAM</span>表时，如果您不更改<span>AUTO_INCREMENT</span>列，则序列号不受影响。如果您取消一个<span>AUTO_INCREMENT</span>列，然后添加另一个<span>AUTO_INCREMENT</span>列，则序号重新排列，从<span>1</span>开始。</p>
			<p>见<a href="problems.html#alter-table-problems" title="A.7.1. Problems with ALTER TABLE">A.7.1节，“与ALTER TABLE有关的问题”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-database"></a>13.1.3. CREATE 
			DATABASE语法</h3></div></div></div><a class="indexterm" name="id2892556"></a><a class="indexterm" name="id2892565"></a><a class="indexterm" name="id2892574"></a><a class="indexterm" name="id2892584"></a><a class="indexterm" name="id2892594"></a><a class="indexterm" name="id2892604"></a>
			<pre><span>CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] <span><i>db_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [<span><i>create_specification</i></span> [, <span><i>create_specification</i></span>] ...]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>create_specification</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [DEFAULT] CHARACTER SET <span><i>charset_name</i></span></span></pre>
			<pre><span>&nbsp; | [DEFAULT] COLLATE <span><i>collation_name</i></span></span></pre>
			<p><span>CREATE DATABASE</span>用于创建数据库，并进行命名。如果要使用<span>CREATE 
			DATABASE</span>，您需要获得数据库<span>CREATE</span>权限。</p>
			<p>有关合法数据库名称的规定列于<a href="language-structure.html#legal-names" title="9.2. Database, Table, Index, Column, and Alias Names">9.2节，“数据库、表、索引、列和别名”</a>。如果存在数据库，并且您没有指定<span>IF NOT EXISTS</span>，则会出现错误。</p>
			<p><span><span>
			create_specification</span>选项用于指定数据库的特性。数据库特性储存在数据库目录中的<span>db.opt</span>文件中。<span>CHARACTER 
			SET</span>子句用于指定默认的数据库字符集。<span>COLLATE</span>子句用于指定默认的数据库整序。字符集和整序名称在</span><a href="charset.html">第10章</a>：<a href="charset.html" title="Chapter 10. Character Set Support"><i>字符集支持</i></a><span>中讨论。</span></p>
			<p>有些目录包含文件，这些文件与数据库中的表对应。<span>MySQL</span>中的数据库的执行方法与这些目录的执行方法相同。因为当数据库刚刚被创建时，在数据库中没有表，所以<span>CREATE 
			DATABASE</span>只创建一个目录。这个目录位于<span>MySQL</span>数据目录和<span>db.opt</span>文件之下。</p>
			<p>如果您手动在数据目录之下创建一个目录（例如，使用<strong><span>mkdir</span></strong>），则服务器会认为这是一个数据库目录，并在<span>SHOW 
			DATABASES</span>的输出中显示出来。</p>
			<p>也可以使用<span>CREATE SCHEMA</span>。</p>
			<p>您还可以使用<strong><span>mysqladmin</span></strong>程序创建数据库。请参见<a href="client-side-scripts.html#mysqladmin" title="8.5. mysqladmin — Client for Administering a MySQL Server">8.5节，“mysqladmin：用于管理MySQL服务器的客户端”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-index"></a>13.1.4. CREATE 
			INDEX语法</h3></div></div></div><a class="indexterm" name="id2892800"></a><a class="indexterm" name="id2892809"></a><a class="indexterm" name="id2892816"></a><a class="indexterm" name="id2892826"></a>
			<pre><span>CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX <span><i>index_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [USING <span><i>index_type</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ON <span><i>tbl_name</i></span> (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>index_col_name</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>col_name</i></span> [(<span><i>length</i></span>)] [ASC | DESC]</span></pre>
			<p><span>CREATE INDEX</span>被映射到一个<span>ALTER 
			TABLE</span>语句上，用于创建索引。请参见<a href="sql-syntax.html#alter-table" title="13.1.2. ALTER TABLE Syntax">13.1.2节，“ALTER 
		TABLE语法”</a>。</p>
			<p>通常，当使用<span>CREATE TABLE</span>创建表时，也同时在表中创建了所有的索引。请参见<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
		TABLE语法”</a>。<span>CREATE INDEX</span>允许您向已有的表中添加索引。</p>
			<p>格式为（<span>col1, col2,...</span>）的一个列清单创建出一个多列索引。通过串接给定列中的值，确定索引值的格式。</p>
			<p>对于<span>CHAR</span>和<span>VARCHAR</span>列，只用一列的一部分就可创建索引。创建索引时，使用<span><i><span>col_name</span></i><span>(<i>length</i>)</span></span>语法，对前缀编制索引。前缀包括每列值的前<span><i><span>length</span></i>个</span>字符。<span>BLOB</span>和<span>TEXT</span>列也可以编制索引，但是必须给出前缀长度。</p>
			<p>此处展示的语句用于创建一个索引，索引使用列名称的前<span>10</span>个字符。</p>
			<pre><span>CREATE INDEX part_of_name ON customer (name(10));</span></pre>
			<p>因为多数名称的前<span>10</span>个字符通常不同，所以此索引不会比使用列的全名创建的索引速度慢很多。另外，使用列的一部分创建索引可以使索引文件大大减小，从而节省了大量的磁盘空间，有可能提高<span>INSERT</span>操作的速度。</p>
			<p>前缀最长为<span>255</span>字节。对于<span>MyISAM</span>和<span>InnoDB</span>表，前缀最长为<span>1000</span>字节。注意前缀的限长以字节计，而<span>CREATE 
			INDEX</span>语句中的前缀长度指的是字符的数目。对于使用多字节字符集的列，在指定列的前缀长度时，要考虑这一点。</p>
			<p>在<span>MySQL 5.1</span>中：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只有当您正在使用<span>MyISAM, InnoDB</span>或<span>BDB</span>表类型时，您可以向有<span>NULL</span>值的列中添加索引。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只有当您正在使用<span>MyISAM, BDB</span>或<span>InnoDB</span>表类型时，您可以向<span>BLOB</span>或<span>TEXT</span>列中添加索引。</p>
			<p>一个<span><i><span>index_col_name</span></i>规约可以以<span>ASC</span>或<span>DESC</span>为结尾。这些关键词将来可以扩展，用于指定递增或递减索引值存储。目前，这些关键词被分析，但是被忽略；索引值均以递增顺序存储。</span></p>
			<p>部分储存引擎允许在创建索引时指定索引类型。<span><i><span>index_type</span></i></span>指定语句的语法是<span>USING
			<span><i>type_name</i></span></span>。不同的储存引擎所支持的<span><i><span>type_name</span></i></span>值已显示在下表中。如果列有多个索引类型，当没有指定<span><i><span>index_type</span></i>时，第一个类型是默认值</span>。</p>
			<table border="1" cellpadding="0" id="table1">
				<tr>
					<td>
					<p><strong><span>
					存储引擎</span></strong></td>
					<td>
					<p><strong><span>
					允许的索引类型</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MyISAM</span></td>
					<td>
					<p>
					<span>BTREE</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>InnoDB</span></td>
					<td>
					<p>
					<span>BTREE</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MEMORY</span><span>/<span>HEAP</span></span></td>
					<td>
					<p>
					<span>HASH</span><span>,
					<span>BTREE</span></span></td>
				</tr>
			</table>
			<p>示例：</p>
			<pre><span>CREATE TABLE lookup (id INT) ENGINE = MEMORY;</span></pre>
			<pre><span>CREATE INDEX id_index USING BTREE ON lookup (id);</span></pre>
			<p><span>TYPE <i>type_name</i></span>可以作为<span>USING
			<i>type_name</i></span>的同义词，用于指定索引类型。但是，<span>USING</span>是首选的格式。另外，在索引规约语法中，位于索引类型前面的索引名称不能使用<span>TYPE</span>。这是因为，与<span>USING</span>不同，<span>TYPE</span>不是保留词，因此会被认为是一个索引名称。</p>
			<p>如果您指定的索引类型在给定的储存引擎中不合法，但是有其它的索引类型适合引擎使用，并且不会影响查询功能，则引擎应使用此类型。</p>
			<p>要了解更多有关<span>MySQL</span>如何使用索引的信息，请参见<a href="optimization.html#mysql-indexes" title="7.4.5. How MySQL Uses Indexes">7.4.5节，“MySQL如何使用索引”</a>。</p>
			<p><span>FULLTEXT</span>索引只能对<span>CHAR, VARCHAR</span>和<span>TEXT</span>列编制索引，并且只能在<span>MyISAM</span>表中编制。请参见<a href="functions.html#fulltext-search" title="12.7. Full-Text Search Functions">12.7节，“全文搜索功能”</a>。</p>
			<p><span>SPATIAL</span>索引只能对空间列编制索引，并且只能在<span>MyISAM</span>表中编制。空间列类型在<a href="spatial-extensions-in-mysql.html">第19章：</a><a href="spatial-extensions-in-mysql.html" title="Chapter 19. Spatial Extensions in MySQL"><i>MySQL中的空间扩展</i></a>中进行了描述。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-table"></a>13.1.5. CREATE 
			TABLE语法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#silent-column-changes">
				13.1.5.1. 沉寂的列规格变更</a></span></dt></dl></div><a class="indexterm" name="id2893328"></a>
			<pre><span>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(<span><i>create_definition</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [<span><i>table_options</i></span>] [<span><i>select_statement</i></span>]</span></pre>
			<p>或：</p>
			<pre><span>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(] LIKE <span><i>old_tbl_name</i></span> [)];</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>create_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>column_definition</i></span></span></pre>
			<pre><span>&nbsp; | [CONSTRAINT [<span><i>symbol</i></span>]] PRIMARY KEY [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | KEY [<span><i>index_name</i></span>] [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | INDEX [<span><i>index_name</i></span>] [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | [CONSTRAINT [<span><i>symbol</i></span>]] UNIQUE [INDEX]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<span><i>index_name</i></span>] [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | [FULLTEXT|SPATIAL] [INDEX] [<span><i>index_name</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | [CONSTRAINT [<span><i>symbol</i></span>]] FOREIGN KEY</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<span><i>index_name</i></span>] (<span><i>index_col_name</i></span>,...) [<span><i>reference_definition</i></span>]</span></pre>
			<pre><span>&nbsp; | CHECK (<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>column_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>col_name</i></span> <span><i>type</i></span> [NOT NULL | NULL] [DEFAULT <span><i>default_value</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [COMMENT &#39;<span><i>string</i></span>&#39;] [<span><i>reference_definition</i></span>]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>type</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; TINYINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | SMALLINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | MEDIUMINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | INT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | INTEGER[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | BIGINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | REAL[(<span><i>length</i></span>,<span><i>decimals</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | DOUBLE[(<span><i>length</i></span>,<span><i>decimals</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | FLOAT[(<span><i>length</i></span>,<span><i>decimals</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | DECIMAL(<span><i>length</i></span>,<span><i>decimals</i></span>) [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | NUMERIC(<span><i>length</i></span>,<span><i>decimals</i></span>) [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | DATE</span></pre>
			<pre><span>&nbsp; | TIME</span></pre>
			<pre><span>&nbsp; | TIMESTAMP</span></pre>
			<pre><span>&nbsp; | DATETIME</span></pre>
			<pre><span>&nbsp; | CHAR(<span><i>length</i></span>) [BINARY | ASCII | UNICODE]</span></pre>
			<pre><span>&nbsp; | VARCHAR(<span><i>length</i></span>) [BINARY]</span></pre>
			<pre><span>&nbsp; | TINYBLOB</span></pre>
			<pre><span>&nbsp; | BLOB</span></pre>
			<pre><span>&nbsp; | MEDIUMBLOB</span></pre>
			<pre><span>&nbsp; | LONGBLOB</span></pre>
			<pre><span>&nbsp; | TINYTEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | TEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | MEDIUMTEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | LONGTEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | ENUM(<span><i>value1</i></span>,<span><i>value2</i></span>,<span><i>value3</i></span>,...)</span></pre>
			<pre><span>&nbsp; | SET(<span><i>value1</i></span>,<span><i>value2</i></span>,<span><i>value3</i></span>,...)</span></pre>
			<pre><span>&nbsp; | <span><i>spatial_type</i></span></span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>index_col_name</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>col_name</i></span> [(<span><i>length</i></span>)] [ASC | DESC]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>reference_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; REFERENCES <span><i>tbl_name</i></span> [(<span><i>index_col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ON DELETE <span><i>reference_option</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ON UPDATE <span><i>reference_option</i></span>]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>reference_option</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; RESTRICT | CASCADE | SET NULL | NO ACTION</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>table_options</span></i></span><span>: <span><i>table_option</i></span> [<span><i>table_option</i></span>] ...</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>table_option</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; {ENGINE|TYPE} = <span><i>engine_name</i></span></span></pre>
			<pre><span>&nbsp; | AUTO_INCREMENT = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | AVG_ROW_LENGTH = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | [DEFAULT] CHARACTER SET <span><i>charset_name</i></span> [COLLATE <span><i>collation_name</i></span>]</span></pre>
			<pre><span>&nbsp; | CHECKSUM = {0 | 1}</span></pre>
			<pre><span>&nbsp; | COMMENT = &#39;<span><i>string</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | CONNECTION = &#39;<span><i>connect_string</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | MAX_ROWS = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | MIN_ROWS = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | PACK_KEYS = {0 | 1 | DEFAULT}</span></pre>
			<pre><span>&nbsp; | PASSWORD = &#39;<span><i>string</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | DELAY_KEY_WRITE = {0 | 1}</span></pre>
			<pre><span>&nbsp; | ROW_FORMAT = {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}</span></pre>
			<pre><span>&nbsp; | UNION = (<span><i>tbl_name</i></span>[,<span><i>tbl_name</i></span>]...)</span></pre>
			<pre><span>&nbsp; | INSERT_METHOD = { NO | FIRST | LAST }</span></pre>
			<pre><span>&nbsp; | DATA DIRECTORY = &#39;<span><i>absolute path to directory</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | INDEX DIRECTORY = &#39;<span><i>absolute path to directory</i></span>&#39;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>partition_options</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION BY</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [LINEAR] HASH(<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; [LINEAR] KEY(<span><i>column_list</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; RANGE(<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; LIST(<span><i>column_list</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [PARTITIONS <span><i>num</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [&nbsp; SUBPARTITION BY</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [LINEAR] HASH(<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | [LINEAR] KEY(<span><i>column_list</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [SUBPARTITIONS(<span><i>num</i></span>)]&nbsp; </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(<span><i>partition_definition</i></span>), [(<span><i>partition_definition</i></span>)], ...]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>partition_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION <span><i>partition_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [VALUES { </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LESS THAN (<span><i>expr</i></span>) | <span>MAXVALUE</span> </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| IN (<span><i>value_list</i></span>) }]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [[STORAGE] ENGINE [=] <span><i>engine-name</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [COMMENT [=] <span><i>&#39;comment_text&#39;</i></span> ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DATA DIRECTORY [=] &#39;<span><i>data_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [INDEX DIRECTORY [=] &#39;<span><i>index_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MAX_ROWS [=] <span><i>max_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MIN_ROWS [=] <span><i>min_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TABLESPACE [=] (<span><i>tablespace_name</i></span>)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [NODEGROUP [=] <span><i>node_group_id</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [(<span><i>subpartition_definition</i></span>), [(<span><i>subpartition_definition</i></span>)], ...]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>subpartition_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SUBPARTITION <span><i>logical_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [[STORAGE] ENGINE [=] <span><i>engine-name</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [COMMENT [=] <span><i>&#39;comment_text&#39;</i></span> ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DATA DIRECTORY [=] &#39;<span><i>data_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [INDEX DIRECTORY [=] &#39;<span><i>index_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MAX_ROWS [=] <span><i>max_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MIN_ROWS [=] <span><i>min_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TABLESPACE [=] (<span><i>tablespace_name</i></span>)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [NODEGROUP [=] <span><i>node_group_id</i></span>]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>select_statement:</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [IGNORE | REPLACE] [AS] SELECT ...&nbsp;&nbsp; (<span><i>Some legal select statement</i></span>)</span></pre>
			<p><span>CREATE TABLE</span>用于创建带给定名称的表。您必须拥有表<span>CREATE</span>权限。</p>
			<p>允许的表名称的规则列于<a href="language-structure.html#legal-names" title="9.2. Database, Table, Index, Column, and Alias Names">9.2节，“数据库、表、索引、列和别名”</a>中。默认的情况是，表被创建到当前的数据库中。如果表已存在，或者如果没有当前数据库，或者如果数据库不存在，则会出现错误。</p>
			<p>表名称被指定为<span><i><span>db_name.tbl_name</span></i></span>，以便在特定的数据库中创建表。不论是否有当前数据库，都可以通过这种方式创建表。如果您使用加引号的识别名，则应对数据库和表名称分别加引号。例如，<span><span>`mydb`.`mytbl`</span>是合法的，但是<span>`mydb.mytbl`</span>不合法。</span></p>
			<p>在创建表格时，您可以使用<span>TEMPORARY</span>关键词。只有在当前连接情况下，<span>TEMPORARY</span>表才是可见的。当连接关闭时，<span>TEMPORARY</span>表被自动取消。这意味着两个不同的连接可以使用相同的临时表名称，同时两个临时表不会互相冲突，也不与原有的同名的非临时表冲突。（原有的表被隐藏，直到临时表被取消时为止。）您必须拥有<span>CREATE 
			TEMPORARY TABLES</span>权限，才能创建临时表。</p>
			<p>如果表已存在，则使用关键词<span>IF NOT EXISTS</span>可以防止发生错误。注意，原有表的结构与<span>CREATE 
			TABLE</span>语句中表示的表的结构是否相同，这一点没有验证。注释：如果您在<span>CREATE 
			TABLE...SELECT</span>语句中使用<span>IF NOT EXISTS</span>，则不论表是否已存在，由<span>SELECT</span>部分选择的记录都会被插入。</p>
			<p><span>MySQL</span>通过数据库目录中的<span>.frm</span>表格式（定义）文件表示每个表。表的存储引擎也可能会创建其它文件。对于<span>MyISAM</span>表，存储引擎可以创建数据和索引文件。因此，对于每个<span>MyISAM</span>表<span><i><span>tbl_name</span></i></span>，有三个磁盘文件：</p>
			<table border="1" cellpadding="0" id="table2">
				<tr>
					<td>
					<p><strong><span>
					文件</span></strong></td>
					<td>
					<p><strong><span>
					作用</span></strong></td>
				</tr>
				<tr>
					<td>
					<p><span><i>
					<span>tbl_name</span></i><span>.frm</span></span></td>
					<td>
					<p>表格式（定义）文件</td>
				</tr>
				<tr>
					<td>
					<p><span><i>
					<span>tbl_name</span></i><span>.MYD</span></span></td>
					<td>
					<p>数据文件</td>
				</tr>
				<tr>
					<td>
					<p><span><i>
					<span>tbl_name</span></i><span>.MYI</span></span></td>
					<td>
					<p>索引文件</td>
				</tr>
			</table>
			<p>用于表示表的由存储引擎创建的文件在<a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types">第15章：<i>存储引擎和表类型</i></a>中描述。</p>
			<p>要了解有关各种列类型的性质的一般说明，请参见<a href="column-types.html" title="Chapter 11. Column Types">第11章：列类型</a>。要了解有关空间列类型的说明，请参见<a href="spatial-extensions-in-mysql.html">第19章：</a><a href="spatial-extensions-in-mysql.html" title="Chapter 19. Spatial Extensions in MySQL"><i>MySQL中的空间扩展</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果没有指定是<span>NULL</span>或是<span>NOT 
			NULL</span>，则列在创建时假定指定为<span>NULL</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>一个整数列可以拥有一个附加属性<span>AUTO_INCREMENT</span>。当您向一个已编入索引的<span>AUTO_INCREMENT</span>列中插入一个<span>NULL</span>值（建议）或<span>0</span>时，此列被设置为下一个序列的值。通常情况下为<span><i><span>value</span></i><span>+1</span></span>，此处<span><i><span>value</span></i></span>是当前在表中的列的最大值。<span>AUTO_INCREMENT</span>序列从<span>1</span>开始。这样的列必须被定义为一种整数类型，请参见<a href="column-types.html#numeric-type-overview" title="11.1.1. Overview of Numeric Types">11.1.1节，“数值类型概述”</a>中的叙述。（值<span>1.0</span>不是整数）。请参见<a href="apis.html#mysql-insert-id" title="25.2.3.36. mysql_insert_id()">25.2.3.36节，“mysql_insert_id()”</a>。</p>
			<p>为<span>--sql-mode</span>服务器选项或<span>sql_mode</span>系统变量指定<span>NO_AUTO_VALUE_ON_ZERO</span>特征位，这样可以把<span>0</span>存储到<span>AUTO_INCREMENT</span>列中，同时不生成一个新的序列值。请参见<a href="database-administration.html#server-options" title="5.3.1. mysqld Command-Line Options">5.3.1节，“<span><strong class="command">mysqld</strong></span>命令行选项”</a>。</p>
			<p>注释：有时候，每个表只有一个<span>AUTO_INCREMENT</span>列，此列必须编制索引，不能有<span>DEFAULT</span>值。一个<span>AUTO_INCREMENT</span>列只有在只包含正数的情况下，才能运行正常。插入一个负数会被认为是插入了一个非常大的正数。这样做是为了避免当数字由正数转为负数时出现精度问题，同时也为了确保<span>AUTO_INCREMENT</span>列中不会包含<span>0</span>。</p>
			<p>对于<span>MyISAM</span>和<span>BDB</span>表，您可以在一个多列关键字中指定一个<span>AUTO_INCREMENT</span>次级列。请参见<a href="tutorial.html#example-auto-increment" title="3.6.9. Using AUTO_INCREMENT">3.6.9节，“使用AUTO_INCREMENT”</a>。</p>
			<p>为了让<span>MySQL</span>与部分<span>ODBC</span>应用软件相兼容，您可以使用以下查询方法找到最后一个插入行的<span>AUTO_INCREMENT</span>值：</p>
			<pre><span>SELECT * FROM <span><i>tbl_name</i></span> WHERE <span><i>auto_col</i></span> IS NULL</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>字符列的定义可以包括一个<span>CHARACTER SET</span>属性，用来指定字符集，也可以指定列的整序。要了解详细情况，请参见<a href="charset.html" title="Chapter 10. Character Set Support">第10章：<i>字符集支持</i></a>。<span>CHARSET</span>是<span>CHARACTER 
			SET</span>的同义词。</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t (c CHAR(20) CHARACTER SET utf8 COLLATE utf8_bin);</span></pre>
			<p><span>MySQL 5.1</span>理解，在字符列定义中的长度规约以字符为单位。（有些早期版本以字节为单位。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DEFAULT</span>子句用于为列指定一个默认值。默认值必须为一个常数，不能为一个函数或一个表达式，有一种情况例外。例如，一个日期列的默认值不能被设置为一个函数，如<span>NOW()</span>或<span>CURRENT_DATE</span>。不过，有一种例外，您可以对<span>TIMESTAMP</span>列指定<span>CURRENT_TIMESTAMP</span>为默认值。请参见<a href="column-types.html#timestamp-4-1" title="11.3.1.1. TIMESTAMP Properties as of MySQL 4.1">11.3.1.1节，“MySQL 4.1中的TIMESTAMP属性”</a>。</p>
			<p><span>BLOB</span>和<span>TEXT</span>列不能被赋予默认值。</p>
			<p>如果在列定义中没有明确的<span>DEFAULT</span>值，则<span>MySQL</span>按照如下规则确定默认值：</p>
			<p>如果列可以使用<span>NULL</span>作为值，则使用<span>DEFAULT 
			NULL</span>子句对列进行定义。（在<span>MySQL</span>的早期版本中也如此。）</p>
			<p>如果列不能使用<span>NULL</span>作为值，则<span>MySQL</span>对列进行定义时不使用<span>DEFAULT</span>子句。输入数据时，如果<span>INSERT</span>或<span>REPLACE</span>语句不包括列的值，则<span>MySQL</span>依据当时的有效的<span>SQL</span>模式操作列：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>如果严格模式没有被启用，则<span>MySQL</span>会根据列数据类型，把列设置为明确的默认值。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			如果严格模式已被启用，则事务表会出现错误，语句被回滚。对于非事务表，会出现错误，不过，如果错误出现在一个多行语句中的第二行或后续行，则以前的各行将被插入。</p>
			<p>假设表<span>t</span>按下面的方法进行定义：</p>
			<pre><span>CREATE TABLE t (i INT NOT NULL);</span></pre>
			<p>在这种情况下，<span>i</span>没有明确的默认值，所以在严格模式中，每个后续语句都会产生一个错误，并且没有行被插入。当未使用严格模式时，只有第三个语句产生错误；明确的默认值被插入到前两个语句中，但是第三个语句会出现错误，因为<span>DEFAULT(i)</span>不会产生一个值：</p>
			<pre><span>INSERT INTO t VALUES();</span></pre>
			<pre><span>INSERT INTO t VALUES(DEFAULT);</span></pre>
			<pre><span>INSERT INTO t VALUES(DEFAULT(i));</span></pre>
			<p>见<a href="database-administration.html#server-sql-mode" title="5.3.2. The Server SQL Mode">5.3.2节，“SQL服务器模式”</a>。</p>
			<p>对于一个给定的表，您可以使用<span>SHOW 
			CREATE TABLE</span>语句来查看那些列有明确的<span>DEFAULT</span>子句。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于列的评注可以使用<span>COMMENT</span>选项来进行指定。评注通过<span>SHOW 
			CREATE TABLE</span>和<span>SHOW FULL COLUMNS</span>语句显示。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>属性<span>SERIAL</span>可以用作<span>BIGINT 
			UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</span>的别名。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>KEY</span>通常是<span>INDEX</span>同义词。如果关键字属性<span>PRIMARY 
			KEY</span>在列定义中已给定，则<span>PRIMARY KEY</span>也可以只指定为<span>KEY</span>。这么做的目的是与其它数据库系统兼容。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>UNIQUE</span>索引中，所有的值必须互不相同。如果您在添加新行时使用的关键字与原有行的关键字相同，则会出现错误。例外情况是，如果索引中的一个列允许包含<span>NULL</span>值，则此列可以包含多个<span>NULL</span>值。此例外情况不适用于<span>BDB</span>表。在<span>BDB</span>中，带索引的列只允许一个单一<span>NULL</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>PRIMARY KEY</span>是一个唯一<span>KEY</span>，此时，所有的关键字列必须定义为<span>NOT 
			NULL</span>。如果这些列没有被明确地定义为<span>NOT NULL</span>，<span>MySQL</span>应隐含地定义这些列。一个表只有一个<span>PRIMARY 
			KEY</span>。如果您没有<span>PRIMARY KEY</span>并且一个应用程序要求在表中使用<span>PRIMARY 
			KEY</span>，则<span>MySQL</span>返回第一个<span>UNIQUE</span>索引，此索引没有作为<span>PRIMARY 
			KEY</span>的<span>NULL</span>列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在已创建的表中，<span>PRIMARY KEY</span>的位置最靠前，然后是所有的<span>UNIQUE</span>索引，然后是非唯一索引。这可以帮助<span>MySQL</span>优化程序选择优先使用哪个索引，并且更快速的检测出重复的<span>UNIQUE</span>关键字。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>PRIMARY KEY</span>可以是一个多列索引。但是，在列规约中使用<span>PRIMARY 
			KEY</span>关键字属性无法创建多列索引。这么做只能把一个列标记为主列。您必须使用一个单独的<span>PRIMARY 
			KEY</span>（<span>index_col_name, 
			...</span>）子句。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>PRIMARY KEY</span>或<span>UNIQUE</span>索引只包括一个列，并且此列为整数类型，则您也可以在<span>SELECT</span>语句中把此列作为<span>_rowid</span>引用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>MySQL</span>中，<span>PRIMARY 
			KEY</span>的名称为<span>PRIMARY</span>。对于其它索引，如果您没有赋予名称，则索引被赋予的名称与第一个已编入索引的列的名称相同，并自选添加后缀（<span>_2, 
			_3,...</span>），使名称为唯一名称。您可以使用<span>SHOW INDEX FROM
			<span><i>tbl_name</i></span></span>来查看表的索引名称。请参见<a href="sql-syntax.html#show-index" title="13.5.4.11. SHOW INDEX Syntax">13.5.4.11节，“SHOW 
			INDEX语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>部分存储引擎允许您在创建索引时指定索引类型。<span><i><span>index_type</span></i>指示语句的语法是<span>USING 
			type_name</span>。</span></p>
			<p>示例：</p>
			<pre><span>CREATE TABLE lookup</span></pre>
			<pre><span>&nbsp; (id INT, INDEX USING BTREE (id))</span></pre>
			<pre><span>&nbsp; ENGINE = MEMORY;</span></pre>
			<p>要了解有关<span>USING</span>的详细说明，请参见<a href="sql-syntax.html#create-index" title="13.1.4. CREATE INDEX Syntax">13.1.4节，“CREATE 
			INDEX语法”</a>。</p>
			<p>要了解有关<span>MySQL</span>如何使用索引的更多信息，请参见<a href="optimization.html#mysql-indexes" title="7.4.5. How MySQL Uses Indexes">7.4.5节，“MySQL如何使用索引”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>MySQL 5.1</span>中，只有<span>MyISAM</span>，<span>InnoDB, 
			BDB</span>和<span>MEMORY</span>存储引擎支持在含有<span>NULL</span>值的列中编索引。在其它情况下，您必须定义已编索引的列为<span>NOT 
			NULL</span>，否则会出现错误。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一个索引规约中使用<span><i><span>col_name</span></i><span>(<i>length</i>)</span></span>语法，您可以创建一个索引，此索引只使用一个<span>CHAR</span>或<span>VARCHAR</span>列的第一个<span><i><span>length</span></i></span>字符。只对列值的前缀编制索引可以使索引文件大大减小。请参见<a href="optimization.html#indexes" title="7.4.3. Column Indexes">7.4.3节，“列索引”</a>。</p>
			<p><span>MyISAM</span>和<span>InnoDB</span>存储引擎也支持对<span>BLOB</span>和<span>TEXT</span>列编索引。当对<span>BLOB</span>或<span>TEXT</span>列编索引时，您必须为索引指定一个前缀长度。例如：</p>
			<pre><span>CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));</span></pre>
			<p>对于<span>MyISAM</span>和<span>InnoDB</span>表，前缀最长可以为<span>1000</span>字节，对于其它表格类型，最长可以为<span>255</span>字节。注意前缀长度限值以字节为单位，而在<span>CREATE 
			TABLE</span>语句中的前缀长度用字符数目来表述。当为一个使用多字节字符集的列指定前缀长度时，一定要考虑到这一点。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>一个<span><i><span>index_col_name</span></i></span>规约可以以<span>ASC</span>或<span>DESC</span>结尾。这些关键词可以在将来进行扩展，用于指定升序或降序的索引值存储。当前，这些关键词被分析但是被忽略；索引值均以升序储存。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当您在<span>SELECT</span>中的<span>TEXT</span>列或<span>BLOB</span>列中使用<span>ORDER 
			BY</span>或<span>GROUP BY</span>时，服务器只使用初始的字节数目对值进行分类。字节数目由<span><span>max_sort_length</span>系统变量进行指示。请参见</span><a href="column-types.html#blob" title="11.4.3. The BLOB and TEXT Types">11.4.3节，“BLOB和TEXT类型<code class="literal"></code>”</a><span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以创建特殊的<span>FULLTEXT</span>索引，用于全文搜索。只有<span>MyISAM</span>表类型支持<span>FULLTEXT</span>索引。<span>FULLTEXT</span>索引只可以从<span>CHAR, 
			VARCHAR</span>和<span>TEXT</span>列中创建。整个列都会被编入索引；不支持对部分列编索引。如果已指定，前缀长度会被忽略。要了解运行的详细说明，请参见<a href="functions.html#fulltext-search" title="12.7. Full-Text Search Functions">12.7节，“全文搜索功能”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以为空间列类型创建<span>SPATIAL</span>索引。只有<span>MyISAM</span>表支持空间类型，已编索引的列必须声明为<span>NOT 
			NULL</span>。请参见<a href="spatial-extensions-in-mysql.html">第19章：</a><a href="spatial-extensions-in-mysql.html" title="Chapter 19. Spatial Extensions in MySQL"><i>MySQL中的空间扩展</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>InnoDB</span>表支持对外键限制条件进行检查。请参见<a href="storage-engines.html#innodb" title="15.2. The InnoDB Storage Engine">15.2节，“InnoDB存储引擎”</a>。注意，在<span>InnoDB</span>中，<span>FOREIGN 
			KEY</span>语法比本节开始时介绍的<span>CREATE TABLE</span>语句的语法更严格：被引用的表中的列必须有明确的命名。<span>InnoDB</span>支持外键的<span>ON 
			DELETE</span>和<span>ON UPDATE</span>两种操作。有关精确语法的说明，请参见<a href="storage-engines.html#innodb-foreign-key-constraints" title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4节，“FOREIGN 
			KEY约束”</a>。</p>
			<p>对于其它存储引擎，<span>MySQL</span>服务器对<span>CREATE 
			TABLE</span>语句中的<span>FOREIGN KEY</span>和<span>REFERENCES</span>语法进行分析，但不采取进一步的行动。所有的存储引擎均对<span>CHECK</span>子句进行分析，但是忽略<span>CHECK</span>子句。请参见<a href="introduction.html#ansi-diff-foreign-keys" title="1.8.5.5. Foreign Keys">1.8.5.5节，“外键”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于<span>MyISAM</span>表，每个<span>NULL</span>列要多占用一位，进位到距离最近的字节。最大记录长度（以字节为单位）按照如下方法计算：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>row length = 1</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (<span><i>sum of column lengths</i></span>)</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (<span><i>number of NULL columns</i></span> + <span><i>delete_flag</i></span> + 7)/8</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (<span><i>number of variable-length columns</i></span>)</span></pre>
			<p>对于采用静态记录格式的表，<span><i><span>delete_flag</span></i></span>为<span>1</span>。静态表在行记录中使用一位用作位标记。位标记指示该行是否已被删除。对于动态表，<span><i><span>delete_flag</span></i></span>为<span>0</span>，因为在动态行标题中已存储了位标记。</p>
			<p>这些计算方法不适用于<span>InnoDB</span>表。对于<span>InnoDB</span>表，<span>NULL</span>列的存储量与<span>NOT 
			NULL</span>列的存储量没有区别。</p>
			<p><span>ENGINE</span>和<span>TYPE</span>选项用于为表指定存储引擎。<span>ENGINE</span>是首选的选项名称。</p>
			<p><span>ENGINE</span>和<span>TYPE</span>选项采用以下值：</p>
			<table border="1" cellpadding="0" id="table3">
				<tr>
					<td>
					<p><strong><span>
					存储引擎</span></strong></td>
					<td>
					<p><strong><span>
					说明</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>ARCHIVE</span></td>
					<td>
					<p>档案存储引擎。请参见<a href="storage-engines.html#archive-storage-engine" title="15.8. The ARCHIVE Storage Engine">15.8节，“ARCHIVE存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>BDB</span></td>
					<td>
					<p>带页面锁定的事务安全表。也称为<span>BerkeleyDB</span>。请参见<a href="storage-engines.html#bdb-storage-engine" title="15.5. The BDB (BerkeleyDB) Storage Engine">15.5节，“BDB (BerkeleyDB)存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>CSV</span></td>
					<td>
					<p>值之间用逗号隔开的表。请参见<a href="storage-engines.html#csv-storage-engine" title="15.9. The CSV Storage Engine">15.9节，“CSV存储引擎</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>EXAMPLE</span></td>
					<td>
					<p>示例引擎。请参见<a href="storage-engines.html#example-storage-engine" title="15.6. The EXAMPLE Storage Engine">15.6节，“EXAMPLE存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>FEDERATED</span></td>
					<td>
					<p>可以访问远程表的存储引擎。请参见<a href="storage-engines.html#federated-storage-engine" title="15.7. The FEDERATED Storage Engine">15.7节，“FEDERATED存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>HEAP</span></td>
					<td>
					<p>见<a href="storage-engines.html#memory-storage-engine" title="15.4. The MEMORY (HEAP) Storage Engine">15.4节，“MEMORY (HEAP)存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p><span>(<em><span>OBSOLETE</span></em>)
					<span>ISAM</span></span></td>
					<td>
					<p>在<span>MySQL 5.1</span>中没有此引擎。如果您要从以前的版本升级到<span>MySQL 
					5.1</span>，您应该在进行升级前把原有的<span>ISAM</span>表转换为<span>MyISAM</span>表。请参见<a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types">第15章：<i>存储引擎和表类型</i></a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>InnoDB</span></td>
					<td>
					<p>带行锁定和外键的事务安全表。请参见<a href="storage-engines.html#innodb" title="15.2. The InnoDB Storage Engine">15.2节，“InnoDB存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MEMORY</span></td>
					<td>
					<p>本表类型的数据只保存在存储器里。（在早期<span>MySQL</span>版本中被称为<span>HEAP</span>。）</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MERGE</span></td>
					<td>
					<p><span>MyISAM</span>表的集合，作为一个表使用。也称为<span>MRG_MyISAM</span>。请参见<a href="storage-engines.html#merge-storage-engine" title="15.3. The MERGE Storage Engine">15.3节，“MERGE存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MyISAM</span></td>
					<td>
					<p>二进制轻便式存储引擎，此引擎是<span>MySQL</span>所用的默认存储引擎。请参见<a href="storage-engines.html#myisam-storage-engine" title="15.1. The MyISAM Storage Engine">15.1节，“MyISAM存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>NDBCLUSTER</span></td>
					<td>
					<p>成簇表，容错表，以存储器为基础的表。也称为<span>NDB</span>。请参见<a href="ndbcluster.html">第17章：</a><a href="ndbcluster.html" title="Chapter 17. MySQL Cluster"><i>MySQL簇</i></a>。</td>
				</tr>
			</table>
			<p>要了解有关<span>MySQL</span>存储引擎的更多信息，请参见<a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types">第15章：<i>存储引擎和表类型</i></a>。</p>
			<p>如果被指定的存储引擎无法利用，则<span>MySQL</span>使用<span>MyISAM</span>代替。例如，一个表定义包括<span>ENGINE=BDB</span>选项，但是<span>MySQL</span>服务器不支持<span>BDB</span>表，则表被创建为<span>MyISAM</span>表。这样，如果您在主机上有事务表，但在从属机上创建的是非交互式表（以加快速度）时，可以进行复制设置。在<span>MySQL 
			5.1</span>中，如果没有遵守存储引擎规约，则会出现警告。</p>
			<p>其它表选项用于优化表的性质。在多数情况下，您不必指定表选项。这些选项适用于所有存储引擎，另有说明除外：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			AUTO_INCREMENT</span><span> </span></p>
			<p>表的初始<span>AUTO_INCREMENT</span>值。在<span>MySQL 
			5.1</span>中，本选项只适用于<span>MyISAM</span>和<span>MEMORY</span>表。<span>InnoDB</span>也支持本选项。如果引擎不支持<span>AUTO_INCREMENT</span>表选项，则要设置引擎的第一个<span>auto-increment</span>值，需插入一个“假”行。该行的值比创建表后的值小一，然后删除该假行。</p>
			<p>对于在<span>CREATE TABLE</span>语句中支持<span>AUTO_INCREMENT</span>表选项的引擎，您也可以使用<span>ALTER 
			TABLE <i>tbl_name</i> AUTO_INCREMENT = <i>n</i></span>来重新设置<span>AUTO_INCREMENT</span>值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			AVG_ROW_LENGTH</span><span> </span></p>
			<p>表中平均行长度的近似值。只需要对含尺寸可变的记录的大型表进行此项设置。</p>
			<p >
			当创建一个<span>MyISAM</span>表时，<span>MySQL</span>使用<span>MAX_ROWS</span>和<span>AVG_ROW_LENGTH</span>选项的乘积来确定得出的表有多大。如果有一个选项未指定，则表的最大尺寸为<span>65,536TB</span>数据。（如果操作系统不支持这么大的文件，则表的尺寸被限定在操作系统的限值处。）如果您想缩小指针尺寸使索引更小，速度更快，并且您不需要大文件，则您可以通过设置<span>myisam_data_pointer_size</span>系统变量来减少默认指针的尺寸。（见<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a>。）如果您希望所有的表可以扩大，超过默认限值，并且愿意让表稍微慢点，并稍微大点，则您可以通过设置此变量增加默认指针的尺寸。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			[DEFAULT] CHARACTER SET</span><span> </span></p>
			<p>用于为表指定一个默认字符集。<span>CHARSET</span>是<span><span>CHARACTER 
			SET</span>的同义词。</span></p>
			<p>对于<span>CHARACTER 
			SET</span><span>. </span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>COLLATE</span><span>
			</span></p>
			<p>用于为表指定一个默认整序。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>CHECKSUM</span><span>
			</span></p>
			<p>如果您希望<span>MySQL</span>随时对所有行进行实时检验求和（也就是，表变更后，<span>MySQL</span>自动更新检验求和），则应把此项设置为<span>1</span>。这样做，表的更新速度会略微慢些，但是更容易寻找到受损的表。<span>CHECKSUM 
			TABLE</span>语句用于报告检验求和（仅限于<span>MyISAM</span>）。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>COMMENT</span><span>
			</span></p>
			<p>表的注释，最长<span>60</span>个字符。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CONNECTION</span><span> </span></p>
			<p><span>FEDERATED</span>表的连接字符串。（
			注释：较早版本的<span>MySQL</span>使用<span>COMMENT</span>选项用于连接字符串。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MAX_ROWS</span><span>
			</span></p>
			<p>
			您打算储存在表中的行数目的最大值。这不是一个硬性限值，而更像一个指示语句，指示出表必须能存储至少这么多行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MIN_ROWS</span><span>
			</span></p>
			<p>您打算存储在表中的行数目的最小值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			PACK_KEYS</span><span> </span></p>
			<p>如果您希望索引更小，则把此选项设置为<span>1</span>。这样做通常使更新速度变慢，同时阅读速度加快。把选项设置为<span>0</span>可以取消所有的关键字压缩。把此选项设置为<span>DEFAULT</span>时，存储引擎只压缩长的<span>CHAR</span>或<span>VARCHAR</span>列（仅限于<span>MyISAM</span>）。</p>
			<p>如果您不使用<span>PACK_KEYS</span>，则默认操作是只压缩字符串，但不压缩数字。如果您使用<span>PACK_KEYS=1</span>，则对数字也进行压缩。</p>
			<p>在对二进制数字关键字进行压缩时，<span>MySQL</span>采用前缀压缩：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>每个关键字需要一个额外的字节来指示前一个关键字中有多少字节与下一个关键字相同。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>指向行的指针以高位字节优先的顺序存储在关键字的后面，用于改进压缩效果。</p>
			<p>
			这意味着，如果两个连续行中有许多相同的关键字，则后续的“相同”的关键字通常只占用两个字节（包括指向行的指针）。与此相比，常规情况下，后续的关键字占用<span><span>storage_size_for_key 
			+ pointer_size</span>（指针尺寸通常为<span>4</span>）。但是，只有在许多数字相同的情况下，前缀压缩才有好处。如果所有的关键字完全不同，并且关键字不能含有<span>NULL</span>值，则每个关键字要多使用一个字节。（在这种情况中，储存压缩后的关键字的长度的字节与用于标记关键字是否为<span>NULL</span>的字节是同一字节。）</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>PASSWORD</span><span>
			</span></p>
			<p>使用密码对<span>.frm</span>文件加密。在标准<span>MySQL</span>版本中，本选项不起任何作用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			DELAY_KEY_WRITE</span><span> </span></p>
			<p>如果您想要延迟对关键字的更新，等到表关闭后再更新，则把此项设置为<span>1</span>（仅限于<span>MyISAM</span>）。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			ROW_FORMAT</span><span> </span></p>
			<p>定义各行应如何储存。当前，此选项只适用于<span>MyISAM</span>表。对于静态行或长度可变行，此选项值可以为<span>FIXED</span>或<span>DYNAMIC</span>。<strong><span>myisampack</span></strong>用于把类型设置为<span>COMPRESSED</span>。请参见<a href="storage-engines.html#myisam-table-formats" title="15.1.3. MyISAM Table Storage Formats">15.1.3节，“MyISAM表的存储格式”</a>。</p>
			<p>在默认情况下，<span>InnoDB</span>记录以压缩格式存储（<span>ROW_FORMAT=COMPACT</span>）。通过指定<span>ROW_FORMAT=REDUNDANT</span>，仍然可以申请用于较早版本的<span>MySQL</span>中的非压缩格式。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			RAID_TYPE</span><span> </span></p>
			<p>在<span>MySQL 5.0</span>中<span>,RAID</span>支持被删除了。要了解有关<span>RAID</span>的说明，请参见<span class="MsoHyperlink"><span>http://dev.mysql.com/doc/refman/4.1/en/create-table.html</span></span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>UNION</span><span>
			</span></p>
			<p>当您想要把一组相同的表当作一个表使用时，采用<span>UNION</span>。<span>UNION</span>仅适用于<span>MERGE</span>表。请参见<a href="storage-engines.html#merge-storage-engine" title="15.3. The MERGE Storage Engine">15.3节，“MERGE存储引擎”</a>。</p>
			<p>对于您映射到一个<span>MERGE</span>表上的表，您必须拥有<span>SELECT, 
			UPDATE</span>和<span>DELETE</span>权限。（注释：以前，所有被使用的表必须位于同一个数据库中，并作为<span>MERGE</span>表。这些限制不再适用。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			INSERT_METHOD</span><span> </span></p>
			<p>如果您希望在<span>MERGE</span>表中插入数据，您必须用<span>INSERT_METHOD</span>指定应插入行的表。<span>INSERT_METHOD</span>选项仅用于<span>MERGE</span>表。使用<span>FIRST</span>或<span>LAST</span>把行插入到第一个或最后一个表中；或者使用<span>NO</span>，阻止插入行。请参见<a href="storage-engines.html#merge-storage-engine" title="15.3. The MERGE Storage Engine">15.3节，“MERGE存储引擎”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DATA 
			DIRECTORY</span><span>,
			<span>INDEX DIRECTORY</span> </span></p>
			<p>通过使用<span>DATA 
			DIRECTORY=&#39;<i>directory</i>&#39;</span>或<span>INDEX 
			DIRECTORY=&#39;<i>directory</i>&#39;</span>，您可以指定<span>MyISAM</span>存储引擎放置表格数据文件和索引文件的位置。注意，目录应是通向目录的完整路径（不是相对路径）。</p>
			<p>仅当您没有使用<span>--skip-symbolic-links</span>选项时，<span>DATA 
			DIRECTORY</span><span>,
			<span>INDEX DIRECTORY</span></span>才能使用。操作系统必须有一个正在工作的、线程安全的<span>realpath()</span>调用。要了解全面信息，请参见<a href="optimization.html#symbolic-links-to-tables" title="7.6.1.2. Using Symbolic Links for Tables on Unix">7.6.1.2节，“在Unix平台上使用表的符号链接</a>”。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于用<span>CREATE TABLE</span>创建的表，可以使用<span><i><span>partition_options</span></i></span>控制分区。如果使用了<span><i><span>partition_options</span></i></span>，则其中必须包含至少一个<span>PARTITION 
			BY</span>子句。本子句包含用于确定分区的函数；该函数会返回一个整值，范围从<span>1</span>到<span><i><span>num</span></i></span>。此处<span><i><span>num</span></i></span>为分区的数目。此函数中可以使用的选项显示在下面的清单中。
			要点：在本节开始时介绍的用于<span><i><span>partition_options</span></i></span>的语法中显示的选项，并不是都能用于所有分区类型。要了解各种类型具体的信息
			，请参见以下各类型的清单。要了解有关在<span>MySQL</span>中的分区的操作和使用情况的全面说明，以及要了解表创建的示例和与<span>MySQL</span>分区有关的其它命令，请参见<a href="partitioning.html">第18章：</a><a href="partitioning.html" title="Chapter 18. Partitioning"><i>分区</i></a>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>HASH</span>（<span><i><span>expr</span></i></span>）：用于混编一个或多个列，创建一个关键字，用于放置行，并确定行的位置。<span><i><span>expr</span></i></span>是一个表达式，使用一个或多个表中的列。该表达式可以是任何能够生成单一整值的合法的<span>MySQL</span>表达式（包括<span>MySQL</span>函数）。例如，这些都是有效的<span>CREATE 
			TABLE</span>语句，语句中使用了<span>PARTITION BY HASH</span>：</p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t1 (col1 INT, col2 CHAR(5)) </span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY HASH(col1);</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t1 (col1 INT, col2 CHAR(5))</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY HASH( ORD(col2) );</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATETIME)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY HASH ( YEAR(col3) );</span></pre>
			<p><span>VALUES LESS THAN</span>或<span>VALUES 
			IN</span>子句不能和<span>PARTITION BY HASH</span>一起使用。</p>
			<p><span>PARTITION BY HASH</span>使用<span><i><span>expr</span></i></span>被分区数目所除后的余数（也就是模数）。要了解示例和其它信息，请参见<a href="partitioning.html#partitioning-hash" title="18.2.3. HASH Partitioning">18.2.3节，“HASH分区”</a>。</p>
			<p><span>LENEAR</span>关键词需要一种不同的算法。在这种情况下，通过一次或多次逻辑<span>AND</span>运算得出的结果，计算出存储记录的分区的数目。要了解线形混编的讨论和示例，请参见<a href="partitioning.html#partitioning-linear-hash" title="18.2.3.1. LINEAR HASH Partitioning">18.2.3.1节，“LINEAR 
				HASH分区”</a>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span><span>KEY(<i>column_list</i>)</span>：与<span>HASH</span>近似，除了有一点不一样，即<span>MySQL</span>提供了混编函数，以保证均匀的数据分布。<i><span>column_list</span></i>自变量只是各列的一个清单。本示例显示了由关键字进行分区的一个简单的表，分为<span>4</span>个分区：</span></p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY KEY(col3)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITIONS 4;</span></pre>
			<p>采用<span>LINEAR</span>关键词，您可以对由关键字分区的表进行线形分区。这与由<span>HASH</span>进行分区的表格有同样的效果；也就是说，使用<span>&amp;</span>操作符查找分区数目，而不是使用模数（详细说明见<a href="partitioning.html#partitioning-linear-hash" title="18.2.3.1. LINEAR HASH Partitioning">18.2.3.1节，“LINEAR 
				HASH分区”</a>和<a href="partitioning.html#partitioning-key" title="18.2.4. KEY Partitioning">18.2.4节，“KEY分区”</a>）。本示例采用了关键字线形分区，用来在<span>5</span>个分区之间分配数据：</p>
			<pre><span>CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)</span></pre>
			<pre><span> &nbsp;&nbsp;&nbsp;PARTITION BY LINEAR KEY(col3)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITIONS 5;</span></pre>
			<p><span>VALUES LESS THAN</span>或<span>VALUES 
			IN</span>子句不能和<span>PARTITION BY KEY</span>一起使用。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>RANGE</span>：在此情况下，<span><i><span>expr</span></i>使用一套<span>VALUES 
			LESS THAN</span>操作符</span>显示了某一范围内的值。当使用范围分区时，您必须使用<span>VALUES 
			LESS THAN</span>定义至少一个分区。<span>VALUES IN</span>不能和范围分区一起使用。</p>
			<p><span>VALUES LESS THAN</span>可以与一个文字值同时使用，或者与一个可以求算单一值的表达式同时使用。</p>
			<p>举例说明，假设您有一个表，您希望采用以下方法对包含年份值的一列进行分区：</p>
			<table border="1" cellpadding="0" id="table4">
				<tr>
					<td>
					<p>分区编号：</td>
					<td>
					<p>年份范围：</td>
				</tr>
				<tr>
					<td>
					<p><span>0</span></td>
					<td>
					<p><span>1990</span>以前</td>
				</tr>
				<tr>
					<td>
					<p><span>1</span></td>
					<td>
					<p><span>1991 - 1994</span></td>
				</tr>
				<tr>
					<td>
					<p><span>2</span></td>
					<td>
					<p><span>1995 - 1998</span></td>
				</tr>
				<tr>
					<td>
					<p><span>3</span></td>
					<td>
					<p><span>1999 - 2002</span></td>
				</tr>
				<tr>
					<td>
					<p><span>4</span></td>
					<td>
					<p><span>2003 - 2005</span></td>
				</tr>
				<tr>
					<td>
					<p><span>5</span></td>
					<td>
					<p><span>2006</span>年以后</td>
				</tr>
			</table>
			<p>采用这种分区方法的表可以通过如下<span>CREATE 
			TABLE</span>语句实现：</p>
			<pre><span>CREATE TABLE t1 (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; year_col INT, </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;some_data INT </span></pre>
			<pre><span>) </span></pre>
			<pre><span>PARTITION BY RANGE (year_col) (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p0 VALUES LESS THAN (1991),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p1 VALUES LESS THAN (1995),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p2 VALUES LESS THAN (1999),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p3 VALUES LESS THAN (2002),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p4 VALUES LESS THAN (2006),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p5 VALUES LESS THAN MAXVALUE</span></pre>
			<pre><span>);</span></pre>
			<p><span>
			<span>PARTITION ... VALUES LESS THAN ...</span>语句按顺序执行。<span>VALUES 
			LESS THAN MAXVALUE</span>的作用是指定大于最大值的“其余”的值。</span></p>
			<p>注意，<span>VALUES LESS THAN</span>子句按顺序执行，执行方式类似于<span><span>switch 
			... case</span>语段的一部分</span>（许多编程语言，如<span>C, Java</span>和<span>PHP</span>也如此）。也就是说，子句必须按照这样一种方法排列，每一个后续的<span>VALUES 
			LESS THAN</span>中指定的上限值大于前一个<span>VALUES LESS THAN</span>中指定的上限值，并在清单的最后加一个参照性的<span>MAXVALUE</span>。</p>
			<p><span>VALUES IN</span>与一系列的值同时使用。举例说明，您可以创建如下的分区方法：</p>
			<pre><span>CREATE TABLE client_firms (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; id INT,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; name VARCHAR(35)</span></pre>
			<pre><span>)</span></pre>
			<pre><span>PARTITION BY RANGE (id) (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)</span></pre>
			<pre><span>);</span></pre>
			<p>当前，与<span>VALUES IN...</span>同时使用的值必须只包含整数值。</p>
			<p>（因为此表只使用<span>VALUES IN</span>表达式进行分区，您也可以用<span>PARTITION 
			BY LIST</span>代替，而不是使用<span>PARTITION BY RANGE</span>。请参见下一条。）</p>
			<p>在使用<span>VALUES LESS THAN</span>或<span>VALUES 
			IN</span>情况下，每个分区使用<span>PARTITION
			<span><i>name</i></span></span>定义，此处<span><i><span>name</span></i></span>是分区的标识名，后面接<span>VALUES...</span>子句。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span><span>LIST(<i>expr</i>)</span>：当根据含有一系列限定性值（例如州代码或国家代码）的列进行分区时使用。在这种情况下，所有与特定的州或国家有关的记录都被分配到一个单一分区中，或者可以预留出一个分区，用于一系列特定的州或国家。<span>LIST(<i>expr</i>)</span>与<span>RANGE</span>类似，除了一点以外，即只有<span>VALUES 
			IN</span>可以被用于为每个分区指定值。</span></p>
			<p>当使用清单分区时，您必须使用<span>VALUES 
			IN</span>定义至少一个分区。<span>VALUES LESS THAN</span>不能与<span>PARTITION 
			BY LIST</span>一起使用。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>分区数目可以使用<span>PARTITION
			<span><i>num</i></span></span>子句，自选进行指定，此处，<span><i><span>num</span></i></span>是分区的数目。如果本子句和其它<span>PARTITION</span>子句同时使用，则<span><i><span>num</span></i></span>必须与使用<span>PARTITION</span>子句说明的分区的总数相等。</p>
			<p>注释：不论您在创建一个由<span>RANGE</span>或<span>LIST</span>进行分区的表时是否使用了<span>PARTITIONS</span>子句，您必须在表定义中包括至少一个<span>PARTITION 
			VALUES</span>（见后）。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>一个分区可以自选分隔成多个子分区。使用自选的<span>SUBPARTITION BY</span>子句可以指示。子分区可以由<span>HASH</span>或<span>KEY</span>进行分隔。两种方法建立的子分区均为<span>LINEAR</span>。分隔子分区时的操作方式与以前描述的分区类型的操作方式一样。（无法由<span>LIST</span>或<span>RANGE</span>进行子分区分隔。）</p>
			<p>使用<span>SUBPARTITIONS</span>关键词，后面接一个整值，可以对子分区的数目进行指示。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用一个<span><i><span>partition_definition</span></i></span>子句可以对每个分区分别进行定义。下面是组成这个子句的各个部分：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>PARTITION <i>
			partition_name</i></span>：用于为分区指定一个逻辑名称。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>VALUE</span>子句：对于范围分区，每个分区必须包括一个<span>VALUES 
			LESS THAN</span>子句；对于清单分区，您必须为每个分区指定一个<span>VALUES IN</span>子句。本子句用于确定哪些行将被存储到此分区中。要了解语法示例，请参见<a href="partitioning.html">第18章：</a><a href="partitioning.html" title="Chapter 18. Partitioning"><i>分区</i></a>中对分区类型的讨论。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>自选的<span>COMMENT</span>子句可以用于描述分区。注释必须加单引号。举例说明：</p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>COMMENT = &#39;Data for the years previous to 1999&#39;</span></pre>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>DATA DIRECTORY</span>和<span>INDEX 
			DIRECTORY</span>可以被用于指示本分区的数据和索引各自的存储位置的目录。<span><i><span>data_dir</span></i></span>和<span><i><span>index_dir</span></i></span>都必须是绝对系统路径。例如：</p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>PARTITION BY LIST(YEAR(adate))</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p1999 VALUES IN (1995, 1999, 2003) DATA DIRECTORY = &#39;<span>/var/appdata/95/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/95/idx</span>&#39;,</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p2000 VALUES IN (1996, 2000, 2004) DATA DIRECTORY = &#39;<span>/var/appdata/96/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/96/idx</span>&#39;,</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p2001 VALUES IN (1997, 2001, 2005) DATA DIRECTORY = &#39;<span>/var/appdata/97/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/97/idx</span>&#39;,</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p2000 VALUES IN (1998, 2002, 2006) DATA DIRECTORY = &#39;<span>/var/appdata/98/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/98/idx</span>&#39;</span></pre>
			<pre><span>);</span></pre>
			<p><span>DATA DIRECTORY</span>和<span>INDEX 
			DIRECTORY</span>的操作方法与<span>CREATE TABLE</span>语句中的<span><i><span>table_option</span></i></span>子句的操作方法一样。此<span><i><span>table_option</span></i></span>子句用于位于<span>MyISAM</span>表管理程序下的各表。</p>
			<p>
			可以为每个分区指定一个数据目录和一个索引目录。如果不指定，则数据和索引被存储在默认的<span>MySQL</span>数据目录中。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>MAX_ROWS</span>和<span>MIN_ROWS</span>分别用于将被存储在分区中的行数目最大值和行数目最小值。<span><i><span>max_number_of_rows</span></i></span>和<span><i><span>min_number_of_rows</span></i>的值</span>必须为正整数。和具有同样名称的桌面选项一样，<span><i><span>max_number_of_rows</span></i></span>和<span><i><span>min_number_of_rows</span></i></span>只作为对服务器的“建议”值，并不是硬性限值。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>自选的<span>TABLESPACE</span>子句可以用于为分区指定一个桌面空间。仅用于<span>MySQL 
			Cluster</span>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>自选的<span>[STORAGE] ENGINE</span>子句可以把本分区中表的类型改为指定的类型。表的类型可以是本<span>MySQL</span>服务器支持的所有类型。<span>STORAGE</span>关键字和等号<span>(=)</span>均为自选项。如果没有使用此选项设置分区存储引擎，则适用于整个表的引擎可以用于此分区。</p>
			<p>注释：分区管理程序对于<span>PARTITION</span>和<span>SUBPARTITION</span>均接受<span>[STORAGE] 
			ENGINE</span>选项。目前，此子句的使用方式仅限于对所有的分区或子分区设置同一个存储引擎，如果试图在同一个表内对不同的分区或子分区设置不同的存储引擎，则会出现错误<span>ERROR 
			1469 (HY000)</span>：在本版本的<span>MySQL</span>中，不允许在各分区中混用管理程序。我们打算在将来的<span>MySQL 
			5.1</span>版本中加入这种对分区的限定。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>NODEGROUP</span>选项可以用于使本分区可以作为节点组的一部分，节点组使用<span><i><span>node_group_id</span></i></span>识别。本选项仅适用于<span>MySQL 
			Cluster</span>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>分区定义可以自选地包含一个或多个<span><i><span>subpartition_definition</span></i></span>子句。每个这种子句至少包括<span>SUBPARTITION
			<i>name</i></span>，此处，<span><i><span>name</span></i></span>是子分区的识别名称。除了用<span>SUBPARTITION</span>代替<span>PARTITION</span>关键词外，用于子分区定义的语法与用于分区定义的语法一样。</p>
			<p>子分区必须由<span>HASH</span>或<span>KEY</span>完成，并且只能对<span>RANGE</span>或<span>LIST</span>分区进行子分区。请参见<a href="partitioning.html#partitioning-subpartitions" title="18.2.5. Subpartitioning">18.2.5节，“子分区”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>分区可以修改、合并、添加到表中，或从表中删去。要了解有关完成这些任务的<span>MySQL</span>命令的基本说明，请参见<a href="sql-syntax.html#alter-table" title="13.1.2. ALTER TABLE Syntax">13.1.2节，“ALTER 
			TABLE语法”</a>。要了解详细的说明和示例，请参见<a href="partitioning.html#partitioning-management" title="18.3. Partition Management">18.3节，“分区管理”</a>。</p>
			<p>您可以在<span>CREATE TABLE</span>语句的末尾添加一个<span>SELECT</span>语句，在一个表的基础上创建表。</p>
			<pre><span>CREATE TABLE <span><i>new_tbl</i></span> SELECT * FROM <span><i>orig_tbl</i></span>;</span></pre>
			<p><span>MySQL</span>会对<span>SELECT</span>中的所有项创建新列。举例说明：</p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE test (a INT NOT NULL AUTO_INCREMENT,</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>PRIMARY KEY (a), KEY(b))</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>TYPE=MyISAM SELECT b,c FROM test2;</b></span></span></pre>
			<p>本语句用于创建含三个列（<span>a, b, c</span>）的<span>MyISAM</span>表。注意，用<span>SELECT</span>语句创建的列附在表的右侧，而不是覆盖在表上。参考以下示例：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM foo;</b></span></span></pre>
			<pre><span>+---+</span></pre>
			<pre><span>| n |</span></pre>
			<pre><span>+---+</span></pre>
			<pre><span>| 1 |</span></pre>
			<pre><span>+---+</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>CREATE TABLE bar (m INT) SELECT n FROM foo;</b></span></span></pre>
			<pre><span>Query OK, 1 row affected (0.02 sec)</span></pre>
			<pre><span>Records: 1&nbsp; Duplicates: 0&nbsp; Warnings: 0</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>SELECT * FROM bar;</b></span></span></pre>
			<pre><span>+------+---+</span></pre>
			<pre><span>| m&nbsp;&nbsp;&nbsp; | n |</span></pre>
			<pre><span>+------+---+</span></pre>
			<pre><span>| NULL | 1 |</span></pre>
			<pre><span>+------+---+</span></pre>
			<pre><span>1 row in set (0.00 sec)</span></pre>
			<p>对应于表<span>foo</span>中的每一行，在表<span>bar</span>中插入一行，含有表<span>foo</span>中的值以及新列中的默认值。</p>
			<p>在由<span>CREATE TABLE...SELECT</span>生成的表中，只在<span>CREATE 
			TABLE</span>部分中命名的列首先出现。在两个部分中都命名的列和只在<span>SELECT</span>部分中命名的列随后出现。也可以通过指定<span>CREATE 
			TABLE</span>部分中的列覆盖<span>SELECT</span>列中的数据类型。</p>
			<p>如果在把数据复制到表中时出现错误，则表会自动被取消，不会被创建。</p>
			<p><span>CREATE TABLE...SELECT</span>不会自动创建任何索引。索引需要专门创建，以便使语句的灵活性更强。如果您希望为已创建的表建立索引，您应在<span>SELECT</span>语句前指定索引。</p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE bar (UNIQUE (n)) SELECT n FROM foo;</b></span></span></pre>
			<p>列的类型会发生部分转化。例如，<span>AUTO_INCREAMENT</span>属性不会被保留，<span>VARCHAR</span>列会变成<span>CHAR</span>列。</p>
			<p>当使用<span>CREATE...SELECT</span>创建表时，在查询时一定要对功能调用和表达式起别名。如果不起别名，则<span>CREATE</span>语句会出现错误或者生成不符合需要的列名称。</p>
			<pre><span>CREATE TABLE artists_and_works</span></pre>
			<pre><span>SELECT artist.name, COUNT(work.artist_id) AS number_of_works</span></pre>
			<pre><span>FROM artist LEFT JOIN work ON artist.id = work.artist_id</span></pre>
			<pre><span>GROUP BY artist.id;</span></pre>
			<p>您也可以明确地为一个已生成的列指定类型：</p>
			<pre><span>CREATE TABLE foo (a TINYINT NOT NULL) SELECT b+1 AS a FROM bar;</span></pre>
			<p>根据其它表的定义（包括在原表中定义的所有的列属性和索引），使用<span>LIKE</span>创建一个空表<span>:</span></p>
			<pre><span>CREATE TABLE <span><i>new_tbl</i></span> LIKE <span><i>orig_tbl</i></span>;</span></pre>
			<p><span>CREATE TABLE...LIKE</span>不会复制对原表或外键定义指定的<span>DATA 
			DIRECTORY</span>或<span>INDEX DIRECTORY</span>表选项。</p>
			<p>您可以在<span>SELECT</span>前增加<span>IGNORE</span>或<span>REPLACE</span>，指示如何对复制唯一关键字值的记录进行操纵。使用<span>IGNORE</span>后，如果新记录复制了原有的唯一关键字值的记录，则新记录被丢弃。使用<span>REPLACE</span>后，新记录替换具有相同的唯一关键字值的记录。如果没有指定<span>IGNORE</span>或<span>REPLACE</span>，则出现多重唯一关键字值时会导致发生错误。</p>
			<p>为了确保更新日志<span>/</span>二进位日志可以被用于再次创建原表，<span>MySQL</span>不允许在<span>CREATE 
			TABLE...SELECT</span>过程中进行联合插入。</p>
			<div class="section">
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="silent-column-changes"></a>
				13.1.5.1.&nbsp;沉寂的列规格变更</h4></div></div></div><a class="indexterm" name="id2897793"></a>
				<p>在有些情况下，较早版本的<span>MySQL</span>会静默地更改在<span>CREATE 
				TABLE</span>或<span>ALTER TABLE</span>语句中给定的列规约。在<span>MySQL 
				5.1</span>中不会进行这类变更。如果使用指定的数据类型无法创建列，则会出现错误。</p>
				<div>
					<div>
						<h3 class="title"><a name="drop-database"></a>13.1.6. DROP 
			DATABASE语法</h3></div></div></div>
			<a class="indexterm" name="id2897830"></a>
			<a class="indexterm" name="id2897840"></a>
			<a class="indexterm" name="id2897848"></a>
			<a class="indexterm" name="id2897859"></a>
			<a class="indexterm" name="id2897869"></a>
			<a class="indexterm" name="id2897879"></a>
			<pre><span>DROP {DATABASE | SCHEMA} [IF EXISTS] <span><i>db_name</i></span></span></pre>
			<p><span>DROP DATABASE</span>用于取消数据库中的所用表格和取消数据库。使用此语句时要非常小心！如果要使用<span>DROP 
			DATABASE</span>，您需要获得数据库<span>DROP</span>权限。</p>
			<p><span>IF EXISTS</span>用于防止当数据库不存在时发生错误。</p>
			<p>也可以使用<span>DROP SCHEMA</span>。</p>
			<p>如果您对一个带有符号链接的数据库使用<span>DROP DATABASE</span>，则链接和原数据库都被取消。</p>
			<p><span>DROP DATABASE</span>会返回已被取消的表的数目。此数目相当于被取消的<span>.frm</span>文件的数目。</p>
			<p>在正常操作中<span>MySQL</span>自身会创建出一些文件和目录。<span>DROP 
			DATABASE</span>语句会从给定的数据库目录中取消这些文件和目录：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有带这些扩展名的文件：</p>
			<table border="1" cellpadding="0" id="table5">
				<tr>
					<td>
					<p>
					<span>.BAK</span></td>
					<td>
					<p>
					<span>.DAT</span></td>
					<td>
					<p>
					<span>.HSH</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>.MRG</span></td>
					<td>
					<p>
					<span>.MYD</span></td>
					<td>
					<p>
					<span>.ISD</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>.MYI</span></td>
					<td>
					<p>
					<span>.db</span></td>
					<td>
					<p>
					<span>.frm</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
			</table>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>名称中包含两位<span>16</span>进制数<span>00-ff</span>的所有子目录。这些子目录用于<span>RAID</span>表。（当对<span>RAID</span>表的支持被取消时，在<span>MySQL 
			5.0</span>中，这些目录不会被取消。您应该在升级到<span>MySQL 5.0</span>或更新的版本前转化原有的<span>RAID</span>表，并人工取消这些目录。请参见<span>MySQL 
			5.0</span>参考手册中有关从较早版本升级到<span>MySQL 5.0</span>的章节。<span>MySQL 
			5.0</span>参考手册可以从<span>MySQL</span>网站中获取。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>db.opt</span>文件</p>
			<p>如果在<span>MySQL</span>取消了上述这些文件之后，在数据库目录中仍保留有其它文件和目录，则数据库目录不能被取消。在这种情况下，您必须人工取消所有保留下的文件或目录，并再次发送<span>DROP 
			DATABASE</span>语句。</p>
			<p>您还可以使用<strong><span>mysqladmin</span></strong>来取消文件。请参见<a href="client-side-scripts.html#mysqladmin" title="8.5. mysqladmin — Client for Administering a MySQL Server">8.5节，“mysqladmin：用于管理MySQL服务器的客户端”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-index"></a>13.1.7. DROP 
			INDEX语法</h3></div></div></div><a class="indexterm" name="id2898172"></a><a class="indexterm" name="id2898181"></a><a class="indexterm" name="id2898191"></a>
			<pre><span>DROP INDEX <span><i>index_name</i></span> ON <span><i>tbl_name</i></span></span></pre>
			<p><span>DROP INDEX</span>用于从表<span><i><span>tbl_name</span></i></span>中取消名称为<span><i><span>index_name</span></i></span>的索引。本语句被映射到一个<span>ALTER 
			TABLE</span>语句中，用于取消索引。请参见<a href="sql-syntax.html#alter-table" title="13.1.2. ALTER TABLE Syntax">13.1.2节，“ALTER 
		TABLE语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-table"></a>13.1.8. DROP 
			TABLE语法</h3></div></div></div><a class="indexterm" name="id2898277"></a><a class="indexterm" name="id2898286"></a><a class="indexterm" name="id2898296"></a>
			<pre><span>DROP [TEMPORARY] TABLE [IF EXISTS]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [RESTRICT | CASCADE]</span></pre>
			<p><span>DROP TABLE</span>用于取消一个或多个表。您必须有每个表的<span>DROP</span>权限。所有的表数据和表定义会被取消，所以使用本语句要小心！</p>
			<p>注意，对于一个带分区的表，<span>DROP TABLE</span>会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。<span>DROP 
			TABLE</span>还会取消与被取消的表有关联的分区定义（<span>.par</span>）文件。</p>
			<p>对与不存在的表，使用<span>IF EXISTS</span>用于防止错误发生。当使用<span>IF 
			EXISTS</span>时，对于每个不存在的表，会生成一个<span>NOTE</span>。请参见<a href="sql-syntax.html#show-warnings" title="13.5.4.22. SHOW WARNINGS Syntax">13.5.4.22节，“SHOW 
		WARNINGS语法”</a>。</p>
			<p><span>RESTRICT</span>和<span>CASCADE</span>可以使分区更容易。目前，<span>RESTRICT</span>和<span>CASCADE</span>不起作用。</p>
			<p>注释：除非您使用<span>TEMPORARY</span>关键词，<span>DROP 
			TABLE</span>会自动提交当前的有效的事务。</p>
			<p><span>TEMPORARY</span>关键词具有以下作用：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>语句只取消<span>TEMPORARY</span>表。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>语句不会终止正在进行中的事务。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不会查验存取权。（<span>TEMPORARY</span>表仅对于创建该表的客户端是可见的，所以查验是不必要的。）</p>
			<p>使用<span>TEMPORARY</span>是确保您不会意外取消一个非<span>TEMPORARY</span>表的良好方法。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="rename-table"></a>13.1.9. RENAME 
			TABLE语法</h3></div></div></div><a class="indexterm" name="id2898503"></a></div></div><div class="section"><div class="titlepage"><div><div>
		<pre><span>RENAME TABLE <span><i>tbl_name</i></span> TO <span><i>new_tbl_name</i></span></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; [, <span><i>tbl_name2</i></span> TO <span><i>new_tbl_name2</i></span>] ...</span></pre>
		<p>本语句用于对一个或多个表进行重命名。</p>
		<p>重命名操作自动进行，这意味着当重命名正在运行时，其它线程不能读取任何表。例如，如果您有一个原有的表<span>old_table</span>，您可以创建另一个具有相同结构的空表<span>new_table</span>，然后用此空表替换原有的表：</p>
		<pre><span>CREATE TABLE <span><i>new_table</i></span> (...);</span></pre>
		<pre><span>RENAME TABLE <span><i>old_table</i></span> TO <span><i>backup_table</i></span>, <span><i>new_table</i></span> TO <span><i>old_table</i></span>;</span></pre>
		<p>如果此语句用于对多个表进行重命名，则重命名操作从左至右进行。如果您想要交换两个表的名称，您可以这样做（假设不存在名称为<span>tmp_table</span>的表）：</p>
		<pre><span>RENAME TABLE <span><i>old_table</i></span> TO <span><i>tmp_table</i></span>,</span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><i>new_table</i></span> TO <span><i>old_table</i></span>,</span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><i>tmp_table</i></span> TO <span><i>new_table</i></span>;</span></pre>
		<p>只要两个数据库位于同一文件系统中，您还可以对表进行重命名，把表从一个数据库中移动到另一个数据库中：</p>
		<pre><span>RENAME TABLE <span><i>current_db.tbl_name</i></span> TO <span><i>other_db.tbl_name;</i></span></span></pre>
		<p>当您执行<span>RENAME</span>时，您不能有被锁定的表，也不能有处于活性状态的事务。您还必须拥有原表的<span>ALTER</span>和<span>DROP</span>权限，以及新表的<span>CREATE</span>和<span>INSERT</span>权限。</p>
		<p>如果<span>MySQL</span>对多个表进行重命名时遇到了错误，<span>MySQL</span>会对所有已被重命名的表进行反向重命名，返回到原来的状态。</p>
		<p>只要您不尝试通过重命名把视图加入另一个数据库中，则<span>RENAME TABLE</span>也可以用于视图。</p>
		<h2 class="title"><a name="data-manipulation"></a>
		13.2.&nbsp;数据操作语句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#delete">13.2.1. 
			DELETE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#do">13.2.2. 
			DO语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler">13.2.3. 
			HANDLER语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert">13.2.4. 
			INSERT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data">13.2.5. 
			LOAD DATA INFILE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replace">13.2.6. 
			REPLACE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#select">13.2.7. 
			SELECT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subqueries">
			13.2.8. Subquery语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#truncate">13.2.9. 
			TRUNCATE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#update">13.2.10. 
			UPDATE语法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delete"></a>13.2.1. DELETE语法</h3></div></div></div><a class="indexterm" name="id2898726"></a>
			<p>单表语法：</p>
			<pre><span>DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ORDER BY ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LIMIT <span><i>row_count</i></span>]</span></pre>
			<p>多表语法：</p>
			<pre><span>DELETE [LOW_PRIORITY] [QUICK] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>tbl_name</i></span>[.*] [, <span><i>tbl_name</i></span>[.*] ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FROM <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<p>或：</p>
			<pre><span>DELETE [LOW_PRIORITY] [QUICK] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FROM <span><i>tbl_name</i></span>[.*] [, <span><i>tbl_name</i></span>[.*] ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; USING <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<p><span><i><span>tbl_name</span></i></span>中有些行满足由<span><i><span>where_definition</span></i></span>给定的条件。<span>DELETE</span>用于删除这些行，并返回被删除的记录的数目。</p>
			<p>如果您编写的<span>DELETE</span>语句中没有<span>WHERE</span>子句，则所有的行都被删除。当您不想知道被删除的行的数目时，有一个更快的方法，即使用<span>TRUNCATE 
			TABLE</span>。请参见<a href="sql-syntax.html#truncate" title="13.2.9. TRUNCATE Syntax">13.2.9节，“TRUNCATE语法”</a>。</p>
			<p>如果您删除的行中包括用于<span>AUTO_INCREMENT</span>列的最大值，则该值被重新用于<span>BDB</span>表，但是不会被用于<span>MyISAM</span>表或<span>InnoDB</span>表。如果您在<span>AUTOCOMMIT</span>模式下使用<span>DELETE 
			FROM <span><i>tbl_name</i></span></span>（不含<span>WHERE</span>子句）删除表中的所有行，则对于所有的表类型（除<span>InnoDB</span>和<span>MyISAM</span>外），序列重新编排。对于<span>InnoDB</span>表，此项操作有一些例外，在<a href="storage-engines.html#innodb-auto-increment-column" title="15.2.6.3. How an AUTO_INCREMENT Column Works in InnoDB">15.2.6.3节，“AUTO_INCREMENT列如何在InnoDB中运行”</a>中进行了讨论。</p>
			<p>对于<span>MyISAM</span>和<span>BDB</span>表，您可以把<span>AUTO_INCREMENT</span>次级列指定到一个多列关键字中。在这种情况下，从序列的顶端被删除的值被再次使用，甚至对于<span>MyISAM</span>表也如此。请参见<a href="tutorial.html#example-auto-increment" title="3.6.9. Using AUTO_INCREMENT">3.6.9节，“使用AUTO_INCREMENT”</a>。</p>
			<p><span>DELETE</span>语句支持以下修饰符：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您指定<span>LOW_PRIORITY</span>，则<span>DELETE</span>的执行被延迟，直到没有其它客户端读取本表时再执行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于<span>MyISAM</span>表，如果您使用<span>QUICK</span>关键词，则在删除过程中，存储引擎不会合并索引端结点，这样可以加快部分种类的删除操作的速度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在删除行的过程中，<span>IGNORE</span>关键词会使<span>MySQL</span>忽略所有的错误。（在分析阶段遇到的错误会以常规方式处理。）由于使用本选项而被忽略的错误会作为警告返回。</p>
			<p>删除操作的速度会受到一些因素的影响，这些因素在<a href="optimization.html#delete-speed" title="7.2.18. Speed of DELETE Statements">7.2.18节，“DELETE语句的速度”</a>中进行了讨论。 </p>
			<p>在<span>MyISAM</span>表中，被删除的记录被保留在一个带链接的清单中，后续的<span>INSERT</span>操作会重新使用旧的记录位置。要重新使用未使用的空间并减小文件的尺寸，则使用<span>OPTIMIZE 
			TABLE</span>语句或<strong><span>myisamchk</span></strong>应用程序重新编排表。<span>OPTIMIZE 
			TABLE</span>更简便，但是<strong><span>myisamchk</span></strong>速度更快。请参见<a href="sql-syntax.html#optimize-table" title="13.5.2.5. OPTIMIZE TABLE Syntax">13.5.2.5节，“OPTIMIZE 
		TABLE语法”</a>和<a href="optimization.html">第7章：</a><a href="optimization.html" title="Chapter 7. Optimization"><i>优化</i></a>。</p>
			<p><span>QUICK</span>修饰符会影响到在删除操作中索引端结点是否合并。当用于被删除的行的索引值被来自后插入的行的相近的索引值代替时，<span>DELETE 
			QUICK</span>最为适用。在此情况下，被删除的值留下来的空穴被重新使用。</p>
			<p>未充满的索引块跨越某一个范围的索引值，会再次发生新的插入。当被删除的值导致出现未充满的索引块时，<span>DELETE 
			QUICK</span>没有作用。在此情况下，使用<span>QUICK</span>会导致未利用的索引中出现废弃空间。下面是此种情况的举例说明：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>创建一个表，表中包含已编索引的<span>AUTO_INCREMENT</span>列。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>在表中插入很多记录。每次插入会产生一个索引值，此索引值被添加到索引的高端处。</p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>DELETE QUICK</span>从列的低端处删除一组记录。</p>
			<p>在此情况下，与被删除的索引值相关的索引块变成未充满的状态，但是，由于使用了<span>QUICK</span>，这些索引块不会与其它索引块合并。当插入新值时，这些索引块仍为未充满的状态，原因是新记录不含有在被删除的范围内的索引值。另外，即使您此后使用<span>DELETE</span>时不包含<span>QUICK</span>，这些索引块也仍是未充满的，除非被删除的索引值中有一部分碰巧位于这些未充满的块的之中，或与这些块相邻。在这些情况下，如果要重新利用未使用的索引空间，需使用<span>OPTIMIZE 
			TABLE</span>。</p>
			<p>如果您打算从一个表中删除许多行，使用<span>DELETE QUICK</span>再加上<span>OPTIMIZE 
			TABLE</span>可以加快速度。这样做可以重新建立索引，而不是进行大量的索引块合并操作。</p>
			<p>用于<span>DELETE</span>的<span>MySQL</span>唯一的<span>LIMIT<span>
			<i>row_count</i></span></span>选项用于告知服务器在控制命令被返回到客户端前被删除的行的最大值。本选项用于确保一个<span>DELETE</span>语句不会占用过多的时间。您可以只重复<span>DELETE</span>语句，直到相关行的数目少于<span>LIMIT</span>值为止。</p>
			<p>如果<span>DELETE</span>语句包括一个<span>ORDER BY</span>子句，则各行按照子句中指定的顺序进行删除。此子句只在与<span>LIMIT</span>联用是才起作用。例如，以下子句用于查找与<span>WHERE</span>子句对应的行，使用<span>timestamp_column</span>进行分类，并删除第一（最旧的）行：</p>
			<pre><span>DELETE FROM somelog</span></pre>
			<pre><span>WHERE user = &#39;jcole&#39;</span></pre>
			<pre><span>ORDER BY timestamp_column</span></pre>
			<pre><span>LIMIT 1;</span></pre>
			<p>您可以在一个<span>DELETE</span>语句中指定多个表，根据多个表中的特定条件，从一个表或多个表中删除行。不过，您不能在一个多表<span>DELETE</span>语句中使用<span>ORDER 
			BY</span>或<span>LIMIT</span>。</p>
			<p><span><i><span>table_references</span></i></span>部分列出了包含在联合中的表。此语法在<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>中进行了说明。</p>
			<p>对于第一个语法，只删除列于<span>FROM</span>子句之前的表中的对应的行。对于第二个语法，只删除列于<span>FROM</span>子句之中（在<span>USING</span>子句之前）的表中的对应的行。作用是，您可以同时删除许多个表中的行，并使用其它的表进行搜索：</p>
			<pre><span>DELETE t1, t2 FROM t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;</span></pre>
			<p>或：</p>
			<pre><span>DELETE FROM t1, t2 USING t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;</span></pre>
			<p>当搜索待删除的行时，这些语句使用所有三个表，但是只从表<span>t1</span>和表<span>t2</span>中删除对应的行。</p>
			<p>以上例子显示了使用逗号操作符的内部联合，但是多表<span>DELETE</span>语句可以使用<span>SELECT</span>语句中允许的所有类型的联合，比如<span>LEFT 
			JOIN</span>。</p>
			<p>本语法允许在名称后面加<span>.*</span>，以便与<span>Access</span>相容。</p>
			<p>如果您使用的多表<span>DELETE</span>语句包括<span>InnoDB</span>表，并且这些表受外键的限制，则<span>MySQL</span>优化程序会对表进行处理，改变原来的从属关系。在这种情况下，该语句出现错误并返回到前面的步骤。要避免此错误，您应该从单一表中删除，并依靠<span>InnoDB</span>提供的<span>ON 
			DELETE</span>功能，对其它表进行相应的修改。</p>
			<p>注释：当引用表名称时，您必须使用别名（如果已给定）：</p>
			<pre><span>DELETE t1 FROM test AS t1, test2 WHERE ...</span></pre>
			<p>进行多表删除时支持跨数据库删除，但是在此情况下，您在引用表时不能使用别名。举例说明：</p>
			<pre><span>DELETE test1.tmp1, test2.tmp2 FROM test1.tmp1, test2.tmp2 WHERE ...</span></pre>
			<p>目前，您不能从一个表中删除，同时又在子查询中从同一个表中选择。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="do"></a>13.2.2. DO语法</h3></div></div></div><a class="indexterm" name="id2899415"></a><pre class="programlisting">DO <em class="replaceable">expr</em> [, <em class="replaceable">expr</em>] ...
</pre></div><div class="section"><div class="titlepage"><div><div>
			<span>DO</span>用于执行表达式，但是不返回任何结果。<span>DO</span>是<span>SELECT<span>
			<i>expr</i></span></span><span>的简化表达方式</span>。<span>DO</span>有一个优势，就是如果您不太关心结果的话，<span>DO</span>的速度稍快。<p>
			<span>DO</span>主要用于执行有副作用的函数，比如<span>RELEASE_LOCK()</span>。</p>
			<h3 class="title"><a name="handler"></a>13.2.3. HANDLER语法</h3></div></div></div><a class="indexterm" name="id2899497"></a><pre class="programlisting">HANDLER <em class="replaceable">tbl_name</em> OPEN [ AS <em class="replaceable">alias</em> ]
HANDLER <em class="replaceable">tbl_name</em> READ <em class="replaceable">index_name</em> { = | &gt;= | &lt;= | &lt; } (<em class="replaceable">value1</em>,<em class="replaceable">value2</em>,...)
    [ WHERE <em class="replaceable">where_condition</em> ] [LIMIT ... ]
HANDLER <em class="replaceable">tbl_name</em> READ <em class="replaceable">index_name</em> { FIRST | NEXT | PREV | LAST }
    [ WHERE <em class="replaceable">where_condition</em> ] [LIMIT ... ]
HANDLER <em class="replaceable">tbl_name</em> READ { FIRST | NEXT }
    [ WHERE <em class="replaceable">where_condition</em> ] [LIMIT ... ]
HANDLER <em class="replaceable">tbl_name</em> CLOSE
</pre>
			<p><span>HANDLER</span>语句提供通往表存储引擎接口的直接通道。<span>HANDLER</span>可以用于<span>MyISAM</span>和<span>InnoDB</span>表。</p>
			<p><span>HANDLER...OPEN</span>语句用于打开一个表，通过后续的<span>HANDLER...READ</span>语句建立读取表的通道。本表目标不会被其它线程共享，也不会关闭，直到线程调用<span>HANDLER...CLOSE</span>或线程中止时为止。如果您使用一个别名打开表，则使用其它<span>HANDLER</span>语句进一步参阅表是必须使用此别名，而不能使用表名。</p>
			<p>如果被指定的索引满足给定的值并且符合了<span>WHERE</span>条件，则第一个<span>HANDLER...READ</span>语法取出一行。如果您有一个多列索引，则指定索引列值为一个用逗号隔开的清单。既可以为索引中的所有列指定值，也可以为索引列的最左边的前缀指定值。假设一个索引包括三个列，名称为<span>col_a</span><span>,
			<span>col_b</span>,</span>和<span>col_c</span>，并按此顺序排列。<span>HANDLER</span>语句可以为索引中的所有三个列指定值，或者为一个最左边前缀中的各列指定值。举例说明：</p>
			<pre><span>HANDLER ... <span><i>index_name</i></span> = (col_a_val,col_b_val,col_c_val) ...</span></pre>
			<pre><span>HANDLER ... <span><i>index_name</i></span> = (col_a_val,col_b_val) ...</span></pre>
			<pre><span>HANDLER ... <span><i>index_name</i></span> = (col_a_val) ...</span></pre>
			<p>第二个<span>HANDLER...READ</span>语法按索引的顺序从表中取出一行。索引的顺序符合<span>WHERE</span>条件。</p>
			<p>第三个<span>HANDLER...READ</span>语法按自然行的顺序从表中取出一行。自然行的顺序符合<span>WHERE</span>条件。当想要对整个表进行扫描时，此语句比<span>HANDLER
			<i>tbl_name</i> READ index_name</span>更快。自然行的顺序指的是行存储在<span>MyISAM</span>表数据文件的顺序。本语句也适用于<span>InnoDB</span>表，但是因为没有独立的数据文件，所以没有这类概念。</p>
			<p>不使用<span>LIMIT</span>子句时，所有形式的<span>HANDLER...READ</span>语句均只取出一行。 
			如果要返回多个行，应加入一个<span>LIMIT</span>子句。本语句于<span>SELECT</span>语句的语法一样。请参见<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。</p>
			<p><span>HANDLER...CLOSE</span>用于关闭使用<span>HANDLER...OPEN</span>打开的表。</p>
			<p>注释：要使用<span>HANDLER</span>接口来查阅一个表的<span>PRIMARY 
			KEY</span>，应使用带引号的识别符<span>`PRIMARY`</span>：</p>
			<pre><span>HANDLER <span><i>tbl_name</i></span> READ `PRIMARY` &gt; (...);</span></pre>
			<p><span>HANDLER</span>是比较低级别的语句。例如，它不能提供一致性。也就是说，<span>HANDLER...OPEN</span>不能为表做快照，也不能锁定表。这意味着，当一个<span>HANDLER...OPEN</span>语句被编写后，表数据可以被更改（用此线程或用其它线程），并且这些更改只会部分地出现在<span>HANDLER...NEXT</span>或<span>HANDLER...PREV</span>扫描中。</p>
			<p>使用<span>HANDLER</span>接口代替常规的<span>SELECT</span>语句有多个原因：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HANDLER</span>比<span>SELECT</span>更快：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>一个指定的存储引擎管理程序目标为了<span>HANDLER...OPEN</span>进行整序。该目标被重新用于该表的后续的<span>HANDLER</span>语句；不需要对每个语句进行重新初始化。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>涉及的分析较少。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>没有优化程序或查询校验开销。 </p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>在两个管理程序请求之间，不需要锁定表。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>管理程序接口不需要提供外观一致的数据（例如，允许无条理的读取），所以存储引擎可以使用优化，而<span>SELECT</span>通常不允许使用优化。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>有些应用程序使用与<span>ISAM</span>近似的接口与<span>MySQL</span>连接。使用<span>HANDLER</span>可以更容易地与这些应用程序连接。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HANDLER</span>允许您采用一种特殊的方式进出数据库。而使用<span>SELECT</span>时难以采用（或不可能采用）这种方式。有些应用程序可以提供一个交互式的用户接口与数据库连接。当与这些应用程序同时使用时，用<span>HANDLER</span>接口观看数据更加自然。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="insert"></a>13.2.4. INSERT语法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#insert-select">13.2.4.1. 
			INSERT ... SELECT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert-delayed">13.2.4.2. 
			INSERT DELAYED语法</a></span></dt></dl></div><a class="indexterm" name="id2899968"></a><a class="indexterm" name="id2899975"></a>
			<pre><span>INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; VALUES ({<span><i>expr</i></span> | DEFAULT},...),(...),...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
			<p>或：</p>
			<pre><span>INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name</i></span>={<span><i>expr</i></span> | DEFAULT}, ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
			<p>或：</p>
			<pre><span>INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SELECT ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
			<p><span>INSERT</span>用于向一个已有的表中插入新行。<span>INSERT...VALUES</span>和<span>INSERT...SET</span>形式的语句根据明确指定的值插入行。<span>INSERT...SELECT</span>形式的语句插入从其它表中选出的行。在<a href="sql-syntax.html#insert-select" title="13.2.4.1. INSERT ... SELECT Syntax">13.2.4.1节，“INSERT 
		... SELECT语法”</a>中对<span>INSERT...SELECT</span>进行了进一步的讨论。</p>
			<p>行应被插入到<span><i><span>tbl_name</span></i>表中。可以按以下方法指定列。本语句向这些列提供值。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>列名称清单或<span>SET</span>子句明确的指示了列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您不为<span>INSERT...VALUES</span>或<span>INSERT...SELECT</span>指定列的清单，则表中每列的值必须在<span>VALUES</span>清单中提供，或由<span>SELECT</span>提供。如果您不知道表中各列的顺序，则使用<span>DESCRIBE
			<i>tbl_name</i></span>查询。</p>
			<p>列值可以采用多种方法给定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
            <a class="indexterm" name="id2931016"></a>

            如果不是在严格模式下运行，则所有没有明确给定值的列都被设置为默认值（明确的或隐含的）。例如，如果您指定了一个列清单，但此清单没有对表中所有的列进行命名，则未命名的各列被设置为默认值。默认值的赋值在<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>中进行了说明。也可参见<a href="introduction.html#constraint-invalid-data" title="1.8.6.2. Constraints on Invalid Data">1.8.6.2节，“对无效数据的约束”</a>。</p>
			<p>
			有时候，您需要对所有没有默认值的列明确地指定值。如果您希望，在没有明确指定值时，<span>INSERT</span>语句可以生成错误信息，则您应该使用<span>STRICT</span>模式。请参见<a href="database-administration.html#server-sql-mode" title="5.3.2. The Server SQL Mode">5.3.2节，“SQL服务器模式”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用关键词<span>DEFAULT</span>，明确地把列设置为默认值。这样，编写向所有列赋值的<span>INSERT</span>语句时可以更容易，因为使用<span>DEFAULT</span>可以避免编写出不完整的、未包含全部列值的<span>VALUES</span>清单。如果不使用<span>DEFUALT</span>，您必须编写一个列名称清单，与<span>VALUES</span>清单中的每个值对应。</p>
			<p>您还可以使用<span>DEFAULT(<i>col_name</i>)</span>作为一种更通用的形式，在表达式中使用，用于生成一个列的默认值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果列清单和<span>VALUES</span>清单均为空清单，则<span>INSERT</span>会创建一个行，每个列都被设置为默认值：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>INSERT INTO <i>tbl_name</i> () VALUES();</b></span></span></pre>
			<p>在<span>STRICT</span>模式中，如果有一列没有默认值，则会出现错误。或者，<span>MySQL</span>会对所有没有明确定义默认值的列使用隐含的默认值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以指定一个表达式<span><i><span>expr</span></i></span>来提供一个列值。如果表达式的类型与列值不匹配，这样做会造成类型转化。并且，给定值的转化会导致不同的插入值，插入何值由列类型而定。例如，向一个<span>INT, 
			FLOAT, DECIMAL(10,6)</span>或<span>YEAR</span>列插入字符串<span><span>&#39;1999.0e-2&#39;</span>，插入值分别是<span>1999</span>，<span>19.9921</span>，<span>19.992100</span>和<span>1999</span>。存储在<span>INT</span>和<span>YEAR</span>列中的值为<span>1999</span>的原因是，在从字符串到整数的转化中，只把字符串的前面部分看作有效的整数或年份。对于浮点列和固定点列，在从字符串到浮点的转化中，把整个字符串均看作有效的浮点值。</span></p>
			<p>表达式<span><i><span>expr</span></i></span>可以引用在值清单中已设置的所有列。例如，您可以这么操作，因为用于<span>col2</span>的值引用了<span>col1</span>，而<span>col1</span>已经被赋值：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO <i>tbl_name</i> (<i>col1</i>,<i>col2</i>) VALUES(15,<i>col1</i>*2);</b></span></span></pre>
			<p>但是以下语句不合法，因为用于<span>col1</span>的值引用了<span>col2</span>，而<span>col2</span>在<span>col1</span>之后被赋值：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO <i>tbl_name</i> (<i>col1</i>,<i>col2</i>) VALUES(<i>col2</i>*2,15);</b></span></span></pre>
			<p>有一种例外情况，那就是含有<span>AUTO_INCREMENT</span>值的列。因为<span>AUTO_INCREMENT</span>值在其它值赋值之后被生成，所以任何在赋值时对<span>AUTO_INCREMENT</span>列的引用都会返回<span>0</span>。</p>
			<p><span>INSERT</span>语句支持下列修改符：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>DELAYED</span>关键字，则服务器会把待插入的行放到一个缓冲器中，而发送<span>INSERT 
			DELAYED</span>语句的客户端会继续运行。如果表正在被使用，则服务器会保留这些行。当表空闲时，服务器开始插入行，并定期检查是否有新的读取请求。如果有新的读取请求，则被延迟的行被延缓执行，直到表再次空闲时为止。请参见<a href="sql-syntax.html#insert-delayed" title="13.2.4.2. INSERT DELAYED Syntax">13.2.4.2节，“INSERT 
			DELAYED语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>LOW_PRIORITY</span>关键词，则<span>INSERT</span>的执行被延迟，直到没有其它客户端从表中读取为止。当原有客户端正在读取时，有些客户端刚开始读取。这些客户端也被包括在内。此时，<span>INSERT 
			LOW_PRIORITY</span>语句等候。因此，在读取量很大的情况下，发出<span>INSERT 
			LOW_PRIORITY</span>语句的客户端有可能需要等待很长一段时间（甚至是永远等待下去）。（这与<span>INSERT 
			DELAYED</span>形成对比，<span>INSERT DELAYED</span>立刻让客户端继续执行。请参见<a href="sql-syntax.html#insert-delayed" title="13.2.4.2. INSERT DELAYED Syntax">13.2.4.2节，“INSERT 
			DELAYED语法”</a>。）注意<span>LOW_PRIORITY</span>通常不应用于<span>MyISAM</span>表，因为这么做会取消同时进行的插入。请参见<a href="storage-engines.html#myisam-storage-engine" title="15.1. The MyISAM Storage Engine">15.1节，“MyISAM存储引擎”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您指定了<span>HIGH_PRIORITY</span>，同时服务器采用<span>--low-priority-updates</span>选项启动，则<span>HIGH_PRIORITY</span>将覆盖<span><span>--low-priority-updates</span>选项。这么做还会导致同时进行的插入被取消。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>mysql_affected_rows()</span><span> 
			C API</span>函数，可以获得用于<span>INSERT</span>的受影响行的值。请参见<a href="apis.html#mysql-affected-rows" title="25.2.3.1. mysql_affected_rows()">25.2.3.1节，“mysql_affected_rows()”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您在一个<span>INSERT</span>语句中使用<span>IGNORE</span>关键词，在执行语句时出现的错误被当作警告处理。例如，没有使用<span>IGNORE</span>时，如果一个行复制了原有的<span>UNIQUE</span>索引或<span>PRIMARY 
			KEY</span>值，会导致出现重复关键字错误，语句执行失败。使用<span>IGNORE</span>时，该行仍然未被插入，但是不会出现错误。<span>IGNORE</span>未被指定时，如果数据转化引发错误，则会使语句执行失败。使用<span>IGNORE</span>后，无效数据被调整到最接近的值，并被插入；此时，生成警告，但是语句执行不会失败。您可以使用<span>mysql_info()</span><span> 
			C API</span>函数测定有多少行被插入到表中。</p>
			<p>如果您指定了<span>ON DUPLICATE KEY UPDATE</span>，并且插入行后会导致在一个<span>UNIQUE</span>索引或<span>PRIMARY 
			KEY</span>中出现重复值，则执行旧行<span>UPDATE</span>。例如，如果列<span>a</span>被定义为<span>UNIQUE</span>，并且包含值<span>1</span>，则以下两个语句具有相同的效果：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (1,2,3)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=c+1;</b></span></span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>UPDATE table SET c=c+1 WHERE a=1;</b></span></span></pre>
			<p>如果行作为新记录被插入，则受影响行的值为<span>1</span>；如果原有的记录被更新，则受影响行的值为<span>2</span>。</p>
			<p>注释：如果列<span>b</span>也是唯一列，则<span>INSERT</span>与此<span>UPDATE</span>语句相当：</p>
			<pre><span>mysql&gt; <span><b>UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;</b></span></span></pre>
			<p>如果<span><span>a=1 OR b=2</span>与多个行向匹配，则只有一个行被更新。通常，您应该尽量避免对带有多个唯一关键字的表使用<span>ON 
			DUPLICATE KEY</span>子句。</span></p>
			<p>您可以在<span>UPDATE</span>子句中使用<span>VALUES(col_name)</span>函数从<span>INSERT...UPDATE</span>语句的<span>INSERT</span>部分引用列值。换句话说，如果没有发生重复关键字冲突，则<span>UPDATE</span>子句中的<span><span>VALUES(<i>col_name</i>)</span>可以引用被插入的<i><span>col_name</span></i>的值。本函数特别适用于多行插入。<span>VALUES()</span>函数只在<span>INSERT...UPDATE</span>语句中有意义，其它时候会返回<span>NULL</span>。</span></p>
			<p>示例：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);</b></span></span></pre>
			<p>本语句与以下两个语句作用相同：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (1,2,3)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=3;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (4,5,6)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=9;</b></span></span></pre>
			<p>当您使用<span>ON DUPLICATE KEY UPDATE</span>时，<span>DELAYED</span>选项被忽略。</p>
			<p>您可以使用<span>SQL LAST_INSERT_ID()</span>函数查找用于<span>AUTO_INCREMENT</span>列的值。从<span>C 
			API</span>的内部，使用<span>mysql_insert_id()</span>函数。不过，您应该注意，两个函数的作用并不总是相同的。在<a href="functions.html#information-functions" title="12.9.3. Information Functions">12.9.3节，“信息函数”</a>和<a href="apis.html#mysql-insert-id" title="25.2.3.36. mysql_insert_id()">25.2.3.36节，“mysql_insert_id()”</a>中进一步讨论了与<span>AUTO_INCREMENT</span>列有关的<span>INSERT</span>语句的作用。</p>
			<p>如果您使用<span>INSERT...VALUES</span>语句时采用了多个值清单或<span>INSERT...SELECT</span>，则该语句按以下格式返回一个信息字符串：</p>
			<pre><span>Records: 100 Duplicates: 0 Warnings: 0</span></pre>
			<p>
			记录指示了经过语句处理的行的数目。（因为重复数目可以不是零，所以该数目不一定是实际被插入的行的数目。）重复数目指的是不能被插入的行的数目，因为这些行会复制部分原有的唯一索引值。警告指的是插入有错误或有问题的列值的次数。在以下情况下会出现警告：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向一个已定义为<span>NOT NULL</span>的列中插入<span>NULL</span>。对于一个多行<span>INSERT</span>语句或<span>INSERT 
			INTO...SELECT</span>语句，根据列数据的类型，列被设置为隐含的默认值。对于数字类型，默认值为<span>0</span>；对于字符串类型，默认值为空字符串<span>(<span>&#39;&#39;</span>)</span>；对于日期和时间类型，默认值为“<span>zero</span>”值。对<span>INSERT 
			INTO...SELECT</span>语句的处理方法与对多行插入的处理方法一样，因为服务器不能检测来自<span>SELECT</span>的结果，不能判断是否返回单一行。（对于单一行<span>INSERT</span>，当<span>NULL</span>被插入一个<span>NOT 
			NULL</span>列时，不会出现警告，而是出现错误，并且语句运行失败。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>数字列的值被设置在列的值范围之外。此值被修改为未最接近的值范围端点。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向一个数字列赋予一个例如<span>&#39;10.34 
			a&#39;</span>的值。尾部的非数字文本被删节，其余的数字部分被插入，如果字符串值没有前导的数字部分，则该列被设置为<span>0</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向一个字符串列（<span>CHAR, VARCHAR, TEXT</span>或<span>BLOB</span>）中插入的字符串超过了列的最大长度。此值被删节到列的最大长度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向日期或时间列中插入的值对于该列的类型是不合法的。根据列的类型，该列被设置到相应的零值。</p>
			<p>如果您正在使用<span>C API</span>，则可以通过调用<span>mysql_info()</span>函数获取信息字符串。请参见<a href="apis.html#mysql-info" title="25.2.3.34. mysql_info()">25.2.3.34节，“mysql_info()”</a>。</p>
			<a class="indexterm" name="id2900883"></a><a class="indexterm" name="id2900892"></a><a class="indexterm" name="id2901132"></a><a class="indexterm" name="id2901141"></a><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="insert-select"></a>13.2.4.1. INSERT 
				... SELECT语法</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; SELECT ...</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
				<p>使用<span>INSERT...SELECT</span>，您可以快速地从一个或多个表中向一个表中插入多个行。</p>
				<p>示例：</p>
				<pre><span>INSERT INTO tbl_temp2 (fld_id)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; SELECT tbl_temp1.fld_order_id</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; FROM tbl_temp1 WHERE tbl_temp1.fld_order_id &gt; 100;</span></pre>
				<p>使用<span>INSERT...SELECT</span>语句时会出现以下情况：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>明确地指定<span>IGNORE</span>，用于忽略会导致重复关键字错误的记录。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>不要同时使用<span>DELAYED</span>和<span>INSERT...SELECT</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INSERT</span>语句的目标表会显示在查询的<span>SELECT</span>部分的<span>FROM</span>子句中。（在有些旧版本的<span>MySQL</span>中不会出现这种情况。）</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>AUTO_INCREMENT</span>列照常运行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>为了确保二进制日志可以被用于再次创建原表，<span>MySQL</span>不允许在<span>INSERT...SELECT</span>运行期间同时进行插入操作。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>目前，您不能在向一个表插入的同时，又在一个子查询中从同一个表中选择。</p>
				<p>在<span>ON DUPLICATE KEY UPDATE</span>的值部分中，只要您不使用<span>SELECT</span>部分中的<span>GROUP 
				BY</span>，您就可以引用在其它表中的列。有一个副作用是，您必须使值部分中的非唯一列的名称符合要求。</p>
				<p>您可以使用<span>REPLACE</span>替代<span>INSERT</span>，来覆盖旧行。对于包含唯一关键字值，并复制了旧行的新行，在进行处理时，<span>REPLACE</span>可以作为<span>INSERT 
				IGNORE</span>的同类子句：新行被用于替换旧行，而不是被丢弃。</p>
				<h4 class="title"><a name="insert-delayed"></a>13.2.4.2. INSERT 
				DELAYED语法</h4></div></div></div><a class="indexterm" name="id2901376"></a><a class="indexterm" name="id2901385"></a><a class="indexterm" name="id2901394"></a>
				<pre><span>INSERT DELAYED ...</span></pre>
				<p>用于<span>INSERT</span>语句的<span>DELAYED</span>选项是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。如果您的客户端不能等待<span>INSERT</span>完成，则这个选项是非常有用的。当您使用<span>MySQL</span>进行日志编写时，这是非常常见的问题。您也可以定期运行<span>SELECT</span>和<span>UPDATE</span>语句，这些语句花费的时间较长。</p>
				<p>当一个客户端使用<span>INSERT DELAYED</span>时，会立刻从服务器处得到一个确定。并且行被排入队列，当表没有被其它线程使用时，此行被插入。</p>
				<p>使用<span>INSERT DELAYED</span>的另一个重要的好处是，来自许多客户端的插入被集中在一起，并被编写入一个块。这比执行许多独立的插入要快很多。</p>
				<p>使用<span>DELAYED</span>时有一些限制：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INSERT DELAYED</span>仅适用于<span>MyISAM, 
				MEMORY</span>和<span>ARCHIVE</span>表。对于<span>MyISAM</span>表，如果在数据文件的中间没有空闲的块，则支持同时采用<span>SELECT</span>和<span>INSERT</span>语句。在这些情况下，基本不需要对<span>MyISAM</span>使用<span>INSERT 
				DELAYED</span>。请参见<a href="storage-engines.html#myisam-storage-engine" title="15.1. The MyISAM Storage Engine">15.1节，“MyISAM存储引擎”</a><span>,
				</span>
              <a href="storage-engines.html#memory-storage-engine" title="15.4. The MEMORY (HEAP) Storage Engine">
				15.4节，“MEMORY (HEAP)存储引擎”</a>和<a href="storage-engines.html#archive-storage-engine" title="15.8. The ARCHIVE Storage Engine">15.8节，“ARCHIVE存储引擎”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INSERT DELAYED</span>应该仅用于指定值清单的<span>INSERT</span>语句。服务器忽略用于<span>INSERT 
				DELAYED...SELECT</span>语句的<span>DELAYED</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>服务器忽略用于<span>INSERT DELAYED...ON 
				DUPLICATE UPDATE</span>语句的<span>DELAYED</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>因为在行被插入前，语句立刻返回，所以您不能使用<span>LAST_INSERT_ID()</span>来获取<span>AUTO_INCREMENT</span>值。<span>AUTO_INCREMENT</span>值可能由语句生成。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span>SELECT</span>语句，<span>DELAYED</span>行不可见，直到这些行确实被插入了为止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>DELAYED</span>在从属复制服务器中被忽略了，因为<span>DELAYED</span>不会在从属服务器中产生与主服务器不一样的数据。</p>
				<p>注意，目前在队列中的各行只保存在存储器中，直到它们被插入到表中为止。这意味着，如果您强行中止了<strong><span>mysqld</span></strong>（例如，使用<span>kill 
				-9</span>）或者如果<strong><span>mysqld</span></strong>意外停止，则所有没有被写入磁盘的行都会丢失。</p>
				<p>以下详细描述了当您对<span>INSERT</span>或<span>REPLACE</span>使用<span>DELAYED</span>选项时会发生什么情况。在这些描述中，“线程”指的是已接受了一个<span>INSERT 
				DELAYED</span>语句的线程，“管理程序”指的是为某个特定的表处理所有<span>INSERT 
				DELAYED</span>语句的线程。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>当一个线程对一个表执行<span>DELAYED</span>语句时，会创建出一个管理程序线程（如果原来不存在），对用于本表的所有<span>DELAYED</span>语句进行处理。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>线程会检查是否管理程序以前已获取了<span>DELAYED</span>锁定；如果没有获取，则告知管理程序线程进行此项操作。即使其它线程对表有<span>READ</span>或<span>WRITE</span>锁定，也可以获得<span>DELAYED</span>锁定。但是管理程序会等待所有的<span>ALTER 
				TABLE</span>锁定或<span>FLUSH TABLE</span>锁定，以确保表的结构是最新的。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>线程执行<span>INSERT</span>语句，但不是把行写入表中，而是把最终行的拷贝放入一个由管理程序线程管理的队列中。线程会提示出现语法错误，这些错误会被报告到客户端中。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>因为在插入操作之前，<span>INSERT</span>返回已经完成，所以客户端不能从服务器处获取重复记录的数目，也不能获取生成的行的<span>AUTO_INCREMENT</span>值。（如果您使用<span>C 
				API</span>，则出于同样的原因，<span><span>mysql_info()</span>函数</span>不会返回任何有意义的东西。）</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				当行被插入表中时，二进制日志被管理程序线程更新。在多行插入情况下，当第一行被插入时，二进制日志被更新。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>每次<span>delayed_insert_limit</span>行被编写时，管理程序会检查是否有<span>SELECT</span>语句仍然未执行。如果有，则会在继续运行前，让这些语句先执行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>当管理程序的队列中没有多余的行时，表被解锁。如果在<span>delayed_insert_timeout</span>时间内，没有接收到新的<span>INSERT 
				DELAYED</span>语句，则管理程序中止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果在某个特定的管理程序队列中，有超过<span><span>delayed_queue_size</span>的行未被执行，则申请<span>INSERT 
				DELAYED</span>的线程会等待，直到队列中出现空间为止。这么做可以确保</span><strong><span>mysqld</span></strong><span>不会把所有的存储器都用于被延迟的存储队列。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>管理程序线程会显示在<span>MySQL</span>进程清单中，其命令列中包含<span>delayed_insert</span>。如果您执行一个<span>FLUSH 
				TABLES</span>语句或使用<span>KILL thread_id</span>进行删除，则会删除此线程。不过，在退出前，线程会首先把所有排入队列的行存储到表中。在这期间，该线程不会从其它线程处接受任何新的<span>INSERT</span>语句。如果您在此之后执行一个<span>INSERT 
				DELAYED</span>语句，则会创建出一个新的管理程序线程。</p>
				<p>注意，如果有一个<span>INSERT 
				DELAYED</span>管理程序正在运行，则这意味着<span>INSERT DELAYED</span>语句比常规的<span>INSERT</span>语句具有更高的优先权。其它更新语句必须等待，直到<span>INSERT 
				DELAYED</span>语句队列都运行完毕，或者管理程序线程被中止（使用<span>KILL 
				thread_id</span>），或者执行了一个<span>FLUSH TABLES</span>时为止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>以下状态变量提供了有关<span>INSERT DELAYED</span>语句的信息：</p>
				<table border="1" cellpadding="0" id="table6">
					<tr>
						<td>
						<p><strong>
						<span>状态变量</span></strong></td>
						<td>
						<p><strong>
						<span>意义</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Delayed_insert_threads</span></td>
						<td>
						<p>管理程序线程的数目</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Delayed_writes</span></td>
						<td>
						<p><span>使用<span>INSERT 
						DELAYED</span>写入的行的数目</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Not_flushed_delayed_rows</span></td>
						<td>
						<p>等待被写入的行的数目</td>
					</tr>
				</table>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>您可以通过发送一个<span>SHOW STATUS</span>语句，或者执行一个<strong><span>mysqladmin 
				extended-status</span></strong>命令，来阅览这些变量。</p>
				<p>注意，当没有使用表时，<span>INSERT DELAYED</span>比常规的<span>INSERT</span>要慢。对于服务器来说，为每个含有延迟行的表操纵一个独立的线程，也是一个额外的系统开销。这意味着只有当您确认您需要时，才应使用<span>INSERT 
				DELAYED</span>。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="load-data"></a>13.2.5. LOAD 
			DATA INFILE语法</h3></div></div></div><a class="indexterm" name="id2902077"></a>
			<pre><span>LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE &#39;<span><i>file_name</i></span>.txt&#39;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [REPLACE | IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; INTO TABLE <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [FIELDS</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TERMINATED BY &#39;<span><i>string</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [[OPTIONALLY] ENCLOSED BY &#39;<span><i>char</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ESCAPED BY &#39;<span><i>char</i></span>&#39; ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LINES</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [STARTING BY &#39;<span><i>string</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TERMINATED BY &#39;<span><i>string</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [IGNORE <span><i>number</i></span> LINES]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(<span><i>col_name_or_user_var</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [SET <span><i>col_name</i></span> = <span><i>expr</i></span>,...)]</span></pre>
			<p><span>LOAD DATA INFILE</span>语句用于高速地从一个文本文件中读取行，并装入一个表中。文件名称必须为一个文字字符串。</p>
			<p>要了解有关<span>INSERT</span>和<span>LOAD DATA 
			INFILE</span>的效率的对比和有关<span>LOAD DATA INFILE</span>加速的更多信息，请参见<a href="optimization.html#insert-speed" title="7.2.16. Speed of INSERT Statements">7.2.16节，“INSERT语句的速度”</a>。</p>
			<p>由<span>character_set_database</span>系统变量指示的字符集被用于解释文件中的信息。<span>SET 
			NAMES</span>和<span>character_set_client</span>的设置不会影响对输入的解释。</p>
			<p>注意，目前不能载入<span>UCS2</span>数据文件。</p>
			<p>您也可以通过使用<strong><span>mysqlimport</span></strong>应用程序载入数据文件；通过向服务器发送一个<span>LOAD 
			DATA INFILE</span>语句实现此功能。<span>--local</span>选项用于使<strong><span>mysqlimport</span></strong>从客户主机中读取数据文件。如果客户端和服务器支持压缩协议，则您可以指定—<span>compress</span>选项提高在慢速网络中的性能。请参见<a href="client-side-scripts.html#mysqlimport" title="8.10. mysqlimport — A Data Import Program">8.10节，“mysqlimport：数据导入程序</a>。</p>
			<p>如果您使用<span>LOW_PRIORITY</span>，则<span>LOAD 
			DATA</span>语句的执行被延迟，直到没有其它的客户端从表中读取为止。</p>
			<p>如果一个<span>MyISAM</span>表满足同时插入的条件（即该表在中间有空闲块），并且您对这个<span>MyISAM</span>表指定了<span>CONCURRENT</span>，则当<span>LOAD 
			DATA</span>正在执行时，其它线程会从表中重新获取数据。即使没有其它线程在同时使用本表格，使用本选项也会略微影响<span>LOAD 
			DATA</span>的性能。</p>
			<p>如果指定了<span>LOCAL</span>，则被认为与连接的客户端有关：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果指定了<span>LOCAL</span>，则文件会被客户主机上的客户端读取，并被发送到服务器。文件会被给予一个完整的路径名称，以指定确切的位置。如果给定的是一个相对的路径名称，则此名称会被理解为相对于启动客户端时所在的目录。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>LOCAL</span>没有被指定，则文件必须位于服务器主机上，并且被服务器直接读取。</p>
			<p>当在服务器主机上为文件定位时，服务器使用以下规则：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果给定了一个绝对的路径名称，则服务器使用此路径名称。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果给定了带有一个或多个引导组件的相对路径名称，则服务器会搜索相对于服务器数据目录的文件。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果给定了一个不带引导组件的文件名称，则服务器会在默认数据库的数据库目录中寻找文件。</p>
			<p>注意，这些规则意味着名为<span>./myfile.txt</span>的文件会从服务器数据目录中被读取，而名为<span>myfile.txt</span>的同样的文件会从默认数据库的数据库目录中读取。例如，下面的<span>LOAD 
			DATA</span>语句会从<span>db1</span>数据库目录中读取文件<span>data.txt</span>，因为<span>db1</span>是当前数据库。即使语句明确把文件载入到<span>db2</span>数据库中的表里，也会从<span>db1</span>目录中读取。</p>
			<pre><span>mysql&gt; <span><b>USE db1;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE db2.my_table;</b></span></span></pre>
			<p>注意，使用正斜杠指定<span>Windows</span>路径名称，而不是使用反斜杠。如果您使用反斜杠，您必须使用两个。</p>
			<p>出于安全原因，当读取位于服务器中的文本文件时，文件必须位于数据库目录中，或者是全体可读的。另外，要对服务器文件使用<span>LOAD 
			DATA INFILE</span>，您必须拥有<span>FILE</span>权限。</p>
			<p>见<a href="database-administration.html#privileges-provided" title="5.7.3. Privileges Provided by MySQL">5.7.3节，“MySQL提供的权限”</a>。</p>
			<p>与让服务器直接读取文件相比，使用<span>LOCAL</span>速度略慢，这是因为文件的内容必须通过客户端发送到服务器上。不过，您不需要<span>FILE</span>权限来载入本地文件。</p>
			<p>只有当您的服务器和您的客户端都许可时，<span>LOCAL</span>才可运行。例如，如果使用—<span>local-infile=0</span>启动<strong><span>mysqld</span></strong>，则<span>LOCAL</span>不运行。请参见<a href="database-administration.html#load-data-local" title="5.6.4. Security Issues with LOAD DATA LOCAL">5.6.4节，“LOAD DATA LOCAL安全问题<code class="literal"></code>”</a>。</p>
			<p>如果您需要<span>LOAD DATA</span>来从一个管道中读取，您可以使用以下方法（此处我们把<span>/</span>目录清单载入一个表格）：</p>
			<pre><span>mkfifo /mysql/db/x/x</span></pre>
			<pre><span>chmod 666 /mysql/db/x/x</span></pre>
			<pre><span>find / -ls &gt; /mysql/db/x/x</span></pre>
			<pre><span>mysql -e &quot;LOAD DATA INFILE &#39;x&#39; INTO TABLE x&quot; x</span></pre>
			<p>有些输入记录把原有的记录复制到唯一关键字值上。<span>REPLACE</span>和<span>IGNORE</span>关键字用于控制这些输入记录的操作。</p>
			<p>如果您指定了<span>REPLACE</span>，则输入行会替换原有行（换句话说，与原有行一样，对一个主索引或唯一索引具有相同值的行）。请参见<a href="sql-syntax.html#replace" title="13.2.6. REPLACE Syntax">13.2.6节，“REPLACE语法”</a>。</p>
			<p>如果您指定<span>IGNORE</span>，则把原有行复制到唯一关键字值的输入行被跳过。如果您这两个选项都不指定，则运行情况根据<span>LOCAL</span>关键词是否被指定而定。不使用<span>LOCAL</span>时，当出现重复关键字值时，会发生错误，并且剩下的文本文件被忽略。使用<span>LOCAL</span>时，默认的运行情况和<span>IGNORE</span>被指定时的情况相同；这是因为在运行中间，服务器没有办法中止文件的传输。</p>
			<p>如果您希望在载入运行过程中忽略外键的限制，您可以在执行<span>LOAD DATA</span>前发送一个<span>SET 
			FOREIGN_KEY_CHECKS=0</span>语句。</p>
			<p>如果您对一个空的<span>MyISAM</span>表使用<span>LOAD DATA 
			INFILE</span>，则所有的非唯一索引会被创建在一个独立批中（对于<span>REPAIR TABLE</span>）。当您有许多索引时，这通常会使<span>LOAD 
			DATA INFILE</span>大大加快。通常，<span>LOAD DATA INFILE</span>的速度会非常快，但是在某些极端情况下，您可以在把文件载入到表中之前使用<span>ALTER 
			TABLE...DISABLE KEYS</span>关闭<span>LOAD DATA INFILE</span>，或者在载入文件之后使用<span>ALTER 
			TABLE...ENABLE KEYS</span>再次创建索引，使创建索引的速度更快。请参见<a href="optimization.html#insert-speed" title="7.2.16. Speed of INSERT Statements">7.2.16节，“INSERT语句的速度”</a>。</p>
			<p><span>LOAD DATA INFILE</span>是<span>SELECT...INTO 
			OUTFILE</span>的补语。（见<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。）要从一个表中把数据写入一个文件中，应使用<span>SELECT...INTO 
			OUTFILE</span>。要读取文件，放回到表中，应使用<span>LOAD DATA INFILE</span>。<span>FIELDS</span>和<span>LINES</span>子句的语法对于两个语句是一样的。两个子句都是自选的，但是如果两个都被指定了，<span>FIELDS</span>必须位于<span>LINES</span>的前面。</p>
			<p>如果您指定了一个<span>FIELDS</span>子句，则每个亚子句（<span>TERMINATED 
			BY, [OPTIONALLY] ENCLOSED BY</span>和<span>ESCAPED BY</span>）也是自选的。不过，您必须指定其中至少一个。</p>
			<p>如果您不指定<span>FIELDS</span>子句，则默认值为假设您写下如下语句时的值：</p>
			<pre><span>FIELDS TERMINATED BY &#39;\t&#39; ENCLOSED BY &#39;&#39; ESCAPED BY &#39;\\&#39;</span></pre>
			<p>如果您不指定<span>LINES</span>子句，则默认值为假设您写下如下语句时的值：</p>
			<pre><span>LINES TERMINATED BY &#39;\n&#39; STARTING BY &#39;&#39;</span></pre>
			<p>换句话说，当读取输入值时，默认值会使<span>LOAD DATA INFILE</span>按如下方式运行：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在新行处寻找行的边界。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不会跳过任何行前缀。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在制表符处把行分解为字段。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不希望字段被包含在任何引号字符之中。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>出现制表符、新行、或在‘<span>\</span>’前有‘<span>\</span>’时，理解为作为字段值一部分的文字字符。</p>
			<p>相反的，当编写输出值时，默认值会使<span>SELECT...INTO OUTFILE</span>按如下方式运行：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在字段之间写入制表符。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不把字段包含在任何引号字符中。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当字段值中出现制表符、新行或‘<span>\</span>’时，使用‘<span>\</span>’进行转义。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在行的末端写入新行。</p>
			<p>注意，要写入<span>FIELDS ESCAPED BY </span>‘<span>\\</span>’，您必须为待读取的值指定两个反斜杠，作为一个单反斜杠使用。</p>
			<p>注释：如果您已经在<span>Windows</span>系统中生成了文本文件，您可能必须使用<span>LINES 
			TERMINATED BY </span>‘<span>\r\n</span>’来正确地读取文件，因为<span>Windows</span>程序通常使用两个字符作为一个行终止符。部分程序，比如<strong><span>WordPad</span></strong>，当编写文件时，可能会使用<span>\r</span>作为行终止符。要读取这样的文件，应使用<span>LINES 
			TERMINATED BY </span>‘<span>\r</span>’。</p>
			<p>如果所有您希望读入的行都含有一个您希望忽略的共用前缀，则您可以使用<span>&#39;<i>prefix_string</i>&#39;</span>来跳过前缀（和前缀前的字符）。如果某行不包括前缀，则整个行被跳过。注释：<span><i><span>prefix_string</span></i></span>会出现在一行的中间。</p>
			<p>示例： </p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;/tmp/test.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>INTO TABLE test LINES STARTING BY &quot;xxx&quot;;</b></span></span></pre>
			<p>使用此语句，您可以读入包含有如下内容的文件：</p>
			<pre><span>xxx&quot;row&quot;,1</span></pre>
			<pre><span>something xxx&quot;row&quot;,2</span></pre>
			<p>并只得到数据<span>(&quot;row&quot;,1)</span>和<span>(&quot;row&quot;,2)</span>。</p>
			<p><span>IGNORE <i>number</i> 
			LINES</span>选项可以被用于在文件的开始处忽略行。例如，您可以使用<span>IGNORE 
			1 LINES</span>来跳过一个包含列名称的起始标题行：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;/tmp/test.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>INTO TABLE test IGNORE 1 LINES;</b></span></span></pre>
			<p>当您联合使用<span>SELECT...INTO OUTFILE</span>和<span>LOAD 
			DATA INFILE</span>来从一个数据库中把数据写入一个文件中，然后再读取文件，返回到数据库中时，用于两个语句的<span>field-</span>和<span>line-handling</span>选项必须匹配。否则，<span>LOAD 
			DATA INFILE</span>不会正确地理解文件的内容。假设您使用<span>SELECT...INTO 
			OUTFILE</span>来编写一个的文件，字段由逗号分隔：</p>
			<pre><span>mysql&gt; <span><b>SELECT * INTO OUTFILE &#39;data.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;,&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FROM table2;</b></span></span></pre>
			<p>要读取由逗号分隔的文件并返回，则正确的语句应该是：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE table2</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;,&#39;;</b></span></span></pre>
			<p>如果您尝试使用以下所示的语句读入文件，则不会运行，因为该语句命令<span>LOAD DATA INFILE</span>寻找位于字段之间的制表符：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE table2</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;\t&#39;;</b></span></span></pre>
			<p>结果很可能是，每个输入行被理解为一个单一字段。</p>
			<p><span>LOAD DATA INFILE</span>也可以被用于读取从外源中获取的文件。例如，一个<span>dBASE</span>格式的文件具有以逗号分隔并且包含在双引号中的字段。如果文件中的各行以新行为结尾，则此处所示的语句描述了您可以用于载入文件的<span>field-</span>和<span>line-handling</span>选项：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE <i>tbl_name</i></b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;,&#39; ENCLOSED BY &#39;&quot;&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LINES TERMINATED BY &#39;\n&#39;;</b></span></span></pre>
			<p>所有<span>field-</span>或<span>line-handling</span>选项都可以指定一个空字符串<span>(<span>&#39;&#39;</span>)</span>。如果字符串不是空的，则<span>FIELDS 
			[OPTIONALLY] ENCLOSED BY</span>和<span>FIELDS ESCAPED BY</span>值必须为单一字符。<span>FIELDS 
			TERMINATED BY, LINES STARTING BY</span>和<span>LINES 
			TERMINATED BY</span>值可以超过一个字符。例如，要编写由回车<span>/</span>换行成对字符作为结尾的行，或读取包含这类行的文件，则应指定一个<span>LINES 
			TERMINATED BY </span>‘<span>\r\n</span>’子句。</p>
			<p>如果<span>jokes</span>被由<span>%%</span>组成的行分隔，<span>要读取包含<span>jokes</span>的文件，您可以这么操作：</span></p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE jokes</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>(a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>joke TEXT NOT NULL);</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;/tmp/jokes.txt&#39; INTO TABLE jokes</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LINES TERMINATED BY &#39;\n%%\n&#39; (joke);</b></span></span></pre>
			<p><span>FIELDS [OPTIONALLY] ENCLOSED BY</span>用于控制字段的引号。对于（<span>SELECT...INTO 
			OUTFILE</span>），如果您忽略了词语<span>OPTIONALLY</span>，则所有的字段都被包含在<span>ENCLOSED 
			BY</span>字符串中。此处展示了此类输出的一个示例（使用逗号作为字段分隔符）：</p>
			<pre><span>&quot;1&quot;,&quot;a string&quot;,&quot;100.20&quot;</span></pre>
			<pre><span>&quot;2&quot;,&quot;a string containing a , comma&quot;,&quot;102.20&quot;</span></pre>
			<pre><span>&quot;3&quot;,&quot;a string containing a \&quot; quote&quot;,&quot;102.20&quot;</span></pre>
			<pre><span>&quot;4&quot;,&quot;a string containing a \&quot;, quote and comma&quot;,&quot;102.20&quot;</span></pre>
			<p>如果您指定了<span>OPTINALLY</span>，则<span>ENCLOSED 
			BY</span>字符只被用于包含具有字符串数据类型（比如<span>CHAR, BINARY, TEXT</span>或<span>ENUM</span>）的列中的值：</p>
			<pre><span>1,&quot;a string&quot;,100.20</span></pre>
			<pre><span>2,&quot;a string containing a , comma&quot;,102.20</span></pre>
			<pre><span>3,&quot;a string containing a \&quot; quote&quot;,102.20</span></pre>
			<pre><span>4,&quot;a string containing a \&quot;, quote and comma&quot;,102.20</span></pre>
			<p>注意，如果在字段值内出现<span>ENCLOSED BY</span>字符，则通过使用<span>ESCAPED 
			BY</span>字符作为前缀，对<span>ENCLOSED BY</span>字符进行转义。另外，要注意，如果您指定了一个空的<span>ESCAPED 
			BY</span>值，则可能会生成不能被<span>LOAD DATA INFILE</span>正确读取的输出值。例如，如果转义符为空字符，则刚显示的先前输出值应显示如下。请观察，第四行中的第二个字段在引号后面包含一个逗号，该引号（错误地）显示出来，作为字段的结尾：</p>
			<pre><span>1,&quot;a string&quot;,100.20</span></pre>
			<pre><span>2,&quot;a string containing a , comma&quot;,102.20</span></pre>
			<pre><span>3,&quot;a string containing a &quot; quote&quot;,102.20</span></pre>
			<pre><span>4,&quot;a string containing a &quot;, quote and comma&quot;,102.20</span></pre>
			<p>对于输入值，<span>ENCLOSED BY</span>字符被从字段字的末尾剥离。（不论<span>OPTIONALLY</span>是否被指定都会剥离；<span>OPTIONALLY</span>对输入值的解释没有影响。）如果<span>ENCLOSED 
			BY</span>字符前面带有<span>ESCAPED BY</span>字符，则被理解为当前字段值的一部分。</p>
			<p>如果字段以<span>ENCLOSED BY</span>字符为开始，当出现这类字符时，只有后面接着字段或行<span>TERMINATED 
			BY</span>序列时，这类字符被认为是一个字段值的结尾。为了避免意思不明确，当在一个字段值中出现<span>ENCLOSED 
			BY</span>字符时，此字符可以重复书写，并被理解为单一的字符。例如，如果指定了<span>ENCLOSED 
			BY <span>&#39;&quot;&#39;</span></span>，则按照以下方法操作引号：</p>
			<pre><span>&quot;The &quot;&quot;BIG&quot;&quot; boss&quot;&nbsp; -&gt; The &quot;BIG&quot; boss</span></pre>
			<pre><span>The &quot;BIG&quot; boss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; The &quot;BIG&quot; boss</span></pre>
			<pre><span>The &quot;&quot;BIG&quot;&quot; boss&nbsp;&nbsp;&nbsp; -&gt; The &quot;&quot;BIG&quot;&quot; boss</span></pre>
			<p><span>FIELDS ESCAPED BY</span>用于控制如何写入或读取特殊字符。如果<span>FIELDS 
			ESCAPED BY</span>字符不是空字符，则可以在输出中用于对以下字符加前缀：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FIELDS ESCAPED BY</span>字符</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FIELDS [OPTIONALLY] ENCLOSED BY</span>字符</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FIELDS TERMINATED BY</span>和<span>LINES 
			TERMINATED BY</span>值的第一个字符</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ASCII 0</span>（在转义符之后编写的字符实际上是<span>ASCII</span>‘<span>0</span>’，而不是一个值为<span>0</span>的字节）</p>
			<p>如果<span>FIELDS ESCAPED BY</span>字符为空字符，则没有字符被转义，并且<span>NULL</span>被作为<span>NULL</span>输出，而不是<span>\N</span>。去指定一个空的转义符不是一个好办法，特别是如果数据的字段值包含任何刚给定的清单中的字符时，更不能这么做。</p>
			<p>对于输入值，如果<span>FIELDS ESCAPED BY</span>字符不是空字符，则出现这种字符时会被剥离，然后以下字符被作为字段值的一部分。例外情况是，被转义的‘<span>0</span>’或‘<span>N</span>’（例如，<span>\0</span>或<span>\N</span>，此时转义符为‘<span>\</span>’）。这些序列被理解为<span>ASCII 
			NUL</span>（一个零值字节）和<span>NULL</span>。用于<span>NULL</span>处理的规则在本节的后部进行说明。</p>
			<p>要了解有关‘<span>\</span>’<span>-escape</span>语法的更多信息，请参见<a href="language-structure.html#literals" title="9.1. Literal Values">9.1节，“文字值”</a>。</p>
			<p>在特定情况下，<span>field-</span>和<span>line-handling</span>选项相互影响：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>LINES TERMINATED BY</span>是空字符串，并且<span>FIELDS 
			TERMINATED BY</span>不是空字符串，则各行以<span>FIELDS TERMINATED BY</span>作为结尾。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS TERMINATED BY</span>和<span>FIELDS 
			ENCLOSED BY</span>值均为空值<span>(<span>&#39;&#39;</span>)</span>，则使用固定行（无分隔）格式。使用固定行格式时，在字段之间不使用分隔符（但是您仍然可以有行终止符）。列值使用列的显示宽度进行写入和读取。例如，如果某列被定义为<span>INT(7)</span>，则使用<span>7</span>字符字段写入列值。输出时，通过读取<span>7</span>个字符获取列值。</p>
			<p><span>LINES TERMINATED BY</span>仍然用于分隔行。如果某行不包含所有字段，则其余的各列被设置到默认值。如果您没有行终止符，您应该把终止符设置为<span>&#39;&#39;</span>。在此情况下，文本文件必须包含每行的所有字段。</p>
			<p>固定行格式也会影响<span>NULL</span>值的操作，这将在以后进行介绍。注意，如果您正在使用一个多字节字符集，则固定规格格式不会运行。</p>
			<p>根据正在使用中的<span>FIELDS</span>和<span>LINES</span>选项的不同，<span>NULL</span>值的操作有所变化：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于默认的<span>FIELDS</span>和<span>LINES</span>值，<span>NULL</span>被作为<span>\N</span>的字段值编写，用于输出；<span>\N</span>字段值被作为<span>NULL</span>读取，用于输入（假设<span>ESCAPED 
			BY</span>字符为‘<span>\</span>’）。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS ENCLOSED BY</span>不是空值，则包含以文字词语<span>NULL</span>为值的字段被作为<span>NULL</span>值读取。这与被<span>FIELDS 
			ENCLOSED BY</span>字符包围的词语<span>NULL</span>不同。该词语被作为字符串<span>&#39;NULL&#39;</span>读取。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS ESCAPED BY</span>是空值，则<span>NULL</span>被作为词语<span>NULL</span>写入。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>采用固定行格式时（当<span>FIELDS TERMINATED BY</span>和<span>FIELDS 
			ENCLOSED BY</span>均为空值时采用），<span>NULL</span>被作为一个空字符串写入。注意，这会导致在被写入文件时，表中的<span>NULL</span>值和空字符串均无法辨别，这是因为两者都被作为空字符串写入。如果您需要在读取文件并返回时能够分辨两者，则您不应使用固定行格式。</p>
			<p><span>LOAD DATA INFILE</span>不支持有些情况：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>固定规格行（<span>FIELDS TERMINATED BY</span>和<span>FIELDS 
			ENCLOSED BY</span>均为空值）和<span>BLOB</span>或<span>TEXT</span>列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您指定了一个分隔符，并且该分隔符与其它的前缀一样，则<span>LOAD DATA 
			INFILE</span>不能正确地理解输入值。例如，下面的<span>FIELDS</span>子句会导致问题：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>FIELDS TERMINATED BY &#39;&quot;&#39; ENCLOSED BY &#39;&quot;&#39;</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS ESCAPED BY</span>为空值，则包含<span>FIELDS 
			ENCLOSED BY</span>或<span>LINES TERMINATED BY</span>的字段值后面再接<span>FIELDS 
			TERMINATED BY</span>值会导致<span>LOAD DATA INFILE</span>过早地停止读取一个字段或行。出现这种情况的原因是<span>LOAD 
			DATA INFILE</span>不能正确地决定字段或行值在哪里结束。</p>
			<p>以下的例子载入了<span>persondata</span>表中的所有列：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;persondata.txt&#39; INTO TABLE persondata;</b></span></span></pre>
			<p>默认情况下，如果在<span>LOAD DATA INFILE</span>语句的末尾处没有设列清单时，则输入行预计会包含一个字段，用于表中的每个列。如果您只想载入一个表的部分列，则应指定一个列清单：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;persondata.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>INTO TABLE persondata (col1,col2,...);</b></span></span></pre>
			<p>如果输入文件中各字段的顺序与表中各列的顺序不同，您也必须指定一个列清单。否则，<span>MySQL</span>不能把输入字段和表中的列匹配起来。</p>
			<p>列清单可以包含列名称或用户变量。支持<span>SET</span>子句。这使您可以把输入值赋予用户变量，然后在把结果赋予列之前，对这些值进行变换。</p>
			<p><span>SET</span>子句中的用户变量可以采用多种方式使用。以下例子使用数据文件中的第一列，直接用于<span>t1.column1</span>的值。在用户变量被用于<span>t2.column2</span>值之前，把第二列赋予用户变量。该变量从属于一个分割运行。</p>
			<pre><span>LOAD DATA INFILE &#39;file.txt&#39;</span></pre>
			<pre><span>&nbsp; INTO TABLE t1</span></pre>
			<pre><span>&nbsp; (column1, @var1)</span></pre>
			<pre><span>&nbsp; SET column2 = @var1/100;</span></pre>
			<p><span>SET</span>子句可以被用于提供不是来源于输入文件的值。以下语句把<span>column3</span>设置为当前的日期和时间：</p>
			<pre><span>LOAD DATA INFILE &#39;file.txt&#39;</span></pre>
			<pre><span>&nbsp; INTO TABLE t1</span></pre>
			<pre><span>&nbsp; (column1, column2)</span></pre>
			<pre><span>&nbsp; SET column3 = CURRENT_TIMESTAMP;</span></pre>
			<p>您也可以通过把输入值赋予一个用户变量，同时不把变量赋予表中的列，来丢弃此输入值：</p>
			<pre><span>LOAD DATA INFILE &#39;file.txt&#39;</span></pre>
			<pre><span>&nbsp; INTO TABLE t1</span></pre>
			<pre><span>&nbsp; (column1, @dummy, column2, @dummy, column3);</span></pre>
			<p>列<span>/</span>变量清单和<span>SET</span>子句的使用受到以下限定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>SET</span>子句中的赋值应只含有位于赋值操作符的左侧的列名称。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以在<span>SET</span>赋值的右侧使用子查询。如果子查询可以返回一个值，并且此值将被赋予到一个列中，则此子查询只能是标量子查询。另外，您不能使用子查询从一个正在被载入的表中选择。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于于列<span>/</span>变量清单或<span>SET</span>子句，被<span>IGNORE</span>子句忽略的行不被处理。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当载入采用固定行格式的数据时，不能使用用户变量，因为用户变量没有显示宽度。</p>
			<p>当处理一个输入行时，<span>LOAD DATA</span>会依据列<span>/</span>变量清单和<span>SET</span>子句，把行拆分成字段，并使用值。然后，得到的行被插入表中。如果有用于表的<span>BEFORE 
			INSERT</span>或<span>AFTER INSERT</span>触发器，则在插入行之前和插入行之后分别启动触发器。</p>
			<p>如果一个输入行含有过多的字段，则多余的字段被忽略，并且警告的数量增加。</p>
			<p>如果一个输入行含有的字段过少，则输入字段缺失的表中的列被设置为默认值。默认值赋值在<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
		TABLE语法”</a>中进行了说明。</p>
			<p>如果字段值缺失，则对一个空字段值会被按不同方式理解：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于字符串类型，列被设置为空字符串。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于数字类型，列被设置为<span>0</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于日期和时间类型，列被设置为该类型相应的“<span>zero</span>”。请参见<a href="column-types.html#date-and-time-types" title="11.3. Date and Time Types">11.3节，“日期和时间类型”</a>。</p>
			<p>如果您明确地把一个空字符串赋予一个<span>INSERT</span>或<span>UPDATE</span>语句中的字符串类型、数字类型或日期或时间类型，则产生的这些值相同。</p>
			<p>只有在两种情况下<span>TIMESTAMP</span>列被设置为当前日期和时间。一种情况时当列有一个<span>NULL</span>值（也就是<span>\N</span>）时；另一种情况是（仅对于第一个<span>TIMESTAMP</span>列），当一个字段清单被指定时，<span>TIMESTAMP</span>列会从字段清单中被略去。</p>
			<p><span>LOAD DATA INFILE</span>把所有的输入值当作字符串，所以您不能按照使用<span>INSERT</span>语句的方式使用<span>ENUM</span>或<span>SET</span>列的数字值。所有的<span>ENUM</span>和<span>SET</span>值必须被指定为字符串。</p>
			<p>当<span>LOAD DATA INFILE</span>语句结束时，会按以下格式返回一个信息字符串： 
			</p>
			<pre><span>Records: 1&nbsp; Deleted: 0&nbsp; Skipped: 0&nbsp; Warnings: 0</span></pre>
			<p>如果您正在使用<span>C API</span>，您可以通过调用<span>mysql_info()</span>函数获取有关语句的信息。请参见<a href="apis.html#mysql-info" title="25.2.3.34. mysql_info()">25.2.3.34节，“mysql_info()”</a>。</p>
			<p>当值通过<span>INSERT</span>语句被插入时或出现相同情况时，会发生警告（见<a href="sql-syntax.html#insert" title="13.2.4. INSERT Syntax">13.2.4节，“INSERT语法”</a>）。例外情况是，当输入行中字段过多或过少时，<span>LOAD 
			DATA INFILE</span>也生成警告。这些警告并不存储；警告的数量只用于指示运行是否良好。</p>
			<p>您可以使用<span>SHOW WARNINGS</span>来得到第一批<span>max_error_count</span>警告的清单，作为有关运行错误的信息。请参见<a href="sql-syntax.html#show-warnings" title="13.5.4.22. SHOW WARNINGS Syntax">13.5.4.22节，“SHOW 
		WARNINGS语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replace"></a>13.2.6. REPLACE语法</h3></div></div></div><a class="indexterm" name="id2904199"></a>
			<pre><span>REPLACE [LOW_PRIORITY | DELAYED]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; VALUES ({<span><i>expr</i></span> | DEFAULT},...),(...),...</span></pre>
			<p>或：</p>
			<pre><span>REPLACE [LOW_PRIORITY | DELAYED]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name</i></span>={<span><i>expr</i></span> | DEFAULT}, ...</span></pre>
			<p>或：</p>
			<pre><span>REPLACE [LOW_PRIORITY | DELAYED]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SELECT ...</span></pre>
			<p><span>REPLACE</span>的运行与<span>INSERT</span>很相像。只有一点除外，如果表中的一个旧记录与一个用于<span>PRIMARY 
			KEY</span>或一个<span>UNIQUE</span>索引的新记录具有相同的值，则在新记录被插入之前，旧记录被删除。请参见<a href="sql-syntax.html#insert" title="13.2.4. INSERT Syntax">13.2.4节，“INSERT语法”</a>。</p>
			<p>注意，除非表有一个<span>PRIMARY KEY</span>或<span>UNIQUE</span>索引，否则，使用一个<span>REPLACE</span>语句没有意义。该语句会与<span>INSERT</span>相同，因为没有索引被用于确定是否新行复制了其它的行。</p>
			<p>所有列的值均取自在<span>REPLACE</span>语句中被指定的值。所有缺失的列被设置为各自的默认值，这和<span>INSERT</span>一样。您不能从当前行中引用值，也不能在新行中使用值。如果您使用一个例如“<span>SET
			<i>col_name</i> = <i>col_name</i> + 1<span>”的赋值，则对位于右侧的列名称的引用会被作为</span>DEFAULT(<i>col_name</i>)</span>处理。因此，该赋值相当于<span>SET
			<i>col_name</i> = DEFAULT(<i>col_name</i>) + 1</span>。</p>
			<p>为了能够使用<span>REPLACE</span>，您必须同时拥有表的<span>INSERT</span>和<span>DELETE</span>权限。</p>
			<p><span>REPLACE</span>语句会返回一个数，来指示受影响的行的数目。该数是被删除和被插入的行数的和。如果对于一个单行<span>REPLACE</span>该数为<span>1</span>，则一行被插入，同时没有行被删除。如果该数大于<span>1</span>，则在新行被插入前，有一个或多个旧行被删除。如果表包含多个唯一索引，并且新行复制了在不同的唯一索引中的不同旧行的值，则有可能是一个单一行替换了多个旧行。</p>
			<p>受影响的行数可以容易地确定是否<span>REPLACE</span>只添加了一行，或者是否<span>REPLACE</span>也替换了其它行：检查该数是否为<span>1</span>（添加）或更大（替换）。</p>
			<p>如果您正在使用<span>C API</span>，则可以使用<span>mysql_affected_rows()</span>函数获得受影响的行数。</p>
			<p>目前，您不能在一个子查询中，向一个表中更换，同时从同一个表中选择。</p>
			<p>以下是所用算法的更详细的说明（该算法也用于<span>LOAD DATA...REPLACE</span>）：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>尝试把新行插入到表中</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>当因为对于主键或唯一关键字出现重复关键字错误而造成插入失败时：</p>
			<p>
			<span>a.<span>&nbsp;&nbsp;&nbsp;
			</span></span>从表中删除含有重复关键字值的冲突行</p>
			<p>
			<span>b.<span>&nbsp;&nbsp;&nbsp;
			</span></span>再次尝试把新行插入到表中</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="select"></a>13.2.7. SELECT语法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#join">13.2.7.1. 
			JOIN语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#union">13.2.7.2. 
			UNION语法<br>
&nbsp;</a></span></dt></dl></div><a class="indexterm" name="id2904508"></a>
			<pre><span>SELECT</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ALL | DISTINCT | DISTINCTROW ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [HIGH_PRIORITY]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [STRAIGHT_JOIN]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>select_expr</i></span>, ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO OUTFILE &#39;<span><i>file_name</i></span>&#39; <span><i>export_options</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | INTO DUMPFILE &#39;<span><i>file_name</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [FROM <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [GROUP BY {<span><i>col_name</i></span> | <span><i>expr</i></span> | <span><i>position</i></span>}</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ASC | DESC], ... [WITH ROLLUP]]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [HAVING <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ORDER BY {<span><i>col_name</i></span> | <span><i>expr</i></span> | <span><i>position</i></span>}</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ASC | DESC] , ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LIMIT {[<span><i>offset</i></span>,] <span><i>row_count</i></span> | <span><i>row_count</i></span> OFFSET <span><i>offset</i></span>}]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [PROCEDURE <span><i>procedure_name</i></span>(<span><i>argument_list</i></span>)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [FOR UPDATE | LOCK IN SHARE MODE]]</span></pre>
			<p><span>SELECT</span>用于恢复从一个或多个表中选择的行，并可以加入<span>UNION</span>语句和子查询。请参见<a href="sql-syntax.html#union" title="13.2.7.2. UNION Syntax">13.2.7.2节，“UNION语法<br>
		”</a>和<a href="sql-syntax.html#subqueries" title="13.2.8. Subquery Syntax">13.2.8节，“Subquery语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>每个<span><i><span>select_expr</span></i></span>都指示一个您想要恢复的列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><i><span>
			table_references</span></i></span>指示行从哪个表或哪些表中被恢复。在<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>中对该语法进行了说明。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><i><span>
			where_definition</span></i></span>包括关键词<span>WHERE</span>，后面接一个表达式。该表达式指示被选择的行必须满足的条件。</p>
			<p>有的行在计算时未引用任何表。<span>SELECT</span>也可以用于恢复这类行。</p>
			<p>举例说明：</p>
			<pre><span>mysql&gt; <span><b>SELECT 1 + 1;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></pre>
			<p>所有被使用的子句必须按语法说明中显示的顺序严格地排序。例如，一个<span>HAVING</span>子句必须位于<span>GROUP 
			BY</span>子句之后，并位于<span>ORDER BY</span>子句之前。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
            <a class="indexterm" name="id2931017"></a>

            <a class="indexterm" name="id2931018"></a>

            使用<span>AS <i>alias_name</i></span>可以为<span><i><span>select_expr</span></i></span>给定一个别名。此别名用作表达式的列名，可以用于<span>GROUP 
			BY</span>、<span>ORDER BY</span>或<span>HAVING</span>子句。例如：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT CONCAT(last_name,&#39;, &#39;,first_name) AS full_name</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>FROM mytable ORDER BY full_name;</b></span></span></pre>
			<p>在为<span><i><span>select_expr</span></i></span>给定别名时，<span>AS</span>关键词是自选的。前面的例子可以这样编写：</p>
			<pre><span>mysql&gt; <span><b>SELECT CONCAT(last_name,&#39;, &#39;,first_name) full_name</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>FROM mytable ORDER BY full_name;</b></span></span></pre>
			<p>因为<span>AS</span>是自选的，如果您忘记在两个<span><i><span>select_expr</span></i></span>表达式之间加逗号，则会出现一个小问题：<span>MySQL</span>会把第二个表达式理解为一个别名。例如，在以下语句中，<span>columnb</span>被作为别名对待：</p>
			<pre><span>mysql&gt; <span><b>SELECT columna columnb FROM mytable;</b></span></span></pre>
			<p>因此，使用<span>AS</span>明确地指定列的别名，把它作为习惯，是一个良好的操作规范。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一个<span>WHERE</span>子句中使用列别名是不允许的，因为当执行<span>WHERE</span>子句时，列值可能还没有被确定。请参见<a href="problems.html#problems-with-alias" title="A.5.4. Problems with Column Aliases">A.5.4节，“与列别名有关的问题”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FROM <i>
			table_references</i></span>子句指示行从哪些表中被恢复。如果您命名的表多于一个，则您在进行一个联合操作。要了解有关联合语法的说明，请参见<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>。对于每一个被指定的表，您可以自选地指定一个别名。</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span><i><span>tbl_name</span></i></span><span> [[AS] <span><i>alias</i></span>]</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;[{USE|IGNORE|FORCE} INDEX (<span><i>key_list</i></span>)]</span></pre>
			<p>使用<span>USE INDEX</span>、<span>IGNORE 
			INDEX</span>、<span>FORCE INDEX</span>可以向优化符提示如何选择索引。这部分内容在<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>中进行了讨论。</p>
			<p>您可以使用<span>SET 
			max_seeks_for_key=<i>value</i></span>作为一种替代方法，来促使<span>MySQL</span>优先采用关键字扫描，替代表扫描。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以把当前数据库中的一个表作为<span><i><span>tbl_name</span></i></span>（在当前数据库中）引用，或作为<span><i><span>db_name</span></i></span><span>.<span><i>tbl_name</i></span></span><span>引用</span>，来明确地指定一个数据库。您可以把一列作为<span><i><span>col_name</span></i></span><span>,
			<span><i>tbl_name</i></span>.<span><i>col_name</i></span></span><span>引用</span>或作为<span><i><span>db_name</span></i></span><span>.<span><i>tbl_name</i></span>.<span><i>col_name</i></span></span>引用。您不需要对一个列引用指定一个<span><i><span>tbl_name</span></i></span>或<span><i><span>db_name</span></i></span><span>.<span><i>tbl_name</i></span></span>前缀，除非此引用意义不明确。意义不明确时，要求指定明确的列引用格式。有关示例见<a href="language-structure.html#legal-names" title="9.2. Database, Table, Index, Column, and Alias Names">9.2节，“数据库、表、索引、列和别名”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
            <a class="indexterm" name="id2931019"></a>

            <a class="indexterm" name="id2931020"></a>

            <a class="indexterm" name="id2931021"></a>

            在没有表被引用的情况下，允许您指定<span>DUAL</span>作为一个假的表名。</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT 1 + 1 FROM DUAL;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; 2</span></pre>
			<p>有些服务器要求一个<span>FROM</span>子句。<span>DUAL</span>仅用于与这些服务器兼容。如果没有表被引用，则<span>MySQL</span>不要求该子句，前面的语句可以按以下方法编写：</p>
			<pre><span>mysql&gt; <span><b>SELECT 1 + 1;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span><i><span>tbl_name</span></i><span> 
			AS <i>alias_name</i></span></span>或<span><i><span>tbl_name 
			alias_name</span></i></span>可以为一个表引用起别名：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee AS t1, info AS t2</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee t1, info t2</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>WHERE</span>子句中，您可以使用<span>MySQL</span>支持的所有函数，不过总计（总结）函数除外。请参见<a href="functions.html">第12章：</a><a href="functions.html" title="Chapter 12. Functions and Operators"><i>函数和操作符</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>被选择的用于输出的列可以使用列名称、列别名或列位置被引用到<span>ORDER BY</span>和<span>GROUP 
			BY</span>子句中。列位置为整数，从<span>1</span>开始：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT college, region, seed FROM tournament</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ORDER BY region, seed;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT college, region AS r, seed AS s FROM tournament</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ORDER BY r, s;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT college, region, seed FROM tournament</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ORDER BY 2, 3;</b></span></span></pre>
			<p>要以相反的顺序进行分类，应把<span>DESC</span>（降序）关键字添加到<span>ORDER 
			BY</span>子句中的列名称中。默认值为升序；该值可以使用<span>ASC</span>关键词明确地指定。</p>
			<p>不建议使用列位置，因为该语法已经从<span>SQL</span>标准中删除。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>GROUP BY</span>，则输出行根据<span>GROUP 
			BY</span>列进行分类，如同您对相同的列进行了<span>ORDER BY</span>。<span>MySQL</span>对<span>GROUP 
			BY</span>进行了扩展，因此您可以在各列（在子句中进行命名）的后面指定<span>ASC</span>和<span>DESC</span>：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT a, COUNT(b) FROM test_table GROUP BY a DESC</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MySQL</span>对<span>GROUP BY</span>的使用进行了扩展，允许选择在<span>GROUP 
			BY</span>子句中没有被提到的字段。如果您没有得到预期的结果，请阅读<span>GROUP BY</span>的说明，请参见<a href="functions.html#group-by-functions-and-modifiers" title="12.10. Functions and Modifiers for Use with GROUP BY Clauses">12.10节，“与GROUP BY子句同时使用的函数和修改程序<code class="literal"></code>”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>GROUP BY</span>允许一个<span>WITH 
			ROLLUP</span>修饰符。请参见<a href="functions.html#group-by-modifiers" title="12.10.2. GROUP BY Modifiers">12.10.2节，“GROUP 
			BY修改程序”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HAVING</span>子句基本上是最后使用，只位于被发送给客户端的条目之前，没有进行优化。（<span>LIMIT</span>用于<span>HAVING</span>之后。）</p>
			<p><span>SQL</span>标准要求<span>HAVING</span>必须引用<span>GROUP 
			BY</span>子句中的列或用于总计函数中的列。不过，<span>MySQL</span>支持对此工作性质的扩展，并允许<span>HAVING</span>因为<span>SELECT</span>清单中的列和外部子查询中的列。</p>
			<p>如果<span>HAVING</span>子句引用了一个意义不明确的列，则会出现警告。在下面的语句中，<span>col2</span>意义不明确，因为它既作为别名使用，又作为列名使用：</p>
			<pre><span>mysql&gt; <span><b>SELECT COUNT(col1) AS col2 FROM t GROUP BY col2 HAVING col2 = 2;</b></span></span></pre>
			<p>标准<span>SQL</span>工作性质具有优先权，因此如果一个<span>HAVING</span>列名既被用于<span>GROUP 
			BY</span>，又被用作输出列清单中的起了别名的列，则优先权被给予<span>GROUP BY</span>列中的列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HAVING</span>不能用于应被用于<span>WHERE</span>子句的条目。例如，不能编写如下语句：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT <i>col_name</i> FROM <i>tbl_name</i> HAVING <i>col_name</i> &gt; 0;</b></span></span></pre>
			<p>而应这么编写：</p>
			<pre><span>mysql&gt; <span><b>SELECT <i>col_name</i> FROM <i>tbl_name</i> WHERE <i>col_name</i> &gt; 0;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HAVING</span>子句可以引用总计函数，而<span>WHERE</span>子句不能引用：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT user, MAX(salary) FROM users</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>GROUP BY user HAVING MAX(salary)&gt;10;</b></span></span></pre>
			<p>（在有些较早版本的<span>MySQL</span>中，本语句不运行。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>LIMIT</span>子句可以被用于限制被<span>SELECT</span>语句返回的行数。<span>LIMIT</span>取一个或两个数字自变量，自变量必须是非负的整数常数（当使用已预备的语句时除外）。</p>
			<p>
			使用两个自变量时，第一个自变量指定返回的第一行的偏移量，第二个自变量指定返回的行数的最大值。初始行的偏移量为<span>0</span>（不是<span>1</span>）：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM tbl LIMIT 5,10;&nbsp; # Retrieve rows 6-15</b></span></span></pre>
			<p>为了与<span>PostgreSQL</span>兼容，<span>MySQL</span>也支持<span>LIMIT
			<span><i>row_count</i> OFFSET <i>offset</i></span></span>语法。</p>
			<p>
			如果要恢复从某个偏移量到结果集合的末端之间的所有的行，您可以对第二个参数是使用比较大的数。本语句可以恢复从第<span>96</span>行到最后的所有行：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM tbl LIMIT 95,18446744073709551615;</b></span></span></pre>
			<p>使用<span>1</span>个自变量时，该值指定从结果集合的开头返回的行数：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM tbl LIMIT 5;&nbsp;&nbsp;&nbsp;&nbsp; # Retrieve first 5 rows</b></span></span></pre>
			<p>换句话说，<span>LIMIT n</span>与<span>LIMIT 
			0,n</span>等价。</p>
			<p>对于已预备的语句，您可以使用位置保持符。以下语句将从<span>tb1</span>表中返回一行：</p>
			<pre><span>mysql&gt; <span><b>SET @a=1;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>PREPARE STMT FROM &quot;SELECT * FROM tbl LIMIT ?&quot;;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>EXECUTE STMT USING @a;</b></span></span></pre>
			<p>以下语句将从<span>tb1</span>表中返回第二到第六行：</p>
			<pre><span>mysql&gt; <span><b>SET @skip=1; SET @numrows=5;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>PREPARE STMT FROM &quot;SELECT * FROM tbl LIMIT ?, ?&quot;;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>EXECUTE STMT USING @skip, @numrows;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SELECT...INTO OUTFILE<span> 
			&#39;<i>file_name</i>&#39;</span></span>形式的<span>SELECT</span>可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有<span>FILE</span>权限，才能使用此语法。<span><i><span>file_name</span></i></span>不能是一个原有的文件。原有文件会阻止例如“<span>/etc/passwd</span>”的文件和数据库表被销毁。</p>
			<p><span>SELECT...INTO OUTFILE</span>语句的主要作用是让您可以非常快速地把一个表转储到服务器机器上。如果您想要在服务器主机之外的部分客户主机上创建结果文件，您不能使用<span>SELECT...INTO 
			OUTFILE</span>。在这种情况下，您应该在客户主机上使用比如“<span>mysql </span>–<span>e
			<span>&quot;SELECT ...&quot; &gt; file_name</span></span><span>”的命令，来生成文件。</span></p>
			<p><span>SELECT...INTO OUTFILE</span>是<span>LOAD 
			DATA INFILE</span>的补语；用于语句的<span>exort_options</span>部分的语法包括部分<span>FIELDS</span>和<span>LINES</span>子句，这些子句与<span>LOAD 
			DATA INFILE</span>语句同时使用。请参见<a href="sql-syntax.html#load-data" title="13.2.5. LOAD DATA INFILE Syntax">13.2.5节，“LOAD DATA INFILE语法”</a>。</p>
			<p><span>FIELDS ESCAPED BY</span>用于控制如何写入特殊字符。如果<span>FIELDS 
			ESCAPED BY</span>字符不是空字符，则被用于在输出中对以下字符设前缀：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>FIELDS ESCAPED BY</span>字符</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>FIELDS [OPTIONALLY] ENCLOSED BY</span>字符</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>FIELDS TERMINATED BY</span>和<span>LINES 
			TERMINATED BY</span>值的第一个字符</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>ASCII 0</span>（在编写时接在转义符后面的是<span>ASCII
			</span>‘<span>0</span>’，而不是一个零值字节）</p>
			<p>如果<span>FIELDS ESCAPED BY</span>字符是空字符，则没有字符被转义，并且<span>NULL</span>被作为<span>NULL</span>输出，而不是作为<span>\N</span>输出。指定一个空的转义符不是一个好的主意。特别是当您的数据中的字段值包含刚被给予的清单中的字符时，更是如此。</p>
			<p>其原因是您必须对所有<span>FIELDS 
			TERMINATED BY, ENCLOSED BY, ESCAPED BY</span>或<span>LINES 
			TERMINATED BY</span>字符进行转义，才能可靠地读取文件并返回。<span>ASCII NUL</span>被转义，以便更容易地使用调页程序观看。</p>
			<p>生成的文件不必符合<span>SQL</span>语法，所以没有其它的字符需要被转义。</p>
			<p>在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。</p>
			<pre><span>SELECT a,b,a+b INTO OUTFILE &#39;/tmp/result.text&#39;</span></pre>
			<pre><span>FIELDS TERMINATED BY &#39;,&#39; OPTIONALLY ENCLOSED BY &#39;&quot;&#39;</span></pre>
			<pre><span>LINES TERMINATED BY &#39;\n&#39;</span></pre>
			<pre><span>FROM test_table;</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>INTO DUMPFILE</span>代替<span>INTO 
			OUTFILE</span>，则<span>MySQL</span>只把一行写入到文件中，不对任何列或行进行终止，也不执行任何转义处理。如果您想要把一个<span>BLOB</span>值存储到文件中，则这个语句是有用的。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>注释：任何由<span>INTO OUTFILE</span>或<span>INTO 
			DUMPFILE</span>创建的文件都可以被服务器主机上的所有用户编写。原因是，<span>MySQL</span>服务器不能创建这样的文件，即文件的所有者不是该文件运行时所属的用户（任何时候，您都不能出于此原因或出于其它原因把<strong><span>mysqld</span></strong>作为根段运行）。该文件必须是全局可写的，这样您就可以操作其中的内容。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>有的过程应在结果集合内处理数据。<span>PROCEDURE</span>子句用于对这些过程进行命名。要了解示例，请参见<a href="extending-mysql.html#procedure-analyse" title="27.3.1. Procedure Analyse">27.3.1节，“步骤分析”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>存储引擎使用页面或行锁。如果您对存储引擎使用<span>FOR UPDATE</span>，则受到查询检验的行会被进行写锁定，直到当前事务结束为止。使用<span>LOCK 
			IN SHARE MODE</span>可以设置一个共享锁。共享锁可以防止其它事务更新或删除被检验的行。请参见<a href="storage-engines.html#innodb-locking-reads" title="15.2.10.5. Locking Reads SELECT ... FOR UPDATE and SELECT ... LOCK IN SHARE MODE">15.2.10.5节，“锁定读取SELECT ... FOR UPDATE和SELECT ... LOCK IN SHARE MODE”</a>。</p>
			<p>在<span>SELECT</span>关键词的后面，您可以使用许多选项。这些选项可以影响语句的运行。</p>
			<p><span>ALL, DISTINCT</span>和<span>DISTINCTROW</span>选项指定是否重复行应被返回。如果这些选项没有被给定，则默认值为<span>ALL</span>（所有的匹配行被返回）。<span>DISTINCT</span>和<span>DISTINCTROW</span>是同义词，用于指定结果集合中的重复行应被删除。</p>
			<p><span>HIGH_PRIORITY, STRAIGHT_JOIN</span>和以<span>SQL_</span>为开头的选项是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HIGH_PRIORITY</span>给予<span>SELECT</span>更高的优先权，高于用于更新表的语句。您应该只对查询使用<span>HIGH_PRIORITY</span>。查询速度非常快，而且立刻被执行。<span>SELECT 
			HIGH_PRIORITY</span>查询在表被锁定用于读取时被发出。即使有一个新的语句正在等待表变为空闲，查询也会运行。</p>
			<p><span>HIGH_PRIORITY</span>不能和<span>SELECT</span>语句同时使用。<span>SELECT</span>语句是<span>UNION</span>的一部分。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>STRAIGHT_JOIN</span>用于促使优化符把表联合在一起，顺序按照这些表在<span>FROM</span>子句中排列的顺序。如果优化符联合表时顺序不佳，您可以使用<span>STRAIGHT_JOIN</span>来加快查询的速度。请参见<a href="optimization.html#explain" title="7.2.1. EXPLAIN Syntax (Get Information About a SELECT)">7.2.1节，“EXPLAIN语法（获取关于SELECT的信息）<code class="literal"></code>”</a>。<span>STRAIGHT_JOIN</span>也可以被用于<span><i><span>table_references</span></i></span>清单中。请参见<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_BIG_RESULT</span>可以与<span>GROUP 
			BY</span>或<span>DISTINCT</span>同时使用，来告知优化符结果集合有很多行。在这种情况下，<span>MySQL</span>直接使用以磁盘为基础的临时表（如果需要的话）。在这种情况下，<span>MySQL</span>还会优先进行分类，不优先使用临时表。临时表对于<span>GROUP 
			BY</span>组分带有关键字。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_BUFFER_RESULT</span>促使结果被放入一个临时表中。这可以帮助<span>MySQL</span>提前解开表锁定，在需要花费较长时间的情况下，也可以帮助把结果集合发送到客户端中。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_SMALL_RESULT</span>可以与<span>GROUP 
			BY</span>或<span>DISTINCT</span>同时使用，来告知优化符结果集合是较小的。在此情况下，<span>MySAL</span>使用快速临时表来储存生成的表，而不是使用分类。在<span>MySQL 
			5.1</span>中，通常不需要这样。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_CALC_FOUND_ROWS</span>告知<span>MySQL</span>计算有多少行应位于结果集合中，不考虑任何<span>LIMIT</span>子句。行的数目可以使用<span>SELECT 
			FOUND_ROWS()</span>恢复。请参见<a href="functions.html#information-functions" title="12.9.3. Information Functions">12.9.3节，“信息函数”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您正在使用一个<span>query_cache_type</span>值，值为<span>2</span>或<span>DEMAND</span>，则<span>SQL_CACHE</span>告知<span>MySQL</span>把查询结果存储在查询缓存中。对于使用<span>UNION</span>的查询或子查询，本选项会影响查询中的所有<span>SELECT</span>。请参见<a href="database-administration.html#query-cache" title="5.13. The MySQL Query Cache">5.13节，“MySQL查询高速缓冲”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_NO_CACHE</span>告知<span>MySQL</span>不要把查询结果存储在查询缓存中。请参见<a href="database-administration.html#query-cache" title="5.13. The MySQL Query Cache">5.13节，“MySQL查询高速缓冲”</a>。对于一个使用<span>UNION</span>或子查询的查询，本选项会影响查询中的<span>SELECT</span>。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="join"></a>13.2.7.1. JOIN语法</h4></div></div></div><a class="indexterm" name="id2906549"></a><a class="indexterm" name="id2906558"></a><a class="indexterm" name="id2906567"></a><a class="indexterm" name="id2906576"></a><a class="indexterm" name="id2906585"></a><a class="indexterm" name="id2906594"></a><a class="indexterm" name="id2906603"></a><a class="indexterm" name="id2906612"></a><a class="indexterm" name="id2906621"></a><a class="indexterm" name="id2906630"></a><a class="indexterm" name="id2906639"></a><a class="indexterm" name="id2906648"></a><a class="indexterm" name="id2906658"></a>
				<p><span>MySQL</span>支持以下<span>JOIN</span>语法。这些语法用于<span>SELECT</span>语句的<span><i><span>table_references</span></i></span>部分和多表<span>DELETE</span>和<span>UPDATE</span>语句：</p>
				<pre class="programlisting"><em class="replaceable">table_references:</em>
    <em class="replaceable">table_reference</em> [, <em class="replaceable">table_reference</em>] …

<em class="replaceable">table_reference</em>:
    <em class="replaceable">table_factor</em>
  | <em class="replaceable">join_table</em>

<em class="replaceable">table_factor</em>:
    <em class="replaceable">tbl_name</em> [[AS] <em class="replaceable">alias</em>]
        [{USE|IGNORE|FORCE} INDEX (<em class="replaceable">key_list</em>)]
  | ( <em class="replaceable">table_references</em> )
  | { OJ <em class="replaceable">table_reference</em> LEFT OUTER JOIN <em class="replaceable">table_reference</em>
        ON <em class="replaceable">conditional_expr</em> }

<em class="replaceable">join_table</em>:
    <em class="replaceable">table_reference</em> [INNER | CROSS] JOIN <em class="replaceable">table_factor</em> [<em class="replaceable">join_condition</em>]
  | <em class="replaceable">table_reference</em> STRAIGHT_JOIN <em class="replaceable">table_factor</em>
  | <em class="replaceable">table_reference</em> STRAIGHT_JOIN <em class="replaceable">table_factor</em> ON <em class="replaceable">condition</em>
  | <em class="replaceable">table_reference</em> LEFT [OUTER] JOIN <em class="replaceable">table_reference</em> <em class="replaceable">join_condition</em>
  | <em class="replaceable">table_reference</em> NATURAL [LEFT [OUTER]] JOIN <em class="replaceable">table_factor</em>
  | <em class="replaceable">table_reference</em> RIGHT [OUTER] JOIN <em class="replaceable">table_reference</em> <em class="replaceable">join_condition</em>
  | <em class="replaceable">table_reference</em> NATURAL [RIGHT [OUTER]] JOIN <em class="replaceable">table_factor</em>

<em class="replaceable">join_condition</em>:
    ON <em class="replaceable">conditional_expr</em>
  | USING (<em class="replaceable">column_list</em>)
</pre>
				<p>一个表引用还被称为一个联合表达式。</p>
				<p>与<span>SQL</span>标准相比，<span><i><span>table_factor</span></i></span>的语法被扩展了。<span>SQL</span>标准只接受<span><i><span>table_reference</span></i></span>，而不是圆括号内的一系列条目。</p>
				<p>如果我们把一系列<span><i><span>table_reference</span></i></span>条目中的每个逗号都看作相当于一个内部联合，则这是一个稳妥的扩展。例如：</p>
				<pre><span>SELECT * FROM t1 LEFT JOIN (t2, t3, t4)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span></pre>
				<p>相当于：</p>
				<pre><span>SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span></pre>
				<p>在<span>MySQL</span>中，<span>CROSS JOIN</span>从语法上说与<span>INNER 
				JOIN</span>等同（两者可以互相替换。在标准<span>SQL</span>中，两者是不等同的。<span>INNER 
				JOIN</span>与<span>ON</span>子句同时使用，<span>CROSS 
				JOIN</span>以其它方式使用。</p>
				<p>通常，在只含有内部联合运行的联合表达式中，圆括号可以被忽略。<span>MySQL</span>也支持嵌套的联合（见<a href="optimization.html#nested-joins" title="7.2.10. How MySQL Optimizes Nested Joins">7.2.10节，“MySQL如何优化嵌套Join”</a>）。</p>
				<p>通常，您不应对<span>ON</span>部分有任何条件。<span>ON</span>部分用于限定在结果集合中您想要哪些行。但是，您应在<span>WHERE</span>子句中指定这些条件。这条规则有一些例外。</p>
				<p>在前面的清单中显示的<span><span>{ OJ 
				... LEFT OUTER JOIN ...}</span>语法的目的只是为了保持与<span>ODBC</span>的兼容性。语法中的花括号应按字面书写；该括号不是中间语法。中间语法用于语法描述的其它地方。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>表引用可以使用<span><i><span>tbl_name</span></i><span> 
				AS <i>alias_name</i></span></span>或<span><i><span>tbl_name 
				alias_name</span></i></span>指定别名：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee AS t1, info AS t2</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee t1, info t2</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>ON</span>条件句是可以被用于<span>WHERE</span>子句的格式的任何条件表达式。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果对于在<span>LEFT JOIN</span>中的<span>ON</span>或<span>USING</span>部分中的右表没有匹配的记录，则所有列被设置为<span>NULL</span>的一个行被用于右表。如果一个表在其它表中没有对应部分，您可以使用这种方法在这种表中查找记录：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT table1.* FROM table1</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LEFT JOIN table2 ON table1.id=table2.id</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE table2.id IS NULL;</b></span></span></pre>
				<p>本例查找在<span>table1</span>中含有一个<span>id</span>值的所有行。同时，在<span>table2</span>中没有此<span>id</span>值（即，<span>table1</span>中的所有行在<span>table2</span>中没有对应的行）。本例假设<span>table2.id</span>被定义为<span>NOT 
				NULL</span>。请参见<a href="optimization.html#left-join-optimization" title="7.2.9. How MySQL Optimizes LEFT JOIN and RIGHT JOIN">7.2.9节，“MySQL如何优化LEFT JOIN和RIGHT 
				JOIN”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				USING(<i>column_list</i>)</span>子句用于为一系列的列进行命名。这些列必须同时在两个表中存在。如果表<span>a</span>和表<span>b</span>都包含列<span>c1, 
				c2</span>和<span>c3</span>，则以下联合会对比来自两个表的对应的列：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>a LEFT JOIN b USING (c1,c2,c3)</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>两个表的<span>NATURAL [LEFT] JOIN</span>被定义为与<span>INNER 
				JOIN</span>语义相同，或与使用<span>USING</span>子句的<span>LEFT 
				JOIN</span>语义相同。<span>USING</span>子句用于为同时存在于两个表中的所有列进行命名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INNER JOIN</span>和，（逗号）在无联合条件下是语义相同的：两者都可以对指定的表计算出笛卡儿乘积（也就是说，第一个表中的每一行被联合到第二个表中的每一行）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>RIGHT JOIN</span>的作用与<span>LEFT 
				JOIN</span>的作用类似。要使代码可以在数据库内移植，建议您使用<span>LEFT JOIN</span>代替<span>RIGHT 
				JOIN</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>STRAIGHT_JOIN</span>与<span>JOIN</span>相同。除了有一点不一样，左表会在右表之前被读取。<span>STRAIGH_JOIN</span>可以被用于这样的情况，即联合优化符以错误的顺序排列表。</p>
				<p>您可以提供提示，当从一个表中恢复信息时，<span>MySQL</span>应使用哪个索引。通过指定<span>USE 
				INDEX</span>（<span>key_list</span>），您可以告知<span>MySQL</span>只使用一个索引来查找表中的行。另一种语法<span>IGNORE 
				INDEX</span>（<span>key_list</span>）可以被用于告知<span>MySQL</span>不要使用某些特定的索引。如果<span>EXPLAIN</span>显示<span>MySQL</span>正在使用来自索引清单中的错误索引时，这些提示会有用处。</p>
				<p>您也可以使用<span>FORCE INDEX</span>，其作用接近<span>USE 
				INDEX</span>（<span>key_list</span>），不过增加了一项作用，一次表扫描被假设为代价很高。换句话说，只有当无法使用一个给定的索引来查找表中的行时，才使用表扫描。</p>
				<p><span>USE KEY</span>、<span>IGNORE KEY</span>和<span>FORCE 
				KEY</span>是<span>USE INDEX</span>、<span>IGNORE 
				INDEX</span>和<span>FORCE INDEX</span>的同义词。</p>
				<p>注释：当<span>MySQL</span>决定如何在表中查找行并决定如何进行联合时，使用<span>USE 
				INDEX</span>、<span>IGNORE INDEX</span>和<span>FORCE 
				INDEX</span>只会影响使用哪些索引。当分解一个<span>ORDER BY</span>或<span>GROUP 
				BY</span>时，这些语句不会影响某个索引是否被使用。</p>
				<p>部分的联合示例：</p>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1,table2 WHERE table1.id=table2.id;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 LEFT JOIN table2 USING (id);</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LEFT JOIN table3 ON table2.id=table3.id;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 USE INDEX (key1,key2)</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE key1=1 AND key2=2 AND key3=3;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 IGNORE INDEX (key3)</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE key1=1 AND key2=2 AND key3=3;</b></span></span></pre>
				<p>见<a href="optimization.html#left-join-optimization" title="7.2.9. How MySQL Optimizes LEFT JOIN and RIGHT JOIN">7.2.9节，“MySQL如何优化LEFT JOIN和RIGHT 
				JOIN”</a>。</p>
				<p>注释：自然联合和使用<span>USING</span>的联合，包括外部联合变量，依据<span>SQL:2003</span>标准被处理。这些变更时<span>MySQL</span>与标准<span>SQL</span>更加相符。不过，对于有些联合，这些变更会导致不同的输出列。另外，有些查询在旧版本（<span>5.0.12</span>以前）工作正常，但也必须重新编写，以符合此标准。对于有关当前联合处理和旧版本中的联合处理的效果的对比，以下列表提供了更详细的信息。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>NATURAL</span>联合或<span>USING</span>联合的列会与旧版本不同。特别是，不再出现冗余的输出列，用于<span>SELECT 
				*</span>扩展的列的顺序会与以前不同。</p>
				<p>示例：</p>
				<pre><span>CREATE TABLE t1 (i INT, j INT);</span></pre>
				<pre><span>CREATE TABLE t2 (k INT, j INT);</span></pre>
				<pre><span>INSERT INTO t1 VALUES(1,1);</span></pre>
				<pre><span>INSERT INTO t2 VALUES(1,1);</span></pre>
				<pre><span>SELECT * FROM t1 NATURAL JOIN t2;</span></pre>
				<pre><span>SELECT * FROM t1 JOIN t2 USING (j);</span></pre>
				<p>对于旧版本，语句会产生以下输出：</p>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>| i&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>| i&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<p>在第一个<span>SELECT</span>语句中，列<span>i</span>同时出现在两个表中，为一个联合列，所以，依据标准<span>SQL</span>，该列在输出中只出现一次。与此类似，在第二个<span>SELECT</span>语句中，列<span>j</span>在<span>USING</span>子句中被命名，应在输出中只出现一次。但是，在两种情况下，冗余的列均没被消除。另外，依据标准<span>SQL</span>，列的顺序不正确。</p>
				<p>现在，语句产生如下输出：</p>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>| j&nbsp;&nbsp;&nbsp; | i&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>| j&nbsp;&nbsp;&nbsp; | i&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<p>冗余的列被消除，并且依据标准<span>SQL</span>，列的顺序是正确的：</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>第一，两表共有的列，按在第一个表中的顺序排列</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>第二，第一个表中特有的列，按该表中的顺序排列</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>第三，第二个表中特有的列，按该表中的顺序排列</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对多方式自然联合的估算会不同。方式要求重新编写查询。假设您有三个表<span>t1(a,b)</span><span>,
				<span>t2(c,b)</span></span>和<span>t3(a,c)</span>，每个表有一行：<span>t1(1,2)</span><span>,
				<span>t2(10,2)</span></span>和<span>t3(7,10)</span>。同时，假设这三个表具有<span>NATURAL 
				JOIN</span>：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT </span>…<span> FROM t1 NATURAL JOIN t2 NATURAL JOIN t3;</span></pre>
				<p>在旧版本中，第二个联合的左操作数被认为是<span>t2</span>，然而它应该为嵌套联合（<span>t1 
				NATURAL JOIN t2</span>）。结果，对<span>t3</span>的列进行检查时，只检查其在<span>t2</span>中的共有列。如果<span>t3</span>与<span>t1</span>有共有列，这些列不被用作<span>equi-join</span>列。因此，在旧版本的<span>MySQL</span>中，前面的查询被转换为下面的<span>equi-join</span>：</p>
				<pre><span>SELECT </span>…<span> FROM t1, t2, t3</span></pre>
				<pre><span>&nbsp; WHERE t1.b = t2.b AND t2.c = t3.c;</span></pre>
				<p>此联合又省略了一个<span>equi-join</span>谓语（<span>t1.a 
				= t3.a</span>）。结果是，该联合产生一个行，而不是空结果。正确的等价查询如下：</p>
				<pre><span>SELECT </span>…<span> FROM t1, t2, t3</span></pre>
				<pre><span>&nbsp; WHERE t1.b = t2.b AND t2.c = t3.c AND t1.a = t3.a;</span></pre>
				<p>如果您要求在当前版本的<span>MySQL</span>中获得和旧版本中相同的查询结果，应把自然联合改写为第一个<span>equi-join</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在旧版本中，逗号操作符（，）和<span>JOIN</span>均有相同的优先权，所以联合表达式<span>t1, 
				t2 JOIN t3</span>被理解为<span>((t1, 
				t2) JOIN t3)</span>。现在，<span>JOIN</span>有更高的优先权，所以表达式被理解为<span>(t1, 
				(t2 JOIN t3))</span>。这个变更会影响使用<span>ON</span>子句的语句，因为该子句只参阅联合操作数中的列。优先权的变更改变了对什么是操作数的理解。</p>
				<p>示例：</p>
				<pre><span>CREATE TABLE t1 (i1 INT, j1 INT);</span></pre>
				<pre><span>CREATE TABLE t2 (i2 INT, j2 INT);</span></pre>
				<pre><span>CREATE TABLE t3 (i3 INT, j3 INT);</span></pre>
				<pre><span>INSERT INTO t1 VALUES(1,1);</span></pre>
				<pre><span>INSERT INTO t2 VALUES(1,1);</span></pre>
				<pre><span>INSERT INTO t3 VALUES(1,1);</span></pre>
				<pre><span>SELECT * FROM t1, t2 JOIN t3 ON (t1.i1 = t3.i3);</span></pre>
				<p>在旧版本中，<span>SELECT</span>是合法的，因为<span>t1, 
				t2</span>被隐含地归为<span>(t1,t2)</span>。现在，<span>JOIN</span>取得了优先权，因此用于<span>ON</span>子句的操作数是<span>t2</span>和<span>t3</span>。因为<span>t1.i1</span>不是任何一个操作数中的列，所以结果是出现在<span><span>&#39;on 
				clause&#39;</span>中有未知列<span>&#39;t1.i1&#39;</span>的错误。要使联合可以被处理，用使用圆括号把前两个表明确地归为一组，这样用于<span>ON</span>子句的操作数为<span>(t1,t2)</span>和<span>t3</span>：</span></p>
				<pre><span>SELECT * FROM (t1, t2) JOIN t3 ON (t1.i1 = t3.i3);</span></pre>
				<p>本变更也适用于<span>INNER JOIN</span>，<span>CROSS 
				JOIN</span>，<span>LEFT JOIN</span>和<span>RIGHT 
				JOIN</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在旧版本中，<span>ON</span>子句可以参阅在其右边命名的表中的列。现在，<span>ON</span>子句只能参阅操作数。</p>
				<p>示例：</p>
				<pre><span>CREATE TABLE t1 (i1 INT);</span></pre>
				<pre><span>CREATE TABLE t2 (i2 INT);</span></pre>
				<pre><span>CREATE TABLE t3 (i3 INT);</span></pre>
				<pre><span>SELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3;</span></pre>
				<p>在旧版本中，<span>SELECT</span>语句是合法的。现在该语句会运行失败，出现在<span>&#39;on 
				clause&#39;</span>中未知列<span>&#39;i3&#39;</span>的错误。这是因为<span>i3</span>是<span>t3</span>中的一个表，而<span>t3</span>不是<span>ON</span>子句中的操作数。本语句应进行如下改写：</p>
				<pre><span>SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在旧版本中，一个<span>USING</span>子句可以被改写为一个<span>ON</span>子句。<span>ON</span>子句对比了相应的列。例如，以下两个子句具有相同的语义：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>a LEFT JOIN b USING (c1,c2,c3)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>a LEFT JOIN b ON a.c1=b.c1 AND a.c2=b.c2 AND a.c3=b.c3</span></pre>
				<p>现在，这两个子句不再是一样的：</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在决定哪些行满足联合条件时，两个联合保持语义相同。</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在决定哪些列显示<span>SELECT *</span>扩展时，两个联合的语义不相同。<span>USING</span>联合选择对应列中的合并值，而<span>ON</span>联合选择所有表中的所有列。对于前面的<span>USING</span>联合，<span>SELECT 
				*</span>选择这些值：</p>
				<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>COALESCE(a.c1,b.c1), COALESCE(a.c2,b.c2), COALESCE(a.c3,b.c3)</span></pre>
				<p>对于<span>ON</span>联合，<span>SELECT 
				*</span>选择这些值：</p>
				<pre><span>a.c1, a.c2, a.c3, b.c1, b.c2, b.c3</span></pre>
				<p>使用内部联合时，<span>COALESCE<span>(a.c1,b.c1)</span></span><span>与<span>a.c1</span>或<span>b.c1</span>相同，因为两列将具有相同的值。使用外部联合时（比如<span>LEFT 
				JOIN</span>），两列中有一列可以为<span>NULL</span>。该列将会从结果中被忽略。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="union"></a>13.2.7.2. UNION语法<br>
&nbsp;</h4></div></div></div><a class="indexterm" name="id2908061"></a></div></div><div class="section"><div class="titlepage"><div><div>
			<pre><span>SELECT ...</span></pre>
			<pre><span>UNION [ALL | DISTINCT]</span></pre>
			<pre><span>SELECT ...</span></pre>
			<pre><span>[UNION [ALL | DISTINCT]</span></pre>
			<pre><span>SELECT ...]</span></pre>
			<p><span>UNION</span>用于把来自许多<span>SELECT</span>语句的结果组合到一个结果集合中。</p>
			<p>列于每个<span>SELECT</span>语句的对应位置的被选择的列应具有相同的类型。（例如，被第一个语句选择的第一列应和被其它语句选择的第一列具有相同的类型。）在第一个<span>SELECT</span>语句中被使用的列名称也被用于结果的列名称。</p>
			<p><span>SELECT</span>语句为常规的选择语句，但是受到如下的限定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只有最后一个<span>SELECT</span>语句可以使用<span>INTO 
			OUTFILE</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HIGH_PRIORITY</span>不能与作为<span>UNION</span>一部分的<span>SELECT</span>语句同时使用。如果您对第一个<span>SELECT</span>指定了<span>HIGH_PRIORITY</span>，则不会起作用。如果您对其它后续的<span>SELECT</span>语句指定了<span>HIGH_PRIORITY</span>，则会产生语法错误。</p>
			<p>如果您对<span>UNION</span>不使用关键词<span>ALL</span>，则所有返回的行都是唯一的，如同您已经对整个结果集合使用了<span>DISTINCT</span>。如果您指定了<span>ALL</span>，您会从所有用过的<span>SELECT</span>语句中得到所有匹配的行。</p>
			<p><span>DISTINCT</span>关键词是一个自选词，不起任何作用，但是根据<span>SQL</span>标准的要求，在语法中允许采用。（在<span>MySQL</span>中，<span>DISTINCT</span>代表一个共用体的默认工作性质。）</p>
			<p>您可以在同一查询中混合<span>UNION ALL</span>和<span>UNION 
			DISTINCT</span>。被混合的<span>UNION</span>类型按照这样的方式对待，即<span>DISTICT</span>共用体覆盖位于其左边的所有<span>ALL</span>共用体。<span>DISTINCT</span>共用体可以使用<span>UNION 
			DISTINCT</span>明确地生成，或使用<span>UNION</span>（后面不加<span>DISTINCT</span>或<span>ALL</span>关键词）隐含地生成。</p>
			<p>如果您想使用<span>ORDER BY</span>或<span>LIMIT</span>子句来对全部<span>UNION</span>结果进行分类或限制，则应对单个地<span>SELECT</span>语句加圆括号，并把<span>ORDER 
			BY</span>或<span>LIMIT</span>放到最后一个的后面。以下例子同时使用了这两个子句：</p>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=10 AND B=1)</span></pre>
			<pre><span>UNION</span></pre>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=11 AND B=2)</span></pre>
			<pre><span>ORDER BY a LIMIT 10;</span></pre>
			<p>这种<span>ORDER BY</span>不能使用包括表名称（也就是，采用<span><i><span>tbl_name</span></i></span><span>.<span><i>col_name</i></span></span>格式的名称）列引用。可以在第一个<span>SELECT</span>语句中提供一个列别名，并在<span>ORDER 
			BY</span>中参阅别名，或使用列位置在<span>ORDER BY</span>中参阅列。（首选采用别名，因为不建议使用列位置。）</p>
			<p>另外，如果带分类的一列有别名，则<span>ORDER BY</span>子句必须引用别名，而不能引用列名称。以下语句中的第一个语句必须运行，但是第二个会运行失败，出现在<span>&#39;order 
			clause&#39;</span>中有未知列<span>&#39;a&#39;</span>的错误：</p>
			<pre><span>(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY b;</span></pre>
			<pre><span>(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY a;</span></pre>
			<p><span>To apply <span>ORDER BY</span> 
			or <span>LIMIT</span> to an individual
			<span>SELECT</span>, place the clause inside 
			the parentheses that enclose the <span>
			SELECT</span>:&nbsp;&nbsp; </span>为了对单个<span>SELECT</span>使用<span>ORDER 
			BY</span>或<span>LIMIT</span>，应把子句放入圆括号中。圆括号包含了<span>SELECT</span>：</p>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=10 AND B=1 ORDER BY a LIMIT 10)</span></pre>
			<pre><span>UNION</span></pre>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=11 AND B=2 ORDER BY a LIMIT 10);</span></pre>
			<p>圆括号中用于单个<span>SELECT</span>语句的<span>ORDER BY</span>只有当与<span>LIMIT</span>结合后，才起作用。否则，<span>ORDER 
			BY</span>被优化去除。</p>
			<p><span>UNION</span>结果集合中的列的类型和长度考虑了被所有<span>SELECT</span>语句恢复的数值。例如，考虑如下语句：</p>
			<pre><span>mysql&gt; <span><b>SELECT REPEAT(&#39;a&#39;,1) UNION SELECT REPEAT(&#39;b&#39;,10);</b></span></span></pre>
			<pre><span>+---------------+</span></pre>
			<pre><span>| REPEAT(&#39;a&#39;,1) |</span></pre>
			<pre><span>+---------------+</span></pre>
			<pre><span>| a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| bbbbbbbbbb&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+---------------+</span></pre>
			<p>（在部分早期版本的<span>MySQL</span>中，第二行已被删节到长度为<span>1</span>。）</p>
			<h3 class="title"><a name="subqueries"></a>
			13.2.8.&nbsp;Subquery语法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#scalar-subqueries">
				13.2.8.1. 子查询作为标量操作数</a></span></dt><dt><span class="section"><a href="sql-syntax.html#comparisons-using-subqueries">13.2.8.2. 
				使用子查询进行比较</a></span></dt><dt><span class="section"><a href="sql-syntax.html#any-in-some-subqueries">13.2.8.3. 
				使用ANY, IN和SOME进行子查询</a></span></dt><dt><span class="section"><a href="sql-syntax.html#all-subqueries">13.2.8.4. 
				使用ALL进行子查询<code class="literal"></code></a></span></dt><dt><span class="section"><a href="sql-syntax.html#row-subqueries">
				13.2.8.5. 行子查询</a></span></dt><dt><span class="section"><a href="sql-syntax.html#exists-and-not-exists-subqueries">13.2.8.6. 
				EXISTS和NOT EXISTS</a></span></dt><dt><span class="section"><a href="sql-syntax.html#correlated-subqueries">
				13.2.8.7. 关联子查询</a></span></dt><dt><span class="section"><a href="sql-syntax.html#unnamed-views">
				13.2.8.8. FROM子句中的子查询<code class="literal"></code></a></span></dt><dt><span class="section"><a href="sql-syntax.html#subquery-errors">13.2.8.9. 
				子查询错误</a></span></dt><dt><span class="section"><a href="sql-syntax.html#optimizing-subqueries">
				13.2.8.10. 优化子查询</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rewriting-subqueries">
				13.2.8.11. 把子查询作为用于早期MySQL版本的联合进行改写</a></span></dt></dl></div><a class="indexterm" name="id2908464"></a><a class="indexterm" name="id2908470"></a><a class="indexterm" name="id2908477"></a><a class="indexterm" name="id2908484"></a>
			<p>子查询是另一个语句中的一个<span>SELECT</span>语句。</p>
			<p><span>MySQL</span>支持<span>SQL</span>标准要求的所有子查询格式和操作，也支持<span>MySQL</span>特有的几种特性。</p>
			<p>以下是一个子查询的例子：</p>
			<pre><span>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);</span></pre>
			<p>在本例中，<span>SELECT * FROM t1...</span>是外部查询（或外部语句）<span>,</span>（<span>SELECT 
			column1 FROM t2</span>）是子查询。我们可以说子查询嵌套在外部查询中。实际上，子查询也可以嵌套在其它子查询中，嵌套程度可以很深。子查询必须要位于圆括号中。</p>
			<p>子查询的主要优势为：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>子查询允许结构化的查询，这样就可以把一个语句的每个部分隔离开。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>有些操作需要复杂的联合和关联。子查询提供了其它的方法来执行这些操作。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在许多人看来，子查询是可读的。实际上，子查询给予人们调用早期<span>SQL</span>“结构化查询语言”的原本的想法，这是子查询的创新。</p>
			<p>以下是一个示例语句。该语句显示了有关子查询语法的要点。子查询语法由<span>SQL</span>标准指定并被<span>MySQL</span>支持。</p>
			<pre><span>DELETE FROM t1</span></pre>
			<pre><span>WHERE s11 &gt; ANY</span></pre>
			<pre><span>(SELECT COUNT(*) /* no hint */ FROM t2</span></pre>
			<pre><span>WHERE NOT EXISTS</span></pre>
			<pre><span>(SELECT * FROM t3</span></pre>
			<pre><span>WHERE ROW(5*t2.s1,77)=</span></pre>
			<pre><span>(SELECT 50,11*s1 FROM t4 UNION SELECT 50,77 FROM</span></pre>
			<pre><span>(SELECT * FROM t5) AS t5)));</span></pre>
			<p>
			一个子查询会返回一个标量（单一值）、一个行、一个列或一个表（一行或多行及一列或多列）。这些子查询被称为标量、列、行和表子查询。可返回一个特定种类结果的子查询经常只被用于特定的语境中，在后面各节中有说明。</p>
			<p>有些语句可以使用子查询。对这些语句的类型基本没有限定。子查询可以包括普通<span>SELECT</span>可以包括的任何关键词或子句：<span>DISTINCT</span><span>,
			<span>GROUP BY</span>,
			<span>ORDER BY</span>,
			<span>LIMIT</span>, </span>联合<span>,
			</span>索引提示<span>, <span>UNION</span></span><span>结构化</span><span>,
			</span>评注和函数等。</p>
			<p>有一个限定是，一个子查询的外部语句必须是以下语句之一：<span>SELECT, INSERT, 
			UPDATE, DELETE, SET</span>或<span>DO</span>。还有一个限定是，目前，您不能在一个子查询中修改一个表，又在同一个表中选择。这适用于<span>DELETE, 
			INSERT, REPLACE</span>和<span>UPDATE</span>语句。在<a href="restrictions.html">附录</a><a href="restrictions.html" title="Appendix I. Feature Restrictions">I：<i>特性限制</i></a>中给出了对子查询使用的更综合的讨论。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="scalar-subqueries"></a>
				13.2.8.1.&nbsp;子查询作为标量操作数</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				子查询最简单的形式是返回单一值的标量子查询。标量子查询是一个单一操作数。只要单一列值或文字是合法的，并且您希望子查询具有所有操作数都具有的特性，则您就可以使用子查询。操作数具有的特性包括：一个数据类型、一个长度、一个指示是否可以为<span>NULL</span>的标志等。举例说明：<pre><span>CREATE TABLE t1 (s1 INT, s2 CHAR(5) NOT NULL);</span></pre>
				<pre><span>INSERT INTO t1 VALUES(100, &#39;abcde&#39;);</span></pre>
				<pre><span>SELECT (SELECT s2 FROM t1);</span></pre>
				<p>在本<span>SELECT</span>中的子查询返回一个单一值<span>(<span>&#39;abcde&#39;</span>)</span>。该单一值的数据类型为<span>CHAR</span>，长度为<span>5</span>，字符集和整序与在<span>CREATE 
				TABLE</span>时有效的默认值相同，并有一个指示符号，指示列中的值可以为<span>NULL</span>。实际上，基本上所有的子查询都为<span>NULL</span>。如果在本例中使用的表为空表，则子查询的值应为<span>NULL</span>。</p>
				<p>在有些情况下，标量子查询不能使用。如果一个语句只允许一个文字值，您不能使用子查询。例如，<span>LIMIT</span>要求文字整数自变量，<span>LOAD 
				DATA</span>要求一个文字字符串文件名。您不能使用子查询来提供这些值。</p>
				<p>后面各节包括更简练的结构（<span>SELECT column1 FROM t1</span>）。当您在这些章节中观看例子时，请设想一下您自己的代码包含更多样、更复杂的结构。</p>
				<p>举例说明，假设我们制作两个表：</p>
				<pre><span>CREATE TABLE t1 (s1 INT);</span></pre>
				<pre><span>INSERT INTO t1 VALUES (1);</span></pre>
				<pre><span>CREATE TABLE t2 (s1 INT);</span></pre>
				<pre><span>INSERT INTO t2 VALUES (2);</span></pre>
				<p>然后执行一个<span>SELECT</span>：</p>
				<pre><span>SELECT (SELECT s1 FROM t2) FROM t1;</span></pre>
				<p>结果为<span>2</span>，因为<span>t2</span>中有一行包含<span>s1</span>，<span>s1</span>有一个值为<span>2</span>。</p>
				<p>
				一个标量子查询可以为一个表达式的一部分。不要忘记圆括号。即使是子查询是一个为函数提供自变量的操作数时，也不要忘记圆括号。举例说明：</p>
				<pre><span>SELECT UPPER((SELECT s1 FROM t1)) FROM t2;</span></pre>
				<h4 class="title"><a name="comparisons-using-subqueries"></a>
				13.2.8.2.&nbsp;使用子查询进行比较</h4></div></div></div>
				<p>子查询最常见的一种使用方式如下：</p>
				<pre><span><i><span>non_subquery_operand</span></i></span><span> <span><i>comparison_operator</i></span> (<span><i>subquery</i></span>)</span></pre>
				<p>当<span><i><span>comparison_operator</span></i></span>是以下
				操作符之一时：</p>
				<pre><span>=&nbsp; &gt;&nbsp; &lt;&nbsp; &gt;=&nbsp; &lt;=&nbsp; &lt;&gt;</span></pre>
				<p>例如：</p>
				<pre><span>&nbsp; ... &#39;a&#39; = (SELECT column1 FROM t1)</span></pre>
				<p>有时，子查询的合法位置只能在比较式的右侧，您可以发现，在有些旧的<span>DBMSs</span>中仍保持这一点。</p>
				<p>以下是一个常见格式的子查询比较的例子。您不能使用联合进行此类比较。表<span>t1</span>中有些值与表<span>t2</span>中的最大值相同。该比较可以查找出所有这类值：</p>
				<pre><span>SELECT column1 FROM t1</span></pre>
				<pre><span>WHERE column1 = (SELECT MAX(column2) FROM t2);</span></pre>
				<p>下面还有另一个例子，该例子也不可能使用联合，因为该例子涉及对其中一个表进行总计。表<span>t1</span>中的有些行含有的值会在给定的列中出现两次。该例子可以查找出所有这些行：</p>
				<pre><span>SELECT * FROM t1 AS t</span></pre>
				<pre><span>WHERE 2 = (SELECT COUNT(*) FROM t1 WHERE t1.id = t.id);</span></pre>
				<p>对于采用这些操作符之一进行的比较，子查询必须返回一个标量。有一个例外，那就是＝可以和行子查询同时使用。请参见<a href="sql-syntax.html#row-subqueries" title="13.2.8.5. Row Subqueries">13.2.8.5节，“行子查询”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="any-in-some-subqueries"></a>
				13.2.8.3.&nbsp;使用ANY, IN和SOME进行子查询</h4></div></div></div>
				<p>语法：</p>
				<pre><span><i><span>operand</span></i></span><span> <span><i>comparison_operator</i></span> ANY (<span><i>subquery</i></span>)</span></pre>
				<pre><span><i><span>operand</span></i></span><span> IN (<span><i>subquery</i></span>)</span></pre>
				<pre><span><i><span>operand</span></i></span><span> <span><i>comparison_operator</i></span> SOME (<span><i>subquery</i></span>)</span></pre>
				<p><span>ANY</span>关键词必须后面接一个比较操作符。<span>ANY</span>关键词的意思是“对于在子查询返回的列中的任一数值，如果比较结果为<span>TRUE</span>的话，则返回<span>TRUE</span>”。例如：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &gt; ANY (SELECT s1 FROM t2);</span></pre>
				<p>假设表<span>t1</span>中有一行包含（<span>10</span>）。如果表<span>t2</span>包含（<span>21</span>，<span>14</span>，<span>7</span>），则表达式为<span>TRUE</span>，因为<span>t2</span>中有一个值为<span>7</span>，该值小于<span>10</span>。如果表<span>t2</span>包含（<span>20</span>，<span>10</span>），或者如果表<span>t2</span>为空表，则表达式为<span>FALSE</span>。如果表<span>t2</span>包含（<span>NULL, 
				NULL, NULL</span>），则表达式为<span>UNKNOWN</span>。</p>
				<p>词语<span>IN</span>是＝<span>ANY</span>的别名。因此，这两个语句是一样的：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);</span></pre>
				<pre><span>SELECT s1 FROM t1 WHERE s1 IN&nbsp;&nbsp;&nbsp; (SELECT s1 FROM t2);</span></pre>
				<p>不过，<span>NOT IN</span>不是<span>&lt;&gt; ANY</span>的别名，但是是<span>&lt;&gt; 
				ALL</span>的别名。请参见<a href="sql-syntax.html#all-subqueries" title="13.2.8.4. Subqueries with ALL">13.2.8.4节，“使用ALL进行子查询<code class="literal"></code>”</a>。</p>
				<p>词语<span>SOME</span>是<span>ANY</span>的别名。因此，这两个语句是一样的：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &lt;&gt; ANY&nbsp; (SELECT s1 FROM t2);</span></pre>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &lt;&gt; SOME (SELECT s1 FROM t2);</span></pre>
				<p>使用词语<span>SOME</span>的机会很少，但是本例显示了为什么<span>SOME</span>是有用的。对于多数人来说，英语短语“<span>a 
				is not equal to any b</span>”的意思是“没有一个<span>b</span>与<span>a</span>相等”，但是在<span>SQL</span>语法中不是这个意思。该语法的意思是“有部分<span>b</span>与<span>a</span>不相等”。使用<span>&lt;&gt; 
				SOME</span>有助于确认每个人都理解该查询的真正含义。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="all-subqueries"></a>
				13.2.8.4.&nbsp;使用ALL进行子查询<code class="literal"></code></h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				语法：<pre><span><i><span>operand</span></i></span><span> <span><i>comparison_operator</i></span> ALL (<span><i>subquery</i></span>)</span></pre>
				<p>词语<span>ALL</span>必须接在一个比较操作符的后面。<span>ALL</span>的意思是“对于子查询返回的列中的所有值，如果比较结果为<span>TRUE</span>，则返回<span>TRUE</span>。”例如：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &gt; ALL (SELECT s1 FROM t2);</span></pre>
				<p>假设表<span>1</span>中有一行包含（<span>10</span>）。如果表<span>t2</span>包含（<span>-5</span>，<span>0</span>，＋<span>5</span>），则表达式为<span>TRUE</span>，因为<span>10</span>比<span>t2</span>中的所有三个值都大。如果表<span>t2</span>包含（<span>12</span>，<span>6</span>，<span>NULL</span>，－<span>100</span>），则表达式为<span>FALSE</span>，因为表<span>t2</span>中有一个值<span>12</span>大于<span>10</span>。如果表<span>t2</span>包含（<span>0</span>，<span>NULL</span>，<span>1</span>），则表达式为<span>unknown</span>。</p>
				<p>最后，如果表<span>t2</span>为空表，则结果为<span>TRUE</span>。因此，当表<span>t2</span>为空表时，以下语句为<span>TRUE</span>：</p>
				<pre><span>SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT s1 FROM t2);</span></pre>
				<p>但是，当表<span>t2</span>为空表时，本语句为<span>NULL</span>：</p>
				<pre><span>SELECT * FROM t1 WHERE 1 &gt; (SELECT s1 FROM t2);</span></pre>
				<p>另外，当表<span>t2</span>为空表时，以下语句为<span>NULL</span>：</p>
				<pre><span>SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT MAX(s1) FROM t2);</span></pre>
				<p>通常，包含<span>NULL</span>值的表和空表为“边缘情况”。当编写子查询代码时，都要考虑您是否把这两种可能性计算在内。</p>
				<p><span>NOT IN</span>是<span>&lt;&gt; ALL</span>的别名。因此，以下两个语句是相同的：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &lt;&gt; ALL (SELECT s1 FROM t2);</span></pre>
				<pre><span>SELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);</span></pre>
				<h4 class="title"><a name="row-subqueries"></a>13.2.8.5.&nbsp;行子查询</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				对于本点的讨论属于标量或列子查询，即返回一个单一值或一列值的子查询。行子查询是一个能返回一个单一行的子查询变量，因此可以返回一个以上的列值。以下是两个例子：<pre><span>SELECT * FROM t1 WHERE (1,2) = (SELECT column1, column2 FROM t2);</span></pre>
				<pre><span>SELECT * FROM t1 WHERE ROW(1,2) = (SELECT column1, column2 FROM t2);</span></pre>
				<p>如果在表<span>t2</span>的一个行中，<span>column1=1</span>并且<span>column2=2</span>，则查询结果均为<span>TRUE</span>。</p>
				<p>表达式（<span>1</span>，<span>2</span>）和<span>ROW</span>（<span>1</span>，<span>2</span>）有时被称为行构造符。两者是等同的，在其它的语境中，也是合法的。例如，以下两个语句在语义上是等同的（但是目前只有第二个语句可以被优化）：</p>
				<pre><span>&nbsp; SELECT * FROM t1 WHERE (column1,column2) = (1,1);</span></pre>
				<pre><span>&nbsp; SELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;</span></pre>
				<p>行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。例如，以下查询可以答复请求，“在表<span>t1</span>中查找同时也存在于表<span>t2</span>中的所有的行”：</p>
				<pre><span>SELECT column1,column2,column3</span></pre>
				<pre><span>FROM t1</span></pre>
				<pre><span>WHERE (column1,column2,column3) IN</span></pre>
				<pre><span>(SELECT column1,column2,column3 FROM t2);</span></pre>
				<h4 class="title"><a name="exists-and-not-exists-subqueries"></a>13.2.8.6. EXISTS和NOT 
				EXISTS</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				如果一个子查询返回任何的行，则<span>EXISTS
				<span><i>subquery</i></span></span>为<span>FALSE</span>。例如：<pre><span>SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2);</span></pre>
				<p>过去，<span>EXISTS</span>子查询以<span>SELECT *</span>为开始，但是可以以<span>SELECT 
				5</span>或<span>SELECT column1</span>或其它的为开始。<span>MySQL</span>在这类子查询中忽略了<span>SELECT</span>清单，因此没有区别。</p>
				<p>对于前面的例子，如果<span>t2</span>包含任何行，即使是只含有<span>NULL</span>值的行，<span>EXISTS</span>条件也为<span>TRUE</span>。这实际上是一个不可能的例子，因为基本上所有的<span>[NOT] 
				EXISTS</span>子查询均包含关联。以下是一些更现实的例子：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>哪些种类的商店出现在一个或多个城市里？</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT store_type FROM stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;WHERE EXISTS (SELECT * FROM cities_stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE cities_stores.store_type = stores.store_type);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>哪些种类的商店没有出现在任何城市里？</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT store_type FROM stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;WHERE NOT EXISTS (SELECT * FROM cities_stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE cities_stores.store_type = stores.store_type);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>哪些种类的商店出现在所有城市里？</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT store_type FROM stores s1</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;WHERE NOT EXISTS (</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM cities WHERE NOT EXISTS (</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM cities_stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE cities_stores.city = cities.city</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND cities_stores.store_type = stores.store_type));</span></pre>
				<p>最后一个例子是一个双嵌套<span>NOT EXISTS</span>查询。也就是，该查询包含一个<span>NOT 
				EXISTS</span>子句，该子句又包含在一个<span>NOT EXISTS</span>子句中。该查询正式地回答了这个问题，“是否有某个城市拥有没有列在<span>Stores</span>中的商店？”。可以比较容易的说，一个带嵌套的<span>NOT 
				EXISTS</span>可以回答这样的问题，“是否对于所有的<span>y</span>，<span>x</span>都为<span>TRUE</span>？”</p>
				<h4 class="title"><a name="correlated-subqueries"></a>
				13.2.8.7.&nbsp;关联子查询</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				相关联的子查询是一个包含对表的引用的子查询。该表也显示在外部查询中。例如：<pre><span>SELECT * FROM t1 WHERE column1 = ANY</span></pre>
				<pre><span>(SELECT column1 FROM t2 WHERE t2.column2 = t1.column2);</span></pre>
				<p>注意，即使子查询的<span>FROM</span>子句不提及表<span>t1</span>，该子查询也会包含一个对<span>t1</span>中一列的引用。所以，<span>MySQL</span>看上去位于子查询的外部，并在外部查询中查找<span>t1</span>。</p>
				<p>假设表<span>t1</span>包含一行，在此行中<span>column1=5</span>并且<span>column2=6</span>；同时，表<span>t2</span>包含一行，在此行中<span>column1=5</span>并且<span>column2=7</span>。简单的表达式<span><span>... 
				WHERE column1 = ANY (SELECT column1 FROM t2)</span>会为<span>TRUE</span>。但是在本例中，在子查询中的<span>WHERE</span>子句为<span>FALSE</span>（因为（<span>5</span>，<span>6</span>）不等于（<span>5</span>，<span>7</span>）），所以子查询总体上为<span>FALSE</span>。</span></p>
				<p>范围划分规则：<span>MySQL</span>从内到外进行评估。例如：</p>
				<pre><span>SELECT column1 FROM t1 AS x</span></pre>
				<pre><span>WHERE x.column1 = (SELECT column1 FROM t2 AS x</span></pre>
				<pre><span>WHERE x.column1 = (SELECT column1 FROM t3</span></pre>
				<pre><span>WHERE x.column2 = t3.column1));</span></pre>
				<p>在本语句中，<span>x.column2</span>必须是表<span>t2</span>中的列，因为<span><span>SELECT 
				column1 FROM t2 AS x ...</span>对<span>t2</span>进行了重命名。它不是表<span>t1</span>中的列，因为<span>SELECT 
				column1 FROM t1 ...</span>是一个更靠外的外部查询。</span></p>
				<p>对于<span>HAVING</span>或<span>ORDER BY</span>子句中的子查询，<span>MySQL</span>也会在外部选择清单中寻找列名称。</p>
				<p>对于特定的情况，相关联的子查询被优化。例如：</p>
				<pre><span><i><span>val</span></i></span><span> IN (SELECT <span><i>key_val</i></span> FROM <span><i>tbl_name</i></span> WHERE <span><i>correlated_condition</i></span>)</span></pre>
				<p>否则，这些子查询效率不高，可能速度会慢。把查询作为联合进行改写可能会改进效率。</p>
				<p>相关联的子查询不能从外部查询中引用总计函数的结果。</p>
				<h4 class="title"><a name="unnamed-views"></a>
				13.2.8.8.&nbsp;FROM子句中的子查询<code class="literal"></code></h4></div></div></div><a class="indexterm" name="id2909893"></a><a class="indexterm" name="id2909900"></a>
				<p>在<span>SELECT</span>语句的<span>FROM</span>子句中，子查询是合法的。实际的语法是：</p>
				<pre><span>SELECT ... FROM (<span><i>subquery</i></span>) [AS] <span><i>name</i></span> ...</span></pre>
				<p><span>[AS]<span><i> name</i></span></span>子句是强制性的，因为<span>FROM</span>子句中的每个表必须有一个名称。在子查询选择列表中的任何列都必须有唯一的名称。您可以在本手册中的其它地方找到对本语法的说明。在该处，所用的词语是“导出表”。</p>
				<p>为了进行详细说明，假设您有如下一个表：</p>
				<pre><span>CREATE TABLE t1 (s1 INT, s2 CHAR(5), s3 FLOAT);</span></pre>
				<p>下面使用了示例表，解释了在<span>FROM</span>子句中如何使用子查询：</p>
				<pre><span>INSERT INTO t1 VALUES (1,&#39;1&#39;,1.0);</span></pre>
				<pre><span>INSERT INTO t1 VALUES (2,&#39;2&#39;,2.0);</span></pre>
				<pre><span>SELECT sb1,sb2,sb3</span></pre>
				<pre><span>FROM (SELECT s1 AS sb1, s2 AS sb2, s3*2 AS sb3 FROM t1) AS sb</span></pre>
				<pre><span>WHERE sb1 &gt; 1;</span></pre>
				<p>结果：<span>2, &#39;2&#39;, 4.0</span>。</p>
				<p>下面是另一个例子：假设您想了解一个分类后的表的一组和的平均值。采用如下操作：</p>
				<pre><span>SELECT AVG(SUM(column1)) FROM t1 GROUP BY column1;</span></pre>
				<p>不过，本查询提供所需的信息：</p>
				<pre><span>SELECT AVG(sum_column1)</span></pre>
				<pre><span>FROM (SELECT SUM(column1) AS sum_column1</span></pre>
				<pre><span>FROM t1 GROUP BY column1) AS t1;</span></pre>
				<p>注意，在子查询中使用的列名称（<span>sum_column1</span>）被整理到外部查询中。</p>
				<p><span>FROM</span>子句中的子查询可以返回标量、列、行或表。<span>FROM</span>子句中的子查询不能为有关联的子查询。</p>
				<p>即使对<span>EXPLAIN</span>语句（即建立临时导出表），<span>FROM</span>子句中的子查询也会被执行。这是因为在优化过程中，上一级的查询需要有关所有表的信息。</p>
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="subquery-errors"></a>
							13.2.8.9.&nbsp;子查询错误</h4></div></div></div>
				<p>以下错误只适用于子查询。本节把这些错误归在一起。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>来自子查询的列的数目不正确</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ERROR 1241 (ER_OPERAND_COL)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SQLSTATE = 21000</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Message = &quot;Operand should contain 1 column(s)&quot;</span></pre>
				<p>在出现以下情况时，发生此错误：</p>
				<pre><span>SELECT (SELECT column1, column2 FROM t2) FROM t1;</span></pre>
				<p>如果您的目的是进行比较，您可以使用能返回多个列的子查询。请参见<a href="sql-syntax.html#row-subqueries" title="13.2.8.5. Row Subqueries">13.2.8.5节，“行子查询”</a>。不过，在其它的语境下，子查询必须为标量操作数。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>来自子查询的行的数目不正确：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ERROR 1242 (ER_SUBSELECT_NO_1_ROW)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SQLSTATE = 21000</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Message = &quot;Subquery returns more than 1 row&quot;</span></pre>
				<p>
				如果在语句中，子查询返回的行多于一个，则发生此错误。请考虑以下例子：</p>
				<pre><span>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);</span></pre>
				<p>如果<span>SELECT column1 
				FROM t2</span>只返回一行，则将执行以前的查询。如果子查询返回的行多于一个，则将出现错误<span>1242</span>。在这种情况下，该查询将被改写为：</p>
				<pre><span>SELECT * FROM t1 WHERE column1 = ANY (SELECT column1 FROM t2);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在子查询中表格使用不正确：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Error 1093 (ER_UPDATE_TABLE_USED)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SQLSTATE = HY000</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Message = &quot;You can&#39;t specify target table &#39;x&#39;</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>for update in FROM clause&quot;</span></pre>
				<p>在如下情况下，发生该错误：</p>
				<pre><span>UPDATE t1 SET column2 = (SELECT MAX(column1) FROM t1);</span></pre>
				<p>和<span>SELECT</span>语句一样，在<span>UPDATE</span>和<span>DELETE</span>语句中，子查询是合法的。所以您可以在<span>UPDATE</span>语句中使用子查询进行赋值。不过，您不能把同一个表（在本例中为表<span>t1</span>）既用于子查询的<span>FROM</span>子句，又用于更新目标。</p>
				<p>对于事务存储引擎，子查询的错误会导致整个语句失效。对于非事务存储引擎，在遇到错误之前进行的数据修订会被保留。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimizing-subqueries"></a>
				13.2.8.10.&nbsp;优化子查询</h4></div></div></div>
				<p>开发过程不断进展，所以从长远来看，没有一个可靠的优化技巧。有些技巧您可能会感兴趣，并原意采用：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>有些子句会影响在子查询中的行的数量和顺序。使用这类子句。例如：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE t1.column1 IN</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(SELECT column1 FROM t2 ORDER BY column1);</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE t1.column1 IN</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(SELECT DISTINCT column1 FROM t2);</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE EXISTS</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(SELECT * FROM t2 LIMIT 1);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>用子查询替换联合。例如，试进行如下操作：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT column1 FROM t1 WHERE t1.column1 IN (</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT column1 FROM t2);</span></pre>
				<p>代替如下操作：</p>
				<pre><span>SELECT DISTINCT t1.column1 FROM t1, t2</span></pre>
				<pre><span>WHERE t1.column1 = t2.column1;</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>部分子查询可以被转换为联合，以便与不支持子查询的旧版本的<span>MySQL</span>相兼容。不过，在有些情况下，把子查询转化为联合可以提高效果。请参见<a href="sql-syntax.html#rewriting-subqueries" title="13.2.8.11. Rewriting Subqueries as Joins for Earlier MySQL Versions">13.2.8.11节，“把子查询作为用于早期MySQL版本的联合进行改写”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>把子句从子查询的外部转移到内部。例如，使用此查询：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>WHERE s1 IN (SELECT s1 FROM t1 UNION ALL SELECT s1 FROM t2);</span></pre>
				<p>代替此查询：</p>
				<pre><span>SELECT * FROM t1</span></pre>
				<pre><span>WHERE s1 IN (SELECT s1 FROM t1) OR s1 IN (SELECT s1 FROM t2);</span></pre>
				<p>另一个例子是，使用此查询：</p>
				<pre><span>SELECT (SELECT column1 + 5 FROM t1) FROM t2;</span></pre>
				<p>代替此查询：</p>
				<pre><span>SELECT (SELECT column1 FROM t1) + 5 FROM t2;</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>使用行子查询，代替关联子查询。举例说明，使用此查询：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>WHERE (column1,column2) IN (SELECT column1,column2 FROM t2);</span></pre>
				<p>代替此查询：</p>
				<pre><span>SELECT * FROM t1</span></pre>
				<pre><span>WHERE EXISTS (SELECT * FROM t2 WHERE t2.column1=t1.column1</span></pre>
				<pre><span>AND t2.column2=t1.column2);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Use <span>
				NOT (a = ANY (...))</span> rather than
				<span>a &lt;&gt; ALL (...)</span>. </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Use <span>
				x = ANY (table containing (1,2))</span> rather than
				<span>x=1 OR x=2</span>. </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Use <span>
				= ANY</span> rather than <span>EXISTS</span>.
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于只返回一行的无关联子查询，<span>IN</span>的速度慢于＝。举例说明，使用此查询：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE t1.<span><i>col_name</i></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>= (SELECT a FROM t2 WHERE b = <span><i>some_const</i></span>);</span></pre>
				<p>代替此查询：</p>
				<pre><span>SELECT * FROM t1 WHERE t1.<span><i>col_name</i></span></span></pre>
				<pre><span>IN (SELECT a FROM t2 WHERE b = <span><i>some_const</i></span>);</span></pre>
				<p>使用这些技巧可以使程序更快或更慢。使用<span>BENCHMARK()</span>函数等<span>MySQL</span>工具，您可以了解到在您所处的情况下，哪些技巧会有帮助。</p>
				<p><span>MySQL</span>本身进行的部分优化包括：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>MySQL</span>只执行一次无关联子查询。使用<span>EXPLAIN</span>确认给定的子查询确实是无关联的。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>MySQL</span>改写<span>IN, 
				ALL, ANY</span>和<span>SOME</span>子查询，目的是如果子查询中的<span>select-list</span>列已编制索引，则能发挥出此优势。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>MySQL</span>使用<span>index-lookup</span>函数代替以下格式的子查询。<span>EXPLAIN</span>把此函数描述为特殊的联合类型（<span>unique_subquery</span>或<span>index_subquery</span>）：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>... IN (SELECT <span><i>indexed_column</i></span> FROM <span><i>single_table</i></span> ...)</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>当表达式中不包含<span>NULL</span>值或空集时，<span>MySQL</span>使用一个包含<span>MIN()</span>或<span>MAX()</span>的表达式，对以下格式的表达式进行扩展：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span><i><span>value</span></i></span><span> {ALL|ANY|SOME} {&gt; | &lt; | &gt;= | &lt;=} (<span><i>non-correlated subquery</i></span>)</span></pre>
				<p>例如，本<span>WHERE</span>子句：</p>
				<pre><span>WHERE 5 &gt; ALL (SELECT x FROM t)</span></pre>
				<p>可以用优化符进行如下处理：</p>
				<pre><span>WHERE 5 &gt; (SELECT MAX(x) FROM t)</span></pre>
				<p>在<span>MySQL</span>内部手册中有一章名为“<span>MySQL</span>如何转换子查询”，可以从<span><a target="_top"  href="http://dev.mysql.com/doc/">http://dev.mysql.com/doc/</a></span>获取。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="rewriting-subqueries"></a>
				13.2.8.11.&nbsp;把子查询作为用于早期MySQL版本的联合进行改写</h4></div></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			在较早版本的<span>MySQL</span>中（早于<span>MySQL 4.1</span>），只支持<span>INSERT...SELECT</span>和<span>REPLACE...SELECT...</span>格式的带嵌套的查询。虽然在<span>MySQL 
			5.1</span>中没有这种情况，但有时，仍然有其它的方法测试一组值的从属关系。并且，在有些情况下，不仅可以在没有子查询时对查询进行改写，而且有时使用这些方法比使用子查询效率更高。这些方法之一是<span>IN()</span>结构：<p>
			举例说明，本查询：</p>
			<pre><span>SELECT * FROM t1 WHERE id IN (SELECT id FROM t2);</span></pre>
			<p>可以被改写为：</p>
			<pre><span>SELECT DISTINCT t1.* FROM t1, t2 WHERE t1.id=t2.id;</span></pre>
			<p>以下查询：</p>
			<pre><span>SELECT * FROM t1 WHERE id NOT IN (SELECT id FROM t2);</span></pre>
			<pre><span>SELECT * FROM t1 WHERE NOT EXISTS (SELECT id FROM t2 WHERE t1.id=t2.id);</span></pre>
			<p>也可以使用<span>IN()</span>进行改写：</p>
			<pre><span>SELECT table1.* FROM table1 LEFT JOIN table2 ON table1.id=table2.id</span></pre>
			<pre><span>WHERE table2.id IS NULL;</span></pre>
			<p><span>LEFT [OUTER] JOIN</span>可以比对应的子查询更快，因为服务器可能对其进行更好的优化——这一点对于单独的<span>MySQL</span>服务器并不明确。在<span>SQL-92</span>之前，不存在外部联合，因此在做某些事情时，子查询是唯一的方法。现在，<span>MySQL</span>服务器和其它许多先进的数据库系统都能提供多种的外部联合类型。</p>
			<p><span>MySQL</span>支持<span>multiple-table 
			DELETE</span>语句，该语句可以被用于高效地删除行。删除时依据来自一个表或同时来自多个表的信息。同时也支持<span>Multiple-table 
			UPDATE</span>语句。</p>
			<h3 class="title"><a name="truncate"></a>13.2.9. TRUNCATE语法</h3></div></div></div><a class="indexterm" name="id2910732"></a></div><div class="section"><div class="titlepage"><div><div>
			<pre><span>TRUNCATE [TABLE] <span><i>tbl_name</i></span></span></pre>
			<p><span>TRUNCATE TABLE</span>用于完全清空一个表。从逻辑上说，该语句与用于删除所有行的<span>DELETE</span>语句等同，但是在有些情况下，两者在使用上有所不同。</p>
			<p>对于<span>InnoDB</span>表，如果有需要引用表的外键限制，则<span>TRUNCATE 
			TABLE</span>被映射到<span>DELETE</span>上；否则使用快速删减（取消和重新创建表）。使用<span>TRUNCATE 
			TABLE</span>重新设置<span>AUTO_INCREMENT</span>计数器，设置时不考虑是否有外键限制。</p>
			<p>对于其它存储引擎，在<span>MySQL 5.1</span>中，<span>TRUNCATE 
			TABLE</span>与<span>DELETE FROM</span>有以下几处不同：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>删减操作会取消并重新创建表，这比一行一行的删除行要快很多。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>删减操作不能保证对事务是安全的；在进行事务处理和表锁定的过程中尝试进行删减，会发生错误。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>被删除的行的数目没有被返回。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只要表定义文件<span><i><span>tbl_name</span></i><span>.frm</span></span>是合法的，则可以使用<span>TRUNCATE 
			TABLE</span>把表重新创建为一个空表，即使数据或索引文件已经被破坏。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>表管理程序不记得最后被使用的<span>AUTO_INCREMENT</span>值，但是会从头开始计数。即使对于<span>MyISAM</span>和<span>InnoDB</span>也是如此。<span>MyISAM</span>和<span>InnoDB</span>通常不再次使用序列值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当被用于带分区的表时，<span>TRUNCATE TABLE</span>会保留分区；即，数据和索引文件被取消并重新创建，同时分区定义（<span>.par</span>）文件不受影响。</p>
			<p><span>TRUNCATE TABLE</span>是在<span>MySQL</span>中采用的一个<span>Oracle 
			SQL</span>扩展。</p>
			<h3 class="title"><a name="update"></a>13.2.10. UPDATE语法</h3></div></div></div><a class="indexterm" name="id2910933"></a>
			<p><span>Single-table</span>语法：</p>
			<pre><span>UPDATE [LOW_PRIORITY] [IGNORE] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name1</i></span>=<span><i>expr1</i></span> [, <span><i>col_name2</i></span>=<span><i>expr2</i></span> ...]</span></pre>
			<pre><span>&nbsp;&nbsp; &nbsp;[WHERE <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ORDER BY ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LIMIT <span><i>row_count</i></span>]</span></pre>
			<p><span>Multiple-table</span>语法：</p>
			<pre><span>UPDATE [LOW_PRIORITY] [IGNORE] <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name1</i></span>=<span><i>expr1</i></span> [, <span><i>col_name2</i></span>=<span><i>expr2</i></span> ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<p><span>UPDATE</span>语法可以用新值更新原有表行中的各列。<span>SET</span>子句指示要修改哪些列和要给予哪些值。<span>WHERE</span>子句指定应更新哪些行。如果没有<span>WHERE</span>子句，则更新所有的行。如果指定了<span>ORDER 
			BY</span>子句，则按照被指定的顺序对行进行更新。<span>LIMIT</span>子句用于给定一个限值，限制可以被更新的行的数目。</p>
			<p><span>UPDATE</span>语句支持以下修饰符：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>LOW_PRIORITY</span>关键词，则<span>UPDATE</span>的执行被延迟了，直到没有其它的客户端从表中读取为止。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>IGNORE</span>关键词，则即使在更新过程中出现错误，更新语句也不会中断。如果出现了重复关键字冲突，则这些行不会被更新。如果列被更新后，新值会导致数据转化错误，则这些行被更新为最接近的合法的值。</p>
			<p>如果您在一个表达式中通过<span><i><span>tbl_name</span></i></span>访问一列，则<span>UPDATE</span>使用列中的当前值。例如，以下语句把年龄列设置为比当前值多一：</p>
			<pre><span>mysql&gt; <span><b>UPDATE persondata SET age=age+1;</b></span></span></pre>
			<p><span>UPDATE</span>赋值被从左到右评估。例如，以下语句对年龄列加倍，然后再进行增加：</p>
			<pre><span>mysql&gt; <span><b>UPDATE persondata SET age=age*2, age=age+1;</b></span></span></pre>
			<p>如果您把一列设置为其当前含有的值，则<span>MySQL</span>会注意到这一点，但不会更新。</p>
			<p>如果您把被已定义为<span>NOT NULL</span>的列更新为<span>NULL</span>，则该列被设置到与列类型对应的默认值，并且累加警告数。对于数字类型，默认值为<span>0</span>；对于字符串类型，默认值为空字符串<span>(<span>&#39;&#39;</span>)</span>；对于日期和时间类型，默认值为“<span>zero</span>”值。</p>
			<p><span>UPDATE</span>会返回实际被改变的行的数目。<span>Mysql_info() 
			C API</span>函数可以返回被匹配和被更新的行的数目，以及在<span>UPDATE</span>过程中产生的警告的数量。</p>
			<p>您可以使用<span>LIMIT <i>
			row_count</i></span>来限定<span>UPDATE</span>的范围。<span>LIMIT</span>子句是一个与行匹配的限定。只要发现可以满足<span>WHERE</span>子句的<span><i><span>row_count</span></i></span>行，则该语句中止，不论这些行是否被改变。</p>
			<p>如果一个<span>UPDATE</span>语句包括一个<span>ORDER BY</span>子句，则按照由子句指定的顺序更新行。</p>
			<p>您也可以执行包括多个表的<span>UPDATE</span>操作。<span><i><span>table_references</span></i></span>子句列出了在联合中包含的表。该语法在<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>中进行了说明。以下是一个例子：</p>
			<pre><span>UPDATE items,month SET items.price=month.price</span></pre>
			<pre><span>WHERE items.id=month.id;</span></pre>
			<p>以上的例子显示出了使用逗号操作符的内部联合，但是<span>multiple-table UPDATE</span>语句可以使用在<span>SELECT</span>语句中允许的任何类型的联合，比如<span>LEFT 
			JOIN</span>。</p>
			<p>注释：您不能把<span>ORDER BY</span>或<span>LIMIT</span>与<span>multiple-table 
			UPDATE</span>同时使用。</p>
			<p>在一个被更改的<span>multiple-table UPDATE</span>中，有些列被引用。您只需要这些列的<span>UPDATE</span>权限。有些列被读取了，但是没被修改。您只需要这些列的<span>SELECT</span>权限。</p>
			<p>如果您使用的<span>multiple-table UPDATE</span>语句中包含带有外键限制的<span>InnoDB</span>表，则<span>MySQL</span>优化符处理表的顺序可能与上下层级关系的顺序不同。在此情况下，语句无效并被
			回滚。同时，更新一个单一表，并且依靠<span>ON 
			UPDATE</span>功能。该功能由<span>InnoDB</span>提供，用于对其它表进行相应的修改。请参见<a href="storage-engines.html#innodb-foreign-key-constraints" title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4节，“FOREIGN 
		KEY约束”</a>。</p>
			<p>目前，您不能在一个子查询中更新一个表，同时从同一个表中选择。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="basic-user-commands"></a>
		13.3.&nbsp;MySQL实用工具语句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#describe">13.3.1. 
			DESCRIBE语法（获取有关列的信息）</a></span></dt><dt><span class="section"><a href="sql-syntax.html#use">13.3.2. 
			USE语法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="describe"></a>13.3.1. DESCRIBE语法（获取有关列的信息）</h3></div></div></div><a class="indexterm" name="id2911402"></a><a class="indexterm" name="id2911411"></a>
			<pre><span>{DESCRIBE | DESC} <span><i>tbl_name</i></span> [<span><i>col_name</i></span> | <span><i>wild</i></span>]</span></pre>
			<p><span>DESCRIBE</span>可以提供有关表中各列的信息。它是<span>SHOW 
			COLUMNS FROM</span>的快捷方式。这些语句也可以显示语句，用于阅览。</p>
			<p>见<a href="sql-syntax.html#show-columns" title="13.5.4.3. SHOW COLUMNS Syntax">13.5.4.3节，“SHOW 
		COLUMNS语法”</a>。</p>
			<p><span><i><span>col_name</span></i></span>可以是一个列名称，或一个包含‘％’和‘<span>_</span>’的通配符的字符串，用于获得对于带有与字符串相匹配的名称的各列的输出。没有必要在引号中包含字符串，除非其中包含空格或其它特殊字符。</p>
			<pre><span>mysql&gt; <span><b>DESCRIBE city;</b></span></span></pre>
			<pre><span>+------------+----------+------+-----+---------+----------------+</span></pre>
			<pre><span>| Field&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;| Type&nbsp;&nbsp;&nbsp;&nbsp; | Null | Key | Default | Extra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------------+----------+------+-----+---------+----------------+</span></pre>
			<pre><span>| Id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | int(11)&nbsp; | NO&nbsp;&nbsp; | PRI | NULL&nbsp;&nbsp;&nbsp; | auto_increment |</span></pre>
			<pre><span>| Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | char(35) | NO&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| Country&nbsp;&nbsp;&nbsp; | char(3)&nbsp; | NO&nbsp;&nbsp; | UNI |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| District&nbsp;&nbsp; | char(20) | YES&nbsp; | MUL |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| Population | int(11)&nbsp; | NO&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------------+----------+------+-----+---------+----------------+</span></pre>
			<pre><span>5 rows in set (0.00 sec)</span></pre>
			<p><span>NULL</span>字段指示是否<span>NULL</span>可以被存储在列中。</p>
			<p><span>Key</span>字段指示是否该列已编制索引。<span>PRI</span>的值指示该列是表的主键的一部分。<span>UNI</span>指示，该列是<span>UNIQUE</span>索引的一部分。<span>MUL</span>值指示，在列中某个给定值多次出现是允许的。</p>
			<p><span>MUL</span>将被显示在<span>UNIQUE</span>索引中，原因之一是多个列会组合成一个复合<span>UNIQUE</span>索引；尽管列的组合是唯一的，但每个列仍可以多次出现同一个给定值。注意，在复合索引中，只有索引最左边的列可以进入<span>Key</span>字段中。</p>
			<p>默认字段指示，默认值被赋予该列。</p>
			<p><span>Extra</span>字段包含可以获取的与给定列有关的附加信息。在我们的例子中，<span>Extra</span>字段指示，<span>Id</span>列使用<span>AUTO_INCREMENT</span>关键词创建。</p>
			<p>如果列类型与您预计的依据<span>CREATE TABLE</span>语句得出的列类型不同，则请注意，<span>MySQL</span>有时会改变列类型。请参见<a href="sql-syntax.html#silent-column-changes" title="13.1.5.1. Silent Column Specification Changes">13.1.5.1节，“沉寂的列规格变更”</a>。</p>
			<p><span>DESCRIBE</span>语句被设立出来，用于与<span>Oracle</span>相兼容。</p>
			<p><span>SHOW CREATE TABLE</span>和<span>SHOW 
			TABLE STATUS</span>语句也可以提供有关表的信息。请参见<a href="sql-syntax.html#show" title="13.5.4. SHOW Syntax">13.5.4节，“SHOW语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="use"></a>13.3.2. USE语法</h3></div></div></div><a class="indexterm" name="id2911699"></a>
			<pre><span>USE <span><i>db_name</i></span></span></pre>
			<p><span>USE <i>db_name</i></span>语句可以通告<span>MySQL</span>把<span><i><span>db_name</span></i></span>数据库作为默认（当前）数据库使用，用于后续语句。该数据库保持为默认数据库，直到语段的结尾，或者直到发布一个不同的<span>USE</span>语句：</p>
			<pre><span>mysql&gt; <span><b>USE db1;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>SELECT COUNT(*) FROM mytable;&nbsp;&nbsp; # selects from db1.mytable</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>USE db2;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>SELECT COUNT(*) FROM mytable;&nbsp;&nbsp; # selects from db2.mytable</b></span></span></pre>
			<p>使用<span>USE</span>语句为一个特定的当前的数据库做标记，不会阻碍您访问其它数据库中的表。下面的例子可以从<span>db1</span>数据库访问作者表，并从<span>db2</span>数据库访问编辑表：</p>
			<pre><span>mysql&gt; <span><b>USE db1;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>SELECT author_name,editor_name FROM author,db2.editor</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE author.editor_id = db2.editor.editor_id;</b></span></span></pre>
			<p><span>USE</span>语句被设立出来，用于与<span>Sybase</span>相兼容。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="transactional-commands"></a>
		13.4.&nbsp;MySQL事务处理和锁定语句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#commit">13.4.1. 
			START TRANSACTION, COMMIT和ROLLBACK语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cannot-roll-back">
			13.4.2. 不能回滚的语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#implicit-commit">
			13.4.3. 会造成隐式提交的语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#savepoints">13.4.4. 
			SAVEPOINT和ROLLBACK TO SAVEPOINT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#lock-tables">13.4.5. 
			LOCK TABLES和UNLOCK TABLES语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-transaction">13.4.6. 
			SET TRANSACTION语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa">
			13.4.7. XA事务</a></span></dt></dl></div>
		<p><span>MySQL</span>通过<span>SET AUTOCOMMIT, START 
		TRANSACTION, COMMIT</span>和<span>ROLLBACK</span>等语句支持本地事务（在给定的客户端连接中）。请参见<a href="sql-syntax.html#commit" title="13.4.1. START TRANSACTION, COMMIT, and ROLLBACK Syntax">13.4.1节，“START 
		TRANSACTION, COMMIT和ROLLBACK语法”</a>。<span>XA</span>事务支持还可以允许<span>MySQL</span>参与分布式事务。请参见<a href="sql-syntax.html#xa" title="13.4.7. XA Transactions">13.4.7节，“XA事务”</a>。</p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="commit"></a>13.4.1. START 
			TRANSACTION, COMMIT和ROLLBACK语法</h3></div></div></div><a class="indexterm" name="id2911894"></a><a class="indexterm" name="id2911903"></a><a class="indexterm" name="id2911912"></a><a class="indexterm" name="id2911921"></a>
			<pre><span>START TRANSACTION | BEGIN [WORK]</span></pre>
			<pre><span>COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]</span></pre>
			<pre><span>ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]</span></pre>
			<pre><span>SET AUTOCOMMIT = {0 | 1}</span></pre>
			<p><span>START TRANSACTION</span>或<span>BEGIN</span>语句可以开始一项新的事务。<span>COMMIT</span>可以提交当前事务，是变更成为永久变更。<span>ROLLBACK</span>可以
			回滚当前事务，取消其变更。<span>SET 
			AUTOCOMMIT</span>语句可以禁用或启用默认的<span>autocommit</span>模式，用于当前连接。</p>
			<p>自选的<span>WORK</span>关键词被支持，用于<span>COMMIT</span>和<span>RELEASE</span>，与<span>CHAIN</span>和<span>RELEASE</span>子句。<span>CHAIN</span>和<span>RELEASE</span>可以被用于对事务完成进行附加控制。<span>Completion_type</span>系统变量的值决定了默认完成的性质。请参见<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a>。</p>
			<p><span>AND CHAIN</span>子句会在当前事务结束时，立刻启动一个新事务，并且新事务与刚结束的事务有相同的隔离等级。<span>RELEASE</span>子句在终止了当前事务后，会让服务器断开与当前客户端的连接。包含<span>NO</span>关键词可以抑制<span>CHAIN</span>或<span>RELEASE</span>完成。如果<span>completion_type</span>系统变量被设置为一定的值，使连锁或释放完成可以默认进行，此时<span>NO</span>关键词有用。</p>
			<p>默认情况下，<span>MySQL</span>采用<span>autocommit</span>模式运行。这意味着，当您执行一个用于更新（修改）表的语句之后，<span>MySQL</span>立刻把更新存储到磁盘中。</p>
			<p>如果您正在使用一个事务安全型的存储引擎（如<span>InnoDB, BDB</span>或<span>NDB</span>簇），则您可以使用以下语句禁用<span>autocommit</span>模式：</p>
			<pre><span>SET AUTOCOMMIT=0;</span></pre>
			<p>通过把<span>AUTOCOMMIT</span>变量设置为零，禁用<span>autocommit</span>模式之后，您必须使用<span>COMMIT</span>把变更存储到磁盘中，或着如果您想要忽略从事务开始进行以来做出的变更，使用<span>ROLLBACK</span>。</p>
			<p>如果您想要对于一个单一系列的语句禁用<span>autocommit</span>模式，则您可以使用<span>START 
			TRANSACTION</span>语句：</p>
			<pre><span>START TRANSACTION;</span></pre>
			<pre><span>SELECT @A:=SUM(salary) FROM table1 WHERE type=1;</span></pre>
			<pre><span>UPDATE table2 SET summary=@A WHERE type=1;</span></pre>
			<pre><span>COMMIT;</span></pre>
			<p>使用<span>START TRANSACTION</span>，<span>autocommit</span>仍然被禁用，直到您使用<span>COMMIT</span>或<span>ROLLBACK</span>结束事务为止。然后<span>autocommit</span>模式恢复到原来的状态。</p>
			<p><span>BEGIN</span>和<span>BEGIN WORK</span>被作为<span>START 
			TRANSACTION</span>的别名受到支持，用于对事务进行初始化。<span>START 
			TRANSACTION</span>是标准的<span>SQL</span>语法，并且是启动一个<span>ad-hoc</span>事务的推荐方法。<span>BEGIN</span>语句与<span>BEGIN</span>关键词的使用不同。<span>BEGIN</span>关键词可以启动一个<span>BEGIN...END</span>复合语句。后者不会开始一项事务。请参见<a href="stored-procedures.html#begin-end" title="20.2.7. BEGIN ... END Compound Statement">20.2.7节，“BEGIN 
		... END复合语句”</a>。</p>
			<p>您也可以按照如下方法开始一项事务：</p>
			<pre><span>START TRANSACTION WITH CONSISTENT SNAPSHOT;</span></pre>
			<p><span>WITH CONSISTENT SNAPSHOT</span>子句用于启动一个一致的读取，用于具有此类功能的存储引擎。目前，该子句只适用于<span>InnoDB</span>。该子句的效果与发布一个<span>START 
			TRANSACTION</span>，后面跟一个来自任何<span>InnoDB</span>表的<span>SELECT</span>的效果一样。请参见<a href="storage-engines.html#innodb-consistent-read" title="15.2.10.4. Consistent Non-Locking Read">15.2.10.4节，“一致的非锁定读”</a>。</p>
			<p>开始一项事务会造成一个隐含的<span>UNLOCK TABLES</span>被执行。</p>
			<p>为了获得最好的结果，事务应只使用由单一事务存储引擎管理的表执行。否则，会出现以下问题：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用的表来自多个事务安全型存储引擎（例如<span>InnoDB</span>和<span>BDB</span>），并且事务隔离等级不是<span>SERIALIZABLE</span>，则有可能当一个事务提交时，其它正在进行中的、使用同样的表的事务将只会发生由第一个事务产生的变更。也就是，用混合引擎不能保证事务的原子性，并会造成不一致。（如果混合引擎事务不经常有，则您可以根据需要使用<span>SET 
			TRANSACTION ISOLATION LEVEL</span>把隔离等级设置到<span>SERIALIZABLE</span>。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您在事务中使用非事务安全型表，则对这些表的任何变更被立刻存储，不论<span>autocommit</span>模式的状态如何。</p>
			<p>如果您在更新了事务中一个事务表之后，发布一个<span>ROLLBACK</span>语句，则会出现一个<span>ER_WARNING_NOT_COMPLETE_ROLLBACK</span>警告。对事务安全型表的变更被
			回滚，但是对非事务安全型表没有变更。</p>
			<p>每个事务被存储在一个组块中的二进制日志中，在<span>COMMIT</span>之上。被回滚的事务不被计入日志。（例外情况：对非事务表的更改不会被
			回滚。如果一个被回滚的事务包括对非事务表的更改，则整个事务使用一个在末端的<span>ROLLBACK</span>语句计入日志，以确保对这些表的更改进行复制。）见<a href="database-administration.html#binary-log" title="5.11.3. The Binary Log">5.11.3节，“二进制日志”</a>。</p>
			<p>您可以使用<span>SET TRANSACTION ISOLATION LEVEL</span>更改事务的隔离等级。请参见<a href="sql-syntax.html#set-transaction" title="13.4.6. SET TRANSACTION Syntax">13.4.6节，“SET 
		TRANSACTION语法”</a>。</p>
			<p>回滚可以慢速运行。在用户没有明确要求时，也可以进行回滚（例如，当错误发生时）。因此，在明确地和隐含的（<span>ROLLBACK 
			SQL</span>命令）回滚时，<span>SHOW PROCESSLIST</span>会在<span>Stage</span>列中显示<span>Rolling 
			back</span>，用于连接。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="cannot-roll-back"></a>
			13.4.2.&nbsp;不能回滚的语句</h3></div></div></div>
			<p>有些语句不能被回滚。通常，这些语句包括数据定义语言（<span>DDL</span>）语句，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。</p>
			<p>
			您在设计事务时，不应包含这类语句。如果您在事务的前部中发布了一个不能被回滚的语句，则后部的其它语句会发生错误，在这些情况下，通过发布<span>ROLLBACK</span>语句不能
			回滚事务的全部效果。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="implicit-commit"></a>
			13.4.3.&nbsp;会造成隐式提交的语句</h3></div></div></div>
			<p>以下语句（以及同义词）均隐含地结束一个事务，似乎是在执行本语句前，您已经进行了一个<span>COMMIT</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ALTER 
			FUNCTION</span><span>,
			<span>ALTER PROCEDURE</span>,
			<span>ALTER TABLE</span>,
			<span>BEGIN</span>,
			<span>CREATE DATABASE</span>,
			<span>CREATE FUNCTION</span>,
			<span>CREATE INDEX</span>,
			<span>CREATE PROCEDURE</span>,
			<span>CREATE TABLE</span>,
			<span>DROP DATABASE</span>,
			<span>DROP FUNCTION</span>,
			<span>DROP INDEX</span>,
			<span>DROP PROCEDURE</span>,
			<span>DROP TABLE</span>,
			<span>LOAD MASTER DATA</span>,
			<span>LOCK TABLES</span>,
			<span>RENAME TABLE</span>,
			<span>SET AUTOCOMMIT=1</span>,
			<span>START TRANSACTION</span>,
			<span>TRUNCATE TABLE</span>,
			<span>UNLOCK TABLES</span>. </span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当当前所有的表均被锁定时，<span>UNLOCK TABLES</span>可以提交事务。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>CREATE 
			TABLE</span><span>, <span>
			CREATE DATABASE</span> <span>DROP DATABASE</span>,
			<span>TRUNCATE TABLE</span>,
			<span>ALTER FUNCTION</span>,
			<span>ALTER PROCEDURE</span>,
			<span>CREATE FUNCTION</span>,
			<span>CREATE PROCEDURE</span>,
			<span>DROP FUNCTION</span></span>和<span><span>DROP 
			PROCEDURE</span>等语句会导致一个隐含提交。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>InnoDB</span>中的<span>CREATE 
			TABLE</span>语句被作为一个单一事务进行处理。这意味着，来自用户的<span>ROLLBACK</span>不会撤销用户在事务处理过程中创建的<span>CREATE 
			TABLE</span>语句。</p>
			<p>事务不能被嵌套。这是隐含<span>COMMIT</span>的结果。当您发布一个<span>START 
			TRANSACTION</span>语句或其同义词时，该<span>COMMIT</span>被执行，用于任何当前事务。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="savepoints"></a>13.4.4. SAVEPOINT和ROLLBACK 
			TO SAVEPOINT语法</h3></div></div></div><a class="indexterm" name="id2912645"></a><a class="indexterm" name="id2912654"></a><a class="indexterm" name="id2912663"></a>
			<pre><span>SAVEPOINT <span><i>identifier</i></span></span></pre>
			<pre><span>ROLLBACK [WORK] TO SAVEPOINT <span><i>identifier</i></span></span></pre>
			<pre><span>RELEASE SAVEPOINT <span><i>identifier</i></span></span></pre>
			<p><span>InnoDB</span>支持<span>SQL</span>语句<span>SAVEPOINT</span><span>,
			<span>ROLLBACK TO SAVEPOINT</span>,
			<span>RELEASE SAVEPOINT</span></span><span>和自选的用于<span>ROLLBACK</span>的<span>WORK</span>关键词。</span></p>
			<p><span>SAVEPOINT</span>语句用于设置一个事务保存点，带一个标识符名称。如果当前事务有一个同样名称的保存点，则旧的保存点被删除，新的保存点被设置。</p>
			<p><span>ROLLBACK TO SAVEPOINT</span>语句会向以命名的保存点回滚一个事务。如果在保存点被设置后，当前事务对行进行了更改，则这些更改会在
			回滚中被撤销。但是，<span>InnoDB</span>不会释放被存储在保存点之后的存储器中的行锁定。（注意，对于新插入的行，锁定信息被存储在行中的事务<span>ID</span>承载；锁定没有被分开存储在存储器中。在这种情况下，行锁定在撤销中被释放。）在被命名的保存点之后设置的保存点被删除。</p>
			<p>如果语句返回以下错误，则意味着不存在带有指定名称的保存点：</p>
			<pre><span>ERROR 1181: Got error 153 during ROLLBACK</span></pre>
			<p><span>RELEASE SAVEPOINT</span>语句会从当前事务的一组保存点中删除已命名的保存点。不出现提交或
			回滚。如果保存点不存在，会出现错误。</p>
			<p>如果您执行<span>COMMIT</span>或执行不能命名保存点的<span>ROLLBACK</span>，则当前事务的所有保存点被删除。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="lock-tables"></a>13.4.5. LOCK 
			TABLES和UNLOCK TABLES语法</h3></div></div></div><a class="indexterm" name="id2912838"></a><a class="indexterm" name="id2912846"></a>
			<pre><span>LOCK TABLES</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>tbl_name</i></span> [AS <span><i>alias</i></span>] {READ [LOCAL] | [LOW_PRIORITY] WRITE}</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [, <span><i>tbl_name</i></span> [AS <span><i>alias</i></span>] {READ [LOCAL] | [LOW_PRIORITY] WRITE}] ...</span></pre>
			<pre><span>UNLOCK TABLES</span></pre>
			<p><span>LOCK TABLES</span>可以锁定用于当前线程的表。如果表被其它线程锁定，则造成堵塞，直到可以获取所有锁定为止。<span>UNLOCK 
			TABLES</span>可以释放被当前线程保持的任何锁定。当线程发布另一个<span>LOCK TABLES</span>时，或当与服务器的连接被关闭时，所有由当前线程锁定的表被隐含地解锁。</p>
			<p><span>&nbsp; </span>
			表锁定只用于防止其它客户端进行不正当地读取和写入。保持锁定（即使是读取锁定）的客户端可以进行表层级的操作，比如<span>DROP 
			TABLE</span>。</p>
			<p>注意，下面是对事务表使用<span>LOCK TABLES</span>的说明：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在尝试锁定表之前，<span>LOCK TABLES</span>不是事务安全型的，会隐含地提交所有活性事务。同时，开始一项事务（例如，使用<span>START 
			TRANSACTION</span>），会隐含地执行<span>UNLOCK TABLES</span>。（见<a href="sql-syntax.html#implicit-commit" title="13.4.3. Statements That Cause an Implicit Commit">13.4.3节，“会造成隐式提交的语句”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对事务表（如<span>InnoDB</span>）使用<span>LOCK 
			TABLES</span>的正确方法是，设置<span>AUTOCOMMIT=0</span>并且不能调用<span>UNLOCK 
			TABLES</span>，直到您明确地提交事务为止。当您调用<span>LOCK TABLES</span>时，<span>InnoDB</span>会内部地取其自己的表锁定，<span>MySQL</span>取其自己的表锁定。<span>InnoDB</span>在下一个提交时释放其表锁定，但是，对于<span>MySQL</span>，要释放表锁定，您必须调用<span>UNLOCK 
			TABLES</span>。您不应该让<span>AUTOCOMMIT=1</span>，因为那样的话，<span>InnoDB</span>会在调用<span>LOCK 
			TABLES</span>之后立刻释放表锁定，并且很容易形成死锁定。注意，如果<span>AUTOCOMMIT=1</span>，我们根本不能获取<span>InnoDB</span>表锁定，这样就可以帮助旧的应用软件避免不必要的死锁定。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ROLLBACK</span>不会释放<span>MySQL</span>的非事务表锁定。</p>
			<p>要使用<span>LOCK TABLES</span>，您必须拥有相关表的<span>LOCK 
			TABLES</span>权限和<span>SELECT</span>权限。</p>
			<p>使用<span>LOCK TABLES</span>的主要原因是仿效事务，或在更新表时加快速度。这将在后面进行更详细的解释。</p>
			<p>如果一个线程获得对一个表地<span>READ</span>锁定，该线程（和所有其它线程）只能从该表中读取。如果一个线程获得对一个表的<span>WRITE</span>锁定，只有保持锁定的线程可以对表进行写入。其它的线程被阻止，直到锁定被释放时为止。</p>
			<p><span>READ LOCAL</span>和<span>READ</span>之间的区别是，<span>READ 
			LOCAL</span>允许在锁定被保持时，执行非冲突性<span>INSERT</span>语句（同时插入）。但是，如果您正打算在<span>MySQL</span>外面操作数据库文件，同时您保持锁定，则不能使用<span>READ 
			LOCAL</span>。对于<span>InnoDB</span>表，<span>READ 
			LOCAL</span>与<span>READ</span>相同。</p>
			<p>当您使用<span>LOCK TABLES</span>时，您必须锁定您打算在查询中使用的所有的表。虽然使用<span>LOCK 
			TABLES</span>语句获得的锁定仍然有效，但是您不能访问没有被此语句锁定的任何的表。同时，您不能在一次查询中多次使用一个已锁定的表——使用别名代替，在此情况下，您必须分别获得对每个别名的锁定。</p>
			<pre><span>mysql&gt; <span><b>LOCK TABLE t WRITE, t AS t1 WRITE;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>INSERT INTO t SELECT * FROM t;</b></span></span></pre>
			<pre><span>ERROR 1100: Table &#39;t&#39; was not locked with LOCK TABLES</span></pre>
			<pre><span>mysql&gt; <span><b>INSERT INTO t SELECT * FROM t AS t1;</b></span></span></pre>
			<p>如果您的查询使用一个别名引用一个表，那么您必须使用同样的别名锁定该表。如果没有指定别名，则不会锁定该表。</p>
			<pre><span>mysql&gt; <span><b>LOCK TABLE t READ;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>SELECT * FROM t AS myalias;</b></span></span></pre>
			<pre><span>ERROR 1100: Table &#39;myalias&#39; was not locked with LOCK TABLES</span></pre>
			<p>相反的，如果您使用一个别名锁定一个表，您必须使用该别名在您的查询中引用该表。</p>
			<pre><span>mysql&gt; <span><b>LOCK TABLE t AS myalias READ;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>SELECT * FROM t;</b></span></span></pre>
			<pre><span>ERROR 1100: Table &#39;t&#39; was not locked with LOCK TABLES</span></pre>
			<pre><span>mysql&gt; <span><b>SELECT * FROM t AS myalias;</b></span></span></pre>
			<p><span>WRITE</span>锁定通常比<span>READ</span>锁定拥有更高的优先权，以确保更新被尽快地处理。这意味着，如果一个线程获得了一个<span>READ</span>锁定，则另一个线程会申请一个<span>WRITE</span>锁定，后续的<span>READ</span>锁定申请会等待，直到<span>WRITE</span>线程获得锁定并释放锁定。您可以使用<span>LOW_PRIORITY 
			WRITE</span>锁定来允许其它线程在该线程正在等待<span>WRITE</span>锁定时获得<span>READ</span>锁定。只有当您确定最终将有一个时机，此时没有线程拥有<span>READ</span>锁定时，您才应该使用<span>LOW_PRIORITY 
			WRITE</span>锁定。</p>
			<p><span>LOCK TABLES</span>按照如下方式执行：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>按照内部定义的顺序，对所有要被锁定的表进行分类。从用户的角度，此顺序是未经定义的。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>如果使用一个读取和一个写入锁定对一个表进行锁定，则把写入锁定放在读取锁定之前。</p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>一次锁定一个表，直到线程得到所有锁定为止。</p>
			<p>该规则确保表锁定不会出现死锁定。但是，对于该规则，您需要注意其它的事情：</p>
			<p>如果您正在对一个表使用一个<span>LOW_PRIORITY WRITE</span>锁定，这只意味着，<span>MySQL</span>等待特定的锁定，直到没有申请<span>READ</span>锁定的线程时为止。当线程已经获得<span>WRITE</span>锁定，并正在等待得到锁定表清单中的用于下一个表的锁定时，所有其它线程会等待<span>WRITE</span>锁定被释放。如果这成为对于应用程序的严重的问题，则您应该考虑把部分表转化为事务安全型表。</p>
			<p>您可以安全地使用<span>KILL</span>来结束一个正在等待表锁定的线程。请参见<a href="sql-syntax.html#kill" title="13.5.5.3. KILL Syntax">13.5.5.3节，“KILL语法”</a>。</p>
			<p>注意，您不能使用<span>INSERT DELAYED</span>锁定任何您正在使用的表，因为，在这种情况下，<span>INSERT</span>由另一个线程执行。</p>
			<p>通常，您不需要锁定表，因为所有的单个<span>UPDATE</span>语句都是原子性的；没有其它的线程可以干扰任何其它当前正在执行的<span>SQL</span>语句。但是，在几种情况下，锁定表会有好处：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您正在对一组<span>MyISAM</span>表运行许多操作，锁定您正在使用的表，可以快很多。锁定<span>MyISAM</span>表可以加快插入、更新或删除的速度。不利方面是，没有线程可以更新一个用<span>READ</span>锁定的表（包括保持锁定的表），也没有线程可以访问用<span>WRITE</span>锁定的表（除了保持锁定的表以外）。</p>
			<p>有些<span>MyISAM</span>操作在<span>LOCK 
			TABLES</span>之下更快的原因是，<span>MySQL</span>不会清空用于已锁定表的关键缓存，直到<span>UNLOCK 
			TABLE</span>被调用为止。通常，关键缓存在每个<span>SQL</span>语句之后被清空。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您正在使用<span>MySQL</span>中的一个不支持事务的存储引擎，则如果您想要确定在<span>SELECT</span>和<span>UPDATE</span>之间没有其它线程，您必须使用<span>LOCK 
			TABLES</span>。本处所示的例子要求<span>LOCK TABLES</span>，以便安全地执行：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>LOCK TABLES trans READ, customer WRITE;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT SUM(value) FROM trans WHERE customer_id=<i>some_id</i>;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>UPDATE customer</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>SET total_value=<i>sum_from_previous_statement</i></b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE customer_id=<i>some_id</i>;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>UNLOCK TABLES;</b></span></span></pre>
			<p>如果没有<span>LOCK TABLES</span>，有可能另一个线程会在执行<span>SELECT</span>和<span>UPDATE</span>语句之间在<span>trans</span>表中插入一个新行。</p>
			<p>通过使用相对更新（<span>UPDATE 
			customer SET <i>value</i>=<i>value</i>+<i>new_value</i></span>）或<span>LAST_INSERT_ID()</span>函数，您可以在许多情况下避免使用<span>LOCK 
			TABLES</span>。请参见<a href="introduction.html#ansi-diff-transactions" title="1.8.5.3. Transactions and Atomic Operations">1.8.5.3节，“事务和原子操作”</a>。</p>
			<p>通过使用用户层级的顾问式锁定函数<span>GET_LOCK()</span>和<span>RELEASE_LOCK()</span>，您也可以在有些情况下避免锁定表。这些锁定被保存在服务器中的一个混编表中，使用<span>pthread_mutex_lock()</span><span>
			</span>和<span><span>pthread_mutex_unlock()</span>，以加快速度。请参见</span><a href="functions.html#miscellaneous-functions" title="12.9.4. Miscellaneous Functions">12.9.4节，“其他函数”</a><span>。</span></p>
			<p>要了解更多有关锁定规则的说明，请参见<a href="optimization.html#internal-locking" title="7.3.1. Locking Methods">7.3.1节，“锁定方法”</a>。</p>
			<p>您可以使用<span>FLUSH TABLES WITH READ LOCK</span>语句锁定位于所有带有读取锁定的数据库中的所有表。请参见<a href="sql-syntax.html#flush" title="13.5.5.2. FLUSH Syntax">13.5.5.2节，“FLUSH语法”</a>。如果您有一个可以及时拍摄快照的文件系统，比如<span>Veritas</span>，这是获得备份的一个非常方便的方式。</p>
			<p>注释：如果您对一个已锁定的表使用<span>ALTER TABLE</span>，该表可能会解锁。请参见<a href="problems.html#alter-table-problems" title="A.7.1. Problems with ALTER TABLE">A.7.1节，“与ALTER TABLE有关的问题”</a>。 </div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="set-transaction"></a>13.4.6. SET 
			TRANSACTION语法</h3></div></div></div><a class="indexterm" name="id2913625"></a><a class="indexterm" name="id2913634"></a>
			<pre><span>SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL</span></pre>
			<pre><span>{ READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }</span></pre>
			<p>本语句用于设置事务隔离等级，用于下一个事务，或者用于当前会话。</p>
			<p>在默认情况下，<span>SET TRANSACTION</span>会为下一个事务（还未开始）设置隔离等级。如果您使用<span>GLOBAL</span>关键词，则语句会设置全局性的默认事务等级，用于从该点以后创建的所有新连接。原有的连接不受影响。要进行此操作，您需要<span>SUPER</span>权限。使用<span>SESSION</span>关键测可以设置默认事务等级，用于对当前连接执行的所有将来事务。</p>
			<p>要了解对每个<span>InnoDB</span>事务隔离等级的描述，请参见<a href="storage-engines.html#innodb-transaction-isolation" title="15.2.10.3. InnoDB and TRANSACTION ISOLATION LEVEL">15.2.10.3节，“InnoDB和TRANSACTION ISOLATION LEVEL”</a>。<span>InnoDB</span>支持<span>MySQL 
			5.1</span>中的各个等级。默认的等级是<span>REPEATABLE READ</span>。</p>
			<p>您可以使用<span>--transaction-isolation</span>选项，对<strong><span>mysqld</span></strong>设置初始的默认全局隔离等级。请参见<a href="database-administration.html#server-options" title="5.3.1. mysqld Command-Line Options">5.3.1节，“<span><strong class="command">mysqld</strong></span>命令行选项”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="xa"></a>
			13.4.7.&nbsp;XA事务</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#xa-statements">
				13.4.7.1. XA事务SQL语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa-states">13.4.7.2. 
				XA事务状态</a></span></dt></dl></div><a class="indexterm" name="id2913760"></a>
			<p>对于<span>InnoDB</span>存储引擎，可以获得对<span>XA</span>事务的支持。<span>MySQL 
			XA</span>的执行依据<span>X/Open CAE</span>文件<em><span>Distributed 
			Transaction Processing: The XA Specification</span></em>。本文件由<span>Open 
			Group</span>出版，可以从<span><a target="_top"  href="http://www.opengroup.org/public/pubs/catalog/c193.htm">http://www.opengroup.org/public/pubs/catalog/c193.htm</a></span>获取。在<a href="restrictions.html#xa-restrictions" title="I.5. Restrictions on XA Transactions">I.5节，“对XA事务的限制”</a>对当前<span>XA</span>执行的限制进行了描述。</p>
			<p>在客户端方面，没有特殊要求。连接<span>MySQL</span>服务器的<span>XA</span>接口由以<span>XA</span>关键词开头的<span>SQL</span>语句组成。<span>MySQL</span>客户端必须能发送<span>SQL</span>语句，并能理解<span>XA</span>语句接口的语义，但是它们不需要被链接到特定的<span>MySQL</span>客户库上。</p>
			<p>当前，在<span>MySQL</span>连接器当中，<span>MySQL</span>连接器<span>/J 
			5.0.0</span>直接支持<span>XA</span>（也就是，通过一个可以控制<span>XA 
			SQL</span>语句接口的等级接口）。</p>
			<p><span>XA</span>支持分布式的事务，具备能力，让多个独立的事务资源参加全局的事务。事务资源通常是<span>RDBMSs</span>，不过也可以是其它种类的资源。</p>
			<p>
			一个全局事务会涉及到多个行动，这些行动本身是事务性的。不过，所有行动都必须作为一个群组成功完成，或者作为一个群组被回滚。实际上，这会延伸<span>ACID</span>性质，“提高等级”，这样，多个<span>ACID</span>事务就可以一起执行，相当于也拥有<span>ACID</span>性质的全局操作的组件。（但是，对于一个分布式事务，您必须使用<span>SERAILIZABLE</span>隔离等级，以实现<span>ACID</span>性质。对于一个非分布式事务，使用<span>REPEATABLE 
			READ</span>就足够了。但是对于分布式事务，使用<span>REPEATABLE READ</span>是不够的。）</p>
			<p>分布式事务的部分示例：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>应用程序相当于一个把消息传递服务和<span>RDBMS</span>组合在一起的整合工具。应用程序可以确保，所有进行消息发送、回收和处理的事务（同时包含一个事务数据库）均在一个全局事务中发生。您可以把这看作是“事务电子邮件。”</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>应用程序执行的行动会涉及到不同数据库服务器，比如<span>MySQL</span>服务器和<span>Oracle</span>服务器（或多个<span>MySQL</span>服务器）。涉及到多个服务器的行动必须作为一个全局事务的一部分发生，而不是作为针对每个服务器的独立的本地事务发生。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>银行把帐户信息保存在<span>RDBMS</span>中，并通过自动取款机（<span>ATMs</span>）分发和收取欠款。必须要确保<span>ATM</span>行动被正确地反映到帐户中，但是这不能只由<span>RDBMS</span>单独完成。全局事务管理器会整合<span>ATM</span>和数据库资源，以确保财务事务的整体一致性。</p>
			<p>使用全局事务的应用程序涉及一个或多个资源管理器和一个事务管理器：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>资源管理器（<span>RM</span>）用于提供通向事务资源的途径。数据库服务器是一种资源管理器。该管理器必须可以提交或
			回滚由<span>RM</span>管理的事务。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>事务管理器（<span>TM</span>）用于协调作为一个全局事务一部分的事务。<span>TM</span>与管理每个事务的<span>RMs</span>进行通讯。一个全局事务中各个单个事务均是全局事务的“分支”。全局事务和各分支通过一种命名方法进行标识。这种命名方法在后面进行讲述。</p>
			<p><span>MySQL</span>执行<span>XA MySQL</span>时，<span>MySQL</span>服务器相当于一个用于管理全局事务中的<span>XA</span>事务的资源管理器。与<span>MySQL</span>服务器连接的客户端相当于事务管理器。</p>
			<p>
			要执行一个全局事务，必须知道涉及到了哪些组件，并且把每个组件引到一点，在此时，组件可以被提交或回滚时。根据每个组件报告的有关组件效能的内容，这些组件必须作为一个原子性群组全部提交或
			回滚。即，要么所有的组件必须提交，要么所有的组件必须回滚。要管理一个全局事务，必须要考虑任何组件或连接网络可能会故障。</p>
			<p>用于执行全局事务的过程使用两阶段提交（<span>2PC</span>），发生时间在由全局事务的分支进行的行动已经被执行之后。</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>在第一阶段，所有的分支被预备好。即，它们被<span>TM</span>告知要准备提交。通常，这意味着用于管理分支的每个<span>RM</span>会记录对于被稳定保存的分支的行动。分支指示是否它们可以这么做。这些结果被用于第二阶段。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>在第二阶段，<span>TM</span>告知<span>RMs</span>是否要提交或
			回滚。如果在预备分支时，所有的分支指示它们将能够提交，则所有的分支被告知要提交。如果在预备时，有任何分支指示它将不能提交，则所有分支被告知
			回滚。</p>
			<p>在有些情况下，一个全局事务可能会使用一阶段提交（<span>1PC</span>）。例如，当一个事务管理器发现，一个全局事务只由一个事务资源组成（即，单一分支），则该资源可以被告知同时进行预备和提交。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="xa-statements"></a>
				13.4.7.1.&nbsp;XA事务SQL语法</h4></div></div></div><a class="indexterm" name="id2914022"></a><a class="indexterm" name="id2914031"></a><a class="indexterm" name="id2914043"></a><a class="indexterm" name="id2914052"></a><a class="indexterm" name="id2914065"></a><a class="indexterm" name="id2914074"></a><a class="indexterm" name="id2914086"></a><a class="indexterm" name="id2914095"></a><a class="indexterm" name="id2914108"></a><a class="indexterm" name="id2914117"></a><a class="indexterm" name="id2914129"></a><a class="indexterm" name="id2914138"></a><a class="indexterm" name="id2914151"></a><a class="indexterm" name="id2914161"></a>
				<p>要在<span>MySQL</span>中执行<span>XA</span>事务，应使用以下语句：</p>
				<pre><span>XA {START|BEGIN} <span><i>xid</i></span> [JOIN|RESUME]</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>XA END <span><i>xid</i></span> [SUSPEND [FOR MIGRATE]]</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>XA PREPARE <span><i>xid</i></span></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>XA COMMIT <span><i>xid</i></span> [ONE PHASE]</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>XA ROLLBACK <span><i>xid</i></span></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>XA RECOVER</span></pre>
				<p>对于<span>XA START</span>，<span>JOIN</span>和<span>RESUME</span>子句不被支持。</p>
				<p>对于<span>XA END</span>，<span>SUSPEND [FOR 
				MIGRATE]</span>子句不被支持。</p>
				<p>每个<span>XA</span>语句以<span>XA</span>关键词为开头，多数语句要求一个<span>xid</span>值。<span> 
				xid</span>是一个<span>XA</span>事务标识符。它指示该语句适用于哪个事务。<span>xid</span>值由客户端提供，或由<span>MySQL</span>服务器生成。<span>xid</span>值包含一到三个部分：</p>
				<pre><span><i><span>xid</span></i></span><span>: <span><i>gtrid</i></span> [, <span><i>bqual</i></span> [, <span><i>formatID</i></span> ]]</span></pre>
				<p><span>gtrid</span>是一个全局事务标识符，<span>bqual</span>是一个分支限定符，<span>formatID</span>是一个数字，用于标识由<span>gtrid</span>和<span>bqual</span>值使用的格式。根据语法的表示，<span>bqual</span>和<span>formatID</span>是自选的。如果没有给定，默认的<span>bqual</span>值是<span>&#39;&#39;</span>。如果没有给定，默认的<span>fromatID</span>值是<span>1</span>。</p>
				<p><span>gtrid</span>和<span>bqual</span>必须为字符串文字，每个的长度最多为<span>64</span>字节（不是字符）。<span>gtrid</span>和<span>bqual</span>可以用多种方法指定。您可以使用带引号的字符串<span>(<span>&#39;ab&#39;</span>)</span>，十六进制字符串<span>(<span>0x6162</span>,
				<span>X&#39;ab&#39;</span>)</span>，或位值<span>(<span>b&#39;<i>nnnn</i>&#39;</span>)</span>。</p>
				<p><span>formatID</span>是一个无符号的整数。</p>
				<p>通过<span>MySQL</span>服务器的带下划线的<span>XA</span>支持子程序，<span>gtrid</span>和<span>bqual</span>值被理解为以字节为单位。但是，在包含<span>XA</span>语句的<span>SQL</span>语句正在被分析的同时，服务器会去操作一些特定的字符集。为了安全，把<span>gtrid</span>和<span>bqual</span>作为十六进制字符串写入。</p>
				<p>通常，<span>xid</span>值由事务管理器生成。由一个<span>TM</span>生成的值必须与由其它<span>TMs</span>生成的值不同。一个给定的<span>TM</span>必须能识别自己的<span>xid</span>值。这些值位于由<span>XA 
				RECOVER</span>语句返回的值清单中。</p>
				<p><span>XA START xid</span>用于启动一个带给定<span>xid</span>值的<span>XA</span>事务。每个<span>XA</span>事务必须有一个唯一的<span>xid</span>值，因此该值当前不能被其它的<span>XA</span>事务使用。使用<span>gtrid</span>和<span>bqual</span>值评估唯一性。所有下列的用于<span>XA</span>事务的<span>XA</span>语句必须使用与<span>XA 
				START</span>语句中给定的相同的<span>xid</span>值进行指定。如果您使用这些语句，但是指定的<span>xid</span>值与部分原有的<span>XA</span>事务不对应的话，会发生错误。</p>
				<p>一项或多项<span>XA</span>事务可以是同一个全局事务的一部分。在一个给定的全局事务中的所有<span>XA</span>事务必须在<span>xid</span>值中使用同样的<span>gtrid</span>值。出于这个原因，<span>gtrid</span>值必须为全局唯一的，这样，有关一个给定的<span>XA</span>事务是哪个全局事务的一部分的问题就不会含糊不清。对于一个全局事务中的每个<span>XA</span>事务，<span>xid</span>值中的<span>bqual</span>部分必须不一样。（<span>bqual</span>值应不一样，这个要求是当前执行<span>MySQL 
				XA</span>的一个限制条件。这不是<span>XA</span>规约的一部分。）</p>
				<p>对于在<span>MySQL</span>服务器上的处于<span>PREPARED</span>状态的<span>XA</span>事务，<span>XA 
				RECOVER</span>语句会返回信息。（见<a href="sql-syntax.html#xa-states" title="13.4.7.2. XA Transaction States">13.4.7.2节，“XA事务状态”</a>.。）输出包括一个行，该行用于服务器上的每个这类<span>XA</span>事务，不论是哪个客户端启动了它。</p>
				<p><span>XA RECOVER</span>输出行看上去像这样（例如，<span>xid</span>值包括<span>&#39;abc&#39;</span><span>,
				<span>&#39;def&#39;</span></span>和 
				<span><span>7</span>等部分）：</span></p>
				<pre><span>mysql&gt; <span><b>XA RECOVER;</b></span></span></pre>
				<pre><span>+----------+--------------+--------------+--------+</span></pre>
				<pre><span>| formatID | gtrid_length | bqual_length | data&nbsp;&nbsp; |</span></pre>
				<pre><span>+----------+--------------+--------------+--------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 | abcdef |</span></pre>
				<pre><span>+----------+--------------+--------------+--------+</span></pre>
				<p>输出列有以下意义：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>formatID</span>是事务<span>xid</span>的<span>formatID</span>部分</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>gtrid_length</span>是<span>xid</span>的<span>gtrid</span>部分的长度，以字节为单位</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>bqual_length</span>是<span>xid</span>的<span>bqual</span>部分的长度，以字节为单位</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>data</span>是<span>xid</span>的<span>gtrid</span>部分和<span>bqual</span>部分的串联</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="xa-states"></a>
				13.4.7.2.&nbsp;XA事务状态</h4></div></div></div></div></div></div><div class="section"><div class="titlepage"><div><div>
		<span>XA</span>事务在以下状态下进展：<p>
		<span>1.<span>&nbsp;&nbsp;&nbsp;
		</span></span>使用<span>XA START</span>来启动一个<span>XA</span>事务，并把它放入<span>ACTIVE</span>状态。</p>
		<p><span>2.<span>&nbsp;&nbsp;&nbsp;
		</span></span>对于一个<span>ACTIVE XA</span>事务，发布构成事务的<span>SQL</span>语句，然后发布一个<span>XA 
		END</span>语句。<span>XA END</span>把事务放入<span>IDLE</span>状态。</p>
		<p><span>3.<span>&nbsp;&nbsp;&nbsp;
		</span></span>对于一个<span>IDLE XA</span>事务，您可以发布一个<span>XA 
		PREPARE</span>语句或一个<span>XA COMMIT</span>…<span>ONE 
		PHASE</span>语句：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span><span>XA PREPARE</span>把事务放入<span>PREPARED</span>状态。在此点上的<span>XA 
		RECOVER</span>语句将在其输出中包括事务的<span>xid</span>值，因为<span>XA 
		RECOVER</span>会列出处于<span>PREPARED</span>状态的所有<span>XA</span>事务。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span><span>XA COMMIT</span>…<span>ONE PHASE</span>用于预备和提交事务。<span>xid</span>值将不会被<span>XA 
		RECOVER</span>列出，因为事务终止。</p>
		<p><span>4.<span>&nbsp;&nbsp;&nbsp;
		</span></span>对于一个<span>PREPARED XA</span>事务，您可以发布一个<span>XA 
		COMMIT</span>语句来提交和终止事务，或者发布<span>XA ROLLBACK</span>来回滚并终止事务。</p>
		<p>下面是一个简单的<span>XA</span>事务，该事务把一行作为一个全局事务的一部分插入一个表中。</p>
		<pre><span>mysql&gt; <span><b>XA START &#39;xatest&#39;;</b></span></span></pre>
		<pre><span>Query OK, 0 rows affected (0.00 sec)</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>mysql&gt; <span><b>INSERT INTO mytable (i) VALUES(10);</b></span></span></pre>
		<pre><span>Query OK, 1 row affected (0.04 sec)</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>mysql&gt; <span><b>XA END &#39;xatest&#39;;</b></span></span></pre>
		<pre><span>Query OK, 0 rows affected (0.00 sec)</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>mysql&gt; <span><b>XA PREPARE &#39;xatest&#39;;</b></span></span></pre>
		<pre><span>Query OK, 0 rows affected (0.00 sec)</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>mysql&gt; <span><b>XA COMMIT &#39;xatest&#39;;</b></span></span></pre>
		<pre><span>Query OK, 0 rows affected (0.00 sec)</span></pre>
		<p>根据一个给定的客户端连接的语境，<span>XA</span>事务和本地（非<span>XA</span>）事务互相排斥。举例说明，如果已经发布了<span>XA 
		START</span>来开始一项<span>XA</span>事务，则本地事务不会被启动，直到<span>XA</span>事务已经被提交或被
		回滚为止。相反的，如果已经使用<span>START 
		TRANSACTION</span>启动一个本地事务，则<span>XA</span>语句不能被使用，直到该事务被提交或被
		回滚为止。</p>
		<h2 class="title"><a name="database-administration-statements"></a>
		13.5.&nbsp;数据库管理语句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#account-management-sql">
			13.5.1. 账户管理语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#table-maintenance-sql">
			13.5.2. 表维护语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-option">13.5.3. 
			SET语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show">13.5.4. 
			SHOW语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#other-administrative-sql">
			13.5.5. 其它管理语句</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="account-management-sql"></a>
			13.5.1.&nbsp;账户管理语句</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#create-user">13.5.1.1. 
				CREATE USER语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-user">13.5.1.2. 
				DROP USER语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#grant">13.5.1.3. 
				GRANT和REVOKE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-user">13.5.1.4. 
				RENAME USER语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-password">13.5.1.5. 
				SET PASSWORD语法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-user"></a>13.5.1.1. CREATE 
				USER语法</h4></div></div></div><a class="indexterm" name="id2914882"></a><a class="indexterm" name="id2914890"></a><a class="indexterm" name="id2914901"></a>
				<pre><span>CREATE USER <span><i>user</i></span> [IDENTIFIED BY [PASSWORD] &#39;<span><i>password</i></span>&#39;]</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [, <span><i>user</i></span> [IDENTIFIED BY [PASSWORD] &#39;<span><i>password</i></span>&#39;]] ...</span></pre>
				<p><span>CREATE USER</span>用于创建新的<span>MySQL</span>账户。要使用<span>CREATE 
				USER</span>，您必须拥有<span>mysql</span>数据库的全局<span>CREATE 
				USER</span>权限，或拥有<span>INSERT</span>权限。对于每个账户，<span>CREATE 
				USER</span>会在没有权限的<span>mysql.user</span>表中创建一个新记录。如果
				账户已经存在，则出现错误。</p>
				<p>使用自选的<span>IDENTIFIED BY</span>子句，可以为账户给定一个密码。<span>user</span>值和
				密码的给定方法和<span>GRANT</span>语句一样。特别是，要在纯文本中指定密码，需忽略<span>PASSWORD</span>关键词。要把
				密码指定为由<span>PASSWORD()</span>函数返回的混编值，需包含关键字<span>PASSWORD</span>。请参见<a href="sql-syntax.html#grant" title="13.5.1.3. GRANT and REVOKE Syntax">13.5.1.3节，“GRANT和REVOKE语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="drop-user"></a>13.5.1.2. DROP 
				USER语法</h4></div></div></div><a class="indexterm" name="id2915028"></a><a class="indexterm" name="id2915037"></a><a class="indexterm" name="id2915047"></a><a class="indexterm" name="id2915057"></a><a class="indexterm" name="id2915067"></a><a class="indexterm" name="id2915078"></a><a class="indexterm" name="id2915088"></a><a class="indexterm" name="id2915098"></a><a class="indexterm" name="id2915108"></a>
				<pre><span>DROP USER <span><i>user</i></span> [, <span><i>user</i></span>] ...</span></pre>
				<p><span>DROP USER</span>语句用于删除一个或多个<span>MySQL</span>账户。要使用<span>DROP 
				USER</span>，您必须拥有<span>mysql</span>数据库的全局<span>CREATE 
				USER</span>权限或<span>DELETE</span>权限。使用与<span>GRANT</span>或<span>REVOKE</span>相同的格式为每个
				账户命名；例如，<span>&#39;jeffrey&#39;@&#39;localhost&#39;</span>。
				账户名称的用户和主机部分与用户表记录的<span>User</span>和<span>Host</span>列值相对应。</p>
				<p>使用<span>DROP USER</span>，您可以取消一个账户和其权限，操作如下：</p>
				<pre><span>DROP USER <span><i>user</i></span>;</span></pre>
				<p>该语句可以删除来自所有授权表的帐户权限记录。</p>
				<p>要点：<span>DROP USER</span>不能自动关闭任何打开的用户对话。而且，如果用户有打开的对话，此时取消用户，则命令不会生效，直到用户对话被关闭后才生效。一旦对话被关闭，用户也被取消，此用户再次试图登录时将会失败。这是有意设计的。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="grant"></a>13.5.1.3. GRANT和REVOKE语法</h4></div></div></div><a class="indexterm" name="id2915267"></a><a class="indexterm" name="id2915276"></a><a class="indexterm" name="id2915285"></a><a class="indexterm" name="id2915295"></a><a class="indexterm" name="id2915305"></a><a class="indexterm" name="id2915312"></a><a class="indexterm" name="id2915322"></a><pre class="programlisting">GRANT <em class="replaceable">priv_type</em> [(<em class="replaceable">column_list</em>)] [, <em class="replaceable">priv_type</em> [(<em class="replaceable">column_list</em>)]] ...
    ON [<em class="replaceable">object_type</em>] {<em class="replaceable">tbl_name</em> | * | *.* | <em class="replaceable">db_name</em>.*}
    TO <em class="replaceable">user</em> [IDENTIFIED BY [PASSWORD] '<em class="replaceable">password</em>']
        [, <em class="replaceable">user</em> [IDENTIFIED BY [PASSWORD] '<em class="replaceable">password</em>']] ...
    [REQUIRE
        NONE |
        [{SSL| X509}]
        [CIPHER '<em class="replaceable">cipher</em>' [AND]]
        [ISSUER '<em class="replaceable">issuer</em>' [AND]]
        [SUBJECT '<em class="replaceable">subject</em>']]
    [WITH <em class="replaceable">with_option</em> [<em class="replaceable">with_option</em>] ...]

<em class="replaceable">object_type</em> =
    TABLE
  | FUNCTION
  | PROCEDURE

<em class="replaceable">with_option</em> =
    GRANT OPTION
  | MAX_QUERIES_PER_HOUR <em class="replaceable">count</em>
  | MAX_UPDATES_PER_HOUR <em class="replaceable">count</em>
  | MAX_CONNECTIONS_PER_HOUR <em class="replaceable">count</em>
  | MAX_USER_CONNECTIONS <em class="replaceable">count</em>
</pre><pre class="programlisting">REVOKE <em class="replaceable">priv_type</em> [(<em class="replaceable">column_list</em>)] [, <em class="replaceable">priv_type</em> [(<em class="replaceable">column_list</em>)]] ...
    ON [<em class="replaceable">object_type</em>] {<em class="replaceable">tbl_name</em> | * | *.* | <em class="replaceable">db_name</em>.*}
    FROM <em class="replaceable">user</em> [, <em class="replaceable">user</em>] ...

REVOKE ALL PRIVILEGES, GRANT OPTION FROM <em class="replaceable">user</em> [, <em class="replaceable">user</em>] ...
</pre>
				<p><span>GRANT</span>和<span>REVOKE</span>语句允许系统管理员创建<span>MySQL</span>用户
				账户，授予权限和撤销权限。</p>
				<p><span>MySQL</span>账户信息存储在<span>mysql</span>数据库的表中。在<a href="database-administration.html">第5章：</a><a href="database-administration.html" title="Chapter 5. Database Administration"><i>数据库管理</i></a>中对本数据库和访问控制系统进行了详尽的讨论。要了解更多详细信息，您应该查询此章。</p>
				<p>如果授权表拥有含有<span>mixed-case</span>数据库或表名称的权限记录，并且<span>lower_case_table_names</span>系统变量已设置，则不能使用<span>REVOKE</span>撤销权限，必须直接操纵授权表。（当<span><span>lower_case_table_names</span>已设置时，<span>GRANT</span>将不会创建此类记录，但是此类记录可能已经在设置变量之前被创建了。）</span></p>
				<p>授予的权限可以分为多个层级：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>全局层级</span></strong></p>
				<p>全局权限适用于一个给定服务器中的所有数据库。这些权限存储在<span>mysql.user</span>表中。<span>GRANT 
				ALL ON *.*</span>和<span><span>REVOKE 
				ALL ON *.*</span>只授予和撤销全局权限。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>数据库层级</span></strong>
				</p>
				<p>数据库权限适用于一个给定数据库中的所有目标。这些权限存储在<span>mysql.db</span>和<span>mysql.host</span>表中。<span>GRANT 
				ALL ON <i>db_name</i>.*</span>和<span><span>REVOKE 
				ALL ON <i>db_name</i>.*</span>只授予和撤销数据库权限。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>表层级</span></strong></p>
				<p>表权限适用于一个给定表中的所有列。这些权限存储在<span>mysql.talbes_priv</span>表中。<span>GRANT 
				ALL ON <i>db_name.tbl_name</i></span>和<span>REVOKE 
				ALL ON <i>db_name.tbl_name</i></span>只授予和撤销表权限。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>列层级</span></strong></p>
				<p>列权限适用于一个给定表中的单一列。这些权限存储在<span>mysql.columns_priv</span>表中。当使用<span>REVOKE</span>时，您必须指定与被授权列相同的列。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>子程序层级</span></strong></p>
				<p><span>CREATE ROUTINE, 
				ALTER ROUTINE, EXECUTE</span>和<span>GRANT</span>权限适用于已存储的子程序。这些权限可以被授予为全局层级和数据库层级。而且，除了<span>CREATE 
				ROUTINE</span>外，这些权限可以被授予为子程序层级，并存储在<span>mysql.procs_priv</span>表中。</p>
				<p>当后续目标是一个表、一个已存储的函数或一个已存储的过程时，<span><i><span>object_type</span></i></span>子句应被指定为<span>TABLE</span>、<span>FUNCTION</span>或<span>PROCEDURE</span>。当从旧版本的<span>MySQL</span>升级时，要使用本子句，您必须升级您的授权表。请参见<a href="installing.html#upgrading-grant-tables" title="2.10.2. Upgrading the Grant Tables">2.10.2节，“升级授权表”</a>。</p>
				<p>要使用<span>GRANT</span>或<span>REVOKE</span>，您必须拥有<span>GRANT 
				OPTION</span>权限，并且您必须用于您正在授予或撤销的权限。</p>
				<p>要撤销所有权限，需使用以下语法。此语法用于取消对于已命名的用户的所有全局层级、数据库层级、表层级和列层级的权限。</p>
				<pre><span>REVOKE ALL PRIVILEGES, GRANT OPTION FROM <span><i>user</i></span> [, <span><i>user</i></span>] ...</span></pre>
				<p>要使用本<span>REVOKE</span>语法，您必须拥有<span>mysql</span>数据库的全局<span>CREATE 
				USER</span>权限或<span>UPDATE</span>权限。</p>
				<p>对于<span>GRANT</span>和<span>REVOKE</span>语句，<span>priv_type</span>可以被指定为以下任何一种：</p>
				<table border="1" cellpadding="0" id="table7">
					<tr>
						<td>
						<p><strong>
						<span>权限</span></strong></td>
						<td>
						<p><strong>
						<span>意义</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>ALL [PRIVILEGES]</span></td>
						<td>
						<p><span>设置除<span>GRANT 
						OPTION</span>之外的所有简单权限</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>ALTER</span></td>
						<td>
						<p><span>允许使用<span>ALTER 
						TABLE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>ALTER ROUTINE</span></td>
						<td>
						<p>更改或取消已存储的子程序</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CREATE</span></td>
						<td>
						<p><span>允许使用<span>CREATE 
						TABLE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CREATE ROUTINE</span></td>
						<td>
						<p>创建已存储的子程序</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CREATE TEMPORARY TABLES</span></td>
						<td>
						<p><span>允许使用<span>CREATE 
						TEMPORARY TABLE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CREATE USER</span></td>
						<td>
						<p>允许使用<span>CREATE USER, 
						DROP USER, RENAME USER</span>和<span>REVOKE 
						ALL PRIVILEGES</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CREATE VIEW</span></td>
						<td>
						<p><span>允许使用<span>CREATE 
						VIEW</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>DELETE</span></td>
						<td>
						<p><span>允许使用<span>DELETE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>DROP</span></td>
						<td>
						<p><span>允许使用<span>DROP 
						TABLE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>EXECUTE</span></td>
						<td>
						<p>允许用户运行已存储的子程序</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>FILE</span></td>
						<td>
						<p><span>允许使用<span>SELECT...INTO 
						OUTFILE</span>和<span>LOAD DATA INFILE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>INDEX</span></td>
						<td>
						<p><span>允许使用<span>CREATE 
						INDEX</span>和<span>DROP INDEX</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>INSERT</span></td>
						<td>
						<p><span>允许使用<span>INSERT</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>LOCK TABLES</span></td>
						<td>
						<p>允许对您拥有<span>SELECT</span>权限的表使用<span>LOCK 
						TABLES</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>PROCESS</span></td>
						<td>
						<p><span>允许使用<span>SHOW 
						FULL PROCESSLIST</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>REFERENCES</span></td>
						<td>
						<p>未被实施</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>RELOAD</span></td>
						<td>
						<p><span>允许使用<span>FLUSH</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>REPLICATION CLIENT</span></td>
						<td>
						<p>允许用户询问从属服务器或主服务器的地址</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>REPLICATION SLAVE</span></td>
						<td>
						<p>用于复制型从属服务器（从主服务器中读取二进制日志事件）</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>SELECT</span></td>
						<td>
						<p><span>允许使用<span>SELECT</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>SHOW DATABASES</span></td>
						<td>
						<p><span>SHOW DATABASES</span>显示所有数据库</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>SHOW VIEW</span></td>
						<td>
						<p><span>允许使用<span>SHOW 
						CREATE VIEW</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>SHUTDOWN</span></td>
						<td>
						<p>允许使用<strong><span>mysqladmin 
						shutdown</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>SUPER</span></td>
						<td>
						<p>允许使用<span>CHANGE 
						MASTER, KILL, PURGE MASTER LOGS</span>和<span>SET 
						GLOBAL</span>语句，<strong><span>mysqladmin 
						debug</span></strong>命令；允许您连接（一次），即使已达到<span>max_connections</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>UPDATE</span></td>
						<td>
						<p><span>允许使用<span>UPDATE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>USAGE</span></td>
						<td>
						<p>“无权限”的同义词</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>GRANT OPTION</span></td>
						<td>
						<p>允许授予权限</td>
					</tr>
				</table>
				<p>当从旧版本的<span>MySQL</span>升级时，要使用<span>EXECUTE, 
				CREATE VIEW, SHOW VIEW, CREATE USER, CREATE ROUTINE</span>和<span>ALTER 
				ROUTINE</span>权限，您必须首先升级您的授权表。请参见<a href="installing.html#upgrading-grant-tables" title="2.10.2. Upgrading the Grant Tables">2.10.2节，“升级授权表”</a>。</p>
				<p><span>REFERENCES</span>权限目前未被使用。</p>
				<p>当您想要创建一个没有权限的用户时，可以指定<span>USAGE</span>。</p>
				<p>使用<span>SHOW GRANTS</span>来确定帐户拥有什么权限。请参见<a href="sql-syntax.html#show-grants" title="13.5.4.10. SHOW GRANTS Syntax">13.5.4.10节，“SHOW 
			GRANTS语法”</a>。</p>
				<p>您可以通过使用<span>ON *.*</span>语法赋予全局权限，或通过使用<span>ON
				<i>db_name</i>.*</span>语法赋予数据库层级权限。如果您指定了<span>ON 
				*</span>并且您已经选择了一个默认数据库，则权限被赋予到这个数据库中。（警告：如果您指定了<span>ON 
				*</span>同时您没有选择一个默认数据库，则权限是全局的。）</p>
				<p><span>FILE, PROCESS, RELOAD, REPLICATION CLIENT, 
				REPLICATION SLAVE, SHOW DATABASES, SHUTDOWN</span>和<span>SUPER</span>权限是管理性权限，只能进行全局授权（使用<span>ON 
				*.*</span>语法）。</p>
				<p>其它权限可以被全局授权，或被赋予为其它层级。</p>
				<p>对于一个表，您可以指定的<span>priv_type</span>值只能是<span>SELECT, 
				INSERT, UPDATE, DELETE, CREATE, DROP, GRANT OPTION, INDEX</span>和<span>ALTER</span>。</p>
				<p>对于一个列（也就是，当您使用一个<span>column_list</span>子句时），您可以指定的<span>priv_type</span>值只能是<span>SELECT, 
				INSERT</span>和<span>UPDATE</span>。</p>
				<p>在子程序层级，您可以指定的<span>priv_type</span>值只能是<span>ALTER 
				ROUTINE, EXECUTE</span>和<span>GRANT OPTION</span>。<span>CREATE 
				ROUTINE</span>不是一个子程序层级的权限，因为您必须拥有此权限，才能创建一个子程序。</p>
				<p>对于全局、数据库、表和子程序层级，<span>GRANT ALL</span>只能赋予在您正在授权的层级中存在的权限。例如，如果您使用<span>GRANT 
				ALL ON <i>db_name</i>.*</span>，这是一个数据库层级语句，因此不会授予全局权限，如<span>FILE</span>等。</p>
				<p><span>MySQL</span>允许您对不存在的数据库目标授予权限。在此情况下，将被授予的权限必须包括<span>CREATE</span>权限。这个性质是有意设计的，目的是允许数据库管理员为将在此后被创建的数据库目标预备用户
				账户和权限。</p>
				<p>要点：当您取消一个表或数据库时，<span>MySQL</span>不会自动撤销任何权限。但是，如果您取消一个子程序，则被赋予该子程序的所有子程序层级的权限都被撤销。</p>
				<p>注意：<span>GRANT</span>语句用于在全局层级或数据库层级赋予权限。当在<span>GRANT</span>语句中指定数据库名称时，允许使用‘<span>_</span>’和‘<span>%</span>’通配符。这意味着，如果您想要使用‘<span>_</span>’字符作为一个数据库名称的一部分，您应该在<span>GRANT</span>语句中指定它为‘<span>\_</span>’，以防止用户可以访问其它符合此通配符格式的数据库；例如，<span>GRANT 
				... ON `foo\_bar`.* TO ...</span>。</p>
				<p>为了接纳对来自任意主机的用户授权的权利，<span>MySQL</span>支持以<span><i><span>user_name</span></i><span>@<i>host_name</i></span></span>的形式指定<span>user</span>值。如果一个<span>user_name</span>或<span>host_name</span>与一个不加引号的标识符一样是合法的，那么您不需要对它加引号。不过，要指定一个包含特殊字符（如‘<span>-</span>’）的<span>user_name</span>字符串，或一个包含特殊字符或通配字符（如‘<span>%</span>’），则引号是必要的；例如，<span>&#39;test-user&#39;@&#39;test-hostname&#39;</span>。分别对<span>username</span>和<span>hostname</span>加引号。</p>
				<p>您可以在<span>hostname</span>中指定通配符。例如<span><i><span>user_name</span></i><span>@&#39;%.loc.gov&#39;</span></span>适用于在<span>loc.gov</span>域中的任何主机的<span>user_name</span>。同时<span><i><span>user_name</span></i><span>@&#39;144.155.166.%&#39;</span></span>适用于<span>144.155.166 
				C</span>级子网中的任何主机的<span>user_name</span>。</p>
				<p>简单形式<span>user_name</span>是<span><i><span>user_name</span></i><span>@&#39;%&#39;</span></span>的同义词。</p>
				<p><span>MySQL</span>不支持<span>usernames</span>中的通配符。通过把带有<span>User=&#39;&#39;</span>的登录项插入到<span>mysql.user</span>表中，或通过使用<span>GRANT</span>语句创建一个带有空名称的用户，可以定义匿名用户：</p>
				<pre><span>mysql&gt; <span><b>GRANT ALL ON test.* TO &#39;&#39;@&#39;localhost&#39; ...</b></span></span></pre>
				<p>当把带引号的值是，需使用反勾号<span>(</span>‘<span>`</span>’<span>)</span>为数据库、表、列和子程序名称加引号。使用单引号<span>(</span>‘<span>&#39;</span>’<span>)</span>为<span>hostnames</span>、<span>usernames</span>和
				密码加引号。</p>
				<p>警告：如果您允许匿名用户连接到<span>MySQL</span>服务器，则您应该同时向所有本地用户授予<span><i><span>user_name</span></i><span>@localhost</span></span>权限。否则，当有名称的用户试图从本地机器登录<span>MySQL</span>服务器时，<span>mysql.user</span>表中的用于<span>localhost</span>的匿名用户帐户会被使用。</p>
				<p>您可以通过执行以下查询来确定是否这适合于您。以下查询列举了所有匿名用户：</p>
				<pre><span>mysql&gt; <span><b>SELECT Host, User FROM mysql.user WHERE User=&#39;&#39;;</b></span></span></pre>
				<p>如果您想要删除本地匿名用户账户，以避免出现刚才谈到的问题，则需使用以下语句：</p>
				<pre><span>mysql&gt; <span><b>DELETE FROM mysql.user WHERE Host=&#39;localhost&#39; AND User=&#39;&#39;;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>FLUSH PRIVILEGES;</b></span></span></pre>
				<p><span>GRANT</span>支持最长为<span>60</span>个字符的<span>hostnames</span>。数据库、表、列和子程序名称最长可为<span>64</span>个字符。<span>Usernames</span>最长可为<span>16</span>个字符。
				注释：不能通过更改<span>mysql.user</span>表来改变<span>usernames</span>的允许长度。如果试图这么做，会导致出现不可预见的问题，可能会造成用户无法登录<span>MySQL</span>服务器。除了采用由<span>MySQL</span>公司提供的用于升级<span>MySQL</span>服务器的<span><span>mysql_fix_privilege_tables</span>原稿之外，</span>请您不要以任何方式变更授权表。</p>
				<p>对于表或列的权限是作为各个权限层级的逻辑<span>OR</span>权限被附加形成的。例如，如果<span>mysql.user</span>表指定一个用户拥有全局<span>SELECT</span>权限，则该权限不能被数据库、表或列层级的登录项定义。</p>
				<p>可以按下列方法计算列权限：</p>
				<pre><span>global privileges</span></pre>
				<pre><span>OR (database privileges AND host privileges)</span></pre>
				<pre><span>OR table privileges</span></pre>
				<pre><span>OR column privileges</span></pre>
				<p>在多数情况下，您只在一个权限层级下向用户授予权利，所以寿命通常不是那么复杂。有关权限检查规程的细节，请参见<a href="database-administration.html#privilege-system" title="5.7. The MySQL Access Privilege System">5.7节，“MySQL访问权限系统”</a>。</p>
				<p>如果您对一个在<span>mysql.user</span>表中不存在的<span>username/hostname</span>组合授予权限，则增加一个登录项并保持在此处，直到使用<span>DELETE</span>语句删除为止。换句话说，<span>GRANT</span>可以创建用户表登录项，但是<span>REVOKE</span>不会取消它们；您必须使用<span>DROP 
				USER</span>或<span>DELETE</span>明确地操作。</p>
				<p>如果创建了一个新的用户，或者如果您拥有全局授权权限，则用户密码被设置为由<span>IDENTIFIED 
				BY</span>子句指定的密码（如果给定了一个）。如果用户已拥有了一个密码，则此密码被新密码替代。</p>
				<p>警告：如果您创建了一个新用户，但是不指定<span>IDENTIFIED BY</span>子句，则用户没有
				密码。这是很不安全的。不过，您可以启用<span>NO_AUTO_CREATE_USER 
				SQL</span>模式，来防止<span>GRANT</span>创建一个新用户（否则<span>GRANT</span>会这么做），除非给定了<span>IDENTIFIED 
				BY</span>来为新用户提供一个密码。</p>
				<p>使用<span>SET PASSWORD</span>语句也可以设置密码。请参见<a href="sql-syntax.html#set-password" title="13.5.1.5. SET PASSWORD Syntax">13.5.1.5节，“SET 
			PASSWORD语法”</a>。</p>
				<p>在<span>IDENTIFIED BY</span>子句中，密码应被作为文字密码只被给定。没有必要使用<span>PASSWORD()</span>函数，因为该函数用于<span>SET 
				PASSWORD</span>语句。例如：</p>
				<pre><span>GRANT ... IDENTIFIED BY &#39;mypass&#39;;</span></pre>
				<p>如果您不想以明白的文字发送密码，并且您知道<span>PASSWORD()</span>返回给密码的混编值，则您可以指定混编值，前面加入关键词<span>PASSWORD</span>：</p>
				<pre><span>GRANT ...</span></pre>
				<pre><span>IDENTIFIED BY PASSWORD &#39;*6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4&#39;;</span></pre>
				<p>在一个<span>C</span>程序中，您可以通过使用<span>make_scrambled_password()</span><span> 
				C API</span>函数得到混编值。</p>
				<p>如果您为一个数据库授予权限，则在<span>mysql.db</span>表中，会根据需要创建登录项。如果使用<span>REVOKE</span>删除了所有的数据库权限，则本登录项被删除。</p>
				<p>如果一个用户不拥有表权限，则当用户申请表清单时（例如，使用<span>SHOW TABLES</span>语句），表名称不显示。</p>
				<p><span>SHOW DATABASES</span>权限允许账户通过发布<span>SHOW 
				DATABASE</span>语句来观看数据名称。不拥有此权限的账户只能看到他们拥有部分权限的数据库，并且如果使用<span>--skip-show-database</span>选项启动服务器，则根本不能使用本语句。</p>
				<p><span>WITH GRANT OPTION</span>子句给予用户能力，可以在指定的权限层级，向其它用户给定其拥有的任何权限。您应该留心您给予了谁<span>GRANT 
				OPTION</span>权限，因为拥有不同权限的两个用户可以联合使用权限！</p>
				<p>您不能向其它用户授予您自己没有的权限；<span>GRANT OPTION</span>权限只允许您赋予您自己拥有的权限。</p>
				<p>要注意，当您在某个特定权限层级向一个用户授予<span>GRANT OPTION</span>权限时，用户拥有的该层级的任何权限（或未来将被给定的权限）也可以由该用户授予。假设您向一个用户赋予了数据库<span>INSERT</span>权限。如果您然后赋予数据库<span>SELECT</span>权限，并指定了<span>WITH 
				GRANT OPTION</span>，则该用户不仅可以向其它用户给予<span>SELECT</span>权限，还可以给予<span>INSERT</span>。如果您然后向用户授予数据库<span>UPDATE</span>权限，则用户可以授予<span>INSERT, 
				SELECT</span>和<span>UPDATE</span>。</p>
				<p>您不应该向一个常规用户授予<span>ALTER</span>权限。如果您这么做，则该用户可以尝试通过对表重新命名来破坏授权系统！</p>
				<p><span>The <span>
				MAX_QUERIES_PER_HOUR <i>count</i></span>,
				<span>MAX_UPDATES_PER_HOUR <i>count</i></span>, 
				and <span>MAX_CONNECTIONS_PER_HOUR <i>
				count</i></span> options limit the number of queries, updates, 
				and logins a user can perform during any given one-hour period. 
				If <span><i>count</i></span> is
				<span>0</span> (the default), this means 
				that there is no limitation for that user.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<span>MAX_QUERIES_PER_HOUR <i>count</i></span>,
				<span>MAX_UPDATES_PER_HOUR <i>count</i></span></span>和<span>MAX_CONNECTIONS_PER_HOUR
				<i>count</i></span>选项限制了在任何给定的一小时期间，用户可以执行的查询、更新和登录的数目。如果<span>count</span>是<span>0</span>（默认值），这意味着，对该用户没有限制。</p>
				<p><span>
				MAX_USER_CONNECTIONS <i>count</i></span>选项限制了账户可以同时进行的连接的最大数目。如果<span>count</span>是<span>0</span>（默认值），则<span>max_user_connections</span>系统可以决定该
				账户同时连接的数目。</p>
				<p>注释：要对一个原有的用户指定任何这类资源限制型选项，同时又不影响原有的权限，需使用<span>GRANT 
				USAGE ON *.* ... WITH MAX_...</span>。</p>
				<p>见<a href="database-administration.html#user-resources" title="5.8.4. Limiting Account Resources">5.8.4节，“限制账户资源”</a>。</p>
				<p>除了根据<span>username</span>和密码进行常规鉴定外，<span>MySQL</span>还可以检查<span>X509</span>证明属性。要为<span>MySQL</span>账户指定与<span>SSL</span>有关的选项，需使用<span>GRANT</span>语句的<span>REQUIRE</span>子句。（要了解有关在<span>MySQL</span>中使用<span>SSL</span>的背景信息，请参见<a href="database-administration.html#secure-connections" title="5.8.7. Using Secure Connections">5.8.7节，“使用安全连接”</a>。）</p>
				<p>对于一个给定的账户，有多种可能性可以限制连接类型：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果账户没有<span>SSL</span>或<span>X509</span>要求，并且如果<span>username</span>和
				密码是有效的，则允许不加密连接。但是，如果客户端有正确的证明和关键文件，则根据客户端的选择，也可以使用加密连接。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>REQUIRE SSL</span>选项用于告知服务器，对于该账户只允许<span>SSL</span>加密连接。注意，如果有允许任何非<span>SSL</span>连接的访问控制记录，则本选项可以被忽略。</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39; REQUIRE SSL;</b></span></span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>REQUIRE X509</span>意味着客户端必须拥有一个有效证明，除非不需要确切的证明、发布者和主题。唯一的要求是，应可以使用<span>CA</span>证明其中之一来验证签名。</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39; REQUIRE X509;</b></span></span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REQUIRE ISSUER &#39;<i>issuer</i>&#39;</span>用于对连接尝试进行限定，客户端必须出示一个由<span>CA</span>’<span>issuer</span>’发布的有效的<span>X509</span>证明。如果客户端出示的证明是有效的，但是有一个不同的发布者，则服务器会拒绝连接。使用<span>X509</span>证明就意味着要加密，所以在这种情况下，<span>SSL</span>选项是不必要的。</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>REQUIRE ISSUER &#39;/C=FI/ST=Some-State/L=Helsinki/</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O=MySQL Finland AB/CN=Tonu Samuel/Email=tonu@example.com&#39;;</span></pre>
				<p>注意，<span>ISSUER</span>值应被作为一个单一字符串输入。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REQUIRE SUBJECT &#39;<i>subject</i>&#39;</span>用于对连接尝试进行限定，客户端必须出示一个包含主题<span>subject</span>的有效的<span>X509</span>证明。如果客户端出示的证明是有效的，但是有一个不同的主题，则服务器会拒绝连接。</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>REQUIRE SUBJECT &#39;/C=EE/ST=Some-State/L=Tallinn/</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O=MySQL demo client certificate/</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CN=Tonu Samuel/Email=tonu@example.com&#39;;</span></pre>
				<p>注意，<span>SUBJECT</span>值应被作为一个单一字符串输入。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>需要<span>REQUIRE 
				CIPHER &#39;<i>cipher</i>&#39;</span>来确认使用了密码和足够长度的关键字。如果使用了采用短型加密关键字的旧算法，<span>SSL</span>本身会比较脆弱。使用本选项，您可以要求使用特定的密码方法来许可一个连接。</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>REQUIRE CIPHER &#39;EDH-RSA-DES-CBC3-SHA&#39;;</b></span></span></pre>
				<p><span>SUBJECT, ISSUER</span>和<span>CIPHER</span>选项可以在<span>REQUIRE</span>子句中结合，如下：</p>
				<pre><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39;</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>REQUIRE SUBJECT &#39;/C=EE/ST=Some-State/L=Tallinn/</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O=MySQL demo client certificate/</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CN=Tonu Samuel/Email=tonu@example.com&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>AND ISSUER &#39;/C=FI/ST=Some-State/L=Helsinki/</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O=MySQL Finland AB/CN=Tonu Samuel/Email=tonu@example.com&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>AND CIPHER &#39;EDH-RSA-DES-CBC3-SHA&#39;;</b></span></span></pre>
				<p>注意，<span>SUBJECT</span>和<span>ISSUER</span>值各自应被作为一个单一字符串输入。</p>
				<p>在<span>REQUIRE</span>各选项之间，<span>AND</span>关键词是自选的。</p>
				<p>选项的顺序无所谓，但是选项不能被指定两次。</p>
				<p>当<span>mysqld</span>启动后，所有的权限被读入存储器中。要了解详细说明，请参见<a href="database-administration.html#privilege-changes" title="5.7.7. When Privilege Changes Take Effect">5.7.7节，“权限更改何时生效”</a>。</p>
				<p>注意，如果您正在使用表权限或列权限，即使只对一个用户使用，服务器也会对所有用户检查表权限和列权限，这会略微降低<span>MySQL</span>的速度。与此类似，如果您对某些用户限制查询、更新或连接的数目，则服务器必须监测这些值。</p>
				<p>标准<span>SQL</span>版本和<span>MySQL</span>版本的<span>GRANT</span>之间的最大区别是：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在<span>MySQL</span>中，权限与<span>hostname</span>和<span>username</span>的组合有关，与 
				单一的<span>username</span>无关。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>标准<span>SQL</span>不拥有全局层级或数据库层级权限，也不支持<span>MySQL</span>支持的所有权限类型。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>MySQL</span>不支持标准<span>SQL 
				TRIGGER</span>或<span>UNDER</span>权限。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>标准<span>SQL</span>权限以一种分等级的方式进行组织。如果您取消一个用户，则用户被授予的所有权限都被撤销。在<span>MySQL</span>中，如果您使用<span>DROP 
				USER</span>，也会如此。请参见<a href="sql-syntax.html#drop-user" title="13.5.1.2. DROP USER Syntax">13.5.1.2节，“DROP 
				USER语法”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在标准<span>SQL</span>中，当您取消一个表时，对一个表的所有权限会被撤销。在标准<span>SQL</span>中，当您撤销一个权限时，根据该权限被授予的所有权限也会被撤销。在<span>MySQL</span>中，只有使用明确的<span>REVOKE</span>语句，或通过操作存储在<span>MySQL</span>授权表中的值，才能取消权限。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在<span>MySQL</span>中，可以只对一个表中的部分列拥有<span>INSERT</span>权限。在此情况下，如果您忽略您不拥有<span>INSERT</span>权限的那些列，，您仍然可以对表执行<span>INSERT</span>语句。如果没有启用严格的<span>SQL</span>模式，则被忽略的列被设置为各自隐含的默认值。在严格模式下，如果某个被忽略的列没有默认值，则该语句被拒绝。<a href="database-administration.html#server-sql-mode" title="5.3.2. The Server SQL Mode">5.3.2节，“SQL服务器模式”</a>对严格模式进行了讨论。<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
				TABLE语法”</a>对隐含默认值进行了讨论。</p>
				<p>您不拥有<span>INSERT</span>权限的列被设置为各自的默认值。标准<span>SQL</span>要求您拥有所有列的<span>INSERT</span>权限。</p>
				<p>在<span>MySQL</span>中，如果您只拥有一个表中的部分列的<span>INSERT</span>权限，同时，如果您从<span>INSERT</span>语句中忽略您不拥有权限的列，则您仍然可以对表执行<span>INSERT</span>语句；那些列将被设置为各自的默认值。在严格模式下（即当<span>sql_mode=&#39;traditional&#39;</span>时，如果某些被忽略的列没有默认值，则<span>INSERT</span>语句将被拒绝。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="rename-user"></a>13.5.1.4. RENAME 
				USER语法</h4></div></div></div><a class="indexterm" name="id2917845"></a><a class="indexterm" name="id2917854"></a><a class="indexterm" name="id2917865"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>RENAME USER <span><i>old_user</i></span> TO <span><i>new_user</i></span></span></pre>
				<pre><span>&nbsp; &nbsp;&nbsp;[, <span><i>old_user</i></span> TO <span><i>new_user</i></span>] ...</span></pre>
				<p><span>RENAME USER</span>语句用于对原有<span>MySQL</span>账户进行重命名。要使用<span>RENAME 
				USER</span>，您必须拥有全局<span>CREATE USER</span>权限或<span>mysql</span>数据库<span>UPDATE</span>权限。如果旧
				账户不存在或者新账户已存在，则会出现错误。<span><i><span>old_user</span></i></span>和<span><i><span>new_user</span></i></span>值的给定方法与<span>GRANT</span>语句一样。</p>
				<h4 class="title"><a name="set-password"></a>13.5.1.5. SET 
				PASSWORD语法</h4></div></div></div><a class="indexterm" name="id2917966"></a><a class="indexterm" name="id2917976"></a><a class="indexterm" name="id2917986"></a>
				<pre><span>SET PASSWORD = PASSWORD(&#39;<span><i>some password</i></span>&#39;)</span></pre>
				<pre><span>SET PASSWORD FOR <span><i>user</i></span> = PASSWORD(&#39;<span><i>some password</i></span>&#39;)</span></pre>
				<p><span>SET PASSWORD</span>语句用于向一个原有<span>MySQL</span>用户
				账户赋予一个密码。</p>
				<p>第一个语法为当前用户设置密码。已使用一个非匿名账户连接到服务器上的任何客户即都可以更改该账户的密码。</p>
				<p>第二个语法为当前服务器主机上的一个特定账户设置密码。只有拥有<span>mysql</span>数据库<span>UPDATE</span>权限的客户端可以这么做。<span>user</span>值应以<span><i><span>user_name</span></i><span>@<i>host_name</i></span></span>的格式被给定，此处<span><i><span>user_name</span></i></span>和<span><i><span>host_name</span></i></span>与<span>mysql.user</span>表登录项的<span>User</span>和<span>Host</span>列中列出的完全一样。举例说明，如果您有一个登录项，<span>User</span>和<span>Host</span>列值为<span>&#39;bob&#39;</span>和<span>&#39;%.loc.gov&#39;</span>，您应该按如下方法写语句：</p>
				<pre><span>mysql&gt; <span><b>SET PASSWORD FOR &#39;bob&#39;@&#39;%.loc.gov&#39; = PASSWORD(&#39;<i>newpass</i>&#39;);</b></span></span></pre>
				<p>这相当于以下语句：</p>
				<pre><span>mysql&gt; <span><b>UPDATE mysql.user SET Password=PASSWORD(&#39;<i>newpass</i>&#39;)</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>WHERE User=&#39;bob&#39; AND Host=&#39;%.loc.gov&#39;;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>FLUSH PRIVILEGES;</b></span></span></pre>
				<p>注释：如果您正在使用一个<span>4.1</span>以前的客户端连接到一个<span>MySQL 
				4.1</span>或<span>MySQL 4.1</span>以后的服务器，则在阅读<a href="database-administration.html#password-hashing" title="5.7.9. Password Hashing in MySQL 4.1">5.7.9节，“MySQL 4.1中的密码哈希处理”</a>之前，不能使用前面的<span>SET PASSWORD</span>或<span>UPDATE</span>语句。
				密码格式在<span>MySQL 
				4.1</span>中变更了，并且在特定情况下，如果您更改密码，您可能无法在连接到服务器上。</p>
				<p>您可以通过执行<span>SELECT CURRENT_USER()</span>观看您当前的鉴定<span>user@host</span>登录项。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="table-maintenance-sql"></a>
			13.5.2.&nbsp;表维护语句</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#analyze-table">13.5.2.1. 
				ANALYZE TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#backup-table">13.5.2.2. 
				BACKUP TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#check-table">13.5.2.3. 
				CHECK TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#checksum-table">13.5.2.4. 
				CHECKSUM TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#optimize-table">13.5.2.5. 
				OPTIMIZE TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#repair-table">13.5.2.6. 
				REPAIR TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#restore-table">13.5.2.7. 
				RESTORE TABLE语法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="analyze-table"></a>13.5.2.1. ANALYZE 
				TABLE语法</h4></div></div></div><a class="indexterm" name="id2918217"></a>
				<pre><span>ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ...</span></pre>
				<p>本语句用于分析和存储表的关键字分布。在分析期间，使用一个读取锁定对表进行锁定。这对于<span>MyISAM, 
				BDB</span>和<span>InnoDB</span>表有作用。对于<span>MyISAM</span>表，本语句与使用<strong><span>myisamchk 
				-a</span></strong>相当。</p>
				<p><span>MySQL</span>使用已存储的关键字分布来决定，当您对除常数以外的对象执行联合时，表按什么顺序进行联合。</p>
				<p>本语句会返回一个含有以下列的表：</p>
				<table border="1" cellpadding="0" id="table8">
					<tr>
						<td>
						<p><strong>
						<span>列</span></strong></td>
						<td>
						<p><strong>
						<span>值</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Table</span></td>
						<td>
						<p>表名称</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Op</span></td>
						<td>
						<p><span>进行分析</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_type</span></td>
						<td>
						<p><span>
						状态、错误、信息或警告之一</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_text</span></td>
						<td>
						<p>消息</td>
					</tr>
				</table>
				<p>您可以使用<span>SHOW INDEX</span>语句检查已存储的关键字分布。请参见<a href="sql-syntax.html#show-index" title="13.5.4.11. SHOW INDEX Syntax">13.5.4.11节，“SHOW 
			INDEX语法”</a>。</p>
				<p>如果从上一个<span>ANALYZE TABLE</span>语句开始，表没有变化，则不再分析该表。</p>
				<p><span>ANALYZE TABLE</span>语句被写入二进制日志中，除非使用了自选的<span>NO_WRITE_TO_BINLOG</span>关键词（或其别名<span>LOCAL</span>）。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="backup-table"></a>13.5.2.2. BACKUP 
				TABLE语法</h4></div></div></div><a class="indexterm" name="id2918452"></a><a class="indexterm" name="id2918461"></a>
				<pre><span>BACKUP TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ... TO &#39;<span><i>/path/to/backup/directory</i></span>&#39;</span></pre>
				<p>注释：本语句不理想。我们正在努力寻找一种更好的替代方式，该方式将提供在线备份能力。同时，也可以使用<strong><span>mysqlhotcopy</span></strong>原本替代。</p>
				<p><span>BACKUP TABLE</span>用于在刷新了所有对磁盘的缓冲变更后，把恢复表所需的最少数目的表文件拷贝到备份目录中。本语句只对<span>MyISAM</span>表起作用。它可以拷贝<span>.frm</span>定义文件和<span>.MYD</span>数据文件。<span>.MYI</span>索引文件可以从这两个文件中重建。本目录应被指定为一个完整的路径名。</p>
				<p>在使用本语句前，请参见<a href="database-administration.html#backup" title="5.9.1. Database Backups">5.9.1节，“数据库备份”</a>。</p>
				<p>
				在备份期间，为每个表保持一个读取锁定，每次一个，在正在备份时锁定。如果您想要把多个表作为一个快照来备份（防止它们在备份操作过程中被更改），您必须实现发布一个<span>LOCK 
				TABLES</span>语句，以获得对一个组群中的每个表的读取锁定。</p>
				<p>该语句会返回一个含有以下列的表：</p>
				<table border="1" cellpadding="0" id="table9">
					<tr>
						<td>
						<p><strong>
						<span>列</span></strong></td>
						<td>
						<p><strong>
						<span>值</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Table</span></td>
						<td>
						<p>表名称</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Op</span></td>
						<td>
						<p><span>进行备份</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_type</span></td>
						<td>
						<p><span>
						状态、错误、信息或警告之一</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_text</span></td>
						<td>
						<p>消息</td>
					</tr>
				</table>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="check-table"></a>13.5.2.3. CHECK 
			TABLE语法</h4></div></div></div><a class="indexterm" name="id2918695"></a>
				<pre><span>CHECK TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ... [<span><i>option</i></span>] ...</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span><i><span>option</span></i></span><span> = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}</span></pre>
				<p>检查一个或多个表是否有错误。<span>CHECK TABLE</span>对<span>MyISAM</span>和<span>InnoDB</span>表有作用。对于<span>MyISAM</span>表，关键字统计数据被更新。</p>
				<p><span>CHECK TABLE</span>也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。</p>
				<p><span>CHECK TABLE</span>语句会返回一个含有以下列的表：</p>
				<table border="1" cellpadding="0" id="table10">
					<tr>
						<td>
						<p><strong>
						<span>列</span></strong></td>
						<td>
						<p><strong>
						<span>值</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Table</span></td>
						<td>
						<p>表名称</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Op</span></td>
						<td>
						<p><span>进行检查</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_type</span></td>
						<td>
						<p><span>
						状态、错误、信息或错误之一</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_text</span></td>
						<td>
						<p>消息</td>
					</tr>
				</table>
				<p>注意，该语句可能会为每个被检查的表产生多行信息。最后一行有一个<span>Msg_type</span>状态值。<span>Msg_text</span>通常应为<span>OK</span>。如果您没有得到<span>OK</span>，或表已经更新了，则您通常应该运行修复后的表。请参见<a href="database-administration.html#table-maintenance" title="5.9.4. Table Maintenance and Crash Recovery">5.9.4节，“表维护和崩溃恢复”</a>。表已经更新了，这意味着表的存储引擎指示没有必要检查表。</p>
				<p>可以给予的不同的检查选项列于下表中。这些选项只适用于检查<span>MyISAM</span>表。对于<span>InnoDB</span>表和视图，这些选项被忽略。</p>
				<table border="1" cellpadding="0" id="table11">
					<tr>
						<td>
						<p><strong>
						<span>类型</span></strong></td>
						<td>
						<p><strong>
						<span>意义</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>QUICK</span></td>
						<td>
						<p>不扫描行，不检查错误的链接。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>FAST</span></td>
						<td>
						<p>只检查没有被正确关闭的表。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CHANGED</span></td>
						<td>
						<p>只检查上次检查后被更改的表，和没有被正确关闭的表。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MEDIUM</span></td>
						<td>
						<p>
						扫描行，以验证被删除的链接是有效的。也可以计算各行的关键字校验和，并使用计算出的校验和验证这一点。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>EXTENDED</span></td>
						<td>
						<p>对每行的所有关键字进行一个全面的关键字查找。这可以确保表是<span>100</span>％一致的，但是花的时间较长。</td>
					</tr>
				</table>
				<p>如果没有指定<span>QUICK, MEDIUM</span>或<span>EXTENDED</span>选项，则对于动态格式<span>MyISAM</span>表，默认检查类型是<span>MEDIUM</span>。这与对表运行<strong><span>myisamchk 
				--medium-check </span></strong><span><b>
				<i><span>tbl_name</span></i></b></span>的结果相同。对于静态格式<span>MyISAM</span>表，默认检查类型也是<span>MEDIUM</span>，除非<span>CHANGED</span>或<span>FAST</span>已被指定。在此情况下，默认值为<span>QUICK</span>。对于<span>CHANGED</span>和<span>FAST</span>，行扫描被跳过，因为行极少被破坏。</p>
				<p>您可以组合检查选项，如下面的例子所示。该例子对表进行了一个快速检查，来查看该表是否被正确关闭：</p>
				<pre><span>CHECK TABLE test_table FAST QUICK;</span></pre>
				<p>注释：在有些情况下，<span>CHECK TABLE</span>会更改表。如果表被标记为“<span>corrupted</span>”或“<span>not 
				closed properly</span>”，则出现这种情况。但是<span>CHECK TABLE</span>不会找出表中的问题。在这种情况下，<span>CHECK 
				TABLE</span>会把表标记为良好。</p>
				<p>
				如果一个表被破坏，很有可能问题在索引中，而不在数据部分中。所有前述的检查类型都可以彻底地检查索引，因此，可以找出多数的错误。</p>
				<p>如果您只想要检查您假定的表是良好的，您应该不使用检查选项或<span>QUICK</span>选项。当您时间匆忙时，应使用<span>QUICK</span>。<span>QUICK</span>无法找出数据文件中的错误的风险非常小。（在多数情况下，在正常使用中，<span>MySQL</span>应能在数据文件中找出错误。如果找出了错误，表被标记为“<span>corrupted</span>”，并不能被使用，直到修复为止。）</p>
				<p>如果您想要时常检查表，<span>FAST</span>和<span>CHANGED</span>多数情况下从原本中被使用（例如，从<span>cron</span>中被执行）。在多数情况下，<span>FAST</span>优先于<span>CHANGED</span>。（只有一种情况<span>FAST</span>不优先于<span>CHANGED</span>，那就是当您怀疑您在<span>MyISAM</span>代码中发现了错误。）</p>
				<p>当<span>MySQL</span>试图通过关键字更新一行或查找一行时，如果您已经运行了一个常规检查后但仍得到来自表的奇怪的错误，此时使用<span>EXTENDED</span>。（如果常规的检查运行成功，则基本用不着<span>EXTENDED</span>。）</p>
				<p>被<span>CHECK TABLE</span>报告的部分问题不会被自动修正：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>发现行。此行中，<span>auto_increment</span>列有<span>0</span>值。</p>
				<p>这意味着，您在表中有一行，该行的<span>AUTO_INCREMENT</span>索引列包含<span>0</span>值。（可以通过使用<span>UPDATE</span>语句，明确地把列设置为<span>0</span>，以创建一个<span>AUTO_INCREMENT</span>列为<span>0</span>的行。）</p>
				<p>这本身不是一个错误，但是如果您决定转储表并恢复表，或对表进行<span>ALTER 
				TABLE</span>，那么会导致出现麻烦。在此情况下，<span>AUTO_INCREMENT</span>列会根据<span>AUTO_INCREMENT</span>列的结果更改值，这会导致出现问题，如重复关键字错误等。</p>
				<p>要消除警告，只需执行一个<span>UPDATE</span>语句，把列设置为除<span>0</span>以外的值。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="checksum-table"></a>13.5.2.4. CHECKSUM 
				TABLE语法</h4></div></div></div><a class="indexterm" name="id2919302"></a>
				<pre><span>CHECKSUM TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ... [ QUICK | EXTENDED ]</span></pre>
				<p>报告一个表校验和。</p>
				<p>如果指定了<span>QUICK</span>，则报告活性表校验和，否则报告<span>NULL</span>。这是非常快的。活性表通过指定<span>CHECKSUM</span>＝<span>1</span>表选项启用，目前只支持用于<span>MyISAM</span>表。请参见<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>。</p>
				<p>在<span>EXTENDED</span>模式下，整个表被一行一行地读取，并计算校验和。对于大型表，这是非常慢的。</p>
				<p>默认情况下，如果既没有指定<span>QUICK</span>，也没有指定<span>EXTENDED</span>，并且如果表存储引擎支持，则<span>MySQL</span>返回一个活性校验和，否则会对表进行扫描。</p>
				<p><span>CHECKSUM TABLE</span>对于不存在的表会返回<span>NULL</span>。对于这种情况，会生成一个警告。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimize-table"></a>13.5.2.5. OPTIMIZE 
				TABLE语法</h4></div></div></div><a class="indexterm" name="id2919431"></a><a class="indexterm" name="id2919440"></a><a class="indexterm" name="id2919450"></a>
				<pre><span>OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ...</span></pre>
				<p>如果您已经删除了表的一大部分，或者如果您已经对含有可变长度行的表（含有<span>VARCHAR, 
				BLOB</span>或<span>TEXT</span>列的表）进行了很多更改，则应使用<span>OPTIMIZE 
				TABLE</span>。被删除的记录被保持在链接清单中，后续的<span>INSERT</span>操作会重新使用旧的记录位置。您可以使用<span>OPTIMIZE 
				TABLE</span>来重新利用未使用的空间，并整理数据文件的碎片。</p>
				<p>在多数的设置中，您根本不需要运行<span>OPTIMIZE TABLE</span>。即使您对可变长度的行进行了大量的更新，您也不需要经常运行，每周一次或每月一次即可，只对特定的表运行。</p>
				<p><span>OPTIMIZE TABLE</span>只对<span>MyISAM, 
				BDB</span>和<span>InnoDB</span>表起作用。</p>
				<p>对于<span>MyISAM</span>表，<span>OPTIMIZE 
				TABLE</span>按如下方式操作：</p>
				<p>
				<span>1.<span>&nbsp;&nbsp;&nbsp;
				</span></span>如果表已经删除或分解了行，则修复表。</p>
				<p>
				<span>2.<span>&nbsp;&nbsp;&nbsp;
				</span></span>如果未对索引页进行分类，则进行分类。</p>
				<p>
				<span>3.<span>&nbsp;&nbsp;&nbsp;
				</span>&nbsp;&nbsp;&nbsp;</span>如果表的统计数据没有更新（并且通过对索引进行分类不能实现修复），则进行更新。</p>
				<p>对于<span>BDB</span>表，<span>OPTIMIZE TABLE</span>目前被映射到<span>ANALYZE 
				TABLE</span>上。对于<span>InnoDB</span>表，<span>OPTIMIZE 
				TABLE</span>被映射到<span>ALTER TABLE</span>上，这会重建表。重建操作能更新索引统计数据并释放成簇索引中的未使用的空间。请参见<a href="sql-syntax.html#analyze-table" title="13.5.2.1. ANALYZE TABLE Syntax">13.5.2.1节，“ANALYZE 
			TABLE语法”</a>。</p>
				<p>使用—<span>skip-new</span>或—<span>safe-mode</span>选项可以启动<span>mysqld</span>。通过启动<span>mysqld</span>，您可以使<span>OPTIMIZE 
				TABLE</span>对其它表类型起作用。</p>
				<p>注意，在<span>OPTIMIZE TABLE</span>运行过程中，<span>MySQL</span>会锁定表。</p>
				<p><span>OPTIMIZE TABLE</span>语句被写入到二进制日志中，除非使用了自选的<span>NO_WRITE_TO_BINLOG</span>关键词（或其别名<span>LOCAL</span>）。已经这么做了，因此，用于<span>MySQL</span>服务器的<span>OPTIMIZE 
				TABLE</span>命令的作用相当于一个复制主服务器，在默认情况下，这些命令将被复制到复制从属服务器中。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="repair-table"></a>13.5.2.6. REPAIR 
				TABLE语法</h4></div></div></div><a class="indexterm" name="id2919705"></a>
				<pre><span>REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ... [QUICK] [EXTENDED] [USE_FRM]</span></pre>
				<p><span>REPAIR TABLE</span>用于修复被破坏的表。默认情况下，<span>REPAIR 
				TABLE</span>与<strong><span>myisamchk 
				--recover </span></strong><span><b><i>
				<span>tbl_name</span></i></b></span>具有相同的效果。<span>REPAIR 
				TABLE</span>对<span>MyISAM</span>和<span>ARCHIVE</span>表起作用。请参见<a href="storage-engines.html#myisam-storage-engine" title="15.1. The MyISAM Storage Engine">15.1节，“MyISAM存储引擎”</a><span>,
				</span>
          <a href="storage-engines.html#archive-storage-engine" title="15.8. The ARCHIVE Storage Engine">
				15.8节，“ARCHIVE存储引擎”</a>。</p>
				<p>通常，您基本上不必运行此语句。但是，如果灾难发生，<span>REPAIR TABLE</span>很有可能从<span>MyISAM</span>表中找回所有数据。如果您的表经常被破坏，您应该尽力找到原因，以避免使用<span>REPAIR 
				TALBE</span>。请参见<a href="problems.html#crashing" title="A.4.2. What to Do If MySQL Keeps Crashing">A.4.2节，“如果MySQL依然崩溃，应作些什么”</a>。同时也见<a href="storage-engines.html#myisam-table-problems" title="15.1.4. MyISAM Table Problems">15.1.4节，“MyISAM表方面的问题”</a>。</p>
				<p>本语句会返回一个含有以下列的表：</p>
				<table border="1" cellpadding="0" id="table12">
					<tr>
						<td>
						<p><strong>
						<span>列</span></strong></td>
						<td>
						<p><strong>
						<span>值</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Table</span></td>
						<td>
						<p>表名称</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Op</span></td>
						<td>
						<p><span>进行修复</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_type</span></td>
						<td>
						<p><span>
						状态、错误、信息或警告之一</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_text</span></td>
						<td>
						<p>消息</td>
					</tr>
				</table>
				<p>对于每个被修复的表，<span>REPAIR TABLE</span>语句会产生多行的信息。上一行含有一个<span>Msg_type</span>状态值。<span>Msg_test</span>通常应为<span>OK</span>。如果您没有得到<span>OK</span>，您应该尝试使用<strong><span>myisamchk 
				--safe-recover</span></strong>修复表，因为<span>REPAIR TABLE</span>尚不会执行所有的<strong><span>myisamchk</span></strong>选项。我们计划在将来使它的灵活性更强。</p>
				<p>如果给定了<span>QUICK</span>，则<span>REPAIR 
				TABLE</span>会尝试只修复索引树。这种类型的修复与使用<strong><span>myisamchk 
				--recover --quick</span></strong>相似。</p>
				<p>如果您使用<span>EXTENDED</span>，则<span>MySQL</span>会一行一行地创建索引行，代替使用分类一次创建一个索引。这种类型的修复与使用<strong><span>myisamchk 
				--safe-recover</span></strong>相似。</p>
				<p>对于<span>REPAIR TABLE</span>，还有一种<span>USE_FRM</span>模式可以利用。如果<span>.MYI</span>索引文件缺失或标题被破坏，则使用此模式。在这种模式下，<span>MySQL</span>可以使用来自<span>.frm</span>文件重新创建<span>.MYI</span>文件。这种修复不能使用<strong><span>myisamchk</span></strong>来完成。
				注释：只能在您不能使用常规<span>REPAIR</span>模式是，才能使用此模式。<span>.MYI</span>标题包含重要的表元数据（特别是，当前的<span>AUTO_INCREMENT</span>值和<span>Delete</span>链接）。这些元数据在<span>REPAIR...USE_FRM</span>中丢失。如果表被压缩，则不能使用<span>USE_FRM</span>。因为本信息也存储在<span>.MYI</span>文件中。</p>
				<p><span>REPAIR TABLE</span>语句被写入二进制日志中，除非使用了自选的<span>NO_WRITE_TO_BINLOG</span>关键词（或其别名<span>LOCAL</span>）。</p>
				<p>警告：如果在<span>REPAIR TABLE</span>运行过程中，服务器停机，则在重新启动之后，在执行其它操作之前，您必须立刻对表再执行一个<span>REPAIR 
				TABLE</span>语句。（通过制作一个备份来启动是一个好办法。）再最不利情况下，您可以有一个新的干净的索引文件，不含有关数据文件的信息。然后，您执行的下一个操作会覆盖数据文件。这很少发生，但是是有可能的。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="restore-table"></a>13.5.2.7. RESTORE 
				TABLE语法</h4></div></div></div><a class="indexterm" name="id2920125"></a>
				<pre><span>RESTORE TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ... FROM &#39;<span><i>/path/to/backup/directory</i></span>&#39;</span></pre>
				<p>用于恢复来自用<span>BACKUP TABLE</span>制作的备份的表。原有的表不会被覆盖；如果您试图覆盖一个原有的表，会发生错误。和<span>BACKUP 
				TABLE</span>一样，<span>RESTORE TABLE</span>目前只对<span>MyISAM</span>表起作用。目录应被指定为一个完整路径名。</p>
				<p>每个表的备份包括其<span>.frm</span>格式文件和<span>.MYD</span>数据文件。恢复操作会恢复这些文件，然后使用这些文件来重建<span>.MYI</span>索引文件。恢复操作比备份操作花的时间更长，这是因为需要重建索引。表含有的索引越多，花的时间就越长。</p>
				<p>该语句会返回一个含有以下列的表：</p>
				<table border="1" cellpadding="0" id="table13">
					<tr>
						<td>
						<p><strong>
						<span>列</span></strong></td>
						<td>
						<p><strong>
						<span>值</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Table</span></td>
						<td>
						<p>表名称</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Op</span></td>
						<td>
						<p><span>进行恢复</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_type</span></td>
						<td>
						<p><span>
						状态、错误、信息或警告之一</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_text</span></td>
						<td>
						<p>消息</td>
					</tr>
				</table>
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="set-option"></a>13.5.3. SET语法</h3></div></div></div><a class="indexterm" name="id2920330"></a><a class="indexterm" name="id2920339"></a>
			<pre><span>SET <span><i>variable_assignment</i></span> [, <span><i>variable_assignment</i></span>] ...</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>variable_assignment</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><i>user_var_name</i></span> = <span><i>expr</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; | [GLOBAL | SESSION] <span><i>system_var_name</i></span> = <span><i>expr</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; | @@[global. | session.]<span><i>system_var_name</i></span> = <span><i>expr</i></span></span></pre>
			<p><span>SET</span>用于设置不同类型的变量。这些变量会影响服务器或客户端的操作。<span>SET</span>可以用于向用户变量或系统变量赋值。</p>
			<p>用于分配账户密码的<span>SET PASSWORD</span>语句在<a href="sql-syntax.html#set-password" title="13.5.1.5. SET PASSWORD Syntax">13.5.1.5节，“SET 
		PASSWORD语法”</a>中进行了讨论。</p>
			<p>多数系统变量可以在运行时间被更改。可以被动态设置的系统变量在<a href="database-administration.html#dynamic-system-variables" title="5.3.3.1. Dynamic System Variables">5.3.3.1节，“动态系统变量”</a>中进行了讨论。</p>
			<p>注释：旧版本的<span>MySQL</span>采用<span>SET OPTION</span>作为这个命令，但是由于有了<span>SET</span>，现在不赞成使用<span>SET 
			OPTION</span>。</p>
			<p>以下例子显示了您可以用于设置变量的不同语法。</p>
			<p>用户变量可以被写作<span>@<i>var_name</i></span>，并可以进行如下设置：</p>
			<pre><span>SET @<span><i>var_name</i></span> = <span><i>expr</i></span>;</span></pre>
			<p>在<a href="language-structure.html#variables" title="9.3. User Variables">9.3节，“用户变量”</a>中给出了有关用户变量的更多信息。</p>
			<p>系统变量可以被作为<span><i><span>var_name</span></i></span>引用到<span>SET</span>语句中。在名称的前面可以自选地添加<span>GLOBAL</span>或<span>@@global</span>，以明确地指示该变量是全局变量。或者在名称前面添加<span>SESSION, 
			@@session</span>，或<span>@@</span>，以指示它是一个会话变量。<span>LOCAL</span>和<span>@@local</span>是<span>SESSION</span>和<span>@@session</span>地同义词。如果没有修改符，则<span>SET</span>设置会话变量。</p>
			<p>支持系统变量的<span>@@<i>var_name</i></span>语法，以便使<span>MySQL</span>语法与其它数据库系统相兼容。</p>
			<p>如果您在同一个语句中设置多个系统变量，则最后一个<span>GLOBAL</span>或<span>SESSION</span>选项被用于没有指定模式的变量。</p>
			<pre><span>SET sort_buffer_size=10000;</span></pre>
			<pre><span>SET @@local.sort_buffer_size=10000;</span></pre>
			<pre><span>SET GLOBAL sort_buffer_size=1000000, SESSION sort_buffer_size=1000000;</span></pre>
			<pre><span>SET @@sort_buffer_size=1000000;</span></pre>
			<pre><span>SET @@global.sort_buffer_size=1000000, @@local.sort_buffer_size=1000000;</span></pre>
			<p>如果您使用<span>SESSION</span>（默认情况）设置一个系统变量，则该值仍然有效，直到当前会话结束为止，或者直到您吧变量设置为一个不同的值为止。如果您使用<span>GLOBAL</span>（要求<span>SUPER</span>权限）来设置一个系统变量，则该值被记住，并被用于新的连接，直到服务器重新启动为止。如果您想要进行永久式变量设置，您应该把它放入一个选项文件。请参见<a href="using-mysql-programs.html#option-files" title="4.3.2. Using Option Files">4.3.2节，“使用选项文件”</a>。</p>
			<p>为了防止不正确的使用，如果您使用<span>SET GLOBAL</span>时同时使用了一个只能与<span>SET 
			SESSION</span>同时使用的变量，或者如果您在设置一个全局变量时未指定<span>GLOBAL</span>（或<span>@@</span>），则<span>MySQL</span>会产生一个错误。</p>
			<p>如果您想要把一个<span>SESSION</span>变量设置为<span>GLOBAL</span>值或把一个<span>GLOBAL</span>值设置为内部<span>MySQL</span>默认值，需使用<span>DEFAULT</span>关键词。例如，在把<span>max_join_size</span>会话值设置为全局值时，以下两个语句是一样的：</p>
			<pre><span>SET max_join_size=DEFAULT;</span></pre>
			<pre><span>SET @@session.max_join_size=@@global.max_join_size;</span></pre>
			<p>您可以使用<span>SHOW VARIABLES</span>来得到系统变量清单。（见<a href="sql-syntax.html#show-variables" title="13.5.4.21. SHOW VARIABLES Syntax">13.5.4.21节，“SHOW VARIABLES语法”</a>。）要获得与样式匹配的一个具体的变量名称或者名称清单，需使用<span>LIKE</span>子句，使用方法如下：</p>
			<pre><span>SHOW VARIABLES LIKE &#39;max_join_size&#39;;</span></pre>
			<pre><span>SHOW GLOBAL VARIABLES LIKE &#39;max_join_size&#39;;</span></pre>
			<p>要得到名称与样式匹配的变量的清单，需使用通配符‘<span>%</span>’：</p>
			<pre><span>SHOW VARIABLES LIKE &#39;have%&#39;;</span></pre>
			<pre><span>SHOW GLOBAL VARIABLES LIKE &#39;have%&#39;;</span></pre>
			<p>通配符可以被用于相匹配的样式中的任何位置。</p>
			<p>您也可以通过使用<span>@@[global.|local.]var_name</span>语法和<span>SELECT</span>来得到值：</p>
			<pre><span>SELECT @@max_join_size, @@global.max_join_size;</span></pre>
			<p>当您使用<span>SELECT @@var_name</span>（即您不指定全局、会话或本地）来恢复一个变量时，则<span>MySQL</span>会返回<span>SESSION</span>值（如果存在）或者<span>GLOBAL</span>值。</p>
			<p>以下清单用于描述带有非标准语法的变量，或描述在系统变量清单中（见<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a>。）中没有描述的变量。尽管这些变量没有被<span>SHOW VARIABLES</span>显示，但是您可以使用<span>SELECT</span>来获得它们的值（例外情况是，使用<span>CHARACTER 
			SET</span>和<span>SET NAMES</span>）。例如：</p>
			<pre><span>mysql&gt; <span><b>SELECT @@AUTOCOMMIT;</b></span></span></pre>
			<pre><span>+--------------+</span></pre>
			<pre><span>| @@AUTOCOMMIT |</span></pre>
			<pre><span>+--------------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</span></pre>
			<pre><span>+--------------+</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			AUTOCOMMIT = {0 | 1}</span><span> </span></p>
			<p>设置<span>autocommit</span>模式。如果设置为<span>1</span>，则所有对表的更改会立刻生效。如果设置为<span>0</span>，则您必须使用<span>COMMIT</span>来接受一个事务，或使用<span>ROLLBACK</span>来取消它。如果您把<span>AUTOCOMMIT</span>模式从<span>0</span>改为<span>1</span>，则<span>MySQL</span>会对开放事务执行一个自动<span>COMMIT</span>。开始一个事务的另一种方法是使用一个<span>START 
			TRANSACTION</span>或<span>BEGIN</span>语句。请参见<a href="sql-syntax.html#commit" title="13.4.1. START TRANSACTION, COMMIT, and ROLLBACK Syntax">13.4.1节，“START 
			TRANSACTION, COMMIT和ROLLBACK语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			BIG_TABLES = {0 | 1}</span><span> </span></p>
			<p>如果设置为<span>1</span>，所有的临时表被存储在磁盘中，而不是存储在储存期中。这样会稍微慢些，但是对于需要一个大型临时表的<span>SELECT</span>操作，不会发生<span>The 
			table <i>tbl_name</i> is full</span>错误。对于一个新连接，默认值为<span>0</span>（使用存储器内部临时表）。通常，您不必设置此变量，因为根据需要，存储器内部表会被自动转换为以磁盘为基础的表。（
			注释：本变量以前被命名为<span>SQL_BIG_TABLES</span>。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CHARACTER SET {<i>charset_name</i> | DEFAULT}</span><span>
			</span></p>
			<p>
			本语句使用给定的映射为所有来自客户端和指向客户端的字符串建立映射。您可以通过在<span>MySQL</span>源分布中编辑<span>sql/convert.cc</span>来添加新的映射。<span>SET 
			CHARACTER SET</span>用于设定三个会话系统变量：<span>character_set_client</span>和<span>character_set_results</span>被设置为给定的字符集，<span>character_set_connection</span>被设置为<span>character_set_database</span>值。</p>
			<p>可以通过使用<span>DEFAULT</span>值恢复默认的映射。</p>
			<p>注意，<span>SET CHARACTER SET</span>的语法与设置其它选项的语法不同。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			FOREIGN_KEY_CHECKS = {0 | 1}</span><span> </span>
			</p>
			<p>如果设置为<span>1</span>（默认情况），则检查<span>InnoDB</span>表的外键限制条件。如果设置为<span>0</span>，则限制条件被忽略。如果重新载入<span>InnoDB</span>表时按照的顺序与上级<span>/</span>下级目录所要求的顺序不同，此时禁用外键检查是有用的。请参见<a href="storage-engines.html#innodb-foreign-key-constraints" title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4节，“FOREIGN 
			KEY约束”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>IDENTITY 
			= <i>value</i></span><span> </span></p>
			<p>该变量是<span>LAST_INSERT_ID</span>变量的同义词。该变量的作用是保持与其它数据库兼容。您可以使用<span>SELECT 
			@@IDENTITY</span>读取其值，并可以使用<span>SET IDENTITY</span>设置它。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			INSERT_ID = <i>value</i></span><span> </span></p>
			<p>用于设置将被以下<span>INSERT</span>或<span>ALTER 
			TABLE</span>语句使用的值。此值在插入一个<span>AUTO_INCREMENT</span>值时使用。本语句主要和二进制日志同时使用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			LAST_INSERT_ID = <i>value</i></span><span> </span>
			</p>
			<p>用于设定将从<span>LAST_INSERT_ID()</span>被返回的值。当您在用于更新表的语句中使用<span>LAST_INSERT_ID()</span>时，它被存储在二进制日志中。设置此变量不会更新由<span>mysql_insert_id() 
			C API</span>函数返回的值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>NAMES {&#39;<i>charset_name</i>&#39; 
			| DEFAULT}</span><span> </span></p>
			<p><span>SET NAMES</span>用于把三个会话系统变量<span>character_set_client, 
			character_set_connection</span>和<span>character_set_results</span>设置为给定的字符集。把<span>character_set_connection</span>设置为<span>charset_name</span>时，同时把<span>collation_connection</span>设置为<span>charset_name</span>的默认整序。</p>
			<p>使用一个<span>DEFAULT</span>值可以恢复默认的映射。</p>
			<p>注意，<span>SET NAMES</span>的语法与用于设置其它选项的语法不同。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ONE_SHOT</span><span>
			</span></p>
			<p>
			这不是一个服务器系统变量，但是它可以被用来影响用于设置字符集、整序和时区的变量的效果。<span>ONE_SHOT</span>主要被用于复制：<span>mysqlbinlog</span>使用<span>SET 
			ONE_SHOT</span>来暂时地修改字符集、整序和时区变量的值，以反映出它们原先的值。</p>
			<p>您不能在使用<span>ONE_SHOT</span>时使用除允许的变量以外的变量；如果您这么做，您会得到如下错误：</p>
			<pre><span>mysql&gt; <span><b>SET ONE_SHOT max_allowed_packet = 1;</b></span></span></pre>
			<pre><span>ERROR 1382 (HY000): The &#39;SET ONE_SHOT&#39; syntax is reserved for purposes internal to the MySQL server </span></pre>
			<p>如果同时使用<span>ONE_SHOT</span>和被允许的变量，则会根据要求更改变量，但是会在下一个语句后，重新设置所有的字符集、整序和与时区有关的服务器系统变量。唯一的例外是，当下一个语句是<span>SET</span>语句时，不会进行重新设置。换句话说，在下一个非<span>SET</span>语句之后，才会进行重新设置。例如：</p>
			<pre><span>mysql&gt; <span><b>SET ONE_SHOT character_set_connection = latin5;</b></span></span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>SET ONE_SHOT collation_connection = latin5_turkish_ci;</b></span></span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>SHOW VARIABLES LIKE &#39;%_connection&#39;;</b></span></span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<pre><span>| character_set_connection | latin5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|</span></pre>
			<pre><span>| collation_connection&nbsp;&nbsp;&nbsp;&nbsp; | latin5_turkish_ci |</span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>SHOW VARIABLES LIKE &#39;%_connection&#39;;</b></span></span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<pre><span>| character_set_connection | latin1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| collation_connection&nbsp;&nbsp;&nbsp;&nbsp; | latin1_swedish_ci |</span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_NOTES = {0 | 1}</span><span> </span></p>
			<p>当设置为<span>1</span>时（默认情况），“注意”一级的警报被记录下来。当设置为<span>0</span>时，“注意”警告被压制。<span>Mysqldump</span>包含输出，用于把此变量设置为<span>0</span>，这样，对于不会影响重新载入操作整体性的事件，重新载入转储文件时不会产生警告。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_AUTO_IS_NULL = {0 | 1}</span><span> </span></p>
			<p>如果设置为<span>1</span>（默认情况），您可以通过使用以下结构查找包含一个<span>AUTO_INCREMENT</span>列的表的最后插入的行：</p>
			<pre><span>WHERE <span><i>auto_increment_column</i></span> IS NULL</span></pre>
			<p>此性质被有些<span>ODBC</span>程序，比如<span>Access</span>使用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_BIG_SELECTS = {0 | 1}</span><span> </span></p>
			<p>如果设定为<span>0</span>，则<span>MySQL</span>会放弃有可能会花很长时间来执行的<span>SELECT</span>语句（也就是，对于这些语句，优化程序估算被检查的行的数目超过了<span>max_join_size</span>的值）。当一个不妥当的<span>WHERE</span>语句被发布后，本语句有用。一个新连接的默认值为<span>1</span>，这可以允许所有的<span>SELECT</span>语句。</p>
			<p>如果您把<span>max_join_size</span>系统变量设置为除<span>DEFAULT</span>以外的值，则<span>SQL_BIG_SELECTS</span>被设置为<span>0</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_BUFFER_RESULT = {0 | 1}</span><span> </span>
			</p>
			<p><span>SQL_BUFFER_RESULT</span>会迫使来自<span>SELECT</span>语句的结果被放入临时表中。这可以帮助<span>MySQL</span>早点解除表锁定。当需要花较长时间把结果发送给客户端时，这是有好处的。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_LOG_BIN = {0 | 1}</span><span> </span></p>
			<p>如果设置为<span>0</span>，则客户端的二进制日志中不会记录日志。客户端必须拥有<span>SUPER</span>权限来设置此选项。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_LOG_OFF = {0 | 1}</span><span> </span></p>
			<p>如果设置为<span>1</span>，则此客户端的总查询日志中不会记录日志。客户端必须拥有<span>SUPER</span>权限来设置此选项。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_LOG_UPDATE = {0 | 1}</span><span> </span></p>
			<p>不赞成使用本变量。本变量被映射到<span>SQL_LOG_BIN</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_QUOTE_SHOW_CREATE = {0 | 1}</span><span> </span>
			</p>
			<p>如果设置为<span>1</span>，则<span>SHOW 
			CREATE TABLE</span>会对表和列的名称加引号。如果设置为<span>0</span>，则加引号操作被禁用。默认情况下，本选项被启用，因此对于含有需要加引号的名称的表，复制操作起作用。请参见<a href="sql-syntax.html#show-create-table" title="13.5.4.5. SHOW CREATE TABLE Syntax">13.5.4.5节，“SHOW 
			CREATE TABLE语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_SAFE_UPDATES = {0 | 1}</span><span> </span></p>
			<p>如果设置为<span>1</span>，则<span>MySQL</span>会放弃在<span>WHERE</span>子句或<span>LIMIT</span>子句中不使用关键字的<span>UPDATE</span>或<span>DELETE</span>语句。这样，当关键字使用不正确时，也有可能理解<span>UPDATE</span>或<span>DELETE</span>语句。这样就可以更改或删除大量的行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_SELECT_LIMIT = {<i>value</i> | DEFAULT}</span><span>
			</span></p>
			<p>从<span>SELECT</span>语句返回的记录的最大数目。对于一个新连接，默认值是“<span>unlimited</span>”。如果您更改了限值，可以使用<span>SQL_SELECT_LIMIT 
			DEFAULT</span>值恢复默认值。</p>
			<p>如果<span>SELECT</span>有一个<span>LIMIT</span>子句，则<span>LIMIT</span>优先于<span>SQL_SELECT_LIMIT</span>值。</p>
			<p><span>SQL_SELECT_LIMT</span>不适用于在被存储的子程序中执行的<span>SELECT</span>语句。它也不适用于不会产生将被返回到客户端的结果集合的<span>SELECT</span>语句。这些包括子查询中的<span>SELECT</span>语句，<span>CREATE 
			TABLE...SELECT</span>和<span>INSERT INTO...SELECT</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_WARNINGS = {0 | 1}</span><span> </span></p>
			<p>本变量用于控制当出现警告时，单行<span>INSERT</span>语句是否产生一个信息字符串。默认值为<span>0</span>。把值设置为<span>1</span>，来产生一个信息字符串。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			TIMESTAMP = {<i>timestamp_value</i> | DEFAULT}</span><span>
			</span></p>
			<p>
			用于为此客户端设置时间。当您使用二进制日志来恢复行时，本语句用于得到原始的时间标记。<span>timestamp_value</span>应为一个<span>Unix</span>时间标记，而不是<span>MySQL</span>时间标记。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			UNIQUE_CHECKS = {0 | 1}</span><span> </span></p>
			<p>如果设置为<span>1</span>（默认情况），则会对<span>InnoDB</span>表中的二级索引执行唯一性检查。如果设置为<span>0</span>，则对于被插入到<span>InnoDB</span>的插入缓冲器中的索引登录项，不执行唯一性检查。如果您可以肯定您的数据不违反唯一性要求，则您可以把此值设定为<span>0</span>，以加快向<span>InnoDB</span>导入大型表的速度。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="show"></a>13.5.4. SHOW语法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#show-character-set">13.5.4.1. 
			SHOW CHARACTER SET语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-collation">13.5.4.2. 
			SHOW COLLATION语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-columns">13.5.4.3. 
			SHOW COLUMNS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-database">13.5.4.4. 
			SHOW CREATE DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-table">13.5.4.5. 
			SHOW CREATE TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-databases">13.5.4.6. 
			SHOW DATABASES语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-engine">13.5.4.7. 
			SHOW ENGINE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-engines">13.5.4.8. 
			SHOW ENGINES语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-errors">13.5.4.9. 
			SHOW ERRORS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-grants">13.5.4.10. 
			SHOW GRANTS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-index">13.5.4.11. 
			SHOW INDEX语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-innodb-status">13.5.4.12. 
			SHOW INNODB STATUS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-logs">13.5.4.13. 
			SHOW LOGS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-open-tables">13.5.4.14. 
			SHOW OPEN TABLES语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-privileges">13.5.4.15. 
			SHOW PRIVILEGES语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-processlist">13.5.4.16. 
			SHOW PROCESSLIST语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-status">13.5.4.17. 
			SHOW STATUS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-table-status">13.5.4.18. 
			SHOW TABLE STATUS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-tables">13.5.4.19. 
			SHOW TABLES语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-triggers">13.5.4.20. 
			SHOW TRIGGERS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-variables">13.5.4.21. 
			SHOW VARIABLES语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-warnings">13.5.4.22. 
			SHOW WARNINGS语法</a></span></dt></dl></div><a class="indexterm" name="id2921795"></a><a class="indexterm" name="id2921810"></a><a class="indexterm" name="id2921823"></a><a class="indexterm" name="id2921832"></a><a class="indexterm" name="id2921841"></a><a class="indexterm" name="id2921850"></a><a class="indexterm" name="id2921859"></a><a class="indexterm" name="id2921868"></a><a class="indexterm" name="id2921877"></a><a class="indexterm" name="id2921886"></a><a class="indexterm" name="id2921895"></a><a class="indexterm" name="id2921904"></a><a class="indexterm" name="id2921913"></a><a class="indexterm" name="id2921922"></a><a class="indexterm" name="id2921931"></a><a class="indexterm" name="id2921940"></a><a class="indexterm" name="id2921949"></a><a class="indexterm" name="id2921958"></a><a class="indexterm" name="id2921967"></a><a class="indexterm" name="id2921976"></a><a class="indexterm" name="id2921985"></a><a class="indexterm" name="id2921994"></a><a class="indexterm" name="id2922003"></a><a class="indexterm" name="id2922012"></a><a class="indexterm" name="id2922021"></a><a class="indexterm" name="id2922030"></a>
			<p><span>SHOW</span>有多种形式，可以提供有关数据库、表、列或服务器状态的信息。本节叙述以下内容：</p>
			<pre><span>SHOW [FULL] COLUMNS FROM <span><i>tbl_name</i></span> [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW CREATE DATABASE <span><i>db_name</i></span></span></pre>
			<pre><span>SHOW CREATE TABLE <span><i>tbl_name</i></span></span></pre>
			<pre><span>SHOW DATABASES [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW ENGINE <span><i>engine_name</i></span> {LOGS | STATUS }</span></pre>
			<pre><span>SHOW [STORAGE] ENGINES</span></pre>
			<pre><span>SHOW ERRORS [LIMIT [<span><i>offset</i></span>,] <span><i>row_count</i></span>]</span></pre>
			<pre><span>SHOW GRANTS FOR <span><i>user</i></span></span></pre>
			<pre><span>SHOW INDEX FROM <span><i>tbl_name</i></span> [FROM <span><i>db_name</i></span>]</span></pre>
			<pre><span>SHOW INNODB STATUS</span></pre>
			<pre><span>SHOW [BDB] LOGS</span></pre>
			<pre><span>SHOW PRIVILEGES</span></pre>
			<pre><span>SHOW [FULL] PROCESSLIST</span></pre>
			<pre><span>SHOW [GLOBAL | SESSION] STATUS [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW TABLE STATUS [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW [OPEN] TABLES [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW TRIGGERS</span></pre>
			<pre><span>SHOW [GLOBAL | SESSION] VARIABLES [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW WARNINGS [LIMIT [<span><i>offset</i></span>,] <span><i>row_count</i></span>]</span></pre>
			<p><span>SHOW</span>语句还有一些形式，可以提供有关复制型主服务器和从属服务器的信息。这些形式在<a href="sql-syntax.html#replication-sql" title="13.6. Replication Statements">13.6节，“复制语句”</a>中进行了叙述。</p>
			<pre><span>SHOW BINLOG EVENTS</span></pre>
			<pre><span>SHOW MASTER LOGS</span></pre>
			<pre><span>SHOW MASTER STATUS</span></pre>
			<pre><span>SHOW SLAVE HOSTS</span></pre>
			<pre><span>SHOW SLAVE STATUS</span></pre>
			<p>如果一个给定的<span>SHOW</span>语句的语法包括一个<span>LIKE<span> 
			&#39;<i>pattern</i>&#39;</span></span>部分，则<span>&#39;<i>pattern</i>&#39;</span>是一个可以包含<span>SQL
			</span>‘<span>%</span>’和‘<span>_</span>’通配符的字符串。对于把语句输出值限定为匹配值，本样式是有用的。</p>
			<a class="indexterm" name="id2922160"></a><a class="indexterm" name="id2922169"></a><a class="indexterm" name="id2922178"></a><a class="indexterm" name="id2922187"></a><a class="indexterm" name="id2922196"></a><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-character-set"></a>13.5.4.1. SHOW 
				CHARACTER SET语法</h4></div></div></div><a class="indexterm" name="id2922275"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW CHARACTER SET [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW CHARACTER SET</span>语句用于显示所有可用的字符集。该语句取一个自选的<span>LIKE</span>子句。该子句指示哪些字符集名称可以匹配。举例说明：</p>
				<pre><span>mysql&gt; <span><b>SHOW CHARACTER SET LIKE &#39;latin%&#39;;</b></span></span></pre>
				<pre><span>+---------+-----------------------------+-------------------+--------+</span></pre>
				<pre><span>| Charset | Description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Default collation | Maxlen |</span></pre>
				<pre><span>+---------+-----------------------------+-------------------+--------+</span></pre>
				<pre><span>| latin1&nbsp; | cp1252 West European&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin1_swedish_ci |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>| latin2&nbsp; | ISO 8859-2 Central European | latin2_general_ci |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>| latin5&nbsp; | ISO 8859-9 Turkish&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin5_turkish_ci |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>| latin7&nbsp; | ISO 8859-13 Baltic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin7_general_ci |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+---------+-----------------------------+-------------------+--------+</span></pre>
				<p><span>Maxlen</span>列显示用于存储一个字符的最大的字节数目。</p>
				<h4 class="title"><a name="show-collation"></a>13.5.4.2. SHOW 
				COLLATION语法</h4></div></div></div><a class="indexterm" name="id2922345"></a>
				<pre><span>SHOW COLLATION [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p>来自<span>SHOW COLLATION</span>的输出包括所有可用的字符集。该语句取一个自选的<span>LIKE</span>子句。该子句的<span>pattern</span>指示哪些整序名称可以匹配。举例说明：</p>
				<pre><span>mysql&gt; <span><b>SHOW COLLATION LIKE &#39;latin1%&#39;;</b></span></span></pre>
				<pre><span>+-------------------+---------+----+---------+----------+---------+</span></pre>
				<pre><span>| Collation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Charset | Id | Default | Compiled | Sortlen |</span></pre>
				<pre><span>+-------------------+---------+----+---------+----------+---------+</span></pre>
				<pre><span>| latin1_german1_ci | latin1&nbsp; |&nbsp; 5 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_swedish_ci | latin1&nbsp; |&nbsp; 8 | Yes&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_danish_ci&nbsp; | latin1&nbsp; | 15 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_german2_ci | latin1&nbsp; | 31 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 |</span></pre>
				<pre><span>| latin1_bin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin1&nbsp; | 47 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_general_ci | latin1&nbsp; | 48 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_general_cs | latin1&nbsp; | 49 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_spanish_ci | latin1&nbsp; | 94 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>+-------------------+---------+----+---------+----------+---------+</span></pre>
				<p><span>Default</span>列指示对于其字符集，整序值是否是默认值。<span>Compiled</span>指示字符集是否被编辑到服务器中。<span>Sortlen</span>与对字符串（在字符集中表达）分类所需的存储器的数量有关。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-columns"></a>13.5.4.3. SHOW 
				COLUMNS语法</h4></div></div></div><a class="indexterm" name="id2922440"></a><a class="indexterm" name="id2922455"></a>
				<pre><span>SHOW [FULL] COLUMNS FROM <span><i>tbl_name</i></span> [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW COLUMNS</span>显示在一个给定表中的各列的信息。对于试图，本语句也起作用。</p>
				<p>如果列类型与根据您的<span>CREATE TABLE</span>语句所预期的列类型不同，则需注意，当您创建或更改表时，<span>MySQL</span>有时会更改列类型。出现这种情况的条件在<a href="sql-syntax.html#silent-column-changes" title="13.1.5.1. Silent Column Specification Changes">13.1.5.1节，“沉寂的列规格变更”</a>中进行了描述。</p>
				<p><span>FULL</span>关键词会使得输出中包含您拥有的权限，并包含对每一列各自的评注。</p>
				<p>您可以使用<span>db_name.tbl_name</span>作为<span>tbl_name 
				FROM db_name</span>语法的另一种形式。换句话说，这两个语句是等价的：</p>
				<pre><span>mysql&gt; <span><b>SHOW COLUMNS FROM mytable FROM mydb;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SHOW COLUMNS FROM mydb.mytable;</b></span></span></pre>
				<p><span>SHOW FIELDS</span>是<span>SHOW 
				COLUMNS</span>的同义词。您也可以使用<span>mysqlshow db_name 
				tbl_name</span>命令列举表的各列。</p>
				<p><span>DESCRIBE</span>语句提供与<span>SHOW 
				COLUMNS</span>相近的信息。请参见<a href="sql-syntax.html#describe" title="13.3.1. DESCRIBE Syntax (Get Information About Columns)">13.3.1节，“DESCRIBE语法（获取关于列的信息）”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-database"></a>13.5.4.4. SHOW 
				CREATE DATABASE语法</h4></div></div></div><a class="indexterm" name="id2922596"></a><a class="indexterm" name="id2922605"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW CREATE {DATABASE | SCHEMA} <span><i>db_name</i></span></span></pre>
				<p>显示用于创建给定数据库<span>CREATE DATABASE</span>语句。也可以使用<span>SHOW 
				CREATE SCHEMA</span>。</p>
				<pre><span>mysql&gt; <span><b>SHOW CREATE DATABASE test\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Database: test</span></pre>
				<pre><span>Create Database: CREATE DATABASE `test`</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*!40100 DEFAULT CHARACTER SET latin1 */</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>SHOW CREATE SCHEMA test\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Database: test</span></pre>
				<pre><span>Create Database: CREATE DATABASE `test` </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*!40100 DEFAULT CHARACTER SET latin1 */</span></pre>
				<h4 class="title"><a name="show-create-table"></a>13.5.4.5. SHOW 
				CREATE TABLE语法</h4></div></div></div><a class="indexterm" name="id2922669"></a>
				<pre><span>SHOW CREATE TABLE <span><i>tbl_name</i></span></span></pre>
				<p>显示用于创建给定表的<span>CREATE TABLE</span>语句。本语句对视图也起作用。</p>
				<pre><span>mysql&gt; <span><b>SHOW CREATE TABLE t\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table: t</span></pre>
				<pre><span>Create Table: CREATE TABLE t (</span></pre>
				<pre><span>&nbsp; id INT(11) default NULL auto_increment,</span></pre>
				<pre><span>&nbsp; s char(60) default NULL,</span></pre>
				<pre><span>&nbsp; PRIMARY KEY (id)</span></pre>
				<pre><span>) ENGINE=MyISAM</span></pre>
				<pre><span>&nbsp;</span></pre>
				<p>根据<span>SQL_QUOTE_SHOW_CREATE</span>选项，<span>SHOW 
				CREATE TABLE</span>会对表名称和列名称加引号。请参见<a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3节，“SET语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-databases"></a>13.5.4.6. SHOW 
				DATABASES语法</h4></div></div></div><a class="indexterm" name="id2922737"></a><a class="indexterm" name="id2922746"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW {DATABASES | SCHEMAS} [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW DATABASES</span>可以在<span>MySQL</span>服务器主机上列举数据库。您也可以使用<span>mysqlshow</span>命令得到此清单。您只能看到您拥有某些权限的数据库，除非您拥有全局<span>SHOW 
				DATABASES</span>权限。</p>
				<p>如果服务器以<span>--skip-show-database</span>选项为起始，则您根本不能使用本语句，除非您拥有<span>SHOW 
				DATABASES</span>权限。</p>
				<p>也可以使用<span>SHOW SCHEMAS</span>。</p>
				<h4 class="title"><a name="show-engine"></a>13.5.4.7. SHOW 
				ENGINE语法</h4></div></div></div><a class="indexterm" name="id2922816"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW ENGINE <span><i>engine_name</i></span> {LOGS | STATUS }</span></pre>
				<p><span>SHOW ENGINE</span>显示存储引擎的日志或状态信息。目前支持以下语句：</p>
				<pre><span>SHOW ENGINE BDB LOGS</span></pre>
				<pre><span>SHOW ENGINE INNODB STATUS</span></pre>
				<p><span>SHOW ENGINE BDB LOGS</span>显示原有<span>BDB</span>日志文件的状态信息。它会返回以下字段：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>File</span><span>
				</span></p>
				<p>通向日志文件的完整路径。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Type</span><span>
				</span></p>
				<p>日志文件类型（用于<span>Berkeley 
				DB</span>日志文件的<span>BDB</span>）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Status</span><span> </span></p>
				<p>日志文件的状态（如果文件可以被取消，则为<span>FREE</span>。如果文件被事务子系统需要，则为<span>IN 
				USE</span>）</p>
				<p><span>SHOW ENGINE INNODB STATUS</span>显示<span>InnoDB</span>存储引擎状态的全面信息。</p>
				<p>这些语句的旧的同义词（现在不赞成使用）是<span>SHOW [BDB] LOGS</span>和<span>SHOW 
				INNODB STATUS</span>。</p>
				<p><span>SHOW ENGINE</span>可以从<span>MySQL 
				4.1.2</span>起使用。</p>
				<h4 class="title"><a name="show-engines"></a>13.5.4.8. SHOW 
				ENGINES语法</h4></div></div></div><a class="indexterm" name="id2922989"></a><a class="indexterm" name="id2922998"></a><a class="indexterm" name="id2923008"></a>
				<pre><span>SHOW [STORAGE] ENGINES</span></pre>
				<p><span>SHOW ENGINES</span>显示存储引擎的状态信息。对于检查一个存储引擎是否被支持，或者对于查看默认引擎是什么，本语句十分有用。<span>SHOW 
				TABLE TYPES</span>是同义词，但不赞成使用。</p>
				<pre class="programlisting">mysql&gt; <strong class="userinput">SHOW ENGINES\G</strong>
*************************** 1. row ***************************
 Engine: MyISAM
Support: DEFAULT
Comment: Default engine as of MySQL 3.23 with great performance
*************************** 2. row ***************************
 Engine: MEMORY
Support: YES
Comment: Hash based, stored in memory, useful for temporary tables
*************************** 3. row ***************************
 Engine: HEAP
Support: YES
Comment: Alias for MEMORY
*************************** 4. row ***************************
 Engine: MERGE
Support: YES
Comment: Collection of identical MyISAM tables
*************************** 5. row ***************************
 Engine: MRG_MYISAM
Support: YES
Comment: Alias for MERGE
*************************** 6. row ***************************
 Engine: ISAM
Support: NO
Comment: Obsolete storage engine, now replaced by MyISAM
*************************** 7. row ***************************
 Engine: MRG_ISAM
Support: NO
Comment: Obsolete storage engine, now replaced by MERGE
*************************** 8. row ***************************
 Engine: InnoDB
Support: YES
Comment: Supports transactions, row-level locking, and foreign keys
*************************** 9. row ***************************
 Engine: INNOBASE
Support: YES
Comment: Alias for INNODB
*************************** 10. row ***************************
 Engine: BDB
Support: NO
Comment: Supports transactions and page-level locking
*************************** 11. row ***************************
 Engine: BERKELEYDB
Support: NO
Comment: Alias for BDB
*************************** 12. row ***************************
 Engine: NDBCLUSTER
Support: DISABLED
Comment: Clustered, fault-tolerant, memory-based tables
*************************** 13. row ***************************
 Engine: NDB
Support: DISABLED
Comment: Alias for NDBCLUSTER
*************************** 14. row ***************************
 Engine: EXAMPLE
Support: NO
Comment: Example storage engine
*************************** 15. row ***************************
 Engine: ARCHIVE
Support: YES
Comment: Archive storage engine
*************************** 16. row ***************************
 Engine: CSV
Support: YES
Comment: CSV storage engine
*************************** 17. row ***************************
 Engine: FEDERATED
Support: NO
Comment: Federated MySQL storage engine
*************************** 18. row ***************************
 Engine: BLACKHOLE
Support: YES
Comment: /dev/null storage engine (anything you write to it disappears)
</pre>
				<p><span>Support</span>值指示某个存储引擎是否被支持，并指示哪个是默认引擎。例如，如果服务器以<span>--default-table-type=InnoDB</span>选项为起始，则<span>InnoDB</span>行的<span>Support</span>值为<span>DEFAULT</span>值。请参见<a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types">第15章：<i>存储引擎和表类型</i></a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-errors"></a>13.5.4.9. SHOW 
				ERRORS语法</h4></div></div></div><a class="indexterm" name="id2923134"></a>
				<pre><span>SHOW ERRORS [LIMIT [<span><i>offset</i></span>,] <span><i>row_count</i></span>]</span></pre>
				<pre><span>SHOW COUNT(*) ERRORS</span></pre>
				<p>本语句与<span>SHOW WARNINGS</span>接近，不过该语句只显示错误，不同时显示错误、警告和注意。</p>
				<p><span>LIMIT</span>子句与<span>SELECT</span>语句具有相同的语法，请参见<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。</p>
				<p><span>SHOW COUNT(*) ERRORS</span>语句显示错误的数目。您也可以从<span>error_count</span>变量中找回此数目：</p>
				<pre><span>SHOW COUNT(*) ERRORS;</span></pre>
				<pre><span>SELECT @@error_count;</span></pre>
				<p>要了解更多信息，请参见<a href="sql-syntax.html#show-warnings" title="13.5.4.22. SHOW WARNINGS Syntax">13.5.4.22节，“SHOW 
			WARNINGS语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-grants"></a>13.5.4.10. SHOW 
				GRANTS语法</h4></div></div></div><a class="indexterm" name="id2923220"></a><a class="indexterm" name="id2923230"></a><a class="indexterm" name="id2923239"></a>
				<pre><span>SHOW GRANTS FOR <span><i>user</i></span></span></pre>
				<p>本语句列出了在为<span>MySQL</span>用户账户复制权限时必须发布的<span>GRANT</span>语句。</p>
				<pre><span>mysql&gt; <span><b>SHOW GRANTS FOR &#39;root&#39;@&#39;localhost&#39;;</b></span></span></pre>
				<pre><span>+---------------------------------------------------------------------+</span></pre>
				<pre><span>| Grants for root@localhost&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------------------------------------------------------------------+</span></pre>
				<pre><span>| GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;localhost&#39; WITH GRANT OPTION |</span></pre>
				<pre><span>+---------------------------------------------------------------------+</span></pre>
				<p>要对当前的会话列出权限，您可以使用以下语句之一：</p>
				<pre><span>SHOW GRANTS;</span></pre>
				<pre><span>SHOW GRANTS FOR CURRENT_USER;</span></pre>
				<pre><span>SHOW GRANTS FOR CURRENT_USER();</span></pre>
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="show-index"></a>13.5.4.11. SHOW 
				INDEX语法</h4></div></div></div>
				<a class="indexterm" name="id2923302"></a>
				<a class="indexterm" name="id2923316"></a>
				<a class="indexterm" name="id2923325"></a>
				<pre><span>SHOW INDEX FROM <span><i>tbl_name</i></span> [FROM <span><i>db_name</i></span>]</span></pre>
				<p><span>SHOW INDEX</span>会返回表索引信息。其格式与<span>ODBC</span>中的<span>SQLStatistics</span>调用相似。</p>
				<p><span>SHOW INDEX</span>会返回以下字段：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Table</span><span> </span></p>
				<p>表的名称。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Non_unique</span><span> </span></p>
				<p>如果索引不能包括重复词，则为<span>0</span>。如果可以，则为<span>1</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Key_name</span><span> </span></p>
				<p>索引的名称。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Seq_in_index</span><span> </span></p>
				<p>索引中的列序列号，从<span>1</span>开始。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Column_name</span><span> </span></p>
				<p>列名称。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Collation</span><span> </span></p>
				<p>列以什么方式存储在索引中。在<span>MySQL</span>中，有值‘<span>A</span>’（升序）或<span>NULL</span>（无分类）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Cardinality</span><span> </span></p>
				<p>索引中唯一值的数目的估计值。通过运行<span>ANALYZE 
				TABLE</span>或<strong><span>myisamchk 
				-a</span></strong>可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，<span>MySQL</span>使用该索引的机会就越大。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Sub_part</span><span> </span></p>
				<p>
				如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为<span>NULL</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Packed</span><span> </span></p>
				<p>指示关键字如何被压缩。如果没有被压缩，则为<span>NULL</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Null</span><span>
				</span></p>
				<p>如果列含有<span>NULL</span>，则含有<span>YES</span>。如果没有，则该列含有<span>NO</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Index_type</span><span> </span></p>
				<p>用过的索引方法（<span>BTREE, 
				FULLTEXT, HASH, RTREE</span>）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Comment</span><span> </span></p>
				<p>多种评注。</p>
				<p>您可以使用<span>db_name.tbl_name</span>作为<span>tbl_name 
				FROM db_name</span>语法的另一种形式。这两个语句是等价的：</p>
				<pre><span>mysql&gt; <span><b>SHOW INDEX FROM mytable FROM mydb;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SHOW INDEX FROM mydb.mytable;</b></span></span></pre>
				<p><span>SHOW KEYS</span>是<span>SHOW INDEX</span>的同义词。您也可以使用<strong><span>mysqlshow 
				-k </span></strong><span><b><i>
				<span>db_name</span></i></b></span><strong><span>
				</span></strong><span><b><i>
				<span>tbl_name</span></i></b></span>命令列举一个表的索引。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-innodb-status"></a>13.5.4.12. SHOW 
				INNODB STATUS语法</h4></div></div></div>
				<pre><span>SHOW INNODB STATUS</span></pre>
				<p>在<span>MySQL 5.1</span>中，这是<span>SHOW 
				ENGINE INNODB STATUS</span>的同义词，但不赞成使用。请参见<a href="sql-syntax.html#show-engine" title="13.5.4.7. SHOW ENGINE Syntax">13.5.4.7节，“SHOW 
			ENGINE语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-logs"></a>13.5.4.13. SHOW 
				LOGS语法</h4></div></div></div>
				<pre><span>SHOW [BDB] LOGS</span></pre>
				<p>在<span>MySQL 5.1</span>中，这是<span>SHOW 
				ENGINE BDB LOGS</span>的同义词，但是不赞成使用。请参见<a href="sql-syntax.html#show-engine" title="13.5.4.7. SHOW ENGINE Syntax">13.5.4.7节，“SHOW 
			ENGINE语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-open-tables"></a>13.5.4.14. SHOW 
				OPEN TABLES语法</h4></div></div></div><a class="indexterm" name="id2923760"></a><a class="indexterm" name="id2923774"></a>
				<pre><span>SHOW OPEN TABLES [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW OPEN TABLES</span>列举在表缓存中当前被打开的非<span>TEMPORARY</span>表。请参见<a href="optimization.html#table-cache" title="7.4.9. How MySQL Opens and Closes Tables">7.4.9节，“MySQL如何打开和关闭表”</a>。</p>
				<p><span>SHOW OPEN TABLES</span>会返回以下字段：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Database</span><span> </span></p>
				<p>含有该表的数据库。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Table</span><span> </span></p>
				<p>表名称。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				In_use</span><span> </span></p>
				<p>
				表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Name_locked</span><span> </span></p>
				<p>表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-privileges"></a>13.5.4.15. SHOW 
				PRIVILEGES语法</h4></div></div></div><a class="indexterm" name="id2923896"></a>
				<pre><span>SHOW PRIVILEGES</span></pre>
				<p><span>SHOW PRIVILEGES</span>显示<span>MySQL</span>服务器支持的系统权限清单。确切的输出根据您的服务器的版本而定。</p>
				<pre><span>mysql&gt; <span><b>SHOW PRIVILEGES\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>Privilege: Alter</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To alter the table</span></pre>
				<pre><span>*************************** 2. row ***************************</span></pre>
				<pre><span>Privilege: Alter routine</span></pre>
				<pre><span>Context: Functions,Procedures</span></pre>
				<pre><span>Comment: To alter or drop stored functions/procedures</span></pre>
				<pre><span>*************************** 3. row ***************************</span></pre>
				<pre><span>Privilege: Create</span></pre>
				<pre><span>Context: Databases,Tables,Indexes</span></pre>
				<pre><span>Comment: To create new databases and tables</span></pre>
				<pre><span>*************************** 4. row ***************************</span></pre>
				<pre><span>Privilege: Create routine</span></pre>
				<pre><span>Context: Functions,Procedures</span></pre>
				<pre><span>Comment: To use CREATE FUNCTION/PROCEDURE</span></pre>
				<pre><span>*************************** 5. row ***************************</span></pre>
				<pre><span>Privilege: Create temporary tables</span></pre>
				<pre><span>Context: Databases</span></pre>
				<pre><span>Comment: To use CREATE TEMPORARY TABLE</span></pre>
				<pre><span>*************************** 6. row ***************************</span></pre>
				<pre><span>Privilege: Create view</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To create new views</span></pre>
				<pre><span>*************************** 7. row ***************************</span></pre>
				<pre><span>Privilege: Create user</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To create new users</span></pre>
				<pre><span>*************************** 8. row ***************************</span></pre>
				<pre><span>Privilege: Delete</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To delete existing rows</span></pre>
				<pre><span>*************************** 9. row ***************************</span></pre>
				<pre><span>Privilege: Drop</span></pre>
				<pre><span>Context: Databases,Tables</span></pre>
				<pre><span>Comment: To drop databases, tables, and views</span></pre>
				<pre><span>*************************** 10. row ***************************</span></pre>
				<pre><span>Privilege: Execute</span></pre>
				<pre><span>Context: Functions,Procedures</span></pre>
				<pre><span>Comment: To execute stored routines</span></pre>
				<pre><span>*************************** 11. row ***************************</span></pre>
				<pre><span>Privilege: File</span></pre>
				<pre><span>Context: File access on server</span></pre>
				<pre><span>Comment: To read and write files on the server</span></pre>
				<pre><span>*************************** 12. row ***************************</span></pre>
				<pre><span>Privilege: Grant option</span></pre>
				<pre><span>Context: Databases,Tables,Functions,Procedures</span></pre>
				<pre><span>Comment: To give to other users those privileges you possess</span></pre>
				<pre><span>*************************** 13. row ***************************</span></pre>
				<pre><span>Privilege: Index</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To create or drop indexes</span></pre>
				<pre><span>*************************** 14. row ***************************</span></pre>
				<pre><span>Privilege: Insert</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To insert data into tables</span></pre>
				<pre><span>*************************** 15. row ***************************</span></pre>
				<pre><span>Privilege: Lock tables</span></pre>
				<pre><span>Context: Databases</span></pre>
				<pre><span>Comment: To use LOCK TABLES (together with SELECT privilege)</span></pre>
				<pre><span>*************************** 16. row ***************************</span></pre>
				<pre><span>Privilege: Process</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To view the plain text of currently executing queries</span></pre>
				<pre><span>*************************** 17. row ***************************</span></pre>
				<pre><span>Privilege: References</span></pre>
				<pre><span>Context: Databases,Tables</span></pre>
				<pre><span>Comment: To have references on tables</span></pre>
				<pre><span>*************************** 18. row ***************************</span></pre>
				<pre><span>Privilege: Reload</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To reload or refresh tables, logs and privileges</span></pre>
				<pre><span>*************************** 19. row ***************************</span></pre>
				<pre><span>Privilege: Replication client</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To ask where the slave or master servers are</span></pre>
				<pre><span>*************************** 20. row ***************************</span></pre>
				<pre><span>Privilege: Replication slave</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To read binary log events from the master</span></pre>
				<pre><span>*************************** 21. row ***************************</span></pre>
				<pre><span>Privilege: Select</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To retrieve rows from table</span></pre>
				<pre><span>*************************** 22. row ***************************</span></pre>
				<pre><span>Privilege: Show databases</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To see all databases with SHOW DATABASES</span></pre>
				<pre><span>*************************** 23. row ***************************</span></pre>
				<pre><span>Privilege: Show view</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To see views with SHOW CREATE VIEW</span></pre>
				<pre><span>*************************** 24. row ***************************</span></pre>
				<pre><span>Privilege: Shutdown</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To shut down the server</span></pre>
				<pre><span>*************************** 25. row ***************************</span></pre>
				<pre><span>Privilege: Super</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To use KILL thread, SET GLOBAL, CHANGE MASTER, etc.</span></pre>
				<pre><span>*************************** 26. row ***************************</span></pre>
				<pre><span>Privilege: Update</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To update existing rows</span></pre>
				<pre><span>*************************** 27. row ***************************</span></pre>
				<pre><span>Privilege: Usage</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: No privileges - allow connect only</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-processlist"></a>13.5.4.16. SHOW 
				PROCESSLIST语法</h4></div></div></div><a class="indexterm" name="id2924087"></a><a class="indexterm" name="id2924096"></a><a class="indexterm" name="id2924105"></a><a class="indexterm" name="id2924114"></a><a class="indexterm" name="id2924124"></a>
				<pre><span>SHOW [FULL] PROCESSLIST</span></pre>
				<p><span>SHOW PROCESSLIST</span>显示哪些线程正在运行。您也可以使用<strong><span>mysqladmin 
				processlist</span></strong>语句得到此信息。如果您有<span>SUPER</span>权限，您可以看到所有线程。否则，您只能看到您自己的线程（也就是，与您正在使用的<span>MySQL</span>账户相关的线程）。请参见<a href="sql-syntax.html#kill" title="13.5.5.3. KILL Syntax">13.5.5.3节，“KILL语法”</a>。如果您不使用<span>FULL</span>关键词，则只显示每个查询的前<span>100</span>个字符。</p>
				<p>本语句报告<span>TCP/IP</span>连接的主机名称（采用<span><i><span>host_name</span></i><span>:<i>client_port</i></span></span>格式），以方便地判定哪个客户端正在做什么。</p>
				<p>如果您得到“<span>too many connections</span>”错误信息，并且想要了解正在发生的情况，本语句是非常有用的。<span>MySQL</span>保留一个额外的连接，让拥有<span>SUPER</span>权限的
				账户使用，以确保管理员能够随时连接和检查系统（假设您没有把此权限给予所有的用户）。</p>
				<p>在来自<span>SHOW PROCESSLIST</span>的输出中常见的一些状态：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Checking table</span><span> </span></p>
				<p>线程正在执行（自动）表格检查。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Closing tables</span><span> </span></p>
				<p>
				意味着线程正在刷新更改后的表数据，并正在关闭使用过的表。这应该是一个快速的操作。如果不快，则您应该验证您的磁盘没有充满，并且磁盘没有被超负荷使用。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Connect Out</span><span> </span></p>
				<p>连接到主服务器上的从属服务器。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Copying to tmp table on disk</span><span>
				</span></p>
				<p>临时结果集合大于<span>tmp_table_size</span>。线程把临时表从存储器内部格式改变为磁盘模式，以节约存储器。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Creating tmp table</span><span> </span></p>
				<p>线程正在创建一个临时表，以保持部分结果。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				deleting from main table</span><span> </span>
				</p>
				<p>服务器正在执行多表删除的第一部分，只从第一个表中删除。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				deleting from reference tables</span><span>
				</span></p>
				<p>服务器正在执行多表删除的第二部分，从其它表中删除匹配的行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Flushing tables</span><span> </span></p>
				<p>线程正在执行<span>FLUSH 
				TABLES</span>，并正在等待所有线程，以关闭表。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				FULLTEXT initialization</span><span> </span>
				</p>
				<p>服务器正在准备执行一个自然语言全文本搜索。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Killed</span><span> </span></p>
				<p>有人已经向线程发送了一个<span>KILL</span>命令。在下一次检查终止标记时，应放弃。该标记在<span>MySQL</span>的每个大循环中都检查，但是在有些情况下，线程终止只需要较短的时间。如果该线程被其它线程锁定，则只要其它线程接触锁定，终止操作就会生效。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Locked</span><span> </span></p>
				<p>该查询被其它查询锁定。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Sending data</span><span> </span></p>
				<p>线程正在为<span>SELECT</span>语句处理行，同时正在向客户端发送数据。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Sorting for group</span><span> </span></p>
				<p>线程正在进行分类，以满足<span>GROUP 
				BY</span>要求。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Sorting for order</span><span> </span></p>
				<p>线程正在进行分类，以满足<span>ORDER 
				BY</span>要求。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Opening tables</span><span> </span></p>
				<p>
				线程正在试图打开一个表。这应该是非常快的过程，除非打开操作受到阻止。例如，一个<span>ALTER 
				TABLE</span>或一个<span>LOCK TABLE</span>语句可以阻止打开一个表，直到语句完成为止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Removing duplicates</span><span> </span></p>
				<p>查询正在使用<span>SELECT 
				DISTINCT</span>。使用时，在早期阶段，<span>MySQL</span>不能优化不同的操作。因此，<span>MySQL</span>要求一个额外的阶段，以便在把结果发送给客户端之前取消所有的复制行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Reopen table</span><span> </span></p>
				<p>
				线程得到一个表锁定，但是在得到锁定后被通知带下方的表结构已更改了。它已经释放了锁定，关闭了表，并试图重新打开它。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Repair by sorting</span><span> </span></p>
				<p>修复代码正在使用一个分类来创建索引。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Repair with keycache</span><span> </span></p>
				<p>
				修复代码正在通过关键缓存一个接一个地使用创建关键字。这比通过分类修复要慢很多。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Searching rows for update</span><span> </span>
				</p>
				<p>线程正在进行第一阶段，以在更新之前，查找所有匹配的行。如果<span>UPDATE</span>正在更改用于查找相关行的索引，则必须这么做。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Sleeping</span><span> </span></p>
				<p>线程正在等待客户端，以向它发送一个新语句。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				System lock</span><span> </span></p>
				<p>
				线程正在等待得到一个用于表的外部系统锁定。如果您没有正在使用多个正在访问同一个表的<span>mysqld</span>服务器，则您可以使用<span>--skip-external-locking</span>选项禁用系统锁定。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Upgrading lock</span><span> </span></p>
				<p><span>INSERT DELAYED</span>管理程序正在试图得到一个表锁定，以插入行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Updating</span><span> </span></p>
				<p>线程正在搜索行，并正在更新这些行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>User 
				Lock</span><span> </span></p>
				<p>线程正在等待<span>GET_LOCK()</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Waiting for tables</span><span> </span></p>
				<p>
				线程得到一个通知，表的底层结构已经改变，需要重新打开表以得到新的结构。但是，为了能重新打开表，必须等待，直到所有其它的线程已经关闭了正在被质询的表。</p>
				<p>如果其它线程已经对正在被质询的表使用了<span>FLUSH 
				TABLES</span>或以下语句之一：<span>FLUSH TABLES<span>
				<i>tbl_name</i></span>, <span>ALTER 
				TABLE</span>, <span>RENAME TABLE</span>,
				<span>REPAIR TABLE</span>,
				<span>ANALYZE TABLE</span></span>或<span><span>OPTIMIZE 
				TABLE</span>；则会出现通知。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				waiting for handler insert</span><span> </span>
				</p>
				<p><span>INSERT DELAYED</span>管理程序已经处理了所有处于等待状态的插入，并正在等待新插入。</p>
				<p>多数状态对应于非常快的操作。如果一个线程在这些状态下停留了数秒，则可能是有问题，需要进行调查。</p>
				<p>有一些其它的状态，在前面的清单中没有提及，但是其中有很多状态对于查找服务器中的程序错误是有用的。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-status"></a>13.5.4.17. SHOW 
				STATUS语法</h4></div></div></div><a class="indexterm" name="id2924776"></a><a class="indexterm" name="id2924783"></a>
				<pre><span>SHOW [GLOBAL | SESSION] STATUS [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW STATUS</span>提供服务器状态信息。此信息也可以使用<strong><span>mysqladmin 
				extended-status</span></strong>命令获得。</p>
				<p>此处显示了局部的输出。对于您的服务器，变量和值的清单可以是不同的。在<a href="database-administration.html#server-status-variables" title="5.3.4. Server Status Variables">5.3.4节，“服务器状态变量”</a>中给出了每个变量的意义。</p>
				<pre><span>mysql&gt; <span><b>SHOW STATUS;</b></span></span></pre>
				<pre><span>+--------------------------+------------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+--------------------------+------------+</span></pre>
				<pre><span>| Aborted_clients&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Aborted_connects&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Bytes_received&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 155372598&nbsp; |</span></pre>
				<pre><span>| Bytes_sent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1176560426 |</span></pre>
				<pre><span>| Connections&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 30023&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Created_tmp_disk_tables&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Created_tmp_tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 8340&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Created_tmp_files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</span></pre>
				<pre><span>| Open_tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Open_files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Open_streams&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Opened_tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 44600&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Questions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 2026873&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</span></pre>
				<pre><span>| Table_locks_immediate&nbsp;&nbsp;&nbsp; | 1920382&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Table_locks_waited&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Threads_cached&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Threads_created&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 30022&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Threads_connected&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Threads_running&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Uptime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 80380&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+--------------------------+------------+</span></pre>
				<p>使用<span>LIKE</span>子句，该语句只显示匹配该样式的那些变量：</p>
				<pre><span>mysql&gt; <span><b>SHOW STATUS LIKE &#39;Key%&#39;;</b></span></span></pre>
				<pre><span>+--------------------+----------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+--------------------+----------+</span></pre>
				<pre><span>| Key_blocks_used&nbsp;&nbsp;&nbsp; | 14955&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Key_read_requests&nbsp; | 96854827 |</span></pre>
				<pre><span>| Key_reads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 162040&nbsp;&nbsp; |</span></pre>
				<pre><span>| Key_write_requests | 7589728&nbsp; |</span></pre>
				<pre><span>| Key_writes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 3813196&nbsp; |</span></pre>
				<pre><span>+--------------------+----------+</span></pre>
				<p>使用<span>GLOBAL</span>选项，您可以得到所有<span>MySQL</span>连接的状态值。使用<span>SESSION</span>，您可以得到所有当前连接的状态值。如果您两个选项都不使用，则默认值为<span>SESSION</span>。<span>LOCAL</span>是<span>SESSION</span>的同义词。</p>
				<p>注意，有些状态变量只有一个全局值。对于这些变量，使用<span>GLOBAL</span>和<span>SESSION</span>会得到同样的值。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-table-status"></a>13.5.4.18. SHOW 
				TABLE STATUS语法</h4></div></div></div><a class="indexterm" name="id2924932"></a><a class="indexterm" name="id2924942"></a><a class="indexterm" name="id2924953"></a>
				<pre><span>SHOW TABLE STATUS [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW TABLE STATUS</span>的性质与<span>SHOW 
				TABLE</span>类似，不过，可以提供每个表的大量信息。您也可以使用<strong><span>mysqlshow 
				--status </span></strong><span><b><i>
				<span>db_name</span></i></b></span>命令得到此清单。</p>
				<p>本语句也显示视图信息。</p>
				<p>对于<span>NDB Cluster</span>表，本语句的输出显示<span>Avg_row_length</span>和<span>Data_length</span>列的适当值，不过<span>BLOB</span>列没有被考虑进来。另外，复制数量在<span>Comment</span>列中显示（作为<span>number_of_replicas</span>）。</p>
				<p><span>SHOW TABLE STATUS</span>会返回以下字段：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Name</span><span>
				</span></p>
				<p>表的名称。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Engine</span><span> </span></p>
				<p>表的存储引擎。在<span>MySQL 
				4.1.2</span>之前，本值被标记为<span>Type</span>。请参见<a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types">第15章：<i>存储引擎和表类型</i></a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Version</span><span> </span></p>
				<p>表的<span>.frm</span>文件的版本号。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Row_format</span><span> </span></p>
				<p>行存储格式（<span>Fixed</span><span>,
				<span>Dynamic</span>,
				<span>Compressed</span>,
				<span>Redundant</span>,
				<span>Compact</span></span><span>）。<span>InnoDB</span>表的格式被报告为<span>Redundant</span>或<span>Compact</span>。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Rows</span><span>
				</span></p>
				<p>行的数目。部分存储引擎，如<span>MyISAM</span>，存储精确的数目。</p>
				<p>对于其它存储引擎，比如<span>InnoDB</span>，本值是一个大约的数，与实际值相差可达<span>40</span>到<span>50</span>％。在这些情况下，使用<span>SELECT 
				COUNT(*)</span>来获得准确的数目。</p>
				<p>对于在<span>INFORMATION_SCHEMA</span>数据库中的表，<span>Rows</span>值为<span>NULL</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Avg_row_length</span><span> </span></p>
				<p>平均的行长度。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Data_length</span><span> </span></p>
				<p>数据文件的长度。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Max_data_length</span><span> </span></p>
				<p>
				数据文件的最大长度。如果给定了数据指针的大小，这是可以被存储在表中的数据的字节总数。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Index_length</span><span> </span></p>
				<p>索引文件的长度。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Data_free</span><span> </span></p>
				<p>被整序，但是未使用的字节的数目。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Auto_increment</span><span> </span></p>
				<p>下一个<span>AUTO_INCREMENT</span>值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Create_time</span><span> </span></p>
				<p>什么时候表被创建。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Update_time</span><span> </span></p>
				<p>什么时候数据文件被最后一次更新。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Check_time</span><span> </span></p>
				<p>
				什么时候表被最后一次检查。不是所有的存储引擎此时都更新，在此情况下，值为<span>NULL</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Collation</span><span> </span></p>
				<p>表的字符集和整序。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Checksum</span><span> </span></p>
				<p>活性校验和值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Create_options</span><span> </span></p>
				<p>和<span>CREATE TABLE</span>同时使用的额外选项。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Comment</span><span> </span></p>
				<p>创建表时使用的评注（或者有关为什么<span>MySQL</span>可以访问表信息的说明）。</p>
				<p>在表评注中，<span>InnoDB</span>表报告表所属的表空间的空闲空间。对于一个位于共享表空间中的表，这是共享表空间中的空闲空间。如果您正在使用多个表空间，并且该表有自己的表空间，则空闲空间只用于此表。</p>
				<p>对于<span>MEMORY (HEAP)</span>表，<span>Data_length, 
				Max_data_length</span>和<span>Index_length</span>值近似于被整序的存储器的实际值。整序算法预留了大量的存储器，以减少整序操作的数量。</p>
				<p>对于视图，由<span>SHOW TABLE STATUS</span>显示的所有字段均为<span>NULL</span>。例外情况是<span>Name</span>指示为视图名称同时<span>Comment</span>称为视图。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-tables"></a>13.5.4.19. SHOW 
				TABLES语法</h4></div></div></div><a class="indexterm" name="id2925476"></a><a class="indexterm" name="id2925490"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW [FULL] TABLES [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW TABLES</span>列举了给定数据库中的非<span>TEMPORARY</span>表。您也可以使用<strong><span>mysqlshow
				</span></strong><span><b><i>
				<span>db_name</span></i></b></span>命令得到此清单。</p>
				<p>本命令也列举数据库中的其它视图。支持<span>FULL</span>修改符，这样<span>SHOW 
				FULL TABLES</span>就可以显示第二个输出列。对于一个表，第二列的值为<span>BASE 
				TABLE</span>；对于一个视图，第二列的值为<span>VIEW</span>。</p>
				<p>注释：如果您对于一个表没有权限，则该表不会在来自<span>SHOW TABLES</span>或的<strong><span>mysqlshow 
				db_name</span></strong>输出中显示。</p>
				<h4 class="title"><a name="show-triggers"></a>13.5.4.20. SHOW 
				TRIGGERS语法</h4></div></div></div><a class="indexterm" name="id2925584"></a><a class="indexterm" name="id2925590"></a><a class="indexterm" name="id2925597"></a>
				<pre><span>SHOW TRIGGERS [FROM <span><i>db_name</i></span>] [LIKE <span><i>expr</i></span>]</span></pre>
				<p><span>SHOW TRIGGERS</span>列出了目前被<span>MySQL</span>服务器定义的触发程序。</p>
				<p>对于在<a href="triggers.html#using-triggers" title="21.3. Using Triggers">21.3节，“使用触发程序”</a>中定义的触发程序<span>ins_sum</span>，本语句的输出显示如下：</p>
				<pre><span>mysql&gt; <span><b>SHOW TRIGGERS LIKE &#39;acc%&#39;;</b></span></span></pre>
				<pre><span>+---------+--------+---------+-------------------------------+--------+---------+</span></pre>
				<pre><span>| Trigger | Event&nbsp; | Table&nbsp;&nbsp; | Statement&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Timing | Created |</span></pre>
				<pre><span>+---------+--------+---------+-------------------------------+--------+---------+</span></pre>
				<pre><span>| ins_sum | INSERT | account |&nbsp; SET @sum = @sum + NEW.amount | BEFORE | NULL&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------+--------+---------+-------------------------------+--------+---------+</span></pre>
				<p>注释：当使用一个含有<span>SHOW TRIGGERS</span>的<span>LIKE</span>子句时，待匹配的表达式（<span>expr</span>）会与触发程序定义时所在的表的名称相比较，而不与触发程序的名称相比较：</p>
				<pre><span>mysql&gt; <span><b>SHOW TRIGGERS LIKE &#39;ins%&#39;;</b></span></span></pre>
				<pre><span>Empty set (0.01 sec)</span></pre>
				<p>对本语句输出中的各列的简要解释如下：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Trigger</span><span>: </span>触发程序的名称。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Event</span><span>: </span>调用触发程序的时间。必须为<span>&#39;INSERT&#39;</span><span>,
				<span>&#39;UPDATE&#39;</span></span>或 
				 
				<span>&#39;DELETE&#39;</span><span>.</span>之一。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Table</span><span>: </span>触发程序定义时对应的表。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Statement</span><span>: </span>
				当触发程序被调用时执行的语句。这与在<span>INFORMATION_SCHEMA.TRIGGERS</span>的<span>ACTION_STATEMENT</span>列中显示的文本一样。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Timing</span><span>:
				<span>&#39;BEFORE&#39;</span></span>或<span>&#39;AFTER&#39;</span>两个值之一。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Created</span><span>: </span>目前，本列的值为<span>NULL</span>。 
				</p>
				<p>为了执行<span>SHOW TRIGGERS</span>，您必须拥有<span>SUPER</span>权限。</p>
				<p>同时也见<a href="information-schema.html#triggers-table" title="23.1.16. The INFORMATION_SCHEMA TRIGGERS Table">23.1.16节，“INFORMATION_SCHEMA TRIGGERS表”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-variables"></a>13.5.4.21. SHOW 
				VARIABLES语法</h4></div></div></div><a class="indexterm" name="id2925833"></a><a class="indexterm" name="id2925840"></a><a class="indexterm" name="id2925847"></a><a class="indexterm" name="id2925857"></a>
				<pre><span>SHOW [GLOBAL | SESSION] VARIABLES [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW VARIABLES</span>显示了部门<span>MySQL</span>系统变量的值。本信息也可以使用<strong><span>mysqladmin 
				variables</span></strong>命令获得。</p>
				<p>使用<span>GLOBAL</span>选项，您可以获得被用于<span>MySQL</span>新连接的值。使用<span>SESSION</span>，您可以得到对于当前连接起效的值。如果您两个选项都不使用，默认值为<span>SESSION</span>。</p>
				<p><span>LOCAL</span>是<span>SESSION</span>的同义词。</p>
				<p>如果默认值不合适，当<span>mysqld</span>启动时或在<span>SET</span>语句运行过程中，您可以使用命令行选项设置多数的这类变量。请参见<a href="database-administration.html#server-options" title="5.3.1. mysqld Command-Line Options">5.3.1节，“<span><strong class="command">mysqld</strong></span>命令行选项”</a>和<a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3节，“SET语法</a>。</p>
				<p>此处显示了部分的输出。对于您的服务器，变量和值的清单会有所不同。在<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a>中给出了每个变量的意义。在<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2节，“调节服务器参数”</a>中提供了有关调整变量的信息。</p>
				<pre><span>mysql&gt; <span><b>SHOW VARIABLES;</b></span></span></pre>
				<pre><span>+---------------------------------+-----------------------------------------------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------------------------------+-----------------------------------------------+</span></pre>
				<pre><span>| auto_increment_increment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| auto_increment_offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| automatic_sp_privileges&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| back_log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| basedir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | /home/jon/bin/mysql-5.1/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| binlog_cache_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| bulk_insert_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 8388608&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| character_set_client&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| character_set_connection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></pre>
				<pre><span>| max_user_connections&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| max_write_lock_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4294967295&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| multi_range_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 256&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| myisam_data_pointer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| myisam_max_sort_file_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 2147483647&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| myisam_recover_options&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| myisam_repair_threads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| myisam_sort_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 8388608&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| ndb_autoincrement_prefetch_sz&nbsp;&nbsp; | 32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| ndb_cache_check_time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| ndb_force_send&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp; </span></pre>
				<pre><span>| time_zone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | SYSTEM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| timed_mutexes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| tmp_table_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 33554432&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| tmpdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| transaction_alloc_block_size&nbsp;&nbsp;&nbsp; | 8192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| transaction_prealloc_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| tx_isolation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | REPEATABLE-READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| updatable_views_with_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 5.1.2-alpha-log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| version_comment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Source distribution&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| version_compile_machine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | i686&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| version_compile_os&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | suse-linux&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| wait_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 28800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------------------------------+-----------------------------------------------+</span></pre>
				<p>使用<span>LIKE</span>子句，本语句只显示与样式相匹配的变量：</p>
				<pre><span>mysql&gt; <span><b>SHOW VARIABLES LIKE &#39;have%&#39;;</b></span></span></pre>
				<pre><span>+-----------------------+----------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+-----------------------+----------+</span></pre>
				<pre><span>| have_archive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_bdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | NO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_blackhole_engine | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_compress&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_crypt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_csv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_example_engine&nbsp;&nbsp; | NO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_federated_engine | NO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_geometry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;|</span></pre>
				<pre><span>| have_innodb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_isam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | NO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_ndbcluster&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | DISABLED |</span></pre>
				<pre><span>| have_openssl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | NO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_partition_engine | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_query_cache&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_raid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | NO&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| have_rtree_keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_symlink&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+-----------------------+----------+</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-warnings"></a>13.5.4.22. SHOW 
				WARNINGS语法</h4></div></div></div><a class="indexterm" name="id2926135"></a>
				<pre><span>SHOW WARNINGS [LIMIT [<span><i>offset</i></span>,] <span><i>row_count</i></span>]</span></pre>
				<pre><span>SHOW COUNT(*) WARNINGS</span></pre>
				<p><span>SHOW WARNINGS</span>显示由上一个生成消息的语句导致的错误、警告和注意消息。如果上一个使用表的语句未生成消息，则什么也不显示。<span>SHOW 
				ERRORS</span>是其相关语句，只显示错误。请参见<a href="sql-syntax.html#show-errors" title="13.5.4.9. SHOW ERRORS Syntax">13.5.4.9节，“SHOW 
			ERRORS语法”</a>。</p>
				<p>对于使用一个表的每个新语句，消息清单均重新设置。</p>
				<p><span>SHOW COUNT(*) WARNINGS</span>语句显示错误、警告和注意的总数。您也可以从<span>warning_count</span>变量中找回此数目。</p>
				<pre><span>SHOW COUNT(*) WARNINGS;</span></pre>
				<pre><span>SELECT @@warning_count;</span></pre>
				<p>如果<span>max_error_count</span>系统变量设置得过低，以致于有的消息没有被存储，则<span>warning_count</span>值可能比由<span>SHOW 
				WARNINGS</span>显示的消息数目要大。本节后部显示的例子展示了这类情况是如何发生的。</p>
				<p><span>LIMIT</span>子句具有与<span>SELECT</span>语句相同的语法。请参见<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。</p>
				<p><span>MySQL</span>服务器会发回由上一个语句引起的错误、警告和注意的总数。如果您正在使用<span>C 
				API</span>，则此值可以通过调用<span>mysql_warning_count()</span>来获得。请参见<a href="apis.html#mysql-warning-count" title="25.2.3.69. mysql_warning_count()">25.2.3.69节，“mysql_warning_count()”</a>。</p>
				<p>对于如<span>LOAD DATA INFILE</span>等语句和如<span>INSERT, 
				UPDATE, CREATE TABLE</span>和<span>ALTER TABLE</span>等<span>DML</span>语句，会生成警告。</p>
				<p>以下<span>DROP TABLE</span>语句会导致一个注意：</p>
				<pre><span>mysql&gt; <span><b>DROP TABLE IF EXISTS no_such_table;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SHOW WARNINGS;</b></span></span></pre>
				<pre><span>+-------+------+-------------------------------+</span></pre>
				<pre><span>| Level | Code | Message&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+-------+------+-------------------------------+</span></pre>
				<pre><span>| Note&nbsp; | 1051 | Unknown table &#39;no_such_table&#39; |</span></pre>
				<pre><span>+-------+------+-------------------------------+</span></pre>
				<p>以下是一个简单的例子，显示了对于<span>CREATE TABLE</span>的一个语法警告，和对于<span>INSERT</span>的转换警告：</p>
				<pre><span>mysql&gt; <span><b>CREATE TABLE t1 (a TINYINT NOT NULL, b CHAR(4)) TYPE=MyISAM;</b></span></span></pre>
				<pre><span>Query OK, 0 rows affected, 1 warning (0.00 sec)</span></pre>
				<pre><span>mysql&gt; <span><b>SHOW WARNINGS\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp; Level: Warning</span></pre>
				<pre><span>&nbsp;&nbsp; Code: 1287</span></pre>
				<pre><span>Message: &#39;TYPE=storage_engine&#39; is deprecated, use</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;ENGINE=storage_engine&#39; instead</span></pre>
				<pre><span>1 row in set (0.00 sec)</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>INSERT INTO t1 VALUES(10,&#39;mysql&#39;),(NULL,&#39;test&#39;),</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>(300,&#39;Open Source&#39;);</b></span></span></pre>
				<pre><span>Query OK, 3 rows affected, 4 warnings (0.01 sec)</span></pre>
				<pre><span>Records: 3&nbsp; Duplicates: 0&nbsp; Warnings: 4</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>SHOW WARNINGS\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp; Level: Warning</span></pre>
				<pre><span>&nbsp;&nbsp; Code: 1265</span></pre>
				<pre><span>Message: Data truncated for column &#39;b&#39; at row 1</span></pre>
				<pre><span>*************************** 2. row ***************************</span></pre>
				<pre><span>&nbsp; Level: Warning</span></pre>
				<pre><span>&nbsp;&nbsp; Code: 1263</span></pre>
				<pre><span>Message: Data truncated, NULL supplied to NOT NULL column &#39;a&#39; at row 2</span></pre>
				<pre><span>*************************** 3. row ***************************</span></pre>
				<pre><span>&nbsp; Level: Warning</span></pre>
				<pre><span>&nbsp;&nbsp; Code: 1264</span></pre>
				<pre><span>Message: Data truncated, out of range for column &#39;a&#39; at row 3</span></pre>
				<pre><span>*************************** 4. row ***************************</span></pre>
				<pre><span>&nbsp; Level: Warning</span></pre>
				<pre><span>&nbsp;&nbsp; Code: 1265</span></pre>
				<pre><span>Message: Data truncated for column &#39;b&#39; at row 3</span></pre>
				<pre><span>4 rows in set (0.00 sec)</span></pre>
				<p>要存储的错误、警告和注意消息的最大数目由<span>max_error_count</span>系统变量控制。默认情况下，该值为<span>64</span>。要更改您想要存储的信息的数目，需更改<span>max_error_count</span>值。在下面的例子中，<span>ALTER 
				TABLE</span>语句会产生三个警告消息，但是只有一个被存储，因为<span>max_error_count</span>被设置为<span>1</span>：</p>
				<pre><span>mysql&gt; <span><b>SHOW VARIABLES LIKE &#39;max_error_count&#39;;</b></span></span></pre>
				<pre><span>+-----------------+-------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp; | Value |</span></pre>
				<pre><span>+-----------------+-------+</span></pre>
				<pre><span>| max_error_count | 64&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+-----------------+-------+</span></pre>
				<pre><span>1 row in set (0.00 sec)</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>SET max_error_count=1;</b></span></span></pre>
				<pre><span>Query OK, 0 rows affected (0.00 sec)</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>ALTER TABLE t1 MODIFY b CHAR;</b></span></span></pre>
				<pre><span>Query OK, 3 rows affected, 3 warnings (0.00 sec)</span></pre>
				<pre><span>Records: 3&nbsp; Duplicates: 0&nbsp; Warnings: 3</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>SELECT @@warning_count;</b></span></span></pre>
				<pre><span>+-----------------+</span></pre>
				<pre><span>| @@warning_count |</span></pre>
				<pre><span>+-----------------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 |</span></pre>
				<pre><span>+-----------------+</span></pre>
				<pre><span>1 row in set (0.01 sec)</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>SHOW WARNINGS;</b></span></span></pre>
				<pre><span>+---------+------+----------------------------------------+</span></pre>
				<pre><span>| Level&nbsp;&nbsp; | Code | Message&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>+---------+------+----------------------------------------+</span></pre>
				<pre><span>| Warning | 1263 | Data truncated for column &#39;b&#39; at row 1 |</span></pre>
				<pre><span>+---------+------+----------------------------------------+</span></pre>
				<pre><span>1 row in set (0.00 sec)</span></pre>
				<p>要禁用警告，需把<span>max_error_count</span>设置为<span>0</span>。在此情况下，<span>warning_count</span>仍然指示有多少警告已经发生，但是这些消息不被存储。</p>
				<p>您可以把<span>SQL_NOTES</span>会话变量设置为<span>0</span>，使“注意”级别的警告不被记录。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="other-administrative-sql"></a>
			13.5.5.&nbsp;其它管理语句</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#cache-index">13.5.5.1. 
				CACHE INDEX语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#flush">13.5.5.2. 
				FLUSH语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#kill">13.5.5.3. 
				KILL语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-index">13.5.5.4. 
				LOAD INDEX INTO CACHE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset">13.5.5.5. 
				RESET语法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cache-index"></a>13.5.5.1. CACHE 
				INDEX语法</h4></div></div></div><a class="indexterm" name="id2926488"></a><a class="indexterm" name="id2926497"></a><a class="indexterm" name="id2926508"></a>
				<pre><span>CACHE INDEX</span></pre>
				<pre><span>&nbsp; <span><i>tbl_index_list</i></span> [, <span><i>tbl_index_list</i></span>] ...</span></pre>
				<pre><span>&nbsp; IN <span><i>key_cache_name</i></span></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span><i><span>tbl_index_list</span></i></span><span>:</span></pre>
				<pre><span>&nbsp; <span><i>tbl_name</i></span> [[INDEX|KEY] (<span><i>index_name</i></span>[, <span><i>index_name</i></span>] ...)]</span></pre>
				<p><span>CACHE INDEX</span>语句把表索引分配给某个关键缓存。该语句只用于<span>MyISAM</span>表。</p>
				<p>下列语句把索引从表<span>t1, t2</span>和<span>t3</span>分配到名为<span>hot_cache</span>的关键缓存：</p>
				<pre><span>mysql&gt; <span><b>CACHE INDEX t1, t2, t3 IN hot_cache;</b></span></span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<pre><span>| Table&nbsp;&nbsp; | Op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Msg_type | Msg_text |</span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<pre><span>| test.t1 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| test.t2 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| test.t3 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<p><span>CACHE INDEX</span>语法允许您指定，只有来自表的特定索引应被分配给缓存。但是，当前的实施会把所有的表索引分配给缓存，所以必须指定表名称，不能指定其它的。</p>
				<p>被引用到<span>CACHE INDEX</span>语句中的关键缓存可以这样创建，即通过使用一个参数设置语句或在服务器参数设置中设置其大小。举例说明：</p>
				<pre><span>mysql&gt; <span><b>SET GLOBAL keycache1.key_buffer_size=128*1024;</b></span></span></pre>
				<p>关键缓存参数可以被作为一个结构化系统变量的成分进行访问。请参见<a href="language-structure.html#structured-system-variables" title="9.4.1. Structured System Variables">9.4.1节，“结构式系统变量”</a>。</p>
				<p>在您可以把索引分配给一个关键缓存以前，缓存必须存在：</p>
				<pre><span>mysql&gt; <span><b>CACHE INDEX t1 IN non_existent_cache;</b></span></span></pre>
				<pre><span>ERROR 1284 (HY000): Unknown key cache &#39;non_existent_cache&#39;</span></pre>
				<p>
				默认情况下，表索引被分配给在服务器启动时被创建的主（默认）键缓存。当一个键高速缓冲被破坏时，所有被分配到此缓存中的索引会再次被分配给默认的
				键高速缓冲。</p>
				<p>
				索引的分配会对服务器产生全局性影响：如果一个客户端把一个索引分配给一个给定的缓存，则不论什么客户端发布查询，本缓存都被用于所有涉及索引的查询。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="flush"></a>13.5.5.2. FLUSH语法</h4></div></div></div><a class="indexterm" name="id2926697"></a><a class="indexterm" name="id2926706"></a><a class="indexterm" name="id2926714"></a><a class="indexterm" name="id2926724"></a>
				<pre><span>FLUSH [LOCAL | NO_WRITE_TO_BINLOG] <span><i>flush_option</i></span> [, <span><i>flush_option</i></span>] ...</span></pre>
				<p>如果您想要清除<span>MySQL</span>使用的部分内部缓存，您应该使用<span>FLUSH</span>语句。要执行<span>FLUSH</span>，您必须拥有<span>RELOAD</span>权限。</p>
				<p><span>flush_option</span>可以为以下的任何一个：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				HOSTS</span><span> </span></p>
				<p>用于清空主机缓存表。如果有的主机更改了<span>IP</span>号或如果您得到了错误信息<span>Host
				<i>host_name</i> is blocked</span>，则您应该刷新主机表。当在连接到<span>MySQL</span>服务器时，如果对于一个给定的主机，接连出现错误“多于<span>max_connect_errors</span>”，此时，<span>MySQL</span>会假定出现了错误，并阻止主机后续的连接申请。刷新主机表允许主机尝试再次连接。请参见<a href="problems.html#blocked-host" title="A.2.5. Host 'host_name' is blocked">A.2.5节，“主机的hos<em class="replaceable">t_name被屏蔽</em>”</a>。您可以使用<span>max_connect_errors=999999999</span>启动<strong><span>mysqld</span></strong>，以避免此错误信息。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				DES_KEY_FILE</span><span> </span></p>
				<p>用于在服务器启动时，从采用<span>--des-key-file</span>选项指定的文件重新载入<span>DES</span>关键字。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>LOGS</span><span>
				</span></p>
				<p>
				用于关闭并重新打开所有的日志文件。如果您已经指定了一个更新日志文件或一个二进制日志文件，同时没有扩展，则相对于前一个文件，日志文件的扩展号增加<span>1</span>。如果您在文件名称中使用了一个扩展，则<span>MySQL</span>会关闭并重新打开日志文件。在<span>Unix</span>中，当相<span>mysqld</span>服务器发送一个<span>SIGHUP</span>信号时，也会如此（例外情况是部分<span>Mac 
				OS X 10.3</span>版本。在这些版本中，<span>mysqld</span>忽略<span>SIGHUP</span>和<span>SIGQUIT</span>）。</p>
				<p>如果服务器使用<span>--log-error</span>选项，则<span>FLUSH 
				LOGS</span>会导致错误日志被重命名（使用后缀<span>-old</span>），同时<span>mysqld</span>会创建一个新的空日志文件。如果没有给定<span>--log-error</span>选项，则不会进行重命名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				PRIVILEGES</span><span> </span></p>
				<p>用于从<span>mysql</span>数据库中的授权表重新载入权限。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				QUERY CACHE</span><span> </span></p>
				<p>对查询缓存进行整理碎片，以更好得利用存储器。与<span>RESET 
				QUERY CACHE</span>不同，本语句不会从缓存中取消任何查询。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				STATUS</span><span> </span></p>
				<p>
				用于把多数状态变量重新设置为零。只在当调试查询时，您才应该使用此项。请参见<a href="introduction.html#bug-reports" title="1.7.1.3. How to Report Bugs or Problems">1.7.1.3节，“如何通报缺陷和问题”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				{TABLE | TABLES} [<i>tbl_name</i> [, <i>tbl_name</i>] ...]</span><span>
				</span></p>
				<p>
				当没有表被命名时，关闭所有打开的表，并迫使所有正在使用的表关闭。这也会刷新查询缓存。此项含有一个或多个表名称，只刷新给定的表。和<span>RESET 
				QUERY CACHE</span>语句一样，<span>FLUSH TABLES</span>还会取消来自查询缓存的所有查询结果。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				TABLES WITH READ LOCK</span><span> </span></p>
				<p>
				对于所有带读取锁定的数据库，关闭所有打开的表，并锁定所有的表，直到您执行<span>UNLOCK 
				TABLES</span>为止。如果您拥有一个可以及时进行快照的文件系统，比如<span>Veritas</span>，则这是进行备份的非常方便的方法。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				USER_RESOURCES</span><span> </span></p>
				<p>
				用于把所有每小时用户资源重新设置为零。这可以使已经达到了每小时连接、查询或更新限值的客户端立刻重新恢复活性。<span>FLUSH 
				USER_RESOURCES</span>不适用于同时连接的最大限值。请参见<a href="sql-syntax.html#grant" title="13.5.1.3. GRANT and REVOKE Syntax">13.5.1.3节，“GRANT和REVOKE语法”</a>。</p>
				<p><span>FLUSH</span>语句被写入二进制日志，除非使用了自选的<span>NO_WRITE_TO_BINLOG</span>关键字（或其别名<span>LOCAL</span>）。
				注释：在任何情况下，<span>FLUSH 
				LOGS</span><span>,
				<span>FLUSH MASTER</span>,
				<span>FLUSH SLAVE</span></span>和<span>FLUSH 
				TABLES WITH READ LOCK</span>都不会被记入日志，因为如果它们被复制到一个从属服务器上，会导致出现问题。</p>
				<p>您也可以使用<span>flush-hosts</span><span>,
				<span>flush-logs</span>,
				<span>flush-privileges</span>,
				<span>flush-status</span></span>或<span>flush-tables</span>命令访问含有<span>mysqladmin</span>应用程序的语句。</p>
				<p>注释：在<span>MySQL 5.1.2-alpha</span>中，不可能在已存储的函数或触发程序中发布<span>FLUSH</span>语句。不过，您可以在已存储的过程中使用<span>FLUSH</span>，只要它们不会从已存储的函数或触发程序中被调用。请参见<a href="restrictions.html#routine-restrictions" title="I.1. Restrictions on Stored Routines and Triggers">I.1节，“对存储子程序和触发程序的限制”</a>。</p>
				<p>要了解有关<span>RESET</span>语句与复制同时使用的信息，也可以见<a href="sql-syntax.html#reset" title="13.5.5.5. RESET Syntax">13.5.5.5节，“RESET语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="kill"></a>13.5.5.3. KILL语法</h4></div></div></div><a class="indexterm" name="id2927205"></a><a class="indexterm" name="id2927214"></a>
				<pre><span>KILL [CONNECTION | QUERY] <span><i>thread_id</i></span></span></pre>
				<p>每个与<span>mysqld</span>的连接都在一个独立的线程里运行，您可以使用<span>SHOW 
				PROCESSLIST</span>语句查看哪些线程正在运行，并使用<span>KILL
				<i>thread_id</i></span>语句终止一个线程。</p>
				<p><span>KILL</span>允许自选的<span>CONNECTION</span>或<span>QUERY</span>修改符：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>KILL CONNECTION</span>与不含修改符的<span>KILL</span>一样：它会终止与给定的<span><i><span>thread_id</span></i></span>有关的连接。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>KILL QUERY</span>会终止连接当前正在执行的语句，但是会保持连接的原状。</p>
				<p>如果您拥有<span>PROCESS</span>权限，则您可以查看所有线程。如果您拥有<span>SUPER</span>权限，您可以终止所有线程和语句。否则，您只能查看和终止您自己的线程和语句。</p>
				<p>您也可以使用<strong><span>mysqladmin 
				processlist</span></strong>和<strong><span>mysqladmin 
				kill</span></strong>命令来检查和终止线程。</p>
				<p>注释：您不能同时使用<span>KILL</span>和<span>Embedded 
				MySQL Server</span>库，因为内植的服务器只运行主机应用程序的线程。它不能创建任何自身的连接线程。</p>
				<p>当您进行一个<span>KILL</span>时，对线程设置一个特有的终止标记。在多数情况下，线程终止可能要花一些时间，这是因为终止标记只会在在特定的间隔被检查：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在<span>SELECT, ORDER BY</span>和<span>GROUP 
				BY</span>循环中，在读取一组行后检查标记。如果设置了终止标记，则该语句被放弃。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在<span>ALTER TABLE</span>过程中，在每组行从原来的表中被读取前，检查终止标记。如果设置了终止标记，则语句被放弃，临时表被删除。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在<span>UPDATE</span>或<span>DELETE</span>运行期间，在每个组读取之后以及每个已更行或已删除的行之后，检查终止标记。如果终止标记被设置，则该语句被放弃。注意，如果您正在使用事务，则变更不会被
				回滚。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>GET_LOCK()</span>会放弃和返回<span>NULL</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INSERT DELAYED</span>线程会快速地刷新（插入）它在存储器中的所有的行，然后终止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果线程在表锁定管理程序中（状态：锁定），则表锁定被快速地放弃。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果在写入调用中，线程正在等待空闲的磁盘空间，则写入被放弃，并伴随<span>&quot;disk 
				full&quot;</span>错误消息。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>警告：对<span>MyISAM</span>表终止一个<span>REPAIR 
				TABLE</span>或<span>OPTIMIZE TABLE</span>操作会导致出现一个被损坏的没有用的表。对这样的表的任何读取或写入都会失败，直到您再次优化或修复它（不中断）。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="load-index"></a>13.5.5.4. LOAD 
				INDEX INTO CACHE语法</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>LOAD INDEX INTO CACHE</span></pre>
				<pre><span>&nbsp; <span><i>tbl_index_list</i></span> [, <span><i>tbl_index_list</i></span>] ...</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span><i><span>tbl_index_list</span></i></span><span>:</span></pre>
				<pre><span>&nbsp; <span><i>tbl_name</i></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [[INDEX|KEY] (<span><i>index_name</i></span>[, <span><i>index_name</i></span>] ...)]</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [IGNORE LEAVES]</span></pre>
				<p><span>LOAD INDEX INTO CACHE</span>语句会把一个表索引预载入到某个关键缓存中。它已经被一个明确的<span>CACHE 
				INDEX</span>语句分配到此关键缓存中。或者，表索引被预载入到默认的关键缓存中。<span>LOAD 
				INDEX INTO CACHE</span>只用于<span>MyISAM</span>表。</p>
				<p><span>IGNORE LEAVES</span>修改符只会导致索引的非叶子节点被预载入。</p>
				<p>对于表<span>t1</span>和<span>t2</span>，以下语句会预载入索引的节点（索引组）：</p>
				<pre><span>mysql&gt; <span><b>LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</b></span></span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<pre><span>| Table&nbsp;&nbsp; | Op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Msg_type | Msg_text |</span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<pre><span>| test.t1 | preload_keys | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| test.t2 | preload_keys | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<p>本语句会预载入所有来自<span>t1</span>的索引组。它只预载入来自<span>t2</span>的非叶子节点的组。</p>
				<p><span>LOAD INDEX INTO CACHE</span>语法允许您指定，只有来自表的特定的索引应被预载入。但是，当前实施会把所有的表索引预载入缓存中，所以一定要指定表名称，不能指定其它的。</p>
				<h4 class="title"><a name="reset"></a>13.5.5.5. RESET语法</h4></div></div></div>
				<pre><span>RESET <span><i>reset_option</i></span> [, <span><i>reset_option</i></span>] ...</span></pre>
				<p><span>RESET</span>语句被用于清除不同的服务器操作的状态。它也作为<span>FLUSH</span>语句的更强大的版本。请参见<a href="sql-syntax.html#flush" title="13.5.5.2. FLUSH Syntax">13.5.5.2节，“FLUSH语法”</a>。</p>
				<p>为了执行<span>RESET</span>，您必须拥有<span>RELOAD</span>权限。</p>
				<p><span>reset_option</span>可以为以下的任何一项：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				MASTER</span><span> </span></p>
				<p>
				可以删除列于索引文件中的所有二进制日志，把二进制日志索引文件重新设置为空，并创建一个新的二进制日志文件。（在以前版本的<span>MySQL</span>中，被称为<span>FLUSH 
				MASTER</span>。）见<a href="sql-syntax.html#replication-master-sql" title="13.6.1. SQL Statements for Controlling Master Servers">13.6.1节，“用于控制主服务器的SQL语句”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				QUERY CACHE</span><span> </span></p>
				<p>从查询缓存中取消所有的查询结果。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				SLAVE</span><span> </span></p>
				<p>
				可以使从属服务器忘记其在主服务器二进制日志中的复制位置，另外，也可以通过删除原有的中继日志文件和开始一个新文件来重新设置中继日志。请参见<a href="sql-syntax.html#replication-slave-sql" title="13.6.2. SQL Statements for Controlling Slave Servers">13.6.2节，“用于控制从服务器的SQL语句”</a>。</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="replication-sql"></a>
		13.6.&nbsp;复制语句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#replication-master-sql">
			13.6.1. 用于控制主服务器的SQL语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replication-slave-sql">
			13.6.2. 用于控制从服务器的SQL语句</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div>
			本节叙述了与复制有关的<span>SQL</span>语句。一组语句被用于控制主服务器。其它的被用于控制从属服务器。<h3 class="title"><a name="replication-master-sql"></a>
			13.6.1.&nbsp;用于控制主服务器的SQL语句</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#purge-master-logs">13.6.1.1. 
				PURGE MASTER LOGS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset-master">13.6.1.2. 
				RESET MASTER语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-sql-log-bin">13.6.1.3. 
				SET SQL_LOG_BIN语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-binlog-events">13.6.1.4. 
				SHOW BINLOG EVENTS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-master-logs">13.6.1.5. 
				SHOW MASTER LOGS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-master-status">13.6.1.6. 
				SHOW MASTER STATUS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-slave-hosts">13.6.1.7. 
				SHOW SLAVE HOSTS语法</a></span></dt></dl></div><a class="indexterm" name="id2927837"></a><a class="indexterm" name="id2927847"></a><a class="indexterm" name="id2927858"></a>
			<p>可以通过<span>SQL</span>界面控制复制。本节讨论了用于管理主复制服务器的语句。<a href="sql-syntax.html#replication-slave-sql" title="13.6.2. SQL Statements for Controlling Slave Servers">13.6.2节，“用于控制从服务器的SQL语句”</a>讨论了用于管理从属服务器的语句。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="purge-master-logs"></a>13.6.1.1. PURGE 
				MASTER LOGS语法</h4></div></div></div><a class="indexterm" name="id2927893"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>PURGE {MASTER | BINARY} LOGS TO &#39;<span><i>log_name</i></span>&#39;</span></pre>
				<pre><span>PURGE {MASTER | BINARY} LOGS BEFORE &#39;<span><i>date</i></span>&#39;</span></pre>
				<p>
				用于删除列于在指定的日志或日期之前的日志索引中的所有二进制日志。这些日志也会从记录在日志索引文件中的清单中被删除，这样被给定的日志成为第一个。</p>
				<p>例如：</p>
				<pre><span>PURGE MASTER LOGS TO &#39;mysql-bin.010&#39;;</span></pre>
				<pre><span>PURGE MASTER LOGS BEFORE &#39;2003-04-02 22:46:26&#39;;</span></pre>
				<p><span>BEFORE</span>变量的<span>date</span>自变量可以为<span>&#39;YYYY-MM-DD 
				hh:mm:ss&#39;</span>格式。<span>MASTER</span>和<span>BINARY</span>是同义词。</p>
				<p>
				如果您有一个活性的从属服务器，该服务器当前正在读取您正在试图删除的日志之一，则本语句不会起作用，而是会失败，并伴随一个错误。不过，如果从属服务器是休止的，并且您碰巧清理了其想要读取的日志之一，则从属服务器启动后不能复制。当从属服务器正在复制时，本语句可以安全运行。您不需要停止它们。</p>
				<p>要清理日志，需按照以下步骤：</p>
				<p>
				<span>1.<span>&nbsp;&nbsp;&nbsp;
				</span></span>在每个从属服务器上，使用<span>SHOW SLAVE STATUS</span>来检查它正在读取哪个日志。</p>
				<p>
				<span>2.<span>&nbsp;&nbsp;&nbsp;
				</span></span>使用<span>SHOW MASTER LOGS</span>获得主服务器上的一系列日志。</p>
				<p>
				<span>3.<span>&nbsp;&nbsp;&nbsp;
				</span></span>
				在所有的从属服务器中判定最早的日志。这个是目标日志。如果所有的从属服务器是更新的，这是清单上的最后一个日志。</p>
				<p>
				<span>4.<span>&nbsp;&nbsp;&nbsp;
				</span></span>制作您将要删除的所有日志的备份。（这个步骤是自选的，但是建议采用。）</p>
				<p>
				<span>5.<span>&nbsp;&nbsp;&nbsp;
				</span></span>清理所有的日志，但是不包括目标日志。</p>
				<h4 class="title"><a name="reset-master"></a>13.6.1.2. RESET 
				MASTER语法</h4></div></div></div><a class="indexterm" name="id2928068"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>RESET MASTER</span></pre>
				<p>可以删除列于索引文件中的所有二进制日志，把二进制日志索引文件重新设置为空，并创建一个新的二进制日志文件。</p>
				<h4 class="title"><a name="set-sql-log-bin"></a>13.6.1.3. SET 
				SQL_LOG_BIN语法</h4></div></div></div><a class="indexterm" name="id2928127"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SET SQL_LOG_BIN = {0|1}</span></pre>
				<p>如果客户端使用一个有<span>SUPER</span>权限的账户连接，则可以禁用或启用当前连接的二进制日志记录。如果客户端没有此权限，则语句被拒绝，并伴随有错误。</p>
				<h4 class="title"><a name="show-binlog-events"></a>13.6.1.4. SHOW 
				BINLOG EVENTS语法</h4></div></div></div><a class="indexterm" name="id2928197"></a>
				<pre><span>SHOW BINLOG EVENTS</span></pre>
				<pre><span>&nbsp;&nbsp; [IN &#39;<span><i>log_name</i></span>&#39;] [FROM <span><i>pos</i></span>] [LIMIT [<span><i>offset</i></span>,] <span><i>row_count</i></span>]</span></pre>
				<p>用于在二进制日志中显示事件。如果您不指定<span>&#39;log_name&#39;</span>，则显示第一个二进制日志。</p>
				<p><span>LIMIT</span>子句和<span>SELECT</span>语句具有相同的语法。请参见<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。</p>
				<p>注释：当服<span>务器把二进制日志的完整内容（该日志包括多数的由<span>MySQL</span>执行的查询）转储到<span>stdout</span>时，发布一个不含<span>LIMIT</span>子句的<span>SHOW 
				BINLOG EVENTS</span>可以启动一个过程，该过程非常消耗时间并消耗资源</span>。要把二进制日志保存到一个文本文件中，用于以后的检查和分析，需使用<span>mysqlbinlog</span>应用程序。请参见<a href="client-side-scripts.html#mysqlbinlog" title="8.6. mysqlbinlog — Utility for Processing Binary Log Files">8.6节，“mysqlbinlog：用于处理二进制日志文件的实用工具”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-master-logs"></a>13.6.1.5. SHOW 
				MASTER LOGS语法</h4></div></div></div><a class="indexterm" name="id2928328"></a><a class="indexterm" name="id2928337"></a>
				<pre><span>SHOW MASTER LOGS</span></pre>
				<pre><span>SHOW BINARY LOGS</span></pre>
				<p>用于列出服务器中的二进制日志文件。本语句被用作<a href="sql-syntax.html#purge-master-logs" title="13.6.1.1. PURGE MASTER LOGS Syntax">13.6.1.1节，“PURGE 
			MASTER LOGS语法”</a>中所述的过程的一部分，用于确定哪些日志可以被清理。</p>
				<pre><span>mysql&gt; <span><b>SHOW BINARY LOGS;</b></span></span></pre>
				<pre><span>+---------------+-----------+</span></pre>
				<pre><span>| Log_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | File_size |</span></pre>
				<pre><span>+---------------+-----------+</span></pre>
				<pre><span>| binlog.000015 |&nbsp;&nbsp;&nbsp; 724935 |</span></pre>
				<pre><span>| binlog.000016 |&nbsp;&nbsp;&nbsp; 733481 |</span></pre>
				<pre><span>+---------------+-----------+</span></pre>
				<p><span>SHOW BINARY LOGS</span>与<span>SHOW 
				MASTER LOGS</span>相当。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-master-status"></a>13.6.1.6. SHOW 
				MASTER STATUS语法</h4></div></div></div><a class="indexterm" name="id2928430"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW MASTER STATUS</span></pre>
				<p>用于提供主服务器二进制日志文件的状态信息。例如：</p>
				<pre><span>mysql &gt; SHOW MASTER STATUS;</span></pre>
				<pre><span>+---------------+----------+--------------+------------------+</span></pre>
				<pre><span>| File&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span></pre>
				<pre><span>+---------------+----------+--------------+------------------+</span></pre>
				<pre><span>| mysql-bin.003 | 73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | test&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | manual,mysql&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------------+----------+--------------+------------------+</span></pre>
				<h4 class="title"><a name="show-slave-hosts"></a>13.6.1.7. SHOW 
				SLAVE HOSTS语法</h4></div></div></div><a class="indexterm" name="id2928510"></a></div></div><div class="section"><div class="titlepage"><div><div>
			<pre><span>SHOW SLAVE HOSTS</span></pre>
			<p>用于显示当前使用主服务器注册的复制从属服务器的清单。不以<span>--report-host=<i>slave_name</i></span>选项为开头的从属服务器不会显示在本清单中。</p>
			<h3 class="title"><a name="replication-slave-sql"></a>
			13.6.2.&nbsp;用于控制从服务器的SQL语句</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#change-master-to">13.6.2.1. 
				CHANGE MASTER TO语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data-from-master">13.6.2.2. 
				LOAD DATA FROM MASTER语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-table-from-master">13.6.2.3. 
				LOAD TABLE <em class="replaceable">tbl_name</em> 
				FROM MASTER语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#master-pos-wait">13.6.2.4. 
				MASTER_POS_WAIT()语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset-slave">13.6.2.5. 
				RESET SLAVE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-global-sql-slave-skip-counter">13.6.2.6. 
				SET GLOBAL SQL_SLAVE_SKIP_COUNTER语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-slave-status">13.6.2.7. 
				SHOW SLAVE STATUS语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#start-slave">13.6.2.8. 
				START SLAVE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#stop-slave">13.6.2.9. 
				STOP SLAVE语法<br>
&nbsp;</a></span></dt></dl></div><a class="indexterm" name="id2928576"></a><a class="indexterm" name="id2928587"></a><a class="indexterm" name="id2928597"></a>
			<p>复制操作可以通过<span>SQL</span>界面控制。本节讨论了用于管理从属复制服务器的语句。<a href="sql-syntax.html#replication-master-sql" title="13.6.1. SQL Statements for Controlling Master Servers">13.6.1节，“用于控制主服务器的SQL语句”</a>讨论了用于管理主服务器的语句。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="change-master-to"></a>13.6.2.1. CHANGE 
				MASTER TO语法</h4></div></div></div><a class="indexterm" name="id2928632"></a>
				<pre><span>&nbsp; CHANGE MASTER TO <span><i>master_def</i></span> [, <span><i>master_def</i></span>] ...</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>master_def:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MASTER_HOST = &#39;<span><i>host_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_USER = &#39;<span><i>user_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_PASSWORD = &#39;<span><i>password</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_PORT = <span><i>port_num</i></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_CONNECT_RETRY = <span><i>count</i></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_LOG_FILE = &#39;<span><i>master_log_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_LOG_POS = <span><i>master_log_pos</i></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | RELAY_LOG_FILE = &#39;<span><i>relay_log_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | RELAY_LOG_POS = <span><i>relay_log_pos</i></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL = {0|1}</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL_CA = &#39;<span><i>ca_file_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL_CAPATH = &#39;<span><i>ca_directory_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL_CERT = &#39;<span><i>cert_file_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL_KEY = &#39;<span><i>key_file_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL_CIPHER = &#39;<span><i>cipher_list</i></span>&#39;</span></pre>
				<p>可以更改从属服务器用于与主服务器进行连接和通讯的参数。</p>
				<p><span>MASTER_USER</span><span>,
				<span>MASTER_PASSWORD</span>,
				<span>MASTER_SSL</span>,
				<span>MASTER_SSL_CA</span>,
				<span>MASTER_SSL_CAPATH</span>,
				<span>MASTER_SSL_CERT</span>,
				<span>MASTER_SSL_KEY</span></span>和<span>MASTER_SSL_CIPHER</span>用于向从属服务器提供有关如何与主服务器连接的信息。</p>
				<p>即使对于在编译时没有<span>SSL</span>支持的从属服务器，<span>SSL</span>选项<span>(<span>MASTER_SSL</span>,
				<span>MASTER_SSL_CA</span>,
				<span>MASTER_SSL_CAPATH</span>,
				<span>MASTER_SSL_CERT</span>,
				<span>MASTER_SSL_KEY</span></span>和<span>MASTER_SSL_CIPHER</span><span>)</span>也可以被更改。它们被保存到<span>master.info</span>文件中，但是会被忽略，直到您使用一个<span>SSL</span>支持已启用的服务器。</p>
				<p>如果您不指定一个给定的参数，则它会保持其原有的值。例外情况在后面的讨论中进行了说明。举例说明，如果用于连接到您的<span>MySQL</span>主服务器的
				密码被更改了，您只需发布这些语句，就可以告知从属服务器新的密码：</p>
				<pre><span>mysql&gt; <span><b>STOP SLAVE; -- if replication was running</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>CHANGE MASTER TO MASTER_PASSWORD=&#39;new3cret&#39;;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>START SLAVE; -- if you want to restart replication</b></span></span></pre>
				<p>没有必要指定没有改变的参数（主机、接口、用户等）。</p>
				<p><span>MASTER_HOST</span>和<span>MASTER_PORT</span>是主服务器主机和其<span>TCP/IP</span>接口的主机名（或<span>IP</span>地址）。注意，如果<span>MASTER_HOST</span>与<span>localhost</span>相等，那么，和<span>MySQL</span>的其它部分一样，接口可以被忽略（例如，如果可以使用<span>Unix</span>插槽文件）。</p>
				<p>如果您指定了<span>MASTER_HOST</span>或<span>MASTER_PORT</span>，则从属服务器会假定主服务器与以前不一样（即使您指定的主机或接口值与当前值是一样的。）在此情况下，主服务器二进制日志的名称和位置的原有值不再适用，因此，如果您不指定语句中的<span>MASTER_LOG_FILE</span>和<span>MASTER_LOG_POS</span>，<span>MASTER_LOG_FILE=&#39;&#39;</span>和<span>MASTER_LOG_POS=4</span>会被静默地添加。</p>
				<p>在<span>MASTER_LOG_FILE</span>和<span>MASTER_LOG_POS</span>坐标点，从属服务器<span>I/O</span>线程在启动之后从主服务器读取。如果您只指定了其中一个，则从属服务器不能指定<span>RELAY_LOG_FILE</span>或<span>RELAY_LOG_POS</span>。如果<span>MSATER_LOG_FILE</span>和<span>MASTER_LOG_POS</span>都没有被指定，则从属服务器会使用在<span>CHANGE 
				MASTER</span>被发布前的最后一个<span>slave SQL thread</span>坐标。当您只想改变要使用的
				密码时，这可以确保复制的连续性。即使从属服务器<span>SQL</span>线程落后于从属服务器<span>I/O</span>线程，也可以确保复制的连续性。</p>
				<p><span>CHANGE MASTER</span>会删除所有的中继日志文件并启动一个新的日志，除非您指定了<span>RELAY_LOG_FILE</span>或<span>RELAY_LOG_POS</span>。在此情况下，中继日志被保持；<span>relay_log_purge</span>全局变量被静默地设置为<span>0</span>。</p>
				<p><span>CHANGE MASTER TO</span>可以更新<span>master.info</span>和<span>relay-log.info</span>文件的内容。</p>
				<p>当您拥有主服务器快照并拥有日志和对应的偏移量时，<span>CHANGE MASTER</span>对于设置从属服务器是有用的。在把快照载入从属服务器之后，您可以在从属服务器上运行<span>CHANGE 
				MASTER TO MASTER_LOG_FILE=&#39;<i>log_name_on_master</i>&#39;, 
				MASTER_LOG_POS=<i>log_offset_on_master</i></span>。</p>
				<p>举例说明：</p>
				<pre><span>mysql&gt; <span><b>CHANGE MASTER TO</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_HOST=&#39;master2.mycompany.com&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_USER=&#39;replication&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_PASSWORD=&#39;bigs3cret&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_PORT=3306,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_LOG_FILE=&#39;master2-bin.001&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_LOG_POS=4,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_CONNECT_RETRY=10;</b></span></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>CHANGE MASTER TO</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>RELAY_LOG_FILE=&#39;slave-relay-bin.006&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>RELAY_LOG_POS=4025;</b></span></span></pre>
				<p>第一个例子可以更改主服务器及其二进制日志坐标。当想要设置从属服务器来复制主服务器时使用。</p>
				<p>
				第二个例子显示了较少被使用的一个操作。当从属服务器含有中继日志，并且您出于某种原因想要执行此日志时使用。要这么做时，不需要连接主服务器。您只需要使用<span>CHANGE 
				MASTER TO</span>并启动<span>SQL</span>线程（<span>START 
				SLAVE SQL_THREAD</span>）。</p>
				<p>
				您甚至可以在一个用于独立非从属服务器的非复制型设置中使用第二种操作，在崩溃之后进行复原。假设您的服务器已崩溃，同时您已恢复了备份。您想要重新播放服务器自己的二进制日志（不是中继日志，而是正规的二进制文件），例如名为<span>myhost-bin.*</span>。首先，应在安全的地方制作这些二进制日志的备份，以防您没有完全遵守以下步骤，意外地让服务器清理了二进制文件。使用<span>SET 
				GLOBAL relay_log_purge=0</span>，进一步增加安全性。然后启动不含<span>--log-bin</span>选项的服务器。使用<span>--replicate-same-server-id</span><span>,
				<span>--relay-log=myhost-bin</span></span>（让服务器相信，这些正规的二进制日志是中继日志）和<span>--skip-slave-start</span><span> 
				options</span>选项。当服务器启动后，发布以下语句：</p>
				<pre><span>mysql&gt; <span><b>CHANGE MASTER TO</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>RELAY_LOG_FILE=&#39;myhost-bin.153&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>RELAY_LOG_POS=410,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_HOST=&#39;some_dummy_string&#39;;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>START SLAVE SQL_THREAD;</b></span></span></pre>
				<p>服务器会读取并执行自己的二进制日志，完成崩溃复原。当复原完成后，运行<span>STOP SLAVE</span>，关闭服务器，删除<span>master.info</span>和<span>relay-log.info</span>，并使用原来的选项重新启动服务器。</p>
				<p>要让服务器认为它是一个从属服务器，需要指定<span>MASTER_HOST</span>（甚至使用假值）。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-from-master"></a>13.6.2.2. LOAD 
				DATA FROM MASTER语法</h4></div></div></div><a class="indexterm" name="id2929197"></a>
				<pre><span>LOAD DATA FROM MASTER</span></pre>
				<p>本命令用于对主服务器进行快照，并拷贝到从属服务器上。它可以更新<span>MASTER_LOG_FILE</span>和<span>MASTER_LOG_POS</span>的值，这样，从属服务器就可以从正确的位置开始进行复制。使用<span>--replicate-*-do-*</span>和<span>--replicate-*-ignore-*</span>选项指定的表和数据库排除规则均被兑现。<span>--replicate-rewrite-db</span>没有被考虑。这是因为使用本选项，用户就可以设置一个例如<span>--replicate-rewrite-db=db1-&gt;db3</span>和<span>--replicate-rewrite-db=db2-&gt;db3</span>的非唯一映射。当从主服务器载入表时，该映射会使从属服务器发生混淆。</p>
				<p>本语句的使用受以下条件的制约：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>只对<span>MyISAM</span>表起作用。如果试图载入一个非<span>MyISAM</span>表，会导致以下错误：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ERROR 1189 (08S01): Net error reading from master</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>当拍摄快照时，会获得对主服务器的全局读取锁定。在载入操作期间，该锁定会阻止对主服务器的更新。</p>
				<p>如果您正在载入大表，您可能必须对主服务器和从属服务器均增加<span>net_read_timeout</span>和<span>net_write_timeout</span>值。请参见<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a>。</p>
				<p>注意，<span>LOAD DATA FROM MASTER</span>不从<span>mysql</span>数据库拷贝任何表。这可以更容易地让主服务器和从属服务器拥有不同的用户和权限。</p>
				<p><span>LOAD DATA FROM MASTER</span>语句要求用于连接主服务器的复制帐户，以便让主服务器拥有<span>RELOAD</span>和<span>SUPER</span>权限，并让所有您想要载入的主服务器表拥有<span>SELECT</span>权限。所有的用户不拥有<span>SELECT</span>权限的主服务器表均被<span>LOAD 
				DATA FROM MASTER</span>忽略。这是因为主服务器会对用户隐藏它们：<span>LOAD 
				DATA FROM MASTER</span>会调用<span>SHOW DATABASES</span>以了解要载入的主服务器数据库，但是<span>SHOW 
				DATABASES</span>只会返回用户有部分权限的数据库。请参见<a href="sql-syntax.html#show-databases" title="13.5.4.6. SHOW DATABASES Syntax">13.5.4.6节，“SHOW 
			DATABASES语法”</a>。在从属服务器方面，发布<span>LOAD DATA FROM 
				MASTER</span>的用户应拥有授权，以取消或创建被复制的数据库和表。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="load-table-from-master"></a>13.6.2.3. LOAD 
				TABLE <em class="replaceable">tbl_name</em> FROM 
				MASTER语法</h4></div></div></div><a class="indexterm" name="id2929437"></a>
				<pre><span>LOAD TABLE <span><i>tbl_name</i></span> FROM MASTER</span></pre>
				<p>用于把表的拷贝从主服务器转移到从属服务器。本语句的主要作用是调试<span>LOAD DATA 
				FROM MASTER</span>。它要求用于连接主服务器的帐户拥有对主服务器的<span>RELOAD</span>和<span>SUPER</span>权限，并拥有对要载入的主服务器表的<span>SELECT</span>权限。在从属服务器方面，发布<span>LOAD 
				TABLE FROM MASTER</span>的用户应拥有取消和创建表的权限。</p>
				<p>用于<span>LOAD DATA FROM MASTER</span>的条件也适用于这里。举例说明，<span>LOAD 
				TABLE FROM MASTER</span>仅对于<span>MyISAM</span>表起作用。对<span>LOAD 
				DATA FROM MASTER</span>的暂停注意也适用。</p>
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="master-pos-wait"></a>13.6.2.4. MASTER_POS_WAIT()语法</h4>
						</div></div></div><a class="indexterm" name="id2929546">
				</a>
				<pre><span>SELECT MASTER_POS_WAIT(&#39;<span><i>master_log_file</i></span>&#39;, <span><i>master_log_pos</i></span>)</span></pre>
				<span>
				这实际上是一个函数，而不是一个语句。它被用于确认，从属服务器已读取并执行了到达主服务器二进制日志的给定位置。要了解完整的描述，请参见</span><a href="functions.html#miscellaneous-functions" title="12.9.4. Miscellaneous Functions">12.9.4节，“其他函数”</a></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reset-slave"></a>13.6.2.5. RESET 
				SLAVE语法</h4></div></div></div><a class="indexterm" name="id2929592"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>RESET SLAVE</span></pre>
				<p>用于让从属服务器忘记其在主服务器的二进制日志中的复制位置。本语句被用于进行一个明确的启动：它会删除<span>master.info</span>和<span>relay-log.info</span>文件，以及所有的中继日志，并启动一个新的中继日志。</p>
				<p>注释：所有的中继日志被删除，即使它们没有被从属服务器<span>SQL</span>线程完全的执行。（如果您已经发布了一个<span>SLAVE</span>语句或如果从属服务器的载入量很大，则这对于一个复制从属服务器是一个很可能出现的情况。）</p>
				<p>存储在<span>master.info</span>文件中的连接信息通过使用在对应的启动选项中指定的值，被立即重新设置了。此信息包括主服务器主机、主服务器接口、主服务器用户和主服务器
				密码等值。当从属服务器<span>SQL</span>线程被中止时，它位于正在复制的临时表的中间，并且发布了<span>RESET 
				SLAVE</span>，则已被复制的临时表在从属服务器中被删除。</p>
				<h4 class="title"><a name="set-global-sql-slave-skip-counter"></a>13.6.2.6. SET 
				GLOBAL SQL_SLAVE_SKIP_COUNTER语法</h4></div></div></div><a class="indexterm" name="id2929698"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SET GLOBAL SQL_SLAVE_SKIP_COUNTER = <span><i>n</i></span></span></pre>
				<p>从主服务器中跳过后面的<span>n</span>个事件。要复原由语句导致的复制中止，这是有用的。</p>
				<p>仅当从属线程没有正在运行时，本语句时有效的。否则，会产生一个错误。</p>
				<h4 class="title"><a name="show-slave-status"></a>13.6.2.7. SHOW 
				SLAVE STATUS语法</h4></div></div></div><a class="indexterm" name="id2929771"></a>
				<pre><span>SHOW SLAVE STATUS</span></pre>
				<p>用于提供有关从属服务器线程的关键参数的信息。如果您使用<span>mysql</span>客户端发布此语句，则您可以使用一个<span>\G</span>语句终止符来获得更便于阅读的竖向版面，而不是使用分号：</p>
				<pre><span>mysql&gt; <span><b>SHOW SLAVE STATUS\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Slave_IO_State: Waiting for master to send event</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_Host: localhost</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_User: root</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_Port: 3306</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Connect_Retry: 3</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_Log_File: gbichot-bin.005</span></pre>
				<pre><span>&nbsp; Read_Master_Log_Pos: 79</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relay_Log_File: gbichot-relay-bin.005</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relay_Log_Pos: 548</span></pre>
				<pre><span>Relay_Master_Log_File: gbichot-bin.005</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; Slave_IO_Running: Yes</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; Slave_SQL_Running: Yes</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Replicate_Do_DB:</span></pre>
				<pre><span>&nbsp; Replicate_Ignore_DB:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Last_Errno: 0</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Last_Error:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Skip_Counter: 0</span></pre>
				<pre><span>&nbsp; Exec_Master_Log_Pos: 79</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relay_Log_Space: 552</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Until_Condition: None</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Until_Log_File:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Until_Log_Pos: 0</span></pre>
				<pre><span>&nbsp; &nbsp;Master_SSL_Allowed: No</span></pre>
				<pre><span>&nbsp;&nbsp; Master_SSL_CA_File:</span></pre>
				<pre><span>&nbsp;&nbsp; Master_SSL_CA_Path:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_SSL_Cert:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; Master_SSL_Cipher:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_SSL_Key:</span></pre>
				<pre><span>Seconds_Behind_Master: 8</span></pre>
				<p><span>SHOW SLAVE STATUS</span>会返回以下字段：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Slave_IO_State</span><span> </span></p>
				<p><span>SHOW PROCESSLIST</span>输出的<span>State</span>字段的拷贝。<span>SHOW 
				PROCESSLIST</span>用于从属<span>I/O</span>线程。如果线程正在试图连接到主服务器，正在等待来自主服务器的时间或正在连接到主服务器等，本语句会通知您。在<a href="replication.html#replication-implementation-details" title="6.3. Replication Implementation Details">6.3节，“复制实施细节”</a>中列出了可能的状态。旧版本的<span>MySQL</span>在连接主服务器不成功时，允许线程继续运行。对于旧版本的<span>MySQL</span>，观看此字段是必须的。如果它正在运行，则无问题；如果它没有运行，则您会在<span>Last_Error</span>字段中发现错误（后面有说明）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Master_Host</span><span> </span></p>
				<p>当前的主服务器主机。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Master_User</span><span> </span></p>
				<p>被用于连接主服务器的当前用户。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Master_Port</span><span> </span></p>
				<p>当前的主服务器接口。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Connect_Retry</span><span> </span></p>
				<p>
				<span>--master-connect-retry</span>选项的当前值</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Master_Log_File</span><span> </span></p>
				<p><span>I/O</span>线程当前正在读取的主服务器二进制日志文件的名称。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Read_Master_Log_Pos</span><span> </span></p>
				<p>在当前的主服务器二进制日志中，<span>I/O</span>线程已经读取的位置。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Relay_Log_File</span><span> </span></p>
				<p><span>SQL</span>线程当前正在读取和执行的中继日志文件的名称。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Relay_Log_Pos</span><span> </span></p>
				<p>在当前的中继日志中，<span>SQL</span>线程已读取和执行的位置。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Relay_Master_Log_File</span><span> </span></p>
				<p>由<span>SQL</span>线程执行的包含多数近期事件的主服务器二进制日志文件的名称。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Slave_IO_Running</span><span> </span></p>
				<p><span>I/O</span>线程是否被启动并成功地连接到主服务器上。对于旧版本的<span>MySQL</span>（在<span>4.1.14</span>和<span>5.0.12</span>之前），如果<span>I/O</span>线程已被启动，即使从属服务器仍没有连接到主服务器上，<span>Slave_IO_Running</span>也将被设置到<span>YES</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Slave_SQL_Running</span><span> </span></p>
				<p><span>SQL</span>线程是否被启动。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Replicate_Do_DB</span><span>,
				<span>Replicate_Ignore_DB</span> </span>
				</p>
				<p>使用<span>--replicate-do-db</span>和<span>--replicate-ignore-db</span>选项指定的数据库清单。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Replicate_Do_Table</span><span>,
				<span>Replicate_Ignore_Table</span>,
				<span>Replicate_Wild_Do_Table</span>,
				<span>Replicate_Wild_Ignore_Table</span>
				</span></p>
				<p>使用<span>--replicate-do-table</span><span>,
				<span>--replicate-ignore-table</span>,
				<span>--replicate-wild-do-table</span></span>和<span>--replicate-wild-ignore_table</span>选项指定的表清单。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Last_Errno</span><span>,
				<span>Last_Error</span> </span></p>
				<p>被多数最近被执行的查询返回的错误数量和错误消息。错误数量为<span>0</span>并且消息为空字符串意味着“没有错误”。如果<span>Last_Error</span>值不是空值，它也会在从属服务器的错误日志中作为消息显示。</p>
				<p>举例说明：</p>
				<pre><span>Last_Errno: 1051</span></pre>
				<pre><span>Last_Error: error &#39;Unknown table &#39;z&#39;&#39; on query &#39;drop table z&#39;</span></pre>
				<p>该消息指示，表<span>z</span>曾经存在于在主服务器中并已被取消了，但是它没有在从属服务器中存在过，因此对于从属服务器，<span>DROP 
				TABLE</span>失败。（举例说明，在设置复制时，如果您忘记了把此表拷贝到从属服务器中，则这有可能发生。）</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Skip_Counter</span><span> </span></p>
				<p>最近被使用的用于<span>SQL_SLAVE_SKIP_COUNTER</span>的值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Exec_Master_Log_Pos</span><span> </span></p>
				<p>来自主服务器的二进制日志的由<span>SQL</span>线程执行的上一个时间的位置（<span>Relay_Master_Log_File</span>）。在主服务器的二进制日志中的<span>(<span>Relay_Master_Log_File</span>,
				<span>Exec_Master_Log_Pos</span>)</span>对应于在中继日志中的<span>(<span>Relay_Log_File</span>,
				<span>Relay_Log_Pos</span>)</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Relay_Log_Space</span><span> </span></p>
				<p>所有原有的中继日志结合起来的总大小。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Until_Condition</span><span>,
				<span>Until_Log_File</span>,
				<span>Until_Log_Pos</span> </span></p>
				<p>在<span>START SLAVE</span>语句的<span>UNTIL</span>子句中指定的值。</p>
				<p><span>Until_Condition</span>具有以下值：</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果没有指定<span>UNTIL</span>子句，则没有值</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果从属服务器正在读取，直到达到主服务器的二进制日志的给定位置为止，则值为<span>Master</span></p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果从属服务器正在读取，直到达到其中继日志的给定位置为止，则值为<span>Relay</span></p>
				<p><span>Until_Log_File</span>和<span>Until_Log_Pos</span>用于指示日志文件名和位置值。日志文件名和位置值定义了<span>SQL</span>线程在哪个点中止执行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Master_SSL_Allowed</span><span>,
				<span>Master_SSL_CA_File</span>,
				<span>Master_SSL_CA_Path</span>,
				<span>Master_SSL_Cert</span>,
				<span>Master_SSL_Cipher</span>,
				<span>Master_SSL_Key</span> </span></p>
				<p>这些字段显示了被从属服务器使用的参数。这些参数用于连接主服务器。</p>
				<p><span>
				Master_SSL_Allowed</span>具有以下值：</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果允许对主服务器进行<span>SSL</span>连接，则值为<span>Yes</span></p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果不允许对主服务器进行<span>SSL</span>连接，则值为<span>No</span></p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果允许<span>SSL</span>连接，但是从属服务器没有让<span>SSL</span>支持被启用，则值为<span>Ignored</span>。</p>
				<p>与<span>SSL</span>有关的字段的值对应于<span>--master-ca</span><span>,
				<span>--master-capath</span>,
				<span>--master-cert</span>,
				<span>--master-cipher</span></span>和<span>--master-key</span>选项的值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Seconds_Behind_Master</span><span> </span></p>
				<p>本字段是从属服务器“落后”多少的一个指示。当从属<span>SQL</span>线程正在运行时（处理更新），本字段为在主服务器上由此线程执行的最近的一个事件的时间标记开始，已经过的秒数。当此线程被从属服务器<span>I/O</span>线程赶上，并进入闲置状态，等待来自<span>I/O</span>线程的更多的事件时，本字段为零。总之，本字段测量从属服务器<span>SQL</span>线程和从属服务器<span>I/O</span>线程之间的时间差距，单位以秒计。</p>
				<p>如果主服务器和从属服务器之间的网络连接较快，则从属服务器<span>I/O</span>线程会非常接近主服务器，所以本字段能够十分近似地指示，从属服务器<span>SQL</span>线程比主服务器落后多少。如果网络较慢，则这种指示不准确；从属<span>SQL</span>线程经常会赶上读取速度较慢地从属服务器<span>I/O</span>线程，因此，<span>Seconds_Behind_Master</span>经常显示值为<span>0</span>。即使<span>I/O</span>线程落后于主服务器时，也是如此。换句话说，本列只对速度快的网络有用。</p>
				<p>
				即使主服务器和从属服务器不具有相同的时钟，时间差计算也会起作用（当从属服务器<span>I/O</span>线程启动时，计算时间差。并假定从此时以后，时间差保持不变）。如果从属<span>SQL</span>线程不运行，或者如果从属服务器<span>I/O</span>线程不运行或未与主服务器连接，则<span>Seconds_Behind_Master</span>为<span>NULL</span>（意义为“未知”）。举例说明，如果在重新连接之前，从属服务器<span>I/O</span>线程休眠了<span>master-connect-retry</span>秒，则显示<span>NULL</span>，因为从属服务器不知道主服务器正在做什么，也不能有把握地说落后多少。</p>
				<p>
				本字段有一个限制。时间标记通过复制被保留，这意味着，如果一个主服务器<span>M1</span>本身是一个从属服务器<span>M0</span>，则来自<span>M1</span>的<span>binlog</span>的任何事件（通过复制来自<span>M0</span>的<span>binlog</span>的事件而产生），与原事件具有相同的时间标记。这可以使<span>MySQL</span>成功地复制<span>TIMESTAMP</span>。但是，<span>Seconds_Behind_Master</span>的缺点是，如果<span>M1</span>也收到来自客户端的直接更新，则值会随机变化，因为有时最近的<span>M1</span>时间来自<span>M0</span>，有时来自直接更新，最近的时间标记也是如此。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="start-slave"></a>13.6.2.8. START 
				SLAVE语法</h4></div></div></div><a class="indexterm" name="id2930616"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>START SLAVE [<span><i>thread_type</i></span> [, <span><i>thread_type</i></span>] ... ]</span></pre>
				<pre><span>START SLAVE [SQL_THREAD] UNTIL</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; MASTER_LOG_FILE = &#39;<span><i>log_name</i></span>&#39;, MASTER_LOG_POS = <span><i>log_pos</i></span></span></pre>
				<pre><span>START SLAVE [SQL_THREAD] UNTIL</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; RELAY_LOG_FILE = &#39;<span><i>log_name</i></span>&#39;, RELAY_LOG_POS = <span><i>log_pos</i></span></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>thread_type: IO_THREAD | SQL_THREAD</span></pre>
				<p>不含选项的<span>START SLAVE</span>会同时启动两个从属服务器线程。<span>I/O</span>线程从主服务器中读取查询，并把它们存储在中继日志中。<span>SQL</span>线程读取中继日志并执行查询。<span>START 
				SLAVE</span>要求<span>SUPER</span>权限。</p>
				<p>如果<span>START SLAVE</span>成功地启动了从属服务器线程，则会返回，不会出现错误。但是，即使在此情况下，也有可能出现这样的现象——服务器线程启动了，然后又停止了（例如，因为它们没有成功地连接到主服务器上，或者没有能读取二进制日志，或者出现了其它问题）。<span>START 
				SLAVE</span>对此不会发出警告。您必须检查从属服务器的错误日志，查看是否有由从属服务器线程产生的错误消息，或者使用<span>SHOW 
				SLAVE STATUS</span>检查它们是否运行正常。</p>
				<p>您可以把<span>IO_THREAD</span>和<span>SQL_THREAD</span>选项添加到语句中，指明哪些线程将要启动。</p>
				<p>可以添加一个<span>UNTIL</span>子句，指定从属服务器应启动并运行，直到<span>SQL</span>线程达到主服务器二进制日志中的一个给定点为止。当<span>SQL</span>线程达到此点时，它会停止。如果在该语句中指定了<span>SQL_THREAD</span>选项，则它只会启动<span>SQL</span>线程。否则，它会同时启动两个从属服务器线程。如果<span>SQL</span>线程正在运行，则<span>UNTIL</span>子句被忽略，并发布一个警告。</p>
				<p>对于一个<span>UNTIL</span>子句，您必须同时指定一个日志文件名和位置。不要把主服务器和中继日志选项混合在一起。</p>
				<p><span>UNTIL</span>条件由一个后续的<span>STOP 
				SLAVE</span>语句，或一个不包括<span>UNTIL</span>子句的<span>START 
				SLAVE</span>语句，或一个服务器重启命令重新设置。</p>
				<p><span>UNTIL</span>子句对于调试复制操作是有用的，或者可用于促使复制操作继续，直到接近一个特定的点时为止，在此点，您想要避免让从属服务器复制一个语句。举例说明，如果在主服务上执行了一个不明智的<span>DROP 
				TABLE</span>语句，您可以使用<span>UNTIL</span>来告知从属服务器，执行到此点就停止，不要再继续了。要查找该事件是什么，需对主服务器日志或从属中继日志使用<span>mysqlbinlog</span>，或通过使用<span>SHOW 
				BINLOG EVENTS</span>语句。</p>
				<p>如果您正在使用<span>UNTIL</span>，让从属服务器成段地处理已复制的查询，则建议您使用<span>--skip-slave-start</span>选项来启动从属服务器，以防止当从属服务器启动时，<span>SQL</span>线程运行。最好在一个选项文件中使用此选项，而不是在命令行中使用，这样，如果发生了意料外的服务器重新启动，它也不会被忘记。</p>
				<p><span>SHOW SLAVE STATUS</span>语句包括了输出字段。这些字段显示了<span>UNTIL</span>条件的当前值。</p>
				<p>在以前版本的<span>MySQL</span>中，本语句被称为<span>SLAVE 
				START</span>。在<span>MySQL 5.1</span>中仍然接受这种用法，以便与以前版本兼容。但现在不赞成使用。</p>
				<h4 class="title"><a name="stop-slave"></a>13.6.2.9. STOP 
				SLAVE语法<br>
&nbsp;</h4></div></div></div><a class="indexterm" name="id2930874"></a></div></div></div><div class="section"><div class="titlepage"><div><div>
		<pre><span>STOP SLAVE [<span><i>thread_type</i></span> [, <span><i>thread_type</i></span>] ... ]</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>thread_type: IO_THREAD | SQL_THREAD</span></pre>
		<p>用于中止从属服务器线程。<span>STOP SLAVE</span>要求<span>SUPER</span>权限。</p>
		<p>和<span>START SLAVE</span>相似，本语句在使用时可以加<span>IO_THREAD</span>和<span>SQL_THREAD</span>选项，指明将被中止的线程。</p>
		<p>在以前版本的<span>MySQL</span>中，本语句被称为<span>SLAVE STOP</span>。在<span>MySQL 
		5.1</span>中仍然接受这种用法，以便与以前版本兼容。但是现在不赞成使用。</p>
		<h2 class="title"><a name="sqlps"></a>
		13.7.&nbsp;用于预处理语句的SQL语法</h2></div></div></div><a class="indexterm" name="id2930996"></a><a class="indexterm" name="id2931005"></a><a class="indexterm" name="id2931014"></a>
		<p><span>MySQL 5.1</span>对服务器一方的预制语句提供支持。如果您使用合适的客户端编程界面，则这种支持可以发挥在<span>MySQL 
		4.1</span>中实施的高效客户端<span>/</span>服务器二进制协议的优势。候选界面包括<span>MySQL 
		C API</span>客户端库（用于<span>C</span>程序）、<span>MySQL 
		Connector/J</span>（用于<span>Java</span>程序）和<span>MySQL 
		Connector/NET</span>。例如，<span>C API</span>可以提供一套能组成预制语句<span>API</span>的函数调用。请参见<a href="apis.html#c-api-prepared-statements" title="25.2.4. C API Prepared Statements">25.2.4节，“C API预处理语句”</a>。其它语言界面可以对使用了二进制协议（通过在<span>C</span>客户端库中链接）的预制语句提供支持。有一个例子是<span><a target="_top"  href="http://php.net/mysqli">PHP 
		5.0<span>中的</span>mysqli<span>扩展</span></a></span>。</p>
		<p>对预制语句，还有一个<span>SQL</span>界面可以利用。与在整个预制语句<span>API</span>中使用二进制协议相比，本界面效率没有那么高，但是它不要求编程，因为在<span>SQL</span>层级，可以直接利用本界面：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>当您无法利用编程界面时，您可以使用本界面。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>有些程序允许您发送<span>SQL</span>语句到将被执行的服务器中，比如<span>mysql</span>客户端程序。您可以从这些程序中使用本界面。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>即使客户端正在使用旧版本的客户端库，您也可以使用本界面。唯一的要求是，您能够连接到一个支持预制语句<span>SQL</span>语法的服务器上。</p>
		<p>预制语句的<span>SQL</span>语法在以下情况下使用：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>
		在编代码前，您想要测试预制语句在您的应用程序中运行得如何。或者也许一个应用程序在执行预制语句时有问题，您想要确定问题是什么。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>您想要创建一个测试案例，该案例描述了您使用预制语句时出现的问题，以便您编制程序错误报告。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>您需要使用预制语句，但是您无法使用支持预制语句的编程<span>API</span>。</p>
		<p>预制语句的<span>SQL</span>语法基于三个<span>SQL</span>语句：</p>
		<pre><span>PREPARE <span><i>stmt_name</i></span> FROM <span><i>preparable_stmt</i></span>;</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>EXECUTE <span><i>stmt_name</i></span> [USING @<span><i>var_name</i></span> [, @<span><i>var_name</i></span>] ...];</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>{DEALLOCATE | DROP} PREPARE <span><i>stmt_name</i></span>;</span></pre>
		<p><span>PREPARE</span>语句用于预备一个语句，并赋予它名称<span>stmt_name</span>，借此在以后引用该语句。语句名称对案例不敏感。<span>preparable_stmt</span>可以是一个文字字符串，也可以是一个包含了语句文本的用户变量。该文本必须展现一个单一的<span>SQL</span>语句，而不是多个语句。使用本语句，‘<span>?</span>’字符可以被用于制作参数，以指示当您执行查询时，数据值在哪里与查询结合在一起。‘<span>?</span>’字符不应加引号，即使您想要把它们与字符串值结合在一起，也不要加引号。参数制作符只能被用于数据值应该出现的地方，不用于<span>SQL</span>关键词和标识符等。</p>
		<p>
		如果带有此名称的预制语句已经存在，则在新的语言被预备以前，它会被隐含地解除分配。这意味着，如果新语句包含一个错误并且不能被预备，则会返回一个错误，并且不存在带有给定名称语句。</p>
		<p>预制语句的范围是客户端会话。在此会话内，语句被创建。其它客户端看不到它。</p>
		<p>在预备了一个语句后，您可使用一个<span>EXECUTE</span>语句（该语句引用了预制语句名称）来执行它。如果预制语句包含任何参数制造符，则您必须提供一个列举了用户变量（其中包含要与参数结合的值）的<span>USING</span>子句。参数值只能有用户变量提供，<span>USING</span>子句必须准确地指明用户变量。用户变量的数目与语句中的参数制造符的数量一样多。</p>
		<p>您可以多次执行一个给定的预制语句，在每次执行前，把不同的变量传递给它，或把变量设置为不同的值。</p>
		<p>要对一个预制语句解除分配，需使用<span>DEALLOCATE PREPARE</span>语句。尝试在解除分配后执行一个预制语句会导致错误。</p>
		<p>如果您终止了一个客户端会话，同时没有对以前已预制的语句解除分配，则服务器会自动解除分配。</p>
		<p>以下<span>SQL</span>语句可以被用在预制语句中：<span>CREATE 
		TABLE, <span>DELETE</span>,
		<span>DO</span>, <span>
		INSERT</span>, <span>REPLACE</span>,
		<span>SELECT</span>,
		<span>SET</span>, <span>
		UPDATE</span></span><span>和多数的<span>SHOW</span>语句。目前不支持其它语句。</span></p>
		<p>以下例子显示了预备一个语句的两种方法。该语句用于在给定了两个边的长度时，计算三角形的斜边。</p>
		<p>第一个例子显示如何通过使用文字字符串来创建一个预制语句，以提供语句的文本：</p>
		<pre><span>mysql&gt; <span><b>PREPARE stmt1 FROM &#39;SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse&#39;;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>SET @a = 3;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>SET @b = 4;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>EXECUTE stmt1 USING @a, @b;</b></span></span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>| hypotenuse |</span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 |</span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>mysql&gt; <span><b>DEALLOCATE PREPARE stmt1;</b></span></span></pre>
		<p>第二个例子是相似的，不同的是提供了语句的文本，作为一个用户变量：</p>
		<pre><span>mysql&gt; <span><b>SET @s = &#39;SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse&#39;;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>PREPARE stmt2 FROM @s;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>SET @a = 6;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>SET @b = 8;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>EXECUTE stmt2 USING @a, @b;</b></span></span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>| hypotenuse |</span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 |</span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>mysql&gt; <span><b>DEALLOCATE PREPARE stmt2;</b></span></span></pre>
		<p>预制语句的<span>SQL</span>语法不能被用于带嵌套的风格中。也就是说，被传递给<span>PREPARE</span>的语句本身不能是一个<span>PREPARE, 
		EXECUTE</span>或<span>DEALLOCATE PREPARE</span>语句。</p>
		<p>预制语句的<span>SQL</span>语法与使用预制语句<span>API</span>调用不同。例如，您不能使用<span>mysql_stmt_prepare()</span><span> 
		C API</span>函数来预备一个<span>PREPARE, EXECUTE</span>或<span>DEALLOCATE 
		PREPARE</span>语句。</p>
		<p>预制语句的<span>SQL</span>语法可以在已存储的过程中使用，但是不能在已存储的函数或触发程序中使用。</p>
		<p>当使用预制语句时，可以在<span>LIMIT</span>子句中使用占位符。请参见<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。</div></div><div><hr><p>
      这是MySQL参考手册的翻译版本，关于MySQL参考手册，<span class="GramE">请访问</span><a target="_top"  href="http://dev.mysql.com/doc/mysql/en">dev.mysql.com</a>。 
		原始参考手册为英文版，与英文版参考手册相比，本翻译版可能不是最新的。</p></div>
</body></html>
