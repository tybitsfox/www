bochsrc文件要点：
默认的配置文件：~/.bochsrc
1.指定BIOS镜像
romimage: file=/usr/share/bochs/BIOS-bochs-latest
2.指定显卡镜像
vgaromimage: file=/usr/share/bochs/VGABIOS-lgpl-latest
3.指定内存大小
megs: 32
4.指定软盘镜像
floppya: 1_44="Image", status=inserted
5.指定启动盘
boot: a
6.指定远程调试
gdbstub: enabled=1, port = 1234, text_base=0, data_base=0, bss_base=0
7.其它
mouse: enable=0
鼠标的使用和禁止可通过ctrl+鼠标中键切换。


常见问题小结
1.Message: ROM: System BIOS must end at 0xfffff
问题原因：
在2.3.5以前的bochs使用的BIOS-bochs-latest是64k的，那个时候需要加上
romimage: file=BIOS-bochs-latest,address=0xf0000
在2.3.5中的BIOS-bochs-latest更新了，变成了128k的，这个时候配置需要改为
romimage: file=$BXSHARE/BIOS-bochs-latest
解决方法：
去掉配置文件中的address那个

2.   directive 'floppy_command_delay' not understood
解决方法：
注掉floppy_command_delay: 50000

3.	ips:1000000  understood
解决方法：
格式不对，应写为：
cpu: ips=1000000


<font size=4 color=red>bochs3.0安装:64位支持及单步调试</font>
从http://bochs.sourceforge.net/下载
./configure --with-all-libs --enable-vbe --enable-debugger
make
sudo make install
然后需将bochs和bximage两个可执行文件拷贝至/usr/local/bin/目录下即可
#需要声卡加--enable-sb16，需要网卡加--enable-ne2000，
#64位机使用--enable-x86-64，mmx和sse, smp默认不支持
#--enable-vbe 该参数在3.0版本中提示无效
bochs3.0的正常使用：
1、配置个简单的rc文件放置到用户目录下：.bochsrc:
megs: 64
floppya: 1_44=/home/tian/boot.img, status=inserted
ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
ata0-master: type=disk, mode=flat, path="/home/tian/hdc.img", cylinders=40,     heads=8, spt=63
boot: c
keyboard: type=mf, serial_delay=150, paste_delay=100000
keyboard:keymap=/usr/local/share/bochs/keymaps/x11-pc-us.map
#keyboard: keymap=us
#log: /dev/null
2、如有建好的镜像文件，可使用：bochs -q 快速启动
3、要进入调试模式，可使用：bochs -dbg
调试命令详解：
二、执行控制：掌控程序的 “方向盘”
执行控制指令
指令	功能	示例
c/cont	继续执行，直到断点或终止	c
s/step	单步执行（进入子程序，如 CALL）	s
n/next	单步执行（跳过子程序，如 CALL 直接执行完）	n
q/quit/exit	退出调试器	q
1. 继续执行（c/cont）

	功能：从当前位置继续运行，直到遇到断点或程序终止。
	示例：调试引导程序时，BIOS 加载完引导扇区（如0x7C00）后，输入c即可让程序 “全速行驶”，直到触发断点。
	类比：如同开车时踩油门，让程序在内存中 “飞驰”，遇到预设的 “红灯”（断点）时停下。

2. 单步执行（s/step）

	功能：执行一条指令，遇到CALL会进入子程序内部。
	示例：当代码中有CALL 0x1000（调用子程序），输入s后，调试器会 “走进” 子程序（0x1000），逐个查看内部指令。
	类比：像逐个打开房间的门（指令），深入子程序的每一行代码。

3. 单步跳过（n/next）

	功能：执行一条指令，遇到CALL会直接执行完子程序并返回。
	示例：遇到CALL printf（打印函数），输入n后，调试器会 “跳过” 函数内部，直接执行完printf，停在CALL的下一条指令。
	类比：坐电梯直达目标楼层（子程序结束），无需查看每层（指令）。

4. 退出调试（q/quit/exit）

	功能：关闭 Bochs 调试会话，简单直接。
	类比：关闭软件窗口，结束调试 “旅程”。

三、断点设置：给程序 “设关卡”
断点设置指令
指令	功能	示例
b/pb/pbreak	物理地址断点	b 0x7C00（引导扇区断点）
vb/vbreak	虚拟地址断点（段：偏移，如 cs:ip）	vb 0:0x7C00
lb/lbreak	线性地址断点（保护模式下使用）	lb 0x123456
info break/blist	查看断点列表	info break
bpd num/bpe num	禁用 / 启用第 num 个断点	bpd 1（禁用断点 1）
d/del/delete num	删除第 num 个断点	delete 1
1. 物理地址断点（b/pb/pbreak）

	功能：在物理内存地址设置断点。
	示例：b 0x7C00（引导扇区加载地址），程序运行到此处立即中断，方便分析引导程序的第一步。
	场景：调试 BIOS 加载的引导扇区，确保代码正确执行。

2. 虚拟地址断点（vb/vbreak）

	功能：在段：偏移的虚拟地址设置断点（实模式常用）。
	示例：vb 0:0x7C00，实模式下等效于物理地址0x7C00，适合早期 BIOS 和引导程序调试。
	场景：分析实模式下的内存分段访问（如CS:IP寻址）。

3. 线性地址断点（lb/lbreak）

	功能：保护模式下，通过线性地址（考虑分页）设置断点。
	示例：lb 0x100000，假设页表已映射，程序运行到该线性地址时中断。
	场景：调试操作系统内核的分页内存访问（如虚拟内存映射）。

4. 断点管理

	查看断点：info break列出所有断点，如： 

	禁用 / 启用：bpd 1（禁用断点 1）、bpe 1（启用断点 1），灵活控制 “关卡” 是否生效。
	删除断点：delete 1移除不需要的断点，保持调试环境整洁。

四、寄存器操作：看透程序的 “状态”
寄存器操作指令
指令	功能	示例
info cpu/r	查看通用寄存器（EAX、EBX 等）	info cpu
sreg [seg]	查看段寄存器（CS、DS 等，可选指定段）	sreg cs（查看代码段）
creg [cr]	查看控制寄存器（CR0、CR3 等，可选指定寄存器）	creg cr0
dreg [dr]	查看调试寄存器（DR0-DR7，可选指定寄存器）	dreg dr0
r register value	设置寄存器值（如 r eax 0x1234）	谨慎使用，影响程序执行
1. 查看寄存器

	通用寄存器（info cpu）：显示EAX、EBX等，如：

用于检查计算结果、指针地址等。

段寄存器（sreg cs）：查看代码段的基址和权限，如：

分析内存分段（实模式 / 保护模式）。

控制寄存器（creg cr0）：查看保护模式标志（如PE位），判断程序是否进入特权模式：

	调试寄存器（dreg dr0）：查看调试寄存器，用于高级硬件调试（如数据断点）。

2. 修改寄存器（r register value）

	示例：r eax 0x1234，直接修改EAX的值，模拟特定输入（如初始化参数）。
	场景：测试程序在不同初始状态下的执行逻辑。

五、内存操作：窥探程序的 “藏宝阁”

内存操作指令
指令	功能	示例
x /nuf addr	查看线性地址内存（n：单元数，u：大小，f：格式）	x /4wx 0x1000（4 个双字，十六进制）
xp /nuf addr	查看物理地址内存（同 x，但针对物理地址）	xp /2bh 0x7C00（2 字节，十六进制，物理地址）
w addr value	写入线性地址内存（字节单位）	w 0x1000 0xFF（写 0xFF 到 0x1000）
setpmem addr size value	写入物理地址内存（size 为 1/2/4，对应字节 / 字 / 双字）	setpmem 0x2000 4 0x12345678（写双字）
1. 查看内存（x/xp）

	线性地址（x）：x /4wx 0x7C00，以双字、十六进制查看引导扇区内容，检查0xAA55（引导

物理地址（xp）：xp /8bh 0x7C00，以字节、十六进制查看物理内存，分析 BIOS 写入的数据：
2. 写入内存（w/setpmem）

	线性地址写入（w）：w 0x7C00 0x90，将NOP指令（0x90）写入引导扇区，模拟代码修改。
	物理地址写入（setpmem）：setpmem 0x1000 4 0x12345678，写入 4 字节数据到物理地址，测试内存初始化。

六、反汇编：让机器语言 “说人话”
反汇编指令
指令	功能	示例
u start end	反汇编 start 到 end 的内存	u 0x7C00 0x7C10（引导扇区前 16 字节）
u /count	反汇编当前地址开始的 count 条指令	u /5（反汇编 5 条指令）

	示例：u 0x7C00 0x7C10，反汇编引导扇区前 16 字节，查看 BIOS 加载的指令： 

	检查JMP指令是否正确跳转到主程序。

2. 反汇编当前指令（u /count）

	示例：u /5，反汇编当前EIP开始的 5 条指令，单步执行时快速预览后续代码，如： 

	提前了解程序下一步操作。

七、I/O 操作：模拟硬件交互
I/O 操作指令
指令	功能	示例
i port	读取 I/O 端口 port 的值	i 0x60（键盘端口）
o port value	写入 I/O 端口 port 的值	o 0x3F8 0x0A（串口发送换行）
1. 读取端口（i port）

	示例：i 0x60，读取键盘端口，查看按下的键的扫描码（如0x1C为 Enter 键），调试键盘驱动时使用。

2. 写入端口（o port value）

	示例：o 0x3F8 0x41，向串口发送字符A，测试串口驱动是否正常工作，模拟硬件通信。

八、实战：调试引导扇区

	设置断点：b 0x7C00，让程序在引导扇区开始处停下。
	运行到断点：c，BIOS 加载引导扇区后，调试器中断。
	单步执行：s，逐步查看引导程序的指令（如初始化寄存器、读取磁盘）。
	检查内存：x /2bh 0x7DFE，确认引导扇区末尾的0xAA55，确保 BIOS 正确加载。
	修改寄存器：r ax 0x0201（模拟读取磁盘扇区），测试引导程序的磁盘访问逻辑。

九、总结

Bochs 的调试指令是底层开发的 “利器”，涵盖程序执行、断点、寄存器、内存、反汇编、I/O 等核心功能。通过这些指令，你可以像 “侦探” 一样，深入剖析程序的每一个细节：

	执行控制：灵活掌控程序的运行节奏（继续、单步、跳过）。
	断点设置：在关键位置 “设卡”，精准定位问题。
	寄存器操作：查看和修改程序的 “状态”，模拟各种输入。
	内存操作：窥探内存中的数据，验证代码和数据的正确性。
	反汇编：将机器语言转换为人类可读的指令，理解程序逻辑。
	I/O 操作：模拟硬件交互，调试驱动程序。

掌握这些指令后，无论是操作系统内核、引导程序还是硬件驱动，你都能轻松调试，提升开发效率。实践是最好的学习方式，不妨从调试引导扇区开始，逐步探索 Bochs 的强大功能！
























