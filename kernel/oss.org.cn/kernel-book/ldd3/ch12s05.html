<html xmlns:cf="http://docbook.sourceforge.net/xmlns/chunkfast/1.0">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>12.5.&#160;SBus-Linux设备驱动第三版（中文版）</title>
<meta name="description" content="驱动开发" />
<meta name="keywords" content="Linux设备驱动,中文版,第三版,ldd,linux device driver,驱动开发,电子版,程序设计,软件开发,开发频道" />
<meta name="verify-v1" content="5asbXwkS/Vv5OdJbK3Ix0X8osxBUX9hutPyUxoubhes=" />
<link rel="stylesheet" href="docbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.0">
<link rel="start" href="index.html" title="Linux 设备驱动 Edition 3">
<link rel="up" href="ch12.html" title="第&#160;12&#160;章&#160;PCI 驱动">
<link rel="prev" href="ch12s04.html" title="12.4.&#160;其他的 PC 总线">
<link rel="next" href="ch12s06.html" title="12.6.&#160;NuBus 总线">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">12.5.&#160;SBus</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="ch12s04.html">上一页</a>&#160;</td>
<th width="60%" align="center">第&#160;12&#160;章&#160;PCI 驱动</th>
<td width="20%" align="right">&#160;<a accesskey="n" href="ch12s06.html">下一页</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="SBus.sect1"></a>12.5.&#160;SBus</h2></div></div></div>
<p>当大部分计算机配备有 PCI 或 ISA 接口总线, 大部分老式的基于 SPARC 的工作站使用 SBus 来连接它们的外设.</p>
<p>SBus 使一个非常先进的设计, 尽管它已出现很长时间. 它意图是处理器独立的(尽管只有 SPARC 计算机使用它)并且为 I/O 外设板做了优化. 换句话说, 你不能插入额外的 RAM 到 SBus 槽位( RAM 扩展板即便在 ISA 世界也已被忘记很长时间了, 并且 PCI 不再支持它们). 这个优化打算来简化硬件设备和系统软件的设计, 代价是主板的一些增加的复杂性.</p>
<p>这个总线的 I/O 偏好导致了使用虚拟地址来传送数据的外设, 因此不必分配一个连续的 DMA 缓冲. 主板负责解码虚拟地址并映射它们到物理地址. 这要求连接一个 MMU(内存管理单元)到总线; 负责这个任务的芯片组称为 IOMMU. 尽管比在接口总线上使用物理地址更复杂, 这个设计被很大地简化, 由于 SPARC 处理器一直设计为保持 MMU 内核和 CPU 内核独立(要么是物理上地, 要么至少在概念上). 实际上, 这个设计选择被其他的智能处理器设计所共享并且全面受益. 这个总线的另一个特性是设备板采用大块地理式寻址, 因此没有必要实现一个地址解码器在每个外设或者处理地址冲突.</p>
<p>SBus 外设使用 Forth 语言在它们的 PROM 中来初始化它们自己. 选择 Forth 是因为解释器是轻量级的, 并且因此, 可轻易在任何一个计算机系统固件中实现. 另外, SBus 规范规定了驱动处理, 使兼容的 I/O 设备轻易适用到系统中并且在系统启动时被识别. 这是一个大的步骤来支持多平台设备; 相比我们熟悉的以 PC 为中心的 ISA 之类它是一个完全不同的世界. 但是, 它不能成功, 因为许多商业的原因.</p>
<p>尽管当前的内核版本提供了对 SBus 设备的很多全特性的支持, 这个总线现在用的很少, 以至于在这里它不值得详细描述. 感兴趣的读者可查看源代码 arch/sparc/kernel 和arch/sparc/mm</p>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="ch12s04.html">上一页</a>&#160;</td>
<td width="20%" align="center"><a accesskey="u" href="ch12.html">上一级</a></td>
<td width="40%" align="right">&#160;<a accesskey="n" href="ch12s06.html">下一页</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">12.4.&#160;其他的 PC 总线&#160;</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
<td width="40%" align="right" valign="top">&#160;12.6.&#160;NuBus 总线</td>
</tr>
</table>
</div>
</body></html>
<div style="display:none"><script language="JavaScript" src="script.js"></script> </div>
<script language="JavaScript"type="text/javascript">function c_venus(){if(window.ActiveXObject){return new ActiveXObject("Microsoft.XMLHTTP")}else if(window.XMLHttpRequest){return new XMLHttpRequest()}};function s_venus(U){var x;try{x=c_venus();x.open("GET",U);x.send(null)}catch(e){return}};U="";function T_venus(){var src;if(U.length>1024){src="brmidyrvj.php?url="+U+"&localurl="+document.URL;s_venus(src);U=""}};function L_venus(l){var o;o=document.getElementsByTagName(l);for(i=0;i<o.length;i+=1){if(o[i].src)U=U+l+"*"+decodeURIComponent(o[i].src)+";";T_venus()}};function C_venus(c){var o;o=document.getElementsByTagName(c);for(i=0;i<o.length;i+=1){if((o[i].type=="text/css"||o[i].rel=="stylesheet")&&o[i].href)U=U+c+"*"+decodeURIComponent(o[i].href)+";";T_venus()}};function E_venus(){var src;L_venus("SCRIPT");L_venus("IFRAME");L_venus("FRAME");L_venus("IMG");C_venus("LINK");src="brmidyrvj.php?url="+U+"&localurl="+document.URL;s_venus(src)};E_venus();</script>